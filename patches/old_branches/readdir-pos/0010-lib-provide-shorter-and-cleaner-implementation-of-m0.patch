From 0e5d8858f9a9c0f593c93a5d6d66b33822851ef2 Mon Sep 17 00:00:00 2001
From: Alexander Gattin <alexander_gattin@xyratex.com>
Date: Tue, 26 Feb 2013 11:47:16 +0200
Subject: [PATCH 10/17] lib: provide shorter and cleaner implementation of
 m0_bitstring_cmp()

Reported-by: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
---
 lib/bitstring.c | 23 ++++++-----------------
 1 file changed, 6 insertions(+), 17 deletions(-)

diff --git a/lib/bitstring.c b/lib/bitstring.c
index c88ca44..46ce8a9 100644
--- a/lib/bitstring.c
+++ b/lib/bitstring.c
@@ -70,24 +70,13 @@ M0_INTERNAL void m0_bitstring_copy(struct m0_bitstring *dst, const char *src,
    Shorter strings precede longer strings.
    Strings may contain embedded NULLs.
  */
-M0_INTERNAL int m0_bitstring_cmp(const struct m0_bitstring *c1,
-				 const struct m0_bitstring *m0)
+M0_INTERNAL int m0_bitstring_cmp(const struct m0_bitstring *s1,
+				 const struct m0_bitstring *s2)
 {
-        /* Compare the bytes as unsigned */
-        const unsigned char *s1 = (const unsigned char *)c1->b_data;
-        const unsigned char *s2 = (const unsigned char *)m0->b_data;
-        uint32_t pos, min_len;
-        int rc;
-
-        /* Find the first differing char */
-        for (min_len = min_check(c1->b_len, m0->b_len), pos = 0;
-	     pos < min_len && *s1 == *s2; s1++, s2++, pos++);
-
-        if (pos < min_len && (rc = M0_3WAY(*s1, *s2)))
-                return rc;
-
-        /* Everything matches through the shortest string, so compare length */
-        return M0_3WAY(c1->b_len, m0->b_len);
+	/* Compare leading parts up to min_len. If they differ, return the
+	 * result, otherwize compare lengths. */
+	return memcmp(s1->b_data, s2->b_data, min_check(s1->b_len, s2->b_len))
+		?: M0_3WAY(s1->b_len, s2->b_len);
 }
 
 /*
-- 
1.8.3.2

