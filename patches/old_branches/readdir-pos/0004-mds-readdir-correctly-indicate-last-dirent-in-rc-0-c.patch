From 3de47e36072f1c1136c121525ff88a52bd0b0274 Mon Sep 17 00:00:00 2001
From: Alexander Gattin <alexander_gattin@xyratex.com>
Date: Sat, 23 Feb 2013 23:15:28 +0200
Subject: [PATCH 04/17] mds/readdir: correctly indicate last dirent in rc==0
 case

* do not initialize iterator when buffer is too small for
  dirent header
* zero d_reclen of last dirent record in rc==0, rc==-ENOENT
  and other cases
---
 mdstore/mdstore.c | 41 +++++++++++++++++++++++------------------
 1 file changed, 23 insertions(+), 18 deletions(-)

diff --git a/mdstore/mdstore.c b/mdstore/mdstore.c
index 8a640ee..65f11d4 100644
--- a/mdstore/mdstore.c
+++ b/mdstore/mdstore.c
@@ -722,6 +722,13 @@ M0_INTERNAL int m0_mdstore_readdir(struct m0_mdstore       *md,
 	       cob->co_fid->f_container, cob->co_fid->f_key, pos_len,
 	       pos_buf);
 
+	ent = rdpg->r_buf.b_addr;
+	nob = rdpg->r_buf.b_nob;
+	if (nob < sizeof(struct m0_dirent)) {
+		rc = -EINVAL;
+		goto out_end;
+	}
+
 	/** Emulate "." and ".." entries at the 1st and 2nd positions. */
 	if (pos_len == 0 || (pos_len == 1 && pos_buf[0] == '.')) {
 		dot = 1;
@@ -737,8 +744,6 @@ M0_INTERNAL int m0_mdstore_readdir(struct m0_mdstore       *md,
 		goto out;
 	}
 
-	ent = rdpg->r_buf.b_addr;
-	nob = rdpg->r_buf.b_nob;
 	/**
 	 * Positions iterator to the closest key greater or equal
 	 * to the starting position. Returns -ENOENT if no such
@@ -765,14 +770,14 @@ M0_INTERNAL int m0_mdstore_readdir(struct m0_mdstore       *md,
 			ent->d_reclen = reclen;
 			M0_LOG(M0_DEBUG,
 			       "Readdir filled entry \"%.*s\" recsize %d",
-			       ent->d_namelen, (char *)ent->d_name, ent->d_reclen);
+			       ent->d_namelen, (char *)ent->d_name,
+			       ent->d_reclen);
 		} else {
-			if (last) {
-				last->d_reclen += nob;
-				rc = 0;
-			} else {
-				rc = -EINVAL;
-			}
+			/**
+			 * If buffer was too small to hold even one record,
+			 * return -EINVAL. Otherwise return 0.
+			 */
+			rc = last == NULL ? -EINVAL : 0;
 			goto out_end;
 		}
 		last = ent;
@@ -785,17 +790,17 @@ M0_INTERNAL int m0_mdstore_readdir(struct m0_mdstore       *md,
 	}
 out_end:
 	m0_cob_iterator_fini(&it);
-	if (rc == -ENOENT) {
-		if (last)
-			last->d_reclen = 0;
-		rdpg->r_end = m0_bitstring_alloc(m0_bitstring_buf_get(rdpg->r_pos),
-						 m0_bitstring_len_get(rdpg->r_pos));
-		M0_LOG(M0_DEBUG,
-		      "Setting last name to \"%.*s\"",
-		      (int)m0_bitstring_len_get(rdpg->r_pos),
-		      (char *)m0_bitstring_buf_get(rdpg->r_pos));
+	if (last != NULL) {
+		last->d_reclen = 0;  /** The last record indicator. */
+		pos_buf = (char *)m0_bitstring_buf_get(rdpg->r_pos);
+		pos_len = m0_bitstring_len_get(rdpg->r_pos);
+		rdpg->r_end = m0_bitstring_alloc(pos_buf, pos_len);
+		M0_LOG(M0_DEBUG, "Setting last name to \"%.*s\"",
+		       pos_len, pos_buf);
 		rc = ENOENT;
 	}
+	if (rc == -ENOENT)
+		rc = ENOENT;
 out:
 	M0_LOG(M0_DEBUG, "Readdir finished with %d", rc);
 	MDSTORE_FUNC_FAIL(READDIR, rc);
-- 
1.8.3.2

