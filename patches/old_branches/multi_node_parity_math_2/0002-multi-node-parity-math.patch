From fc7e22d8a89d6129d5d14441d67095630689554a Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Fri, 9 Aug 2013 19:27:51 +0530
Subject: [PATCH 2/9] multi-node-parity-math

1. Below listed two redundant functions from sns/parity_math.c have been
   removed:
   a. static void restored_list_update(struct m0_sns_ir_block *block);
   b. static inline bool is_bitmap_empty(const struct m0_bitmap *bitmap);
2. Removed the state M0_SI_BLOCK_RESTORED from enum m0_sns_ir_block_status
   in sns/parity_math.h
---
 sns/parity_math.c       | 51 +++++++++++++------------------------------------
 sns/parity_math.h       |  1 -
 sns/ut/parity_math_ut.c | 27 +++-----------------------
 3 files changed, 16 insertions(+), 63 deletions(-)

diff --git a/sns/parity_math.c b/sns/parity_math.c
index c3e51df..11c3517 100644
--- a/sns/parity_math.c
+++ b/sns/parity_math.c
@@ -120,10 +120,6 @@ static void incr_recover(struct m0_sns_ir_block *failed_block,
 static void gfaxpy(struct m0_bufvec *y, struct m0_bufvec *x,
 		   m0_parity_elem_t alpha);
 
-static void restored_list_update(struct m0_sns_ir_block *block);
-
-static inline bool is_bitmap_empty(const struct m0_bitmap *bitmap);
-
 static inline bool is_valid_block_idx(const  struct m0_sns_ir *ir,
 				      uint32_t block_idx);
 
@@ -939,16 +935,15 @@ M0_INTERNAL void m0_sns_ir_recover(struct m0_sns_ir *ir,
 	struct m0_sns_ir_block *alive_block;
 
 	M0_PRE(ir != NULL && bufvec != NULL && bitmap != NULL);
-	M0_PRE(M0_IN(ir->si_mode, (M0_SI_BARE, M0_SI_XFORM)));
+
 	b_set_nr = m0_bitmap_set_nr(bitmap);
 	M0_PRE(b_set_nr > 0);
+	M0_PRE(ergo(b_set_nr > 1, ir->si_mode == M0_SI_XFORM));
 	M0_PRE(ergo(ir->si_mode == M0_SI_XFORM,
 		    is_valid_block_idx(ir, failed_index)));
-	M0_PRE(ergo(b_set_nr > 1, ir->si_mode == M0_SI_XFORM));
-
 	M0_PRE(ergo(ir->si_mode == M0_SI_XFORM,
-	       M0_IN(ir->si_blocks[failed_index].sib_status,
-		     (M0_SI_BLOCK_FAILED, M0_SI_BLOCK_RESTORED))));
+	            ir->si_blocks[failed_index].sib_status ==
+		    M0_SI_BLOCK_FAILED));
 	if (b_set_nr == 1) {
 		for (block_idx = 0; block_idx < bitmap->b_nr; ++block_idx) {
 			if (m0_bitmap_get(bitmap, block_idx))
@@ -957,17 +952,17 @@ M0_INTERNAL void m0_sns_ir_recover(struct m0_sns_ir *ir,
 	}
 	blocks = ir->si_blocks;
 	switch (ir->si_mode) {
+	/* Input block is assumed to be an untransformed block, and is used for
+	 * recovering all failed blocks */
 	case M0_SI_BARE:
 		alive_block = &blocks[block_idx];
 		alive_block->sib_addr = bufvec;
-		for (j = 0; j < block_count(ir); ++j) {
-			if (ir->si_blocks[j].sib_status == M0_SI_BLOCK_FAILED) {
+		for (j = 0; j < block_count(ir); ++j)
+			if (ir->si_blocks[j].sib_status == M0_SI_BLOCK_FAILED)
 				incr_recover(&blocks[j], alive_block, ir);
-				if (is_data(ir, j))
-					restored_list_update(&blocks[j]);
-			}
-		}
 		break;
+	/* Input block is assumed to be a transformed block, and is
+	 * cummulatively added to a block with index failed_index. */
 	case M0_SI_XFORM:
 		if (!is_usable(ir, (struct m0_bitmap*) bitmap,
 			       &blocks[failed_index]))
@@ -976,8 +971,6 @@ M0_INTERNAL void m0_sns_ir_recover(struct m0_sns_ir *ir,
 		       1);
 		dependency_bitmap_update(&blocks[failed_index],
 					 bitmap);
-		if (is_data(ir, failed_index))
-			restored_list_update(&blocks[failed_index]);
 		break;
 	}
 }
@@ -1070,15 +1063,6 @@ static void dependency_bitmap_update(struct m0_sns_ir_block *block,
 	}
 }
 
-static void restored_list_update(struct m0_sns_ir_block *block)
-{
-	M0_PRE(block != NULL);
-
-	if (is_bitmap_empty(&block->sib_bitmap)) {
-		block->sib_status = M0_SI_BLOCK_RESTORED;
-	}
-}
-
 void m0_sns_ir_local_xform(struct m0_sns_ir *ir)
 {
 	struct m0_sns_ir_block *res_block;
@@ -1087,15 +1071,13 @@ void m0_sns_ir_local_xform(struct m0_sns_ir *ir)
 	uint32_t		j;
 
 	M0_PRE(ir != NULL);
+	M0_PRE(ir->si_mode == M0_SI_BARE);
 	res_block = ir->si_blocks;
 	par_block = ir->si_blocks;
-        /**
-	 * Loop over all recently restored data blocks to use them for recovery
-	 * of failed parity blocks.
-	 */
+
 	for (i = 0; i < block_count(ir); ++i) {
 		if (is_data(ir, ir->si_blocks[i].sib_idx) &&
-		    ir->si_blocks[i].sib_status != M0_SI_BLOCK_ALIVE)
+		    ir->si_blocks[i].sib_status == M0_SI_BLOCK_FAILED)
 			for (j = 0; j < block_count(ir); ++j) {
 				if (!is_data(ir, ir->si_blocks[j].sib_idx) &&
 				    ir->si_blocks[j].sib_status ==
@@ -1108,11 +1090,6 @@ void m0_sns_ir_local_xform(struct m0_sns_ir *ir)
 	ir->si_mode = M0_SI_XFORM;
 }
 
-static inline bool is_bitmap_empty(const struct m0_bitmap *bitmap)
-{
-	return m0_bitmap_set_nr(bitmap) == 0;
-}
-
 static inline bool is_valid_block_idx(const struct m0_sns_ir *ir,
 				      uint32_t block_idx)
 {
@@ -1135,8 +1112,6 @@ static bool is_usable(const struct m0_sns_ir *ir,
 	M0_PRE(in_bmap != NULL && failed_block != NULL && ir != NULL);
 	M0_PRE(in_bmap->b_nr == failed_block->sib_bitmap.b_nr);
 
-	if (failed_block->sib_status == M0_SI_BLOCK_RESTORED)
-		return false;
 	last_usable_bid = last_usable_block_id(ir, failed_block->sib_idx);
 	if (last_usable_bid == block_count(ir))
 		return false;
diff --git a/sns/parity_math.h b/sns/parity_math.h
index 06e3a7a..8b4ece6 100644
--- a/sns/parity_math.h
+++ b/sns/parity_math.h
@@ -55,7 +55,6 @@ enum m0_parity_cal_algo {
 enum m0_sns_ir_block_status {
 	M0_SI_BLOCK_ALIVE,
 	M0_SI_BLOCK_FAILED,
-	M0_SI_BLOCK_RESTORED,
 };
 
 enum m0_sns_ir_mode {
diff --git a/sns/ut/parity_math_ut.c b/sns/ut/parity_math_ut.c
index dbd0d47..43edaee 100644
--- a/sns/ut/parity_math_ut.c
+++ b/sns/ut/parity_math_ut.c
@@ -1051,21 +1051,18 @@ static void sns_ir_nodes_compare(struct sns_ir_node *node, struct m0_bufvec *x,
 
 	ir = node[0].sin_ir;
 	for (i = 0; i < ir.si_data_nr; ++i) {
-		/* Failed data blocks will have status M0_SI_BLOCK_RESTORED
-		 * post-recovery. */
 		if (node[0].sin_ir.si_blocks[i].sib_status ==
-		    M0_SI_BLOCK_RESTORED) {
+		    M0_SI_BLOCK_FAILED) {
 			M0_UT_ASSERT(bufvec_eq(node[0].sin_ir.si_blocks[i].
 					       sib_addr, &x[i]));
 		}
 	}
 	for (; i < ir.si_data_nr + ir.si_parity_nr; ++i) {
-		/* Failed parity blocks will have status M0_SI_BLOCK_FAILED
-		 * post-recovery. */
 		if (node[0].sin_ir.si_blocks[i].sib_status ==
 		    M0_SI_BLOCK_FAILED) {
 			M0_UT_ASSERT(bufvec_eq(node[0].sin_ir.si_blocks[i].
-					       sib_addr, &p[i - ir.si_data_nr]));
+					       sib_addr, &p[i -
+					                    ir.si_data_nr]));
 		}
 	}
 }
@@ -1226,25 +1223,7 @@ static bool bufvec_eq(struct m0_bufvec *bvec_1, struct m0_bufvec *bvec_2)
 		 !m0_bufvec_cursor_move(&bvec_2_cursor, step));
 	return ret == 0;
 }
-#if 0
-static void bufvec_copy(struct m0_bufvec *des, struct m0_bufvec *src)
-{
-	struct m0_bufvec_cursor src_cursor;
-	struct m0_bufvec_cursor des_cursor;
-	m0_bcount_t		step;
 
-	M0_UT_ASSERT(src->ov_vec.v_nr == des->ov_vec.v_nr);
-	m0_bufvec_cursor_init(&src_cursor, src);
-	m0_bufvec_cursor_init(&des_cursor, des);
-	do {
-		memcpy(m0_bufvec_cursor_addr(&des_cursor),
-		       m0_bufvec_cursor_addr(&src_cursor),
-		       src->ov_vec.v_count[0]);
-		step = m0_bufvec_cursor_step(&src_cursor);
-	} while (!m0_bufvec_cursor_move(&src_cursor, step) &&
-		 !m0_bufvec_cursor_move(&des_cursor, step));
-}
-#endif
 static inline uint32_t block_nr(const struct m0_sns_ir *ir)
 {
 	return ir->si_data_nr + ir->si_parity_nr;
-- 
1.8.3.2

