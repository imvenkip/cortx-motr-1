From 86a995fef881dfda064c21d9c81fafa664d4c51e Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Wed, 11 Sep 2013 10:09:24 +0530
Subject: [PATCH 6/9] multi-node-parity-math 2

1. Changed m0_sns_ir_recover() to handle the case when remote blocks
   get submitted before all local blocks are consumed.
---
 sns/parity_math.c       | 96 ++++++++++++++++++++++++++++++++++++++-----------
 sns/parity_math.h       | 21 +++++++----
 sns/ut/parity_math_ut.c | 14 ++++----
 3 files changed, 97 insertions(+), 34 deletions(-)

diff --git a/sns/parity_math.c b/sns/parity_math.c
index c04aef2..4011178 100644
--- a/sns/parity_math.c
+++ b/sns/parity_math.c
@@ -120,6 +120,20 @@ static void incr_recover(struct m0_sns_ir_block *failed_block,
 static void gfaxpy(struct m0_bufvec *y, struct m0_bufvec *x,
 		   m0_parity_elem_t alpha);
 
+/**
+ * Adds correction for a remote block that is received before all blocks
+ * local to a node are transformed. This correction is needed only when
+ * set of failed blocks involve both data and parity blocks.
+ */
+static void forward_rectification(struct m0_sns_ir *ir,
+				  struct m0_bufvec *in_bufvec,
+				  uint32_t failed_index);
+/**
+ * When a set of failed blocks contain both data and parity blocks, this
+ * function transforms partially recovered data block, local to a node
+ * for computing failed parity.
+ */
+static void failed_data_blocks_xform(struct m0_sns_ir *ir);
 static inline bool is_valid_block_idx(const  struct m0_sns_ir *ir,
 				      uint32_t block_idx);
 
@@ -132,6 +146,7 @@ static bool is_usable(const struct m0_sns_ir *ir,
 
 static uint32_t last_usable_block_id(const struct m0_sns_ir *ir,
 				     uint32_t block_idx);
+static inline  bool are_failures_mixed(const struct m0_sns_ir *ir);
 
 static inline const struct m0_matrix* recovery_mat_get(const struct m0_sns_ir
 						       *ir,
@@ -719,7 +734,7 @@ M0_INTERNAL void m0_parity_math_buffer_xor(struct m0_buf *dest,
 }
 
 M0_INTERNAL int m0_sns_ir_init(const struct m0_parity_math *math,
-			       struct m0_sns_ir *ir)
+			       uint32_t local_nr, struct m0_sns_ir *ir)
 {
 	uint32_t i;
 	int	 ret = 0;
@@ -730,11 +745,11 @@ M0_INTERNAL int m0_sns_ir_init(const struct m0_parity_math *math,
 	M0_SET0(ir);
 	ir->si_data_nr		   = math->pmi_data_count;
 	ir->si_parity_nr	   = math->pmi_parity_count;
+	ir->si_local_nr		   = local_nr;
 	ir->si_vandmat		   = math->pmi_vandmat;
 	ir->si_parity_recovery_mat = math->pmi_vandmat_parity_slice;
 	ir->si_failed_data_nr	   = 0;
 	ir->si_alive_nr		   = block_count(ir);
-	ir->si_mode		   = M0_SI_BARE;
 
 	M0_ALLOC_ARR(ir->si_blocks, ir->si_alive_nr);
 	if (ir->si_blocks == NULL)
@@ -926,7 +941,8 @@ M0_INTERNAL void m0_sns_ir_fini(struct m0_sns_ir *ir)
 M0_INTERNAL void m0_sns_ir_recover(struct m0_sns_ir *ir,
 				   struct m0_bufvec *bufvec,
 				   const struct m0_bitmap *bitmap,
-				   uint32_t failed_index)
+				   uint32_t failed_index,
+				   enum m0_sns_ir_block_type block_type)
 {
 	uint32_t		j;
 	size_t			block_idx = 0;
@@ -938,12 +954,13 @@ M0_INTERNAL void m0_sns_ir_recover(struct m0_sns_ir *ir,
 
 	b_set_nr = m0_bitmap_set_nr(bitmap);
 	M0_PRE(b_set_nr > 0);
-	M0_PRE(ergo(b_set_nr > 1, ir->si_mode == M0_SI_XFORM));
-	M0_PRE(ergo(ir->si_mode == M0_SI_XFORM,
+	M0_PRE(ergo(b_set_nr > 1, block_type == M0_SI_BLOCK_REMOTE));
+	M0_PRE(ergo(block_type == M0_SI_BLOCK_REMOTE,
 		    is_valid_block_idx(ir, failed_index)));
-	M0_PRE(ergo(ir->si_mode == M0_SI_XFORM,
+	M0_PRE(ergo(block_type == M0_SI_BLOCK_REMOTE,
 	            ir->si_blocks[failed_index].sib_status ==
 		    M0_SI_BLOCK_FAILED));
+	M0_PRE(ergo(block_type == M0_SI_BLOCK_LOCAL, ir->si_local_nr != 0));
 	if (b_set_nr == 1) {
 		for (block_idx = 0; block_idx < bitmap->b_nr; ++block_idx) {
 			if (m0_bitmap_get(bitmap, block_idx))
@@ -951,19 +968,28 @@ M0_INTERNAL void m0_sns_ir_recover(struct m0_sns_ir *ir,
 		}
 	}
 	blocks = ir->si_blocks;
-	switch (ir->si_mode) {
+	switch (block_type) {
 	/* Input block is assumed to be an untransformed block, and is used for
 	 * recovering all failed blocks */
-	case M0_SI_BARE:
+	case M0_SI_BLOCK_LOCAL:
+
+		M0_CNT_DEC(ir->si_local_nr);
 		alive_block = &blocks[block_idx];
 		alive_block->sib_addr = bufvec;
 		for (j = 0; j < block_count(ir); ++j)
-			if (ir->si_blocks[j].sib_status == M0_SI_BLOCK_FAILED)
+			if (ir->si_blocks[j].sib_status == M0_SI_BLOCK_FAILED) {
 				incr_recover(&blocks[j], alive_block, ir);
+				m0_bitmap_set(&blocks[j].sib_bitmap,
+					      alive_block->sib_idx, false);
+			}
+		if (ir->si_local_nr == 0 && are_failures_mixed(ir)) {
+			failed_data_blocks_xform(ir);
+		}
 		break;
+
 	/* Input block is assumed to be a transformed block, and is
 	 * cummulatively added to a block with index failed_index. */
-	case M0_SI_XFORM:
+	case M0_SI_BLOCK_REMOTE:
 		if (!is_usable(ir, (struct m0_bitmap*) bitmap,
 			       &blocks[failed_index]))
 			break;
@@ -971,6 +997,10 @@ M0_INTERNAL void m0_sns_ir_recover(struct m0_sns_ir *ir,
 		       1);
 		dependency_bitmap_update(&blocks[failed_index],
 					 bitmap);
+		if (is_data(ir, failed_index) && are_failures_mixed(ir) &&
+		    ir->si_local_nr != 0)
+			forward_rectification(ir, bufvec, failed_index);
+
 		break;
 	}
 }
@@ -997,8 +1027,6 @@ static void incr_recover(struct m0_sns_ir_block *failed_block,
 		mat_elem = *m0_matrix_elem_get(mat, col, row);
 		gfaxpy(failed_block->sib_addr, alive_block->sib_addr,
 		       mat_elem);
-		m0_bitmap_set(&failed_block->sib_bitmap, alive_block->sib_idx,
-			      false);
 	}
 }
 
@@ -1063,31 +1091,53 @@ static void dependency_bitmap_update(struct m0_sns_ir_block *block,
 	}
 }
 
-void m0_sns_ir_local_xform(struct m0_sns_ir *ir)
+static void forward_rectification(struct m0_sns_ir *ir,
+				  struct m0_bufvec *in_bufvec,
+				  uint32_t failed_index)
+{
+	struct m0_sns_ir_block in_block;
+	uint32_t	       j;
+
+	M0_PRE(ir->si_local_nr != 0);
+	M0_PRE(is_data(ir, failed_index));
+	M0_PRE(ir->si_blocks[failed_index].sib_status == M0_SI_BLOCK_FAILED);
+
+	memcpy(&in_block, &ir->si_blocks[failed_index], sizeof in_block);
+	in_block.sib_addr = in_bufvec;
+	for (j = 0; j < block_count(ir); ++j)
+		if (!is_data(ir, ir->si_blocks[j].sib_idx) &&
+		    ir->si_blocks[j].sib_status == M0_SI_BLOCK_FAILED)
+			incr_recover(&ir->si_blocks[j],
+				     &in_block,
+				     ir);
+}
+
+static void failed_data_blocks_xform(struct m0_sns_ir *ir)
 {
 	struct m0_sns_ir_block *res_block;
 	struct m0_sns_ir_block *par_block;
 	uint32_t		i;
 	uint32_t		j;
 
-	M0_PRE(ir != NULL);
-	M0_PRE(ir->si_mode == M0_SI_BARE);
+	M0_PRE(ir->si_local_nr == 0);
 	res_block = ir->si_blocks;
 	par_block = ir->si_blocks;
 
 	for (i = 0; i < block_count(ir); ++i) {
 		if (is_data(ir, ir->si_blocks[i].sib_idx) &&
-		    ir->si_blocks[i].sib_status == M0_SI_BLOCK_FAILED)
+			    ir->si_blocks[i].sib_status == M0_SI_BLOCK_FAILED)
 			for (j = 0; j < block_count(ir); ++j) {
 				if (!is_data(ir, ir->si_blocks[j].sib_idx) &&
-				    ir->si_blocks[j].sib_status ==
-				    M0_SI_BLOCK_FAILED)
+					     ir->si_blocks[j].sib_status ==
+					     M0_SI_BLOCK_FAILED) {
 					incr_recover(&par_block[j],
-						     &res_block[i],
-						     ir);
+						     &res_block[i], ir);
+					m0_bitmap_set(&par_block[j].sib_bitmap,
+						      res_block[i].sib_idx,
+						      false);
+				}
 			}
 	}
-	ir->si_mode = M0_SI_XFORM;
 }
 
 static inline bool is_valid_block_idx(const struct m0_sns_ir *ir,
@@ -1150,6 +1200,10 @@ static inline const struct m0_matrix* recovery_mat_get(const struct m0_sns_ir
 		&ir->si_parity_recovery_mat;
 }
 
+static inline  bool are_failures_mixed(const struct m0_sns_ir *ir)
+{
+	return !!ir->si_data_nr && !!ir->si_parity_nr;
+}
 static inline uint32_t block_count(const struct m0_sns_ir *ir)
 {
 	return ir->si_data_nr + ir->si_parity_nr;
diff --git a/sns/parity_math.h b/sns/parity_math.h
index 703d572..45b9634 100644
--- a/sns/parity_math.h
+++ b/sns/parity_math.h
@@ -57,9 +57,9 @@ enum m0_sns_ir_block_status {
 	M0_SI_BLOCK_FAILED,
 };
 
-enum m0_sns_ir_mode {
-	M0_SI_BARE,
-	M0_SI_XFORM,
+enum m0_sns_ir_block_type {
+	M0_SI_BLOCK_LOCAL,
+	M0_SI_BLOCK_REMOTE,
 };
 /**
  * Every member of a parity-group is called as a block. During incremental
@@ -121,6 +121,9 @@ struct m0_sns_ir {
 	uint32_t		si_parity_nr;
 	uint32_t		si_failed_data_nr;
 	uint32_t		si_alive_nr;
+	/* Number of blocks from a parity group that are available locally
+	 * on a node. */
+	uint32_t		si_local_nr;
 	/* Array holding all blocks */
 	struct m0_sns_ir_block *si_blocks;
 	/* Vandermonde matrix used during RS encoding */
@@ -131,8 +134,6 @@ struct m0_sns_ir {
 	 * math::pmi_vandmat_parity_slice.
 	 */
 	struct m0_matrix	si_parity_recovery_mat;
-	/* Mode in which incremental recovery is currently operating. */
-	enum m0_sns_ir_mode     si_mode;
 };
 
 /**
@@ -470,13 +471,15 @@ M0_INTERNAL int m0_sns_ir_failure_register(struct m0_bufvec *recov_addr,
 /**
  * Populates the structure m0_sns_ir with fields relevant for recovery.
  * @param[in]  math
+ * @param[in]  local_nr Number of blocks from a parity group, that are available
+ *			locally on a node.
  * @param[out] ir
  * @retval     0       on success
  * @retval     -ENOMEM when it fails to allocate array of m0_sns_ir_block or
  *		       when initialization of bitmap fails.
  */
 M0_INTERNAL int m0_sns_ir_init(const struct m0_parity_math *math,
-			       struct m0_sns_ir *ir);
+			       uint32_t local_nr, struct m0_sns_ir *ir);
 /**
  * Computes data-recovery matrix. Populates dependency bitmaps for failed
  * blocks.
@@ -499,11 +502,15 @@ M0_INTERNAL int m0_sns_ir_mat_compute(struct m0_sns_ir *ir);
  *			    bufvec.
  * @param[in] failed_index  index of a failed block for which the input bufvec
  *			    is to be used.
+ * @param[in] block_type    indicates whether incoming block is placed locally
+ *			    on a node or coming from a remote node. All remote
+ *			    blocks are assumed to be transformed.
  */
 M0_INTERNAL void m0_sns_ir_recover(struct m0_sns_ir *ir,
 				   struct m0_bufvec *bufvec,
 				   const struct m0_bitmap *bitmap,
-				   uint32_t failed_index);
+				   uint32_t failed_indexi,
+				   enum m0_sns_ir_block_type block_type);
 /**
  * When failures include both data and parity blocks, this function uses
  * local copy of recovered (partially or fully) data-block for recovering
diff --git a/sns/ut/parity_math_ut.c b/sns/ut/parity_math_ut.c
index 79424d1..509b3a5 100644
--- a/sns/ut/parity_math_ut.c
+++ b/sns/ut/parity_math_ut.c
@@ -696,7 +696,7 @@ static void direct_recover(struct m0_parity_math *math,  struct m0_bufvec *x,
 			rand() % (math->pmi_parity_count + 1);
 
 	failed_arr = failure_setup(math, total_failures, MIXED_FAILURE);
-	ret = m0_sns_ir_init(math, &ir);
+	ret = m0_sns_ir_init(math, &ir, 0);
 	M0_UT_ASSERT(ret == 0);
 
 	ret = m0_vector_init(&b, ir.si_data_nr);
@@ -909,7 +909,8 @@ static void sns_ir_nodes_init(struct m0_parity_math *math,
 			node[i].sin_alive_nr = alive_bpn;
 		else
 			node[i].sin_alive_nr = alive_bpn + alive_nr % node_nr;
-		ret = m0_sns_ir_init(math, &node[i].sin_ir);
+		ret = m0_sns_ir_init(math, &node[i].sin_ir,
+				     node[i].sin_alive_nr);
 		M0_UT_ASSERT(ret == 0);
 		M0_ALLOC_ARR(node[i].sin_alive, node[i].sin_alive_nr);
 		M0_UT_ASSERT(node[i].sin_alive != NULL);
@@ -1003,14 +1004,16 @@ static void sns_ir_nodes_recover(struct sns_ir_node *node, uint32_t node_nr,
 			if (alive_idx < ir.si_data_nr) {
 				m0_sns_ir_recover(&node[i].sin_ir,
 						  &x[alive_idx],
-						  &alive_bitmap, 0);
+						  &alive_bitmap, 0,
+						  M0_SI_BLOCK_LOCAL);
 			}
 			else if (alive_idx >= ir.si_data_nr &&
 				 alive_idx < ir.si_data_nr + ir.si_parity_nr) {
 				m0_sns_ir_recover(&node[i].sin_ir,
 						  &p[alive_idx -
 						  ir.si_data_nr],
-						  &alive_bitmap, 0);
+						  &alive_bitmap, 0,
+						  M0_SI_BLOCK_LOCAL);
 			}
 			for (k = 0; k < total_failures; ++k) {
 				m0_bitmap_set(&node[i].sin_bitmap[k],
@@ -1019,7 +1022,6 @@ static void sns_ir_nodes_recover(struct sns_ir_node *node, uint32_t node_nr,
 			m0_bitmap_set(&alive_bitmap, node[i].sin_alive[j],
 				      false);
 		}
-		m0_sns_ir_local_xform(&node[i].sin_ir);
 	}
 	m0_bitmap_fini(&alive_bitmap);
 }
@@ -1037,7 +1039,7 @@ static void sns_ir_nodes_gather(struct sns_ir_node *node, uint32_t node_nr,
 			m0_sns_ir_recover(&node[0].sin_ir,
 					  &node[i].sin_recov_arr[k],
 					  &node[i].sin_bitmap[k],
-					  failed_arr[k]);
+					  failed_arr[k], M0_SI_BLOCK_REMOTE);
 		}
 	}
 }
-- 
1.8.3.2

