From 299792cb97959b7d0ba9dd8e89c7cfce0e171561 Mon Sep 17 00:00:00 2001
From: Mandar Sawant <mandar_sawant@xyratex.com>
Date: Wed, 11 Sep 2013 17:21:54 +0530
Subject: [PATCH 7/9] Integrated RS changes to handle intermittent remote cp
 transformation with sns.

---
 sns/cm/repair/ag.c       | 10 ++++++----
 sns/cm/repair/ut/xform.c |  6 +++++-
 sns/cm/repair/xform.c    |  8 +++++---
 sns/parity_math.h        |  2 +-
 sns/ut/parity_math_ut.c  |  7 +++----
 5 files changed, 20 insertions(+), 13 deletions(-)

diff --git a/sns/cm/repair/ag.c b/sns/cm/repair/ag.c
index c5bbf6f..cbd0117 100644
--- a/sns/cm/repair/ag.c
+++ b/sns/cm/repair/ag.c
@@ -96,8 +96,8 @@ static int incr_recover_failure_register(struct m0_sns_cm_repair_ag *rag)
 						rag->rag_fc[i].fc_failed_idx,
 						&rag->rag_ir);
 		/*XXX: Remove this after finding a better solution.*/
-		if (rag->rag_base.sag_base.cag_cp_local_nr == 0)
-			rag->rag_ir.si_mode = M0_SI_XFORM;
+		/*if (rag->rag_base.sag_base.cag_cp_local_nr == 0)
+			rag->rag_ir.si_mode = M0_SI_XFORM;*/
 		if (rc != 0)
 			goto out;
 	}
@@ -109,7 +109,8 @@ out:
 static int incr_recover_init(struct m0_sns_cm_repair_ag *rag,
 			     struct m0_pdclust_layout *pl)
 {
-	int rc;
+	uint64_t local_cp_nr;
+	int      rc;
 
 	M0_PRE(rag != NULL);
 	M0_PRE(pl != NULL);
@@ -122,7 +123,8 @@ static int incr_recover_init(struct m0_sns_cm_repair_ag *rag,
 	if (m0_pdclust_K(pl) == 1)
 		return 0;
 
-	rc = m0_sns_ir_init(&rag->rag_math, &rag->rag_ir);
+	local_cp_nr = rag->rag_base.sag_base.cag_cp_local_nr;
+	rc = m0_sns_ir_init(&rag->rag_math, local_cp_nr, &rag->rag_ir);
 	if (rc != 0) {
 		m0_parity_math_fini(&rag->rag_math);
 		return rc;
diff --git a/sns/cm/repair/ut/xform.c b/sns/cm/repair/ut/xform.c
index 62ea230..ab6ab61 100644
--- a/sns/cm/repair/ut/xform.c
+++ b/sns/cm/repair/ut/xform.c
@@ -392,9 +392,13 @@ static void test_multi_cp_single_failure(void)
 
 static void rs_init()
 {
+	uint64_t local_cp_nr;
+
+	local_cp_nr = n_rag.rag_base.sag_base.cag_cp_local_nr;
 	M0_UT_ASSERT(m0_parity_math_init(&n_rag.rag_math, DATA_NR,
 					 PARITY_NR) == 0);
-	M0_UT_ASSERT(m0_sns_ir_init(&n_rag.rag_math, &n_rag.rag_ir) == 0);
+	M0_UT_ASSERT(m0_sns_ir_init(&n_rag.rag_math, local_cp_nr,
+				    &n_rag.rag_ir) == 0);
 }
 
 static void buffers_attach(struct m0_net_buffer *nb, struct m0_cm_cp *cp,
diff --git a/sns/cm/repair/xform.c b/sns/cm/repair/xform.c
index 5a1c433..4e07f85 100644
--- a/sns/cm/repair/xform.c
+++ b/sns/cm/repair/xform.c
@@ -149,12 +149,16 @@ static void cp_xor_recover(struct m0_cm_cp *dst_cp, struct m0_cm_cp *src_cp)
 
 static void cp_rs_recover(struct m0_cm_cp *src_cp, uint32_t failed_index)
 {
+	struct m0_sns_cm_cp        *scp;
 	struct m0_net_buffer       *nbuf_head;
 	struct m0_sns_cm_repair_ag *rag = sag2repairag(ag2snsag(src_cp->c_ag));
+	enum m0_sns_ir_block_type   bt;
 
 	nbuf_head = cp_data_buf_tlist_head(&src_cp->c_buffers);
+	scp = cp2snscp(src_cp);
+	bt = scp->sc_is_local ? M0_SI_BLOCK_LOCAL : M0_SI_BLOCK_REMOTE;
 	m0_sns_ir_recover(&rag->rag_ir, &nbuf_head->nb_buffer,
-			  &src_cp->c_xform_cp_indices, failed_index);
+			  &src_cp->c_xform_cp_indices, failed_index, bt);
 }
 
 /*
@@ -271,8 +275,6 @@ M0_INTERNAL int m0_sns_cm_repair_cp_xform(struct m0_cm_cp *cp)
 		else if ((rag->rag_math.pmi_parity_algo ==
 				M0_PARITY_CAL_ALGO_REED_SOLOMON) && !rs_done) {
 			cp_rs_recover(cp, scp->sc_failed_idx);
-			if (ag->cag_cp_local_nr == ag->cag_transformed_cp_nr)
-				m0_sns_ir_local_xform(&rag->rag_ir);
 			rs_done = true;
 		}
 		//cp_incr_recover(res_cp, cp, rag->rag_fc[i].fc_failed_idx);
diff --git a/sns/parity_math.h b/sns/parity_math.h
index 45b9634..6c818e6 100644
--- a/sns/parity_math.h
+++ b/sns/parity_math.h
@@ -518,7 +518,7 @@ M0_INTERNAL void m0_sns_ir_recover(struct m0_sns_ir *ir,
  * per parity group. Subsequent triggers will result into a no-operaiton.
  * @param ir holds information relevant for recovery
  */
-M0_INTERNAL void m0_sns_ir_local_xform(struct m0_sns_ir *ir);
+//M0_INTERNAL void m0_sns_ir_local_xform(struct m0_sns_ir *ir);
 M0_INTERNAL void m0_sns_ir_fini(struct m0_sns_ir *ir);
 /** @} end group Incremental recovery APIs */
 
diff --git a/sns/ut/parity_math_ut.c b/sns/ut/parity_math_ut.c
index 509b3a5..87b8602 100644
--- a/sns/ut/parity_math_ut.c
+++ b/sns/ut/parity_math_ut.c
@@ -696,7 +696,7 @@ static void direct_recover(struct m0_parity_math *math,  struct m0_bufvec *x,
 			rand() % (math->pmi_parity_count + 1);
 
 	failed_arr = failure_setup(math, total_failures, MIXED_FAILURE);
-	ret = m0_sns_ir_init(math, &ir, 0);
+	ret = m0_sns_ir_init(math, 0, &ir);
 	M0_UT_ASSERT(ret == 0);
 
 	ret = m0_vector_init(&b, ir.si_data_nr);
@@ -909,8 +909,7 @@ static void sns_ir_nodes_init(struct m0_parity_math *math,
 			node[i].sin_alive_nr = alive_bpn;
 		else
 			node[i].sin_alive_nr = alive_bpn + alive_nr % node_nr;
-		ret = m0_sns_ir_init(math, &node[i].sin_ir,
-				     node[i].sin_alive_nr);
+		ret = m0_sns_ir_init(math, node[i].sin_alive_nr, &node[i].sin_ir);
 		M0_UT_ASSERT(ret == 0);
 		M0_ALLOC_ARR(node[i].sin_alive, node[i].sin_alive_nr);
 		M0_UT_ASSERT(node[i].sin_alive != NULL);
@@ -1099,7 +1098,7 @@ static void test_invalid_input(void)
 	M0_UT_ASSERT(ret == 0);
 	total_failures = math.pmi_parity_count + 1;
 	failed_arr = failure_setup(&math, total_failures, MIXED_FAILURE);
-	ret = m0_sns_ir_init(&math, &ir);
+	ret = m0_sns_ir_init(&math, 0, &ir);
 	for (i = 0; i < total_failures - 1; ++i) {
 		ret = m0_sns_ir_failure_register(&recov_arr,
 						 failed_arr[i],
-- 
1.8.3.2

