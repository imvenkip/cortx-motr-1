From 8cc9352f4c84eda9eb919ca529bc40a345a849c2 Mon Sep 17 00:00:00 2001
From: Mandar Sawant <mandar_sawant@xyratex.com>
Date: Tue, 10 Sep 2013 11:30:21 +0530
Subject: [PATCH 5/9] Fixed issues found during testing. - Handle case where
 local copy packets are zero.

---
 cm/cp.c                |  2 +-
 sns/cm/cm.c            |  1 +
 sns/cm/cp.c            |  2 ++
 sns/cm/cp.h            |  4 ++++
 sns/cm/iter.c          |  3 ++-
 sns/cm/net.c           |  2 ++
 sns/cm/repair/acc_cp.c |  8 ++++++--
 sns/cm/repair/ag.c     |  8 +++++++-
 sns/cm/repair/xform.c  | 35 +++++++++++++++++++++++++++++------
 sns/cm/sns_cp_onwire.h |  2 ++
 sns/parity_math.c      |  2 +-
 11 files changed, 57 insertions(+), 12 deletions(-)

diff --git a/cm/cp.c b/cm/cp.c
index 6aa3741..afed38c 100644
--- a/cm/cp.c
+++ b/cm/cp.c
@@ -426,12 +426,12 @@ static void cp_fom_fini(struct m0_fom *fom)
 	M0_CNT_INC(ag->cag_freed_cp_nr);
 	ag_fini = ag->cag_ops->cago_ag_can_fini(ag, cp);
 	m0_cm_cp_fini(cp);
-	cp->c_ops->co_free(cp);
 	/**
 	 * Try to create a new copy packet since this copy packet is
 	 * making way for new copy packets in sliding window.
 	 */
 	m0_cm_lock(cm);
+	cp->c_ops->co_free(cp);
         if (ag_fini)
                 ag->cag_ops->cago_fini(ag);
 	if (m0_cm_has_more_data(cm))
diff --git a/sns/cm/cm.c b/sns/cm/cm.c
index 6b6f3fb..cfdbbc1 100644
--- a/sns/cm/cm.c
+++ b/sns/cm/cm.c
@@ -713,6 +713,7 @@ M0_INTERNAL int m0_sns_cm_buf_attach(struct m0_net_buffer_pool *bp,
 		if (buf == NULL)
 			return -ENOBUFS;
 		m0_cm_cp_buf_add(cp, buf);
+		buf->nb_buffer.ov_vec.v_nr = seg_nr;
 		M0_CNT_DEC(rem_bufs);
 		if (!scp->sc_is_local) {
 			if (scm->sc_ibp_reserved_nr > 0)
diff --git a/sns/cm/cp.c b/sns/cm/cp.c
index 44c052b..3cc472a 100644
--- a/sns/cm/cp.c
+++ b/sns/cm/cp.c
@@ -220,6 +220,7 @@ M0_INTERNAL int m0_sns_cm_cp_setup(struct m0_sns_cm_cp *scp,
 				   const struct m0_fid *cob_fid,
 				   uint64_t stob_offset,
 				   uint64_t data_seg_nr,
+				   uint64_t failed_unit_index,
 				   uint64_t ag_cp_idx)
 {
 	struct m0_sns_cm *scm = cm2sns(scp->sc_base.c_ag->cag_cm);
@@ -228,6 +229,7 @@ M0_INTERNAL int m0_sns_cm_cp_setup(struct m0_sns_cm_cp *scp,
 	M0_PRE(scp != NULL && scp->sc_base.c_ag != NULL);
 
 	scp->sc_base.c_data_seg_nr = data_seg_nr;
+	scp->sc_failed_idx = failed_unit_index;
 	m0_sns_cm_cp_tgt_info_fill(scp, cob_fid, stob_offset, ag_cp_idx);
 	m0_bitmap_init(&scp->sc_base.c_xform_cp_indices,
                        scp->sc_base.c_ag->cag_cp_global_nr);
diff --git a/sns/cm/cp.h b/sns/cm/cp.h
index e0c0993..319cfbd 100644
--- a/sns/cm/cp.h
+++ b/sns/cm/cp.h
@@ -50,6 +50,8 @@ struct m0_sns_cm_cp {
 	 */
 	bool                   sc_is_local;
 
+	uint64_t               sc_failed_idx;
+
 	bool                   sc_is_acc;
 
 	/** Offset within the stob. */
@@ -122,7 +124,9 @@ M0_INTERNAL int m0_sns_cm_cp_setup(struct m0_sns_cm_cp *scp,
 				   const struct m0_fid *cob_fid,
 				   uint64_t stob_offset,
 				   uint64_t data_seg_nr,
+				   uint64_t failed_unit_index,
 				   uint64_t ag_cp_idx);
+
 M0_INTERNAL void m0_sns_cm_cp_addb_log(const struct m0_cm_cp *cp);
 
 /** @} SNSCMCP */
diff --git a/sns/cm/iter.c b/sns/cm/iter.c
index 2bd8fb0..06f8877 100644
--- a/sns/cm/iter.c
+++ b/sns/cm/iter.c
@@ -529,7 +529,8 @@ static int iter_cp_setup(struct m0_sns_cm_iter *it)
 		 * index of the copy packet is (sfc->sfc_sa.sa_unit - 1).
 		 */
 		rc = m0_sns_cm_cp_setup(scp, &sfc->sfc_cob_fid, stob_offset,
-					cp_data_seg_nr, sfc->sfc_sa.sa_unit - 1);
+					cp_data_seg_nr, ~0,
+					sfc->sfc_sa.sa_unit - 1);
 		if (rc < 0)
 			M0_RETURN(rc);
 
diff --git a/sns/cm/net.c b/sns/cm/net.c
index 880bd39..d5a3f6a 100644
--- a/sns/cm/net.c
+++ b/sns/cm/net.c
@@ -111,6 +111,7 @@ static void snscpx_to_snscp(const struct m0_sns_cpx *sns_cpx,
         sns_cp->sc_sid.si_bits.u_hi = sns_cpx->scx_sid.f_container;
         sns_cp->sc_sid.si_bits.u_lo = sns_cpx->scx_sid.f_key;
 	sns_cp->sc_cobfid = sns_cpx->scx_sid;
+	sns_cp->sc_failed_idx = sns_cpx->scx_failed_idx;
 
         sns_cp->sc_index =
                 sns_cpx->scx_ivecs.cis_ivecs[0].ci_iosegs[0].ci_index;
@@ -158,6 +159,7 @@ static int snscp_to_snscpx(struct m0_sns_cm_cp *sns_cp,
 
         sns_cpx->scx_sid.f_container = sns_cp->sc_sid.si_bits.u_hi;
         sns_cpx->scx_sid.f_key = sns_cp->sc_sid.si_bits.u_lo;
+	sns_cpx->scx_failed_idx = sns_cp->sc_failed_idx;
         sns_cpx->scx_cp.cpx_prio = cp->c_prio;
         sns_cpx->scx_phase = M0_CCP_SEND;
         m0_cm_ag_id_copy(&sns_cpx->scx_cp.cpx_ag_id, &cp->c_ag->cag_id);
diff --git a/sns/cm/repair/acc_cp.c b/sns/cm/repair/acc_cp.c
index 84ea27f..192be3b 100644
--- a/sns/cm/repair/acc_cp.c
+++ b/sns/cm/repair/acc_cp.c
@@ -30,7 +30,7 @@
 
 #include "sns/cm/cp.h"
 #include "sns/cm/cm.h"
-#include "sns/cm/ag.h"
+#include "sns/cm/repair/ag.h"
 #include "sns/cm/cm_utils.h"
 
 /**
@@ -53,8 +53,11 @@ M0_INTERNAL int m0_sns_cm_repair_cp_recv_wait(struct m0_cm_cp *cp);
 
 static void acc_cp_free(struct m0_cm_cp *cp)
 {
+        struct m0_sns_cm_repair_ag *rag = sag2repairag(ag2snsag(cp->c_ag));
+
 	M0_PRE(cp != NULL);
 
+	M0_CNT_INC(rag->rag_acc_freed);
 	m0_cm_cp_buf_release(cp);
 }
 
@@ -109,6 +112,7 @@ M0_INTERNAL void m0_sns_cm_acc_cp_init(struct m0_sns_cm_cp *scp,
 M0_INTERNAL int m0_sns_cm_acc_cp_setup(struct m0_sns_cm_cp *scp,
 				       struct m0_fid *tgt_cobfid,
 				       uint64_t tgt_cob_index,
+				       uint64_t failed_unit_idx,
 				       uint64_t data_seg_nr)
 {
 	struct m0_sns_cm_ag *sag = ag2snsag(scp->sc_base.c_ag);
@@ -121,7 +125,7 @@ M0_INTERNAL int m0_sns_cm_acc_cp_setup(struct m0_sns_cm_cp *scp,
 		scp->sc_is_local = true;
 	scp->sc_is_acc = true;
 	return m0_sns_cm_cp_setup(scp, tgt_cobfid, tgt_cob_index, data_seg_nr,
-				  ~0);
+				  failed_unit_idx, ~0);
 }
 
 /** @} SNSCMCP */
diff --git a/sns/cm/repair/ag.c b/sns/cm/repair/ag.c
index ebac865..c5bbf6f 100644
--- a/sns/cm/repair/ag.c
+++ b/sns/cm/repair/ag.c
@@ -48,6 +48,7 @@ M0_INTERNAL void m0_sns_cm_acc_cp_init(struct m0_sns_cm_cp *scp,
 M0_INTERNAL int m0_sns_cm_acc_cp_setup(struct m0_sns_cm_cp *scp,
 				       struct m0_fid *tgt_cobfid,
 				       uint64_t tgt_cob_index,
+				       uint64_t failed_unit_idx,
 				       uint64_t data_seg_nr);
 
 M0_INTERNAL struct m0_sns_cm_repair_ag *
@@ -94,6 +95,9 @@ static int incr_recover_failure_register(struct m0_sns_cm_repair_ag *rag)
 		rc = m0_sns_ir_failure_register(&nbuf_head->nb_buffer,
 						rag->rag_fc[i].fc_failed_idx,
 						&rag->rag_ir);
+		/*XXX: Remove this after finding a better solution.*/
+		if (rag->rag_base.sag_base.cag_cp_local_nr == 0)
+			rag->rag_ir.si_mode = M0_SI_XFORM;
 		if (rc != 0)
 			goto out;
 	}
@@ -169,7 +173,6 @@ static void repair_ag_fini(struct m0_cm_aggr_group *ag)
         cm = ag->cag_cm;
         M0_ASSERT(cm != NULL);
         scm = cm2sns(cm);
-	M0_CNT_INC(rag->rag_acc_freed);
 	/**
 	 * Free the aggregation group if this is the last copy packet
 	 * being finalised for a given aggregation group.
@@ -358,6 +361,7 @@ M0_INTERNAL int m0_sns_cm_repair_ag_setup(struct m0_sns_cm_ag *sag,
 		rc = m0_sns_cm_acc_cp_setup(&rag->rag_fc[i].fc_tgt_acc_cp,
 					    &rag->rag_fc[i].fc_tgt_cobfid,
 					    rag->rag_fc[i].fc_tgt_cob_index,
+					    rag->rag_fc[i].fc_failed_idx,
 					    cp_data_seg_nr);
 		if (rc < 0)
 			return rc;
@@ -389,6 +393,8 @@ M0_INTERNAL bool m0_sns_cm_ag_accumulator_is_full(const struct m0_sns_cm_ag *sag
 			M0_CNT_INC(xform_cp_nr);
 	}
 
+	M0_LOG(M0_DEBUG, "acc is full: xform_cp_nr: [%lu] global_cp_nr: [%lu]", xform_cp_nr,
+		global_cp_nr);
 	return xform_cp_nr == global_cp_nr - sag->sag_fnr ? true : false;
 }
 
diff --git a/sns/cm/repair/xform.c b/sns/cm/repair/xform.c
index 4a6e359..5a1c433 100644
--- a/sns/cm/repair/xform.c
+++ b/sns/cm/repair/xform.c
@@ -147,8 +147,7 @@ static void cp_xor_recover(struct m0_cm_cp *dst_cp, struct m0_cm_cp *src_cp)
 	}
 }
 
-static void cp_rs_recover(struct m0_cm_cp *dst_cp, struct m0_cm_cp *src_cp,
-			  uint32_t failed_index)
+static void cp_rs_recover(struct m0_cm_cp *src_cp, uint32_t failed_index)
 {
 	struct m0_net_buffer       *nbuf_head;
 	struct m0_sns_cm_repair_ag *rag = sag2repairag(ag2snsag(src_cp->c_ag));
@@ -158,6 +157,7 @@ static void cp_rs_recover(struct m0_cm_cp *dst_cp, struct m0_cm_cp *src_cp,
 			  &src_cp->c_xform_cp_indices, failed_index);
 }
 
+/*
 static void cp_incr_recover(struct m0_cm_cp *dst_cp, struct m0_cm_cp *src_cp,
 			    uint32_t failed_index)
 {
@@ -169,6 +169,7 @@ static void cp_incr_recover(struct m0_cm_cp *dst_cp, struct m0_cm_cp *src_cp,
 			M0_PARITY_CAL_ALGO_REED_SOLOMON)
 		cp_rs_recover(dst_cp, src_cp, failed_index);
 }
+*/
 
 /** Merges the source bitmap to the destination bitmap. */
 static void res_cp_bitmap_merge(struct m0_cm_cp *dst, struct m0_cm_cp *src)
@@ -216,6 +217,7 @@ out:
 M0_INTERNAL int m0_sns_cm_repair_cp_xform(struct m0_cm_cp *cp)
 {
 	struct m0_sns_cm_ag        *sns_ag;
+	struct m0_sns_cm_cp        *scp;
 	struct m0_sns_cm_repair_ag *rag;
 	struct m0_cm_aggr_group    *ag;
 	struct m0_cm_cp            *res_cp;
@@ -223,6 +225,8 @@ M0_INTERNAL int m0_sns_cm_repair_cp_xform(struct m0_cm_cp *cp)
         struct m0_dbenv            *dbenv;
         struct m0_cob_domain       *cdom;
 	struct m0_cm_ag_id          id;
+	bool                        bitmap_merge;
+	bool                        rs_done = false;
 	int                         rc;
 	int                         i;
 
@@ -231,6 +235,7 @@ M0_INTERNAL int m0_sns_cm_repair_cp_xform(struct m0_cm_cp *cp)
 	ag = cp->c_ag;
 	id = ag->cag_id;
 	scm = cm2sns(ag->cag_cm);
+	scp = cp2snscp(cp);
 	sns_ag = ag2snsag(ag);
 	rag = sag2repairag(sns_ag);
 	m0_cm_ag_lock(ag);
@@ -259,15 +264,29 @@ M0_INTERNAL int m0_sns_cm_repair_cp_xform(struct m0_cm_cp *cp)
 	}
 
 	for (i = 0; i < sns_ag->sag_fnr; ++i) {
+		bitmap_merge = false;
 		res_cp = &rag->rag_fc[i].fc_tgt_acc_cp.sc_base;
-		cp_incr_recover(res_cp, cp, rag->rag_fc[i].fc_failed_idx);
+		if (rag->rag_math.pmi_parity_algo == M0_PARITY_CAL_ALGO_XOR)
+			cp_xor_recover(res_cp, cp);
+		else if ((rag->rag_math.pmi_parity_algo ==
+				M0_PARITY_CAL_ALGO_REED_SOLOMON) && !rs_done) {
+			cp_rs_recover(cp, scp->sc_failed_idx);
+			if (ag->cag_cp_local_nr == ag->cag_transformed_cp_nr)
+				m0_sns_ir_local_xform(&rag->rag_ir);
+			rs_done = true;
+		}
+		//cp_incr_recover(res_cp, cp, rag->rag_fc[i].fc_failed_idx);
 
 		/*
 		 * Merge the bitmaps of incoming copy packet with the
 		 * resultant copy packet.
 		 */
-		if (cp->c_xform_cp_indices.b_nr > 0)
-			res_cp_bitmap_merge(res_cp, cp);
+		if (cp->c_xform_cp_indices.b_nr > 0) {
+			if (scp->sc_is_local || (scp->sc_failed_idx == rag->rag_fc[i].fc_failed_idx)) {
+				res_cp_bitmap_merge(res_cp, cp);
+				bitmap_merge = true;
+			}
+		}
 		/*
 		 * Check if all copy packets are processed at this stage,
 		 * For incoming path transformation can be marked as complete
@@ -280,13 +299,17 @@ M0_INTERNAL int m0_sns_cm_repair_cp_xform(struct m0_cm_cp *cp)
 		if ((rc = m0_sns_cm_cob_is_local(
 					&rag->rag_fc[i].fc_tgt_cobfid,
 					dbenv, cdom)) == 0) {
-			if (m0_sns_cm_ag_accumulator_is_full(sns_ag, i)) {
+			if (bitmap_merge && m0_sns_cm_ag_accumulator_is_full(sns_ag, i)) {
+				M0_LOG(M0_DEBUG, "1:Enqueuing acc got tgt ind: [%u]",
+					rag->rag_fc[i].fc_tgt_idx);
 				rc = res_cp_enqueue(res_cp);
 				if (rc != 0)
 					goto out;
 			}
 		} else if (rc == -ENOENT && ag->cag_cp_local_nr ==
 						ag->cag_transformed_cp_nr) {
+			M0_LOG(M0_DEBUG, "2:Enqueuing acc got tgt ind: [%u]",
+				rag->rag_fc[i].fc_tgt_idx);
 			rc = res_cp_enqueue(res_cp);
 			if (rc != 0)
 				goto out;
diff --git a/sns/cm/sns_cp_onwire.h b/sns/cm/sns_cp_onwire.h
index c2521fb..d627387 100644
--- a/sns/cm/sns_cp_onwire.h
+++ b/sns/cm/sns_cp_onwire.h
@@ -43,6 +43,8 @@ struct m0_sns_cpx {
         /** Destination stob id. */
         struct m0_fid             scx_sid;
 
+	uint64_t                  scx_failed_idx;
+
 	/** Copy packet fom phase before sending it onwire. */
 	uint32_t                  scx_phase;
 } M0_XCA_RECORD;
diff --git a/sns/parity_math.c b/sns/parity_math.c
index 11c3517..c04aef2 100644
--- a/sns/parity_math.c
+++ b/sns/parity_math.c
@@ -283,7 +283,7 @@ M0_INTERNAL void m0_parity_math_fini(struct m0_parity_math *math)
 		m0_matrix_fini(&math->pmi_sys_mat);
 		m0_vector_fini(&math->pmi_sys_vec);
 		m0_vector_fini(&math->pmi_sys_res);
-		m0_parity_fini();
+		//m0_parity_fini();
 	}
 }
 
-- 
1.8.3.2

