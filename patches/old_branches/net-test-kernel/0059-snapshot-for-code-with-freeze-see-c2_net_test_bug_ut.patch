From 08fd9adde1d9eede520583ef8d6749ec05ef257e Mon Sep 17 00:00:00 2001
From: Maxim Medved <Max_Medved@xyratex.com>
Date: Tue, 18 Dec 2012 16:35:27 +0200
Subject: [PATCH 59/71] snapshot for code with freeze, see c2_net_test_bug_ut()

---
 lib/linux_kernel/ktrace.c   |   6 +
 net/test/commands.c         |  16 +-
 net/test/commands.h         |  12 +-
 net/test/console.c          |  17 +-
 net/test/network.c          |   1 +
 net/test/node.c             |  21 +-
 net/test/node_bulk.c        | 168 +++++++-----
 net/test/node_helper.c      |   2 +-
 net/test/node_ping.c        |  97 ++++++-
 net/test/node_ping.h        |   1 +
 net/test/service.h          |   1 -
 net/test/ut/client_server.c |  32 ++-
 net/test/ut/commands.c      |   6 +-
 net/test/ut/main.c          |   6 +-
 net/test/ut/network.c       | 632 +++++++++++++++++++++++++++++++++++++++++++-
 utils/linux_kernel/main.c   |   4 +
 utils/ut.valgrind           |   2 +-
 utils/ut_main.c             |   6 +
 18 files changed, 897 insertions(+), 133 deletions(-)

diff --git a/lib/linux_kernel/ktrace.c b/lib/linux_kernel/ktrace.c
index 84f8e3a..6930a1a 100644
--- a/lib/linux_kernel/ktrace.c
+++ b/lib/linux_kernel/ktrace.c
@@ -35,6 +35,11 @@
  * @{
  */
 
+static char *trace_immediate_mask = "all";
+static char *trace_level	  = "debug+";
+static char *trace_print_context  = "full";
+
+/*
 static char *trace_immediate_mask;
 module_param(trace_immediate_mask, charp, 0644);
 MODULE_PARM_DESC(trace_immediate_mask,
@@ -53,6 +58,7 @@ MODULE_PARM_DESC(trace_print_context,
 		 " controls whether to display additional trace point"
 		 " info, like subsystem, file, func, etc.; values:"
 		 " none, func, full");
+*/
 
 static int set_trace_immediate_mask(void)
 {
diff --git a/net/test/commands.c b/net/test/commands.c
index 5074e88..f97f339 100644
--- a/net/test/commands.c
+++ b/net/test/commands.c
@@ -215,7 +215,7 @@ static void cmd_free(struct c2_net_test_cmd *cmd)
 	C2_PRE(cmd != NULL);
 
 	if (cmd->ntc_type == C2_NET_TEST_CMD_INIT) {
-		c2_net_test_str_fini  (&cmd->ntc_init.ntci_tm_ep);
+		c2_net_test_str_fini(&cmd->ntc_init.ntci_tm_ep);
 		c2_net_test_slist_fini(&cmd->ntc_init.ntci_ep);
 	}
 }
@@ -327,7 +327,7 @@ static void commands_recv_ep_put(struct c2_net_test_cmd_ctx *ctx,
 static bool is_buf_in_recv_q(struct c2_net_test_cmd_ctx *ctx,
 			  size_t buf_index)
 {
-	C2_PRE(buf_index < ctx->ntcc_ep_nr * 2);
+	C2_PRE(buf_index < ctx->ntcc_ep_nr * 3);
 
 	return ctx->ntcc_buf_status[buf_index].ntcbs_in_recv_queue;
 }
@@ -386,11 +386,11 @@ static int commands_initfini(struct c2_net_test_cmd_ctx *ctx,
 	if (rc != 0)
 		goto free_sem_send;
 
-	rc = c2_net_test_ringbuf_init(&ctx->ntcc_rb, ctx->ntcc_ep_nr * 2);
+	rc = c2_net_test_ringbuf_init(&ctx->ntcc_rb, ctx->ntcc_ep_nr * 3);
 	if (rc != 0)
 		goto free_sem_recv;
 
-	C2_ALLOC_ARR(ctx->ntcc_buf_status, ctx->ntcc_ep_nr * 2);
+	C2_ALLOC_ARR(ctx->ntcc_buf_status, ctx->ntcc_ep_nr * 3);
 	if (ctx->ntcc_buf_status == NULL)
 		goto free_rb;
 
@@ -398,7 +398,7 @@ static int commands_initfini(struct c2_net_test_cmd_ctx *ctx,
 					  &c2_net_test_commands_tm_cb,
 					  &commands_buffer_cb,
 					  C2_NET_TEST_CMD_SIZE_MAX,
-					  2 * ctx->ntcc_ep_nr,
+					  3 * ctx->ntcc_ep_nr,
 					  0, 0,
 					  ep_list->ntsl_nr,
 					  &timeouts, false);
@@ -408,7 +408,7 @@ static int commands_initfini(struct c2_net_test_cmd_ctx *ctx,
 	rc = c2_net_test_network_ep_add_slist(&ctx->ntcc_net, ep_list);
 	if (rc != 0)
 		goto free_net_ctx;
-	for (i = 0; i < ctx->ntcc_ep_nr; ++i) {
+	for (i = 0; i < ctx->ntcc_ep_nr * 2; ++i) {
 		rc = commands_recv_enqueue(ctx, ctx->ntcc_ep_nr + i);
 		if (rc != 0) {
 			commands_recv_dequeue_nr(ctx, i);
@@ -422,7 +422,7 @@ static int commands_initfini(struct c2_net_test_cmd_ctx *ctx,
     fini:
 	C2_PRE(c2_net_test_commands_invariant(ctx));
 	c2_net_test_commands_send_wait_all(ctx);
-	commands_recv_dequeue_nr(ctx, ctx->ntcc_ep_nr);
+	commands_recv_dequeue_nr(ctx, ctx->ntcc_ep_nr * 2);
     free_net_ctx:
 	c2_net_test_network_ctx_fini(&ctx->ntcc_net);
     free_buf_status:
@@ -588,7 +588,7 @@ bool c2_net_test_commands_invariant(struct c2_net_test_cmd_ctx *ctx)
 		return false;
 	if (ctx->ntcc_ep_nr != ctx->ntcc_net.ntc_ep_nr)
 		return false;
-	if (ctx->ntcc_ep_nr * 2 != ctx->ntcc_net.ntc_buf_ping_nr)
+	if (ctx->ntcc_ep_nr * 3 != ctx->ntcc_net.ntc_buf_ping_nr)
 		return false;
 	if (ctx->ntcc_net.ntc_buf_bulk_nr != 0)
 		return false;
diff --git a/net/test/commands.h b/net/test/commands.h
index f99dc6e..cfb4565 100644
--- a/net/test/commands.h
+++ b/net/test/commands.h
@@ -56,10 +56,12 @@ enum c2_net_test_role {
 
 /**
    Test type - can be ping test or bulk test.
+   C2_NET_TEST_TYPE_STUB used in UTs.
  */
 enum c2_net_test_type {
 	C2_NET_TEST_TYPE_PING,
-	C2_NET_TEST_TYPE_BULK
+	C2_NET_TEST_TYPE_BULK,
+	C2_NET_TEST_TYPE_STUB,
 };
 
 /**
@@ -228,7 +230,11 @@ typedef void (*c2_net_test_commands_send_cb_t)(struct c2_net_test_cmd_ctx *ctx,
    Commands context.
  */
 struct c2_net_test_cmd_ctx {
-	/** network context for this command context */
+	/**
+	 * Network context for this command context.
+	 * First ntcc_ep_nr ping buffers are used for commands sending,
+	 * other ntcc_ep_nr * 2 ping buffers are used for commands receiving.
+	 */
 	struct c2_net_test_network_ctx	   ntcc_net;
 	/**
 	   Ring buffer for receive queue.
@@ -278,7 +284,7 @@ struct c2_net_test_cmd_ctx {
    @return -errno (failure)
    @note
    - buffers for message sending/receiving will be allocated here,
-     two buffers per endpoint;
+     three buffers per endpoint: one for sending, two for receiving;
    - all buffers will have C2_NET_TEST_CMD_SIZE_MAX size;
    - all buffers for receiving commands will be added to receive queue here;
    - buffers will not be automatically added to receive queue after
diff --git a/net/test/console.c b/net/test/console.c
index 03ab858..4ec63c0 100644
--- a/net/test/console.c
+++ b/net/test/console.c
@@ -53,14 +53,13 @@
 
 static int console_role_init_fini(struct c2_net_test_console_role_ctx *ctx,
 				 struct c2_net_test_console_cfg *cfg,
-				 enum c2_net_test_role role,
-				 bool init)
+				 enum c2_net_test_role role)
 {
 	struct c2_net_test_slist *nodes;
 	char			 *addr_console;
 	int			  rc = -ENOMEM;
 
-	if (!init)
+	if (cfg == NULL)
 		goto fini;
 
 	addr_console = role == C2_NET_TEST_ROLE_CLIENT ?
@@ -107,32 +106,30 @@ success:
 }
 
 static int console_init_fini(struct c2_net_test_console_ctx *ctx,
-			     struct c2_net_test_console_cfg *cfg,
-			     bool init)
+			     struct c2_net_test_console_cfg *cfg)
 {
 	int rc;
 
 	C2_PRE(ctx != NULL);
-	C2_PRE(ergo(init, cfg != NULL));
 
 	ctx->ntcc_cfg = cfg;
 	rc = console_role_init_fini(&ctx->ntcc_clients, cfg,
-				    C2_NET_TEST_ROLE_CLIENT, init);
+				    C2_NET_TEST_ROLE_CLIENT);
 	if (rc == 0)
 		rc = console_role_init_fini(&ctx->ntcc_servers, cfg,
-					    C2_NET_TEST_ROLE_SERVER, init);
+					    C2_NET_TEST_ROLE_SERVER);
 	return rc;
 }
 
 int c2_net_test_console_init(struct c2_net_test_console_ctx *ctx,
 			     struct c2_net_test_console_cfg *cfg)
 {
-	return console_init_fini(ctx, cfg, true);
+	return console_init_fini(ctx, cfg);
 }
 
 void c2_net_test_console_fini(struct c2_net_test_console_ctx *ctx)
 {
-	int rc = console_init_fini(ctx, NULL, false);
+	int rc = console_init_fini(ctx, NULL);
 	C2_POST(rc == 0);
 }
 
diff --git a/net/test/network.c b/net/test/network.c
index 7127358..e03270e 100644
--- a/net/test/network.c
+++ b/net/test/network.c
@@ -406,6 +406,7 @@ void c2_net_test_network_ctx_fini(struct c2_net_test_network_ctx *ctx)
 	c2_free(ctx->ntc_buf_ping);
 	net_test_tm_stop(ctx->ntc_tm);
 	c2_net_tm_fini(ctx->ntc_tm);
+	c2_free(ctx->ntc_tm);
 	c2_net_domain_fini(ctx->ntc_dom);
 	c2_free(ctx->ntc_dom);
 }
diff --git a/net/test/node.c b/net/test/node.c
index a790c5c..3ee779c 100644
--- a/net/test/node.c
+++ b/net/test/node.c
@@ -176,6 +176,7 @@
      node_	-> service;
      node_u	-> node_;
      node_k	-> node_;
+     commands	-> network;
      console	-> commands;
      console_u	-> console;
      stats_u	-> stats;
@@ -694,20 +695,14 @@ enum {
 	NODE_WAIT_CMD_GRANULARITY_MS = 20,
 };
 
-static void node_tm_event_cb(const struct c2_net_tm_event *ev)
-{
-}
-
-static const struct c2_net_tm_callbacks node_tm_cb = {
-	.ntc_event_cb = node_tm_event_cb
-};
-
 static struct c2_net_test_service_ops *
 service_ops_get(struct c2_net_test_cmd *cmd)
 {
 	C2_PRE(cmd->ntc_type == C2_NET_TEST_CMD_INIT);
 
 	switch (cmd->ntc_init.ntci_type) {
+	case C2_NET_TEST_TYPE_STUB:
+		return &c2_net_test_node_stub_ops;
 	case C2_NET_TEST_TYPE_PING:
 		return &c2_net_test_node_ping_ops;
 	case C2_NET_TEST_TYPE_BULK:
@@ -833,15 +828,13 @@ static void node_thread(struct c2_net_test_node_ctx *ctx)
 }
 
 static int node_init_fini(struct c2_net_test_node_ctx *ctx,
-			  struct c2_net_test_node_cfg *cfg,
-			  bool init)
+			  struct c2_net_test_node_cfg *cfg)
 {
 	struct c2_net_test_slist ep_list;
 	int			 rc;
 
 	C2_PRE(ctx != NULL);
-	C2_PRE(ergo(init, cfg != NULL));
-	if (!init)
+	if (cfg == NULL)
 		goto fini;
 
 	C2_SET0(ctx);
@@ -874,12 +867,12 @@ failed:
 int c2_net_test_node_init(struct c2_net_test_node_ctx *ctx,
 			  struct c2_net_test_node_cfg *cfg)
 {
-	return node_init_fini(ctx, cfg, true);
+	return node_init_fini(ctx, cfg);
 }
 
 void c2_net_test_node_fini(struct c2_net_test_node_ctx *ctx)
 {
-	int rc = node_init_fini(ctx, NULL, false);
+	int rc = node_init_fini(ctx, NULL);
 	C2_POST(rc == 0);
 }
 
diff --git a/net/test/node_bulk.c b/net/test/node_bulk.c
index 41ba899..9b41e62 100644
--- a/net/test/node_bulk.c
+++ b/net/test/node_bulk.c
@@ -316,6 +316,11 @@ node_bulk_state_change_allowed(enum transfer_state from,
 	return i < allowed_size;
 }
 
+static bool node_bulk_state_is_final(enum transfer_state state)
+{
+	return C2_IN(state, (TS_FAILED, TS_TRANSFERRED, TS_BADMSG));
+}
+
 static void node_bulk_state_change(struct node_bulk_ctx *ctx,
 				   size_t bs_index,
 				   enum transfer_state state)
@@ -376,7 +381,7 @@ static void node_bulk_state_change(struct node_bulk_ctx *ctx,
 	/* add to ringbufs if needed */
 	if (state == TS_UNUSED)
 		c2_net_test_ringbuf_push(&ctx->nbc_rb_bulk_unused, bs_index);
-	if (C2_IN(state, (TS_FAILED, TS_TRANSFERRED, TS_BADMSG)))
+	if (node_bulk_state_is_final(state))
 		c2_net_test_ringbuf_push(&ctx->nbc_rb_bulk_final, bs_index);
 	/* set start & finish timestamp */
 	if (C2_IN(state, (TS_RECEIVING, TS_QUEUED)))
@@ -606,8 +611,8 @@ static void buf_desc_swap(struct node_bulk_ctx *ctx,
 		ctx->nbc_bs[buf_bulk_index].bsb_desc_send);
 }
 
-static void buf_desc_free(struct node_bulk_ctx *ctx,
-			  size_t buf_bulk_index)
+static void buf_desc_server_free(struct node_bulk_ctx *ctx,
+				 size_t buf_bulk_index)
 {
 	C2_PRE(ctx != NULL);
 	C2_PRE(buf_bulk_index < ctx->nbc_buf_bulk_nr);
@@ -616,6 +621,16 @@ static void buf_desc_free(struct node_bulk_ctx *ctx,
 	c2_net_desc_free(&ctx->nbc_bs[buf_bulk_index].bsb_desc_send);
 }
 
+static void buf_desc_client_free(struct node_bulk_ctx *ctx,
+				 size_t bs_index)
+{
+	C2_PRE(ctx != NULL);
+	C2_PRE(bs_index * 2 + 1 < ctx->nbc_buf_bulk_nr);
+
+	c2_net_desc_free(&net_buf_bulk_get(ctx, bs_index * 2)->nb_desc);
+	c2_net_desc_free(&net_buf_bulk_get(ctx, bs_index * 2 + 1)->nb_desc);
+}
+
 static c2_bcount_t buf_desc_deserialize(struct node_bulk_ctx *ctx,
 					size_t buf_bulk_index,
 					size_t buf_ping_index,
@@ -649,7 +664,7 @@ static c2_bcount_t buf_desc_deserialize(struct node_bulk_ctx *ctx,
 					       offset + len_total);
 	if (len == 0) {
 		/* free already allocated network descriptor */
-		buf_desc_free(ctx, buf_bulk_index);
+		buf_desc_server_free(ctx, buf_bulk_index);
 		return 0;
 	}
 	len_total = net_test_len_accumulate(len_total, len);
@@ -673,12 +688,10 @@ static c2_bcount_t node_bulk_server_transfer_start(struct node_bulk_ctx *ctx,
 						   size_t buf_ping_index,
 						   c2_bcount_t offset)
 {
-	struct buf_status_bulk *bs;
-	struct c2_net_buffer   *buf;
-	c2_bcount_t		len;
-	size_t			buf_bulk_index;
-	bool			no_unused_buf;
-	int			rc;
+	c2_bcount_t len;
+	size_t	    buf_bulk_index;
+	bool	    no_unused_buf;
+	int	    rc;
 
 	no_unused_buf = c2_net_test_ringbuf_is_empty(&ctx->nbc_rb_bulk_unused);
 	if (no_unused_buf) {
@@ -707,18 +720,14 @@ static c2_bcount_t node_bulk_server_transfer_start(struct node_bulk_ctx *ctx,
 	/* start active bulk receiving */
 	rc = c2_net_test_network_bulk_enqueue(&ctx->nbc_net, buf_bulk_index, 0,
 					      C2_NET_QT_ACTIVE_BULK_RECV);
-	bs = &ctx->nbc_bs[buf_bulk_index];
-	buf = c2_net_test_network_buf(&ctx->nbc_net, C2_NET_TEST_BUF_BULK,
-				      buf_bulk_index);
-	bs->bsb_recv.bse_func_rc = rc;
+	ctx->nbc_bs[buf_bulk_index].bsb_recv.bse_func_rc = rc;
 	if (rc != 0) {
 		/*
 		 * Addition buffer to network queue failed.
 		 * Free allocated (when deserialized) network descriptors.
 		 */
 		node_bulk_state_change(ctx, buf_bulk_index, TS_FAILED);
-		c2_net_desc_free(&bs->bsb_desc_send);
-		c2_net_desc_free(&buf->nb_desc);
+		buf_desc_server_free(ctx, buf_bulk_index);
 		sd_update(ctx, MT_BULK, MS_FAILED, MD_RECV);
 	}
 	return rc == 0 ? len : 0;
@@ -738,8 +747,8 @@ static void node_bulk_cb_server(struct node_bulk_ctx *ctx,
 	C2_PRE(ctx != NULL);
 	C2_PRE(ctx->nbc_nh.ntnh_role == C2_NET_TEST_ROLE_SERVER);
 	C2_PRE(ergo(q == C2_NET_QT_MSG_RECV, buf_index < ctx->nbc_buf_ping_nr));
-	C2_PRE(ergo(q == C2_NET_QT_ACTIVE_BULK_RECV ||
-		    q == C2_NET_QT_ACTIVE_BULK_SEND,
+	C2_PRE(ergo(C2_IN(q, (C2_NET_QT_ACTIVE_BULK_RECV,
+			      C2_NET_QT_ACTIVE_BULK_SEND)),
 		    buf_index < ctx->nbc_buf_bulk_nr));
 
 	if (q == C2_NET_QT_MSG_RECV) {
@@ -761,7 +770,7 @@ static void node_bulk_cb_server(struct node_bulk_ctx *ctx,
 	} else if (q == C2_NET_QT_ACTIVE_BULK_RECV) {
 		if (ev->nbe_status != 0) {
 			C2_LOG(C2_DEBUG, "--- active bulk recv FAILED!");
-			buf_desc_free(ctx, buf_index);
+			buf_desc_server_free(ctx, buf_index);
 			return;
 		}
 		/*
@@ -775,12 +784,45 @@ static void node_bulk_cb_server(struct node_bulk_ctx *ctx,
 		ctx->nbc_bs[buf_index].bsb_send.bse_func_rc = rc;
 		if (rc != 0) {
 			C2_LOG(C2_DEBUG, "--- active bulk send FAILED!");
-			buf_desc_free(ctx, buf_index);
+			buf_desc_server_free(ctx, buf_index);
 			node_bulk_state_change(ctx, buf_index, TS_FAILED);
 			sd_update(ctx, MT_BULK, MS_FAILED, MD_SEND);
 		}
 	} else if (q == C2_NET_QT_ACTIVE_BULK_SEND) {
-		buf_desc_free(ctx, buf_index);
+		buf_desc_server_free(ctx, buf_index);
+	}
+}
+
+static void node_bulk_cb_client(struct node_bulk_ctx *ctx,
+				size_t buf_index,
+				enum c2_net_queue_type q,
+				const struct c2_net_buffer_event *ev)
+{
+	struct buf_status_bulk *bs;
+
+	C2_PRE(ctx != NULL);
+	C2_PRE(ctx->nbc_nh.ntnh_role == C2_NET_TEST_ROLE_CLIENT);
+	C2_PRE(ergo(q == C2_NET_QT_MSG_SEND, buf_index < ctx->nbc_buf_ping_nr));
+	C2_PRE(ergo(C2_IN(q, (C2_NET_QT_PASSIVE_BULK_RECV,
+			      C2_NET_QT_PASSIVE_BULK_SEND)),
+		    buf_index < ctx->nbc_buf_bulk_nr));
+
+	if (q == C2_NET_QT_MSG_SEND) {
+		/*
+		 * Change state for every bulk buffer, which
+		 * descriptor is stored in current message.
+		 */
+		c2_tl_for(bsb, &ctx->nbc_bsp[buf_index].bsp_buffers, bs) {
+			bs->bsb_msg.bse_cb_rc = ev->nbe_status;
+			node_bulk_state_change_cb(ctx, bs->bsb_index,
+						  ev->nbe_status == 0);
+			bsb_tlist_del(bs);
+		} c2_tl_endfor;
+	} else if (C2_IN(q, (C2_NET_QT_PASSIVE_BULK_RECV,
+			     C2_NET_QT_PASSIVE_BULK_SEND))) {
+		bs = &ctx->nbc_bs[buf_index / 2];
+		if (node_bulk_state_is_final(bs->bsb_ts))
+			buf_desc_client_free(ctx, buf_index / 2);
 	}
 }
 
@@ -839,21 +881,9 @@ static void node_bulk_cb(struct c2_net_test_network_ctx *net_ctx,
 		bs_e->bse_cb_rc = ev->nbe_status;
 		node_bulk_state_change_cb(ctx, bs_index, ev->nbe_status == 0);
 	}
-	if (role_client && q == C2_NET_QT_MSG_SEND) {
-		/*
-		 * Change state for every bulk buffer, which
-		 * descriptor is stored in current message.
-		 */
-		c2_tl_for(bsb, &ctx->nbc_bsp[buf_index].bsp_buffers, bs) {
-			bs->bsb_msg.bse_cb_rc = ev->nbe_status;
-			node_bulk_state_change_cb(ctx, bs->bsb_index,
-						  ev->nbe_status == 0);
-			bsb_tlist_del(bs);
-		} c2_tl_endfor;
-	}
-	if (!role_client)
-		node_bulk_cb_server(ctx, buf_index, q, ev);
-	if (q == C2_NET_QT_MSG_SEND || q == C2_NET_QT_MSG_RECV) {
+	(role_client ? node_bulk_cb_client : node_bulk_cb_server)
+		(ctx, buf_index, q, ev);
+	if (C2_IN(q, (C2_NET_QT_MSG_SEND, C2_NET_QT_MSG_RECV))) {
 		/* ping buffer can be reused now */
 		c2_net_test_ringbuf_push(&ctx->nbc_rb_ping_unused, buf_index);
 	}
@@ -873,7 +903,6 @@ static void node_bulk_cb(struct c2_net_test_network_ctx *net_ctx,
 		  buf_send ? MD_SEND : MD_RECV);
 	/* state transitions from final states */
 	node_bulk_state_transition_auto_all(ctx);
-	/* reuse ping buffer on the test server */
 }
 
 static struct c2_net_test_network_buffer_callbacks node_bulk_buf_cb = {
@@ -931,7 +960,6 @@ static void client_transfer_start(struct node_bulk_ctx *ctx,
 	rc = client_bulk_enqueue(ctx, bs_index * 2);
 	bs->bsb_send.bse_func_rc = rc;
 	if (rc != 0) {
-		C2_LOG(C2_DEBUG, "123");
 		node_bulk_state_change(ctx, bs_index, TS_FAILED);
 		sd_update(ctx, MT_BULK, MS_FAILED, MD_SEND);
 		return;
@@ -939,7 +967,6 @@ static void client_transfer_start(struct node_bulk_ctx *ctx,
 	rc = client_bulk_enqueue(ctx, bs_index * 2 + 1);
 	bs->bsb_recv.bse_func_rc = rc;
 	if (rc != 0) {
-		C2_LOG(C2_DEBUG, "456");
 		node_bulk_state_change(ctx, bs_index, TS_FAILED1);
 		client_bulk_dequeue(ctx, bs_index * 2);
 		sd_update(ctx, MT_BULK, MS_FAILED, MD_RECV);
@@ -1257,29 +1284,8 @@ static void node_bulk_worker(struct node_bulk_ctx *ctx)
 	c2_net_test_nh_sd_copy_locked(&ctx->nbc_nh);
 }
 
-static void *node_bulk_init_fini(struct c2_net_test_service *svc,
-				 void *ctx_,
-				 bool init)
-{
-	struct node_bulk_ctx *ctx;
-
-	C2_PRE(ergo(init, ctx_ == NULL));
-	C2_PRE(ergo(init, svc != NULL));
-	if (init) {
-		C2_ALLOC_PTR(ctx);
-		if (ctx != NULL) {
-			ctx->nbc_svc			  = svc;
-			ctx->nbc_nh.ntnh_test_initialized = false;
-		}
-	} else {
-		ctx = NULL;
-	}
-	return ctx;
-}
-
 static int node_bulk_test_init_fini(struct node_bulk_ctx *ctx,
-				    const struct c2_net_test_cmd *cmd,
-				    bool init)
+				    const struct c2_net_test_cmd *cmd)
 {
 	struct c2_net_test_network_timeouts timeouts;
 	const struct c2_net_test_cmd_init  *icmd;
@@ -1293,9 +1299,8 @@ static int node_bulk_test_init_fini(struct node_bulk_ctx *ctx,
 	size_t				    nr;
 
 	C2_PRE(ctx != NULL);
-	C2_PRE(equi(init, cmd != NULL));
 
-	if (!init)
+	if (cmd == NULL)
 		goto fini;
 	icmd	    = &cmd->ntc_init;
 	role_client = icmd->ntci_role == C2_NET_TEST_ROLE_CLIENT;
@@ -1404,7 +1409,8 @@ free_bsp:
 	}
 free_sstatus:
 	if (ctx->nbc_nh.ntnh_role == C2_NET_TEST_ROLE_CLIENT) {
-		nr = init ? icmd->ntci_ep.ntsl_nr : ctx->nbc_net.ntc_ep_nr;
+		nr = cmd != NULL ? icmd->ntci_ep.ntsl_nr :
+				   ctx->nbc_net.ntc_ep_nr;
 		for (i = 0; i < nr; ++i) {
 			ss = &ctx->nbc_sstatus[i];
 			ssb_tlink_fini(ss);
@@ -1421,14 +1427,39 @@ success:
 	return rc;
 }
 
+static void *node_bulk_init_fini(void *ctx_,
+				 struct c2_net_test_service *svc,
+				 bool init)
+{
+	struct node_bulk_ctx *ctx;
+	int		      rc;
+
+	C2_PRE(equi(init, ctx_ == NULL));
+	C2_PRE(equi(init, svc != NULL));
+
+	if (init) {
+		C2_ALLOC_PTR(ctx);
+		if (ctx != NULL) {
+			ctx->nbc_svc			  = svc;
+			ctx->nbc_nh.ntnh_test_initialized = false;
+		}
+	} else {
+		ctx = ctx_;
+		rc = node_bulk_test_init_fini(ctx, NULL);
+		C2_ASSERT(rc == 0);
+		c2_free(ctx);
+	}
+	return init ? ctx : NULL;
+}
+
 static void *node_bulk_init(struct c2_net_test_service *svc)
 {
-	return node_bulk_init_fini(svc, NULL, true);
+	return node_bulk_init_fini(NULL, svc, true);
 }
 
 static void node_bulk_fini(void *ctx_)
 {
-	void *rc = node_bulk_init_fini(NULL, ctx_, false);
+	void *rc = node_bulk_init_fini(ctx_, NULL, false);
 	C2_POST(rc == NULL);
 }
 
@@ -1483,7 +1514,7 @@ static int node_bulk_cmd_init(void *ctx_,
 	    !ergo(role_client, 2 * ctx->nbc_bs_nr == ctx->nbc_buf_bulk_nr))
 		goto reply;
 
-	rc = node_bulk_test_init_fini(ctx, cmd, true);
+	rc = node_bulk_test_init_fini(ctx, cmd);
 reply:
 	/* fill reply */
 	reply->ntc_type = C2_NET_TEST_CMD_INIT_DONE;
@@ -1551,9 +1582,6 @@ static int node_bulk_cmd_stop(void *ctx_,
 	rc = c2_thread_join(&ctx->nbc_thread);
 	C2_ASSERT(rc == 0);
 	c2_thread_fini(&ctx->nbc_thread);
-	/* finalize test structures */
-	rc = node_bulk_test_init_fini(ctx, NULL, false);
-	C2_ASSERT(rc == 0);
 	/* change service state */
 	c2_net_test_service_state_change(ctx->nbc_svc,
 					 C2_NET_TEST_SERVICE_FINISHED);
diff --git a/net/test/node_helper.c b/net/test/node_helper.c
index 8c91a92..24d8a57 100644
--- a/net/test/node_helper.c
+++ b/net/test/node_helper.c
@@ -69,7 +69,7 @@ void c2_net_test_nh_sd_copy_locked(struct c2_net_test_nh *nh)
 }
 
 void c2_net_test_nh_sd_get_locked(struct c2_net_test_nh *nh,
-				struct c2_net_test_cmd_status_data *sd)
+				  struct c2_net_test_cmd_status_data *sd)
 {
 	C2_PRE(c2_net_test_nh__invariant(nh));
 
diff --git a/net/test/node_ping.c b/net/test/node_ping.c
index 3aa8432..45ac210 100644
--- a/net/test/node_ping.c
+++ b/net/test/node_ping.c
@@ -765,18 +765,22 @@ static void *node_ping_init_fini(void *ctx_,
 				 struct c2_net_test_service *svc,
 				 bool init)
 {
-	struct node_ping_ctx *ctx = ctx_;
+	struct node_ping_ctx *ctx;
+	int		      rc;
 
-	C2_PRE(equi(init, ctx == NULL));
+	C2_PRE(equi(init, ctx_ == NULL));
 	C2_PRE(equi(init, svc != NULL));
 
 	if (init) {
 		C2_ALLOC_PTR(ctx);
 		if (ctx != NULL) {
-			ctx->npc_svc = svc;
+			ctx->npc_svc			  = svc;
+			ctx->npc_nh.ntnh_test_initialized = false;
 		}
 	} else {
-		node_ping_test_init_fini(ctx, NULL);
+		ctx = ctx_;
+		rc = node_ping_test_init_fini(ctx, NULL);
+		C2_ASSERT(rc == 0);
 		c2_free(ctx);
 	}
 	return init ? ctx : NULL;
@@ -982,6 +986,91 @@ struct c2_net_test_service_ops c2_net_test_node_ping_ops = {
 	.ntso_cmd_handler_nr = ARRAY_SIZE(node_ping_cmd_handler),
 };
 
+static void *node_stub_init(struct c2_net_test_service *svc)
+{
+	return svc;
+}
+
+static void node_stub_fini(void *ctx_)
+{
+}
+
+static int node_stub_step(void *ctx_)
+{
+	return 0;
+}
+
+static int node_stub_cmd_init(void *ctx_,
+			      const struct c2_net_test_cmd *cmd,
+			      struct c2_net_test_cmd *reply)
+{
+	reply->ntc_type = C2_NET_TEST_CMD_INIT_DONE;
+	reply->ntc_done.ntcd_errno = 0;
+	return 0;
+}
+
+static int node_stub_cmd_start(void *ctx_,
+			       const struct c2_net_test_cmd *cmd,
+			       struct c2_net_test_cmd *reply)
+{
+	reply->ntc_type = C2_NET_TEST_CMD_START_DONE;
+	reply->ntc_done.ntcd_errno = 0;
+	return 0;
+}
+
+static int node_stub_cmd_stop(void *ctx_,
+			      const struct c2_net_test_cmd *cmd,
+			      struct c2_net_test_cmd *reply)
+{
+	c2_net_test_service_state_change(ctx_, C2_NET_TEST_SERVICE_FINISHED);
+	reply->ntc_type = C2_NET_TEST_CMD_STOP_DONE;
+	reply->ntc_done.ntcd_errno = 0;
+	return 0;
+}
+
+static int node_stub_cmd_status(void *ctx_,
+				const struct c2_net_test_cmd *cmd,
+				struct c2_net_test_cmd *reply)
+{
+	struct c2_net_test_cmd_status_data *sd;
+
+	reply->ntc_type = C2_NET_TEST_CMD_STATUS_DATA;
+	sd = &reply->ntc_status_data;
+	C2_SET0(sd);
+	sd->ntcsd_finished = true;
+	sd->ntcsd_time_start = c2_time_now();
+	sd->ntcsd_time_finish = c2_time_add(sd->ntcsd_time_start,
+					    C2_MKTIME(0, 1));
+	return 0;
+}
+
+static struct c2_net_test_service_cmd_handler node_stub_cmd_handler[] = {
+	{
+		.ntsch_type    = C2_NET_TEST_CMD_INIT,
+		.ntsch_handler = node_stub_cmd_init,
+	},
+	{
+		.ntsch_type    = C2_NET_TEST_CMD_START,
+		.ntsch_handler = node_stub_cmd_start,
+	},
+	{
+		.ntsch_type    = C2_NET_TEST_CMD_STOP,
+		.ntsch_handler = node_stub_cmd_stop,
+	},
+	{
+		.ntsch_type    = C2_NET_TEST_CMD_STATUS,
+		.ntsch_handler = node_stub_cmd_status,
+	},
+};
+
+struct c2_net_test_service_ops c2_net_test_node_stub_ops = {
+	.ntso_init	     = node_stub_init,
+	.ntso_fini	     = node_stub_fini,
+	.ntso_step	     = node_stub_step,
+	.ntso_cmd_handler    = node_stub_cmd_handler,
+	.ntso_cmd_handler_nr = ARRAY_SIZE(node_stub_cmd_handler),
+};
+
 /**
    @} end of NetTestPingNodeInternals group
  */
diff --git a/net/test/node_ping.h b/net/test/node_ping.h
index 6d92c9e..094ac84 100644
--- a/net/test/node_ping.h
+++ b/net/test/node_ping.h
@@ -33,6 +33,7 @@
  */
 
 extern struct c2_net_test_service_ops c2_net_test_node_ping_ops;
+extern struct c2_net_test_service_ops c2_net_test_node_stub_ops;
 
 /**
    @} end of NetTestPingNodeDFS group
diff --git a/net/test/service.h b/net/test/service.h
index c099ae8..a08e4af 100644
--- a/net/test/service.h
+++ b/net/test/service.h
@@ -27,7 +27,6 @@
 #include "lib/thread.h"			/* c2_thread */
 
 #include "net/test/commands.h"		/* c2_net_test_cmd_ctx */
-#include "net/test/node.h"		/* c2_net_test_node_ctx */
 
 /**
    @defgroup NetTestServiceDFS Test Service
diff --git a/net/test/ut/client_server.c b/net/test/ut/client_server.c
index d122074..5af8daf 100644
--- a/net/test/ut/client_server.c
+++ b/net/test/ut/client_server.c
@@ -18,6 +18,10 @@
  * Original creation date: 05/19/2012
  */
 
+#ifdef __KERNEL__
+#include <linux/kgdb.h>
+#endif
+
 #include "lib/ut.h"			/* C2_UT_ASSERT */
 #include "lib/memory.h"			/* c2_free */
 #include "lib/thread.h"			/* C2_THREAD_INIT */
@@ -35,17 +39,17 @@ enum {
 	NTCS_PORTAL		  = 42,
 	NTCS_NODES_MAX		  = 128,
 	NTCS_NODE_ADDR_MAX	  = 0x100,
-	/** @todo 10min for debugging in gdb */
+	/** @todo 20min for debugging in gdb */
+	NTCS_TIMEOUT_CMD_MS	  = 1200000,
+	NTCS_TIMEOUT_SEND_MS	  = 1200000,
+	NTCS_TIMEOUT_RECV_MS	  = 1200000,
+	NTCS_TIMEOUT_BULK_MS	  = 1200000,
 	/*
-	NTCS_TIMEOUT_CMD_MS	  = 600000,
-	NTCS_TIMEOUT_SEND_MS	  = 600000,
-	NTCS_TIMEOUT_RECV_MS	  = 600000,
-	NTCS_TIMEOUT_BULK_MS	  = 600000,
-	*/
 	NTCS_TIMEOUT_CMD_MS	  = 20000,
 	NTCS_TIMEOUT_SEND_MS	  = 20000,
 	NTCS_TIMEOUT_RECV_MS	  = 20000,
 	NTCS_TIMEOUT_BULK_MS	  = 20000,
+	*/
 	NTCS_TMID_CONSOLE4CLIENTS = 2998,
 	NTCS_TMID_CONSOLE4SERVERS = 2999,
 	NTCS_TMID_NODES		  = 3000,
@@ -172,6 +176,10 @@ static void net_test_client_server(const char *nid,
 	int				    i;
 	c2_time_t			    _1s = C2_MKTIME(1, 0);
 
+#ifdef __KERNEL__
+	kgdb_breakpoint();
+#endif
+
 	C2_PRE(clients_nr <= NTCS_NODES_MAX);
 	C2_PRE(servers_nr <= NTCS_NODES_MAX);
 	/* prepare config for test clients and test servers */
@@ -205,7 +213,7 @@ static void net_test_client_server(const char *nid,
 		rc = C2_THREAD_INIT(&node_thread[i],
 				    struct c2_net_test_node_cfg *,
 				    NULL, &net_test_node, &node_cfg[i],
-				    "node_thread#%d", i);
+				    "ut_node_thread#%d", i);
 		C2_UT_ASSERT(rc == 0);
 	}
 	/* wait until test node started */
@@ -343,10 +351,18 @@ static void net_test_client_server(const char *nid,
 	addr_free(addr_console4clients);
 }
 
+void c2_net_test_client_server_stub_ut(void)
+{
+	net_test_client_server("0@lo", C2_NET_TEST_TYPE_STUB,
+			       1, 1, 1, 1, 1, 1,
+			       0, 0, 0, 0);
+}
+
 void c2_net_test_client_server_ping_ut(void)
 {
 	net_test_client_server("0@lo", C2_NET_TEST_TYPE_PING,
-			       8, 8, 8, 128, 0x1000, 0x1000,
+			       /* 8, 8, 8, 128, 0x1000, 0x1000, */
+			       1, 1, 8, 128, 0x1000, 0x1000,
 			       0, 0, 0, 0);
 	/*
 	net_test_client_server("0@lo", C2_NET_TEST_TYPE_PING,
diff --git a/net/test/ut/commands.c b/net/test/ut/commands.c
index 5e97bcb..23c293f 100644
--- a/net/test/ut/commands.c
+++ b/net/test/ut/commands.c
@@ -343,6 +343,7 @@ static void commands_node_thread(struct net_test_cmd_node *node)
 	}
 	commands_ut_send(node, ctx);			/* test #5 */
 	commands_ut_send(node, ctx);
+	commands_ut_send(node, ctx);
 	barrier_with_main(node);	/* barrier #5.0 */
 	/* main thread will start receiving here */
 	barrier_with_main(node);	/* barrier #5.1 */
@@ -514,16 +515,17 @@ static void net_test_command_ut(size_t nr)
 	flags_reset(nr);
 	commands_ut_send_all(nr);
 	barrier_with_nodes();				/* barrier #4.1 */
-	C2_UT_ASSERT(is_flags_set_odd(nr));
 	barrier_with_nodes();				/* barrier #4.2 */
+	C2_UT_ASSERT(is_flags_set_odd(nr));
 	barrier_with_nodes();				/* barrier #4.3 */
 	/*
-	   Test #5: every node sends two commands, and only after that console
+	   Test #5: every node sends three commands, and only after that console
 	   starts to receive.
 	 */
 	/* nodes will send two commands here */
 	barrier_with_nodes();				/* barrier #5.0 */
 	commands_ut_recv_all(nr, C2_TIME_NEVER);
+	commands_ut_recv_all(nr, C2_TIME_NEVER);
 	flags_reset(nr);
 	commands_ut_recv_all(nr, timeout_get_abs());
 	C2_UT_ASSERT(is_flags_set(nr, false));
diff --git a/net/test/ut/main.c b/net/test/ut/main.c
index 7fe0bf8..85c1268 100644
--- a/net/test/ut/main.c
+++ b/net/test/ut/main.c
@@ -42,6 +42,8 @@ extern void c2_net_test_network_ut_bulk(void);
 extern void c2_net_test_cmd_ut_single(void);
 extern void c2_net_test_cmd_ut_multiple(void);
 
+extern void c2_net_test_bug_ut(void);
+extern void c2_net_test_client_server_stub_ut(void);
 extern void c2_net_test_client_server_ping_ut(void);
 extern void c2_net_test_client_server_bulk_ut(void);
 
@@ -67,8 +69,10 @@ const struct c2_test_suite c2_net_test_ut = {
 		{ "network-ping",	c2_net_test_network_ut_ping	  },
 		{ "network-bulk",	c2_net_test_network_ut_bulk	  },
 		{ "cmd-single",		c2_net_test_cmd_ut_single	  },
-#ifndef __KERNEL__
 		{ "cmd-multiple",	c2_net_test_cmd_ut_multiple	  },
+		{ "bug",		c2_net_test_bug_ut		  },
+#ifndef __KERNEL__
+		{ "client-server-stub",	c2_net_test_client_server_stub_ut },
 		{ "client-server-ping",	c2_net_test_client_server_ping_ut },
 		{ "client-server-bulk",	c2_net_test_client_server_bulk_ut },
 #endif
diff --git a/net/test/ut/network.c b/net/test/ut/network.c
index a3fbf86..b9d1edb 100644
--- a/net/test/ut/network.c
+++ b/net/test/ut/network.c
@@ -18,25 +18,34 @@
  * Original creation date: 05/19/2012
  */
 
-/** @todo remove */
-#ifndef __KERNEL__
-#include <stdio.h>		/* printf */
-#endif
-
 #include "lib/ut.h"		/* C2_UT_ASSERT */
 #include "lib/semaphore.h"	/* c2_semaphore */
 #include "lib/memory.h"		/* c2_alloc */
+#include "lib/trace.h"		/* C2_LOG */
 #include "net/lnet/lnet.h"	/* c2_net_lnet_ifaces_get */
 
 #include "net/test/network.h"
 
-/** @todo debug only, remove it */
-#ifndef __KERNEL__
-#define LOGD(format, ...) printf(format, ##__VA_ARGS__)
-#else
-#define LOGD(format, ...) do {} while (0)
+/* START COPY-PASTE FROM client_server.c */
+#ifdef __KERNEL__
+#include <linux/kgdb.h>
+#include <linux/completion.h>
 #endif
 
+#include "lib/ut.h"			/* C2_UT_ASSERT */
+#include "lib/memory.h"			/* c2_free */
+#include "lib/thread.h"			/* C2_THREAD_INIT */
+#include "lib/semaphore.h"		/* c2_semaphore_down */
+#include "lib/misc.h"			/* C2_SET0 */
+#include "lib/trace.h"			/* C2_LOG */
+
+#include "net/lnet/lnet.h"		/* C2_NET_LNET_PID */
+
+#include "net/test/commands.h"		/* c2_net_test_commands */
+/* END COPY-PASTE FROM client_server.c */
+
+#define LOGD(...) C2_LOG(C2_DEBUG, ##__VA_ARGS__)
+
 enum {
 	NET_TEST_PING_BUF_SIZE = 4096,
 	NET_TEST_PING_BUF_STEP = 511,	/** @see c2_net_test_network_ut_ping */
@@ -496,6 +505,609 @@ void c2_net_test_network_ut_buf_desc(void)
 	c2_net_test_network_ctx_fini(&ctx);
 }
 
+/* START COPY-PASTE FROM client_server.c */
+/*
+ ***********************************************************************
+ ***********************************************************************
+ ***********************************************************************
+ ***********************************************************************
+ */
+
+enum {
+	NODE_WAIT_CMD_GRANULARITY_MS = 20,
+};
+
+/** Node configuration */
+struct c2_net_test_node_cfg {
+	/** Node endpoint address (for commands) */
+	char	 *ntnc_addr;
+	/** Console endpoint address (for commands) */
+	char	 *ntnc_addr_console;
+	/** Send commands timeout. @see c2_net_test_commands_init(). */
+	c2_time_t ntnc_send_timeout;
+};
+
+/** Node context. */
+struct c2_net_test_node_ctx {
+	/** Commands context. Connected to the test console. */
+	struct c2_net_test_cmd_ctx     ntnc_cmd;
+	/** Node thread */
+	struct c2_thread	       ntnc_thread;
+	/**
+	   Exit flag for the node thread.
+	   Node thread will check this flag and will terminate if it is set.
+	 */
+	bool			       ntnc_exit_flag;
+	/**
+	 * 'node-thread-was-finished' semaphore.
+	 * Initialized to 0. External routines can down() or timeddown()
+	 * this semaphore to wait for the node thread.
+	 * up() at the end of the node thread.
+	 */
+	struct c2_semaphore	       ntnc_thread_finished_sem;
+};
+
+/**
+ * Console configuration.
+ * Set by console user before calling c2_net_test_init()
+ */
+struct c2_net_test_console_cfg {
+	/** Console commands endpoint address for the test servers */
+	char			*ntcc_addr_console4servers;
+	/** Console commands endpoint address for the test clients */
+	char			*ntcc_addr_console4clients;
+	/**
+	 * List of test server command endpoints.
+	 * Test console will use this endpoints for sending/receiving
+	 * commands to/from test servers.
+	 */
+	struct c2_net_test_slist ntcc_servers;
+	/**
+	 * List of test client command endpoints.
+	 * @see c2_net_test_console_cfg.ntcc_servers
+	 */
+	struct c2_net_test_slist ntcc_clients;
+	/**
+	 * List of test server data endpoints.
+	 * Every test server will create one transfer machine with endpoint
+	 * from this list. Every test client will send/receive test messages
+	 * to/from all test server data endpoints.
+	 */
+	struct c2_net_test_slist ntcc_data_servers;
+	/**
+	 * List of test client data endpoints.
+	 * @see c2_net_test_console_cfg.ntcc_data_servers
+	 */
+	struct c2_net_test_slist ntcc_data_clients;
+	/** Commands send timeout for the test nodes and test console */
+	c2_time_t		 ntcc_cmd_send_timeout;
+	/** Commands receive timeout for the test nodes and test console */
+	c2_time_t		 ntcc_cmd_recv_timeout;
+};
+
+/** Test console context for the node role */
+struct c2_net_test_console_role_ctx {
+	/** Commands structure */
+	struct c2_net_test_cmd_ctx	   *ntcrc_cmd;
+	/** Accumulated status data */
+	struct c2_net_test_cmd_status_data *ntcrc_sd;
+	/** Number of nodes */
+	size_t				    ntcrc_nr;
+	/** -errno for the last function */
+	int				   *ntcrc_errno;
+	/** status of last received *_DONE command */
+	int				   *ntcrc_status;
+};
+
+/** Test console context */
+struct c2_net_test_console_ctx {
+	/** Test console configuration */
+	struct c2_net_test_console_cfg	   *ntcc_cfg;
+	/** Test clients */
+	struct c2_net_test_console_role_ctx ntcc_clients;
+	/** Test servers */
+	struct c2_net_test_console_role_ctx ntcc_servers;
+};
+
+static struct c2_net_test_node_cfg client_cfg;
+static struct c2_net_test_node_cfg server_cfg;
+
+#ifdef __KERNEL__
+static DECLARE_COMPLETION(client_completion);
+static DECLARE_COMPLETION(server_completion);
+#else
+static struct c2_semaphore client_completion;
+static struct c2_semaphore server_completion;
+#endif
+
+#ifdef __KERNEL__
+static void net_test_wait_for_completion(struct completion *completion)
+#else
+static void net_test_wait_for_completion(struct c2_semaphore *completion)
+#endif
+{
+#ifdef __KERNEL__
+	wait_for_completion(completion);
+#else
+	c2_semaphore_down(completion);
+#endif
+}
+
+#ifdef __KERNEL__
+static void net_test_complete(struct completion *completion)
+#else
+static void net_test_complete(struct c2_semaphore *completion)
+#endif
+{
+#ifdef __KERNEL__
+	complete(completion);
+#else
+	c2_semaphore_up(completion);
+#endif
+}
+
+static void node_thread(struct c2_net_test_node_ctx *ctx)
+{
+	struct c2_net_test_cmd cmd;
+	struct c2_net_test_cmd reply;
+	int		       rc;
+	bool		       done_flag;
+
+	C2_PRE(ctx != NULL);
+
+	done_flag = false;
+	do {
+		/* get command */
+		rc = c2_net_test_commands_recv(&ctx->ntnc_cmd,
+					       &cmd, c2_time_now());
+		if (rc == 0)
+			rc = c2_net_test_commands_recv_enqueue(&ctx->ntnc_cmd,
+							cmd.ntc_buf_index);
+		if (rc == 0 && cmd.ntc_ep_index >= 0) {
+			/* we have command. handle it */
+			reply.ntc_done.ntcd_errno = 0;
+			reply.ntc_type = C2_NET_TEST_CMD_INIT_DONE;
+			reply.ntc_ep_index = cmd.ntc_ep_index;
+			c2_net_test_commands_received_free(&cmd);
+			/* send reply */
+			c2_net_test_commands_send_wait_all(&ctx->ntnc_cmd);
+			rc = c2_net_test_commands_send(&ctx->ntnc_cmd, &reply);
+			C2_SET0(&cmd);
+			done_flag = true;
+		} else if (rc == -ETIMEDOUT) {
+			/* we haven't command. take a step. */
+		} else {
+			break;
+		}
+	} while (!done_flag && !ctx->ntnc_exit_flag);
+	c2_semaphore_up(&ctx->ntnc_thread_finished_sem);
+}
+
+static void net_test_node(struct c2_net_test_node_cfg *node_cfg)
+{
+	struct c2_net_test_node_ctx *ctx;
+	struct c2_net_test_slist     ep_list;
+	int			     rc;
+	int			     counter = 0;
+
+	LOGD("enter");
+	C2_PRE(node_cfg != NULL);
+
+	C2_ALLOC_PTR(ctx);
+	C2_ASSERT(ctx != NULL);
+	C2_SET0(ctx);
+
+	LOGD("checkpoint %d", counter++);
+	rc = c2_net_test_slist_init(&ep_list, node_cfg->ntnc_addr_console, '`');
+	if (rc != 0)
+		goto failed;
+	LOGD("checkpoint %d", counter++);
+	rc = c2_net_test_commands_init(&ctx->ntnc_cmd,
+				       node_cfg->ntnc_addr,
+				       node_cfg->ntnc_send_timeout,
+				       NULL,
+				       &ep_list);
+	c2_net_test_slist_fini(&ep_list);
+	LOGD("checkpoint %d", counter++);
+	if (rc != 0)
+		goto failed;
+	LOGD("checkpoint %d", counter++);
+	rc = c2_semaphore_init(&ctx->ntnc_thread_finished_sem, 0);
+	if (rc != 0)
+		goto commands_fini;
+	C2_UT_ASSERT(rc == 0);
+	ctx->ntnc_exit_flag = false;
+	LOGD("checkpoint %d", counter++);
+	rc = C2_THREAD_INIT(&ctx->ntnc_thread, struct c2_net_test_node_ctx *,
+			    NULL, &node_thread, ctx, "BUG_NODE_THREAD");
+	LOGD("checkpoint %d", counter++);
+	C2_UT_ASSERT(rc == 0);
+	LOGD("checkpoint %d", counter++);
+	if (node_cfg == &client_cfg) {
+		//LOGD("net_test_complete(&client_completion);");
+		net_test_complete(&client_completion);
+	} else if (node_cfg == &server_cfg) {
+		//LOGD("net_test_complete(&server_completion);");
+		net_test_complete(&server_completion);
+	} else {
+		C2_IMPOSSIBLE("invalid node_cfg");
+	}
+	/* wait for the test node thread */
+	LOGD("checkpoint %d", counter++);
+	c2_semaphore_down(&ctx->ntnc_thread_finished_sem);
+	ctx->ntnc_exit_flag = true;
+	LOGD("checkpoint %d", counter++);
+	c2_net_test_commands_send_wait_all(&ctx->ntnc_cmd);
+	LOGD("checkpoint %d", counter++);
+	rc = c2_thread_join(&ctx->ntnc_thread);
+	C2_ASSERT(rc == 0);
+	LOGD("checkpoint %d", counter++);
+	c2_thread_fini(&ctx->ntnc_thread);
+	LOGD("checkpoint %d", counter++);
+	c2_semaphore_fini(&ctx->ntnc_thread_finished_sem);
+commands_fini:
+	LOGD("checkpoint %d", counter++);
+	c2_net_test_commands_fini(&ctx->ntnc_cmd);
+failed:
+	LOGD("checkpoint %d", counter++);
+	c2_free(ctx);
+	LOGD("leave");
+}
+
+static int console_role_init_fini(struct c2_net_test_console_role_ctx *ctx,
+				  struct c2_net_test_console_cfg *cfg,
+				  enum c2_net_test_role role)
+{
+	struct c2_net_test_slist *nodes;
+	char			 *addr_console;
+	int			  rc = -ENOMEM;
+	int			  counter = 0;
+
+	LOGD("enter");
+	if (cfg == NULL)
+		goto fini;
+
+	LOGD("checkpoint %d", counter++);
+	addr_console = role == C2_NET_TEST_ROLE_CLIENT ?
+		cfg->ntcc_addr_console4clients : cfg->ntcc_addr_console4servers;
+	nodes = role == C2_NET_TEST_ROLE_CLIENT ?
+		&cfg->ntcc_clients : &cfg->ntcc_servers;
+
+	LOGD("checkpoint %d", counter++);
+	C2_ALLOC_PTR(ctx->ntcrc_cmd);
+	if (ctx->ntcrc_cmd == NULL)
+		goto fail;
+	LOGD("checkpoint %d", counter++);
+	C2_ALLOC_PTR(ctx->ntcrc_sd);
+	if (ctx->ntcrc_sd == NULL)
+		goto fini_cmd;
+	ctx->ntcrc_nr = nodes->ntsl_nr;
+	LOGD("checkpoint %d", counter++);
+	C2_ALLOC_ARR(ctx->ntcrc_errno, ctx->ntcrc_nr);
+	if (ctx->ntcrc_errno == NULL)
+		goto fini_sd;
+	LOGD("checkpoint %d", counter++);
+	C2_ALLOC_ARR(ctx->ntcrc_status, ctx->ntcrc_nr);
+	if (ctx->ntcrc_status == NULL)
+		goto fini_errno;
+
+	LOGD("checkpoint %d", counter++);
+	rc = c2_net_test_commands_init(ctx->ntcrc_cmd, addr_console,
+				       cfg->ntcc_cmd_send_timeout, NULL, nodes);
+	LOGD("checkpoint %d", counter++);
+	if (rc != 0)
+		goto fini_status;
+
+	rc = 0;
+	goto success;
+
+fini:
+	rc = 0;
+	c2_net_test_commands_fini(ctx->ntcrc_cmd);
+fini_status:
+	c2_free(ctx->ntcrc_status);
+fini_errno:
+	c2_free(ctx->ntcrc_errno);
+fini_sd:
+	c2_free(ctx->ntcrc_sd);
+fini_cmd:
+	c2_free(ctx->ntcrc_cmd);
+fail:
+success:
+	LOGD("leave");
+	return rc;
+}
+
+static int console_init_fini(struct c2_net_test_console_ctx *ctx,
+			     struct c2_net_test_console_cfg *cfg)
+{
+	int rc;
+
+	C2_PRE(ctx != NULL);
+
+	ctx->ntcc_cfg = cfg;
+	rc = console_role_init_fini(&ctx->ntcc_clients, cfg,
+				    C2_NET_TEST_ROLE_CLIENT);
+	if (rc == 0)
+		rc = console_role_init_fini(&ctx->ntcc_servers, cfg,
+					    C2_NET_TEST_ROLE_SERVER);
+	return rc;
+}
+
+static size_t net_test_console_cmd(struct c2_net_test_console_ctx *ctx,
+				   enum c2_net_test_role role,
+				   enum c2_net_test_cmd_type cmd_type)
+{
+	struct c2_net_test_console_role_ctx *rctx;
+	struct c2_net_test_console_cfg	    *cfg;
+	struct c2_net_test_cmd_ctx	    *cmd_ctx;
+	struct c2_net_test_cmd		     cmd;
+	int				     i;
+	int				     j;
+	int				     rc;
+	struct c2_net_test_slist	    *nodes;
+	struct c2_net_test_slist	    *nodes_data;
+	bool				     role_client;
+	c2_time_t			     deadline;
+	size_t				     success_nr = 0;
+	size_t				     failures_nr = 0;
+	size_t				     rcvd_nr = 0;
+	enum c2_net_test_cmd_type	     answer[] = {
+		[C2_NET_TEST_CMD_INIT]	 = C2_NET_TEST_CMD_INIT_DONE,
+		[C2_NET_TEST_CMD_START]	 = C2_NET_TEST_CMD_START_DONE,
+		[C2_NET_TEST_CMD_STOP]	 = C2_NET_TEST_CMD_STOP_DONE,
+		[C2_NET_TEST_CMD_STATUS] = C2_NET_TEST_CMD_STATUS_DATA,
+	};
+
+	C2_PRE(ctx != NULL);
+	C2_PRE(role == C2_NET_TEST_ROLE_SERVER ||
+	       role == C2_NET_TEST_ROLE_CLIENT);
+	C2_PRE(cmd_type == C2_NET_TEST_CMD_INIT ||
+	       cmd_type == C2_NET_TEST_CMD_START ||
+	       cmd_type == C2_NET_TEST_CMD_STOP ||
+	       cmd_type == C2_NET_TEST_CMD_STATUS);
+
+	C2_SET0(&cmd);
+	cfg = ctx->ntcc_cfg;
+
+	role_client  = role == C2_NET_TEST_ROLE_CLIENT;
+	cmd.ntc_type = cmd_type;
+	nodes	     = role_client ? &cfg->ntcc_clients : &cfg->ntcc_servers;
+	nodes_data   = role_client ? &cfg->ntcc_data_clients :
+				     &cfg->ntcc_data_servers;
+	rctx	     = role_client ? &ctx->ntcc_clients : &ctx->ntcc_servers;
+	cmd_ctx	     = rctx->ntcrc_cmd;
+
+	/* clear commands receive queue */
+	while ((rc = c2_net_test_commands_recv(cmd_ctx, &cmd, c2_time_now())) !=
+	       -ETIMEDOUT) {
+		/*
+		 * Exit from this loop after nodes->ntsl_nr failures.
+		 * It will prevent from infinite loop if after every
+		 * c2_net_test_commands_recv_enqueue() will be
+		 * unsuccessful c2_net_test_commands_recv().
+		 */
+		failures_nr += rc != 0;
+		if (failures_nr > nodes->ntsl_nr)
+			break;
+		rc = c2_net_test_commands_recv_enqueue(cmd_ctx,
+						       cmd.ntc_buf_index);
+		/** @todo rc != 0 is lost here */
+		c2_net_test_commands_received_free(&cmd);
+	}
+	/* send all commands */
+	for (i = 0; i < nodes->ntsl_nr; ++i) {
+		if (cmd_type == C2_NET_TEST_CMD_INIT)
+			cmd.ntc_init.ntci_tm_ep = nodes_data->ntsl_list[i];
+		cmd.ntc_ep_index     = i;
+		rctx->ntcrc_errno[i] = c2_net_test_commands_send(cmd_ctx, &cmd);
+	}
+	c2_net_test_commands_send_wait_all(cmd_ctx);
+
+	deadline = c2_time_add(c2_time_now(), cfg->ntcc_cmd_recv_timeout);
+	while (c2_time_now() <= deadline && rcvd_nr < nodes->ntsl_nr) {
+		rc = c2_net_test_commands_recv(cmd_ctx, &cmd, deadline);
+		/* deadline reached */
+		if (rc == -ETIMEDOUT)
+			break;
+		/** @todo possible spinlock if all recv fails instantly? */
+		if (rc != 0)
+			continue;
+		rcvd_nr++;
+		/* reject unknown sender */
+		j = cmd.ntc_ep_index;
+		if (j < 0)
+			goto reuse_cmd;
+		/* reject unexpected command type */
+		if (cmd.ntc_type != answer[cmd_type])
+			goto reuse_cmd;
+		/*
+		 * reject command from node, which can't have outgoing cmd
+		 * because c2_net_test_commands_send() to this node failed.
+		 */
+		C2_ASSERT(j >= 0 && j < nodes->ntsl_nr);
+		if (rctx->ntcrc_errno[j] != 0)
+			goto reuse_cmd;
+		/* handle incoming command */
+		success_nr++;
+		/*
+		 * @todo console user can't recover from this error -
+		 * cmd.ntc_buf_index is lost. use ringbuf to save?
+		 */
+reuse_cmd:
+		rc = c2_net_test_commands_recv_enqueue(cmd_ctx,
+						       cmd.ntc_buf_index);
+		if (j != -1) {
+			C2_ASSERT(j >= 0 && j < nodes->ntsl_nr);
+			rctx->ntcrc_errno[j] = rc;
+		}
+		c2_net_test_commands_received_free(&cmd);
+	}
+
+	return success_nr;
+}
+
+/*
+struct timer_break_ctx {
+	struct c2_thread    tbc_thread;
+	struct c2_semaphore tbc_sem;
+	c2_time_t	    tbc_delay;
+};
+
+static void timer_break_thread(struct timer_break_ctx *ctx)
+{
+	c2_semaphore_timeddown(&ctx->tbc_sem, ctx->tbc_delay);
+#ifdef __KERNEL__
+	kgdb_breakpoint();
+#endif
+}
+
+static void timer_break_init(struct timer_break_ctx *ctx, c2_time_t delay)
+{
+	int rc;
+
+	rc = C2_THREAD_INIT(&ctx->tbc_thread,
+			    struct timer_break_ctx *,
+			    NULL, &timer_break_thread, ctx,
+			    "TIMER_BREAK");
+	C2_UT_ASSERT(rc == 0);
+	rc = c2_semaphore_init(&ctx->tbc_sem, 0);
+	C2_UT_ASSERT(rc == 0);
+}
+
+static void timer_break_fini(struct timer_break_ctx *ctx)
+{
+	int rc;
+
+	C2_PRE(ctx != 0);
+
+	c2_semaphore_up(&ctx->tbc_sem);
+	rc = c2_thread_join(&ctx->tbc_thread);
+	C2_ASSERT(rc == 0);
+	c2_thread_fini(&ctx->tbc_thread);
+	c2_semaphore_fini(&ctx->tbc_sem);
+}
+*/
+
+static void kgdb_break(void)
+{
+#ifdef __KERNEL__
+	kgdb_breakpoint();
+#endif
+}
+
+void c2_net_test_bug_ut(void)
+{
+	static struct c2_thread		   client_thread;
+	static struct c2_thread		   server_thread;
+	struct c2_net_test_console_cfg	  *console_cfg;
+	struct c2_net_test_console_ctx	  *console;
+	int				   rc;
+	c2_time_t			   debug_timeout = C2_MKTIME(2, 0);
+	// struct timer_break_ctx		   break_10s;
+	int				   counter = 0;
+
+	LOGD("enter");
+
+	C2_ALLOC_PTR(console);
+	C2_ASSERT(console != NULL);
+	C2_ALLOC_PTR(console_cfg);
+	C2_ASSERT(console_cfg != NULL);
+	kgdb_break();
+	LOGD("checkpoint %d", counter++);
+	// timer_break_init(&break_10s, C2_MKTIME(10, 0));
+	/* prepare config for test clients and test servers */
+	client_cfg.ntnc_addr	     = "0@lo:12345:42:3128";
+	client_cfg.ntnc_addr_console = "0@lo:12345:42:2998";
+	client_cfg.ntnc_send_timeout = debug_timeout;
+	server_cfg.ntnc_addr	     = "0@lo:12345:42:3384";
+	server_cfg.ntnc_addr_console = "0@lo:12345:42:2999";
+	server_cfg.ntnc_send_timeout = debug_timeout;
+	/* spawn test clients and test servers */
+	LOGD("checkpoint %d", counter++);
+	LOGD("checkpoint %d", counter++);
+	rc = C2_THREAD_INIT(&client_thread,
+			    struct c2_net_test_node_cfg *,
+			    NULL, &net_test_node, &client_cfg,
+			    "BUG_CLIENT_THREAD");
+	C2_UT_ASSERT(rc == 0);
+	LOGD("checkpoint %d", counter++);
+	rc = C2_THREAD_INIT(&server_thread,
+			    struct c2_net_test_node_cfg *,
+			    NULL, &net_test_node, &server_cfg,
+			    "BUG_SERVER_THREAD");
+	C2_UT_ASSERT(rc == 0);
+	/* wait until test node started */
+	LOGD("checkpoint %d", counter++);
+	//LOGD("net_test_wait_for_completion(&client_completion);");
+	net_test_wait_for_completion(&client_completion);
+	LOGD("checkpoint %d", counter++);
+	//LOGD("net_test_wait_for_completion(&server_completion);");
+	net_test_wait_for_completion(&server_completion);
+	LOGD("checkpoint %d", counter++);
+	/* prepare console config */
+	console_cfg->ntcc_addr_console4servers = "0@lo:12345:42:2999";
+	console_cfg->ntcc_addr_console4clients = "0@lo:12345:42:2998";
+	LOGD("checkpoint %d", counter++);
+	kgdb_break();
+	rc = c2_net_test_slist_init(&console_cfg->ntcc_clients,
+				    "0@lo:12345:42:3128", ',');
+	LOGD("checkpoint %d", counter++);
+	C2_UT_ASSERT(rc == 0);
+	rc = c2_net_test_slist_init(&console_cfg->ntcc_servers,
+				    "0@lo:12345:42:3384", ',');
+	LOGD("checkpoint %d", counter++);
+	C2_UT_ASSERT(rc == 0);
+	rc = c2_net_test_slist_init(&console_cfg->ntcc_data_clients,
+				    "0@lo:12345:42:3000", ',');
+	LOGD("checkpoint %d", counter++);
+	C2_UT_ASSERT(rc == 0);
+	rc = c2_net_test_slist_init(&console_cfg->ntcc_data_servers,
+				    "0@lo:12345:42:3256", ',');
+	LOGD("checkpoint %d", counter++);
+	C2_UT_ASSERT(rc == 0);
+	console_cfg->ntcc_cmd_send_timeout   = debug_timeout;
+	console_cfg->ntcc_cmd_recv_timeout   = debug_timeout;
+	/* initialize console */
+	LOGD("checkpoint %d", counter++);
+	rc = console_init_fini(console, console_cfg);
+	C2_UT_ASSERT(rc == 0);
+	/* send INIT to the test servers */
+	LOGD("checkpoint %d", counter++);
+	rc = net_test_console_cmd(console, C2_NET_TEST_ROLE_SERVER,
+				  C2_NET_TEST_CMD_INIT);
+	C2_UT_ASSERT(rc == 1);
+	/* send INIT to the test clients */
+	LOGD("checkpoint %d", counter++);
+	rc = net_test_console_cmd(console, C2_NET_TEST_ROLE_CLIENT,
+				  C2_NET_TEST_CMD_INIT);
+	C2_UT_ASSERT(rc == 1);
+	LOGD("checkpoint %d", counter++);
+	/* finalize console */
+	c2_net_test_slist_fini(&console_cfg->ntcc_servers);
+	c2_net_test_slist_fini(&console_cfg->ntcc_clients);
+	c2_net_test_slist_fini(&console_cfg->ntcc_data_servers);
+	c2_net_test_slist_fini(&console_cfg->ntcc_data_clients);
+	LOGD("checkpoint %d", counter++);
+	rc = console_init_fini(console, NULL);
+	C2_UT_ASSERT(rc == 0);
+	/* finalize test clients and test servers */
+	LOGD("checkpoint %d", counter++);
+	rc = c2_thread_join(&client_thread);
+	C2_UT_ASSERT(rc == 0);
+	c2_thread_fini(&client_thread);
+	LOGD("checkpoint %d", counter++);
+	rc = c2_thread_join(&server_thread);
+	C2_UT_ASSERT(rc == 0);
+	c2_thread_fini(&server_thread);
+	c2_free(console_cfg);
+	c2_free(console);
+	LOGD("leave");
+	// timer_break_fini(&break_10s);
+}
+
+/* END COPY-PASTE FROM client_server.c */
+
 /*
  *  Local variables:
  *  c-indentation-style: "K&R"
diff --git a/utils/linux_kernel/main.c b/utils/linux_kernel/main.c
index 90ea48f..d31ba32 100644
--- a/utils/linux_kernel/main.c
+++ b/utils/linux_kernel/main.c
@@ -53,6 +53,7 @@ static void run_kernel_ut(int ignored)
         printk(KERN_INFO "Colibri Kernel Unit Test\n");
 
 	c2_uts_init();
+#if 0
 	/* sort test suites in alphabetic order */
 	c2_ut_add(&c2_klibc2_ut);  /* test lib first */
 	c2_ut_add(&buffer_pool_ut);
@@ -60,7 +61,9 @@ static void run_kernel_ut(int ignored)
 	c2_ut_add(&c2_net_bulk_if_ut);
 	c2_ut_add(&c2_net_bulk_mem_ut);
 	c2_ut_add(&c2_net_lnet_ut);
+#endif
 	c2_ut_add(&c2_net_test_ut);
+#if 0
 	c2_ut_add(&c2_net_tm_prov_ut);
 	c2_ut_add(&xcode_ut);
 	c2_ut_add(&rpc_service_ut);
@@ -69,6 +72,7 @@ static void run_kernel_ut(int ignored)
 	c2_ut_add(&layout_ut);
 
 	c2_ut_add(&c2_loop_ut); /* c2loop driver */
+#endif
 
 	c2_ut_run();
 	c2_uts_fini();
diff --git a/utils/ut.valgrind b/utils/ut.valgrind
index 78d0ff2..c80a295 100755
--- a/utils/ut.valgrind
+++ b/utils/ut.valgrind
@@ -1,6 +1,6 @@
 #!/bin/sh
 
-EXE=${0%/*}/.libs/lt-ut
+EXE=${0%/*}/.libs/ut
 
 valgrind \
     --tool=memcheck \
diff --git a/utils/ut_main.c b/utils/ut_main.c
index 48e7339..1ff6494 100644
--- a/utils/ut_main.c
+++ b/utils/ut_main.c
@@ -77,6 +77,7 @@ extern const struct c2_test_suite layout_ut;
 void add_uts(void)
 {
 	/* sort test suites in alphabetic order */
+	/*
 	c2_ut_add(&libc2_ut);
 	c2_ut_add(&ad_ut);
 	c2_ut_add(&adieu_ut);
@@ -100,7 +101,9 @@ void add_uts(void)
 	c2_ut_add(&c2_net_bulk_if_ut);
 	c2_ut_add(&c2_net_bulk_mem_ut);
 	c2_ut_add(&c2_net_lnet_ut);
+	*/
 	c2_ut_add(&c2_net_test_ut);
+	/*
 	c2_ut_add(&c2_net_tm_prov_ut);
 	c2_ut_add(&parity_math_ut);
 	c2_ut_add(&frm_ut);
@@ -114,10 +117,13 @@ void add_uts(void)
 	c2_ut_add(&xcode_bufvec_ut);
 	c2_ut_add(&xcode_ut);
 	c2_ut_add(&xcode_ff2c_ut);
+	*/
 	/* These tests have redirection of messages. */
+	/*
 	c2_ut_add(&addb_ut);
 	c2_ut_add(&console_ut);
 	c2_ut_add(&yaml2db_ut);
+	*/
 }
 
 int main(int argc, char *argv[])
-- 
1.8.3.2

