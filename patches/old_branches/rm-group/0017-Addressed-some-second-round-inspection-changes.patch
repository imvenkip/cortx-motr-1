From 3b1d477aeed9a960bab7fdfd65fab67b1a2ea24e Mon Sep 17 00:00:00 2001
From: Rajesh Bhalerao <Rajesh_Bhalerao@xyratex.com>
Date: Tue, 3 Sep 2013 11:25:54 +0530
Subject: [PATCH 17/24] Addressed some second round inspection changes.

---
 rm/file.c          |  8 ++++----
 rm/file.h          |  8 ++++----
 rm/rm.c            | 38 ++++++++++++++++++++------------------
 rm/rm.h            | 12 ++++++------
 rm/rm_foms.c       |  2 +-
 rm/rm_fops.c       |  2 +-
 rm/rm_internal.h   |  2 +-
 rm/rm_service.c    |  3 ++-
 rm/ut/file.c       |  2 +-
 rm/ut/rcredits.c   |  3 ++-
 rm/ut/rings.c      |  2 +-
 rm/ut/rm_service.c |  2 +-
 12 files changed, 44 insertions(+), 40 deletions(-)

diff --git a/rm/file.c b/rm/file.c
index fbfb1dd..ffdaa0a 100644
--- a/rm/file.c
+++ b/rm/file.c
@@ -481,10 +481,10 @@ M0_INTERNAL void m0_file_fini(struct m0_file *file)
 }
 M0_EXPORTED(m0_file_fini);
 
-M0_INTERNAL void m0_file_owner_init(struct m0_rm_owner  *owner,
-				    enum m0_rm_group_id  grp_id,
-				    struct m0_file      *file,
-				    struct m0_rm_remote *creditor)
+M0_INTERNAL void m0_file_owner_init(struct m0_rm_owner      *owner,
+				    const struct m0_uint128 *grp_id,
+				    struct m0_file          *file,
+				    struct m0_rm_remote     *creditor)
 {
 	m0_rm_owner_init(owner, grp_id, &file->fi_res, creditor);
 }
diff --git a/rm/file.h b/rm/file.h
index a4bb41c..aa46fc0 100644
--- a/rm/file.h
+++ b/rm/file.h
@@ -105,10 +105,10 @@ M0_INTERNAL void m0_file_fini(struct m0_file *file);
  * @param owner - Owner for file
  * @param creditor - Creditor for this owner
  */
-M0_INTERNAL void m0_file_owner_init(struct m0_rm_owner  *owner,
-				    enum m0_rm_group_id  grp_id,
-				    struct m0_file      *file,
-				    struct m0_rm_remote *creditor);
+M0_INTERNAL void m0_file_owner_init(struct m0_rm_owner      *owner,
+				    const struct m0_uint128 *grp_id,
+				    struct m0_file          *file,
+				    struct m0_rm_remote     *creditor);
 
 /**
  * Finalises the owner of file-lock
diff --git a/rm/rm.c b/rm/rm.c
index 1e9530b..24ac07e 100644
--- a/rm/rm.c
+++ b/rm/rm.c
@@ -188,8 +188,7 @@ M0_BOB_DEFINE(M0_INTERNAL, &rem_bob, m0_rm_remote);
 struct m0_addb_ctx m0_rm_addb_ctx;
 static m0_time_t   rm_addb_update_interval =
 	M0_MKTIME(M0_ADDB_DEF_STAT_PERIOD_S, 0);
-static const struct m0_uint128 standalone_group_id =
-				M0_UINT128(0, M0_RM_NO_GROUP);
+const struct m0_uint128 m0_rm_standalone_grp_id = M0_UINT128(0, M0_RM_NO_GROUP);
 
 static struct m0_addb_rec_type *rm_cntr_rts[] = {
 	/* borrow */
@@ -583,10 +582,10 @@ M0_INTERNAL void m0_rm_owner_unlock(struct m0_rm_owner *owner)
 }
 M0_EXPORTED(m0_rm_owner_unlock);
 
-M0_INTERNAL void m0_rm_owner_init(struct m0_rm_owner    *owner,
-				  enum m0_rm_group_id    grp_id,
-				  struct m0_rm_resource *res,
-				  struct m0_rm_remote   *creditor)
+M0_INTERNAL void m0_rm_owner_init(struct m0_rm_owner      *owner,
+				  const struct m0_uint128 *grp_id,
+				  struct m0_rm_resource   *res,
+				  struct m0_rm_remote     *creditor)
 {
 	M0_PRE(ergo(creditor != NULL,
 		    creditor->rem_state >= REM_SERVICE_LOCATED));
@@ -598,7 +597,7 @@ M0_INTERNAL void m0_rm_owner_init(struct m0_rm_owner    *owner,
 	m0_rm_owner_lock(owner);
 	owner_state_set(owner, ROS_INITIALISING);
 	m0_rm_owner_unlock(owner);
-	owner->ro_group_id = M0_UINT128(0, grp_id);
+	owner->ro_group_id = *grp_id;
 
 	m0_rm_ur_tlist_init(&owner->ro_borrowed);
 	m0_rm_ur_tlist_init(&owner->ro_sublet);
@@ -663,6 +662,7 @@ M0_INTERNAL int m0_rm_owner_selfadd(struct m0_rm_owner  *owner,
 		rc = m0_rm_credit_copy(credit_transfer, r) ?:
 		     m0_rm_loan_init(nominal_capital, r, NULL);
 		if (rc == 0) {
+			nominal_capital->rl_other = owner->ro_creditor;
 			nominal_capital->rl_id = M0_RM_LOAN_SELF_ID;
 			/* Add capital to the borrowed list. */
 			m0_rm_ur_tlist_add(&owner->ro_borrowed,
@@ -798,7 +798,7 @@ M0_INTERNAL void m0_rm_credit_init(struct m0_rm_credit *credit,
 	M0_PRE(owner->ro_resource->r_ops->rop_credit_init != NULL);
 
 	credit->cr_datum = 0;
-	credit->cr_group_id = standalone_group_id;
+	credit->cr_group_id = m0_rm_standalone_grp_id;
 	m0_rm_ur_tlink_init(credit);
 	pr_tlist_init(&credit->cr_pins);
 	m0_rm_credit_bob_init(credit);
@@ -1136,7 +1136,7 @@ M0_INTERNAL void m0_rm_remote_fini(struct m0_rm_remote *rem)
 }
 M0_EXPORTED(m0_rm_remote_fini);
 
-M0_INTERNAL void m0_rev_session_wait(struct m0_rm_remote *remote)
+M0_INTERNAL void m0_rm_rev_session_wait(struct m0_rm_remote *remote)
 {
 	struct m0_clink *clink;
 
@@ -1455,7 +1455,7 @@ M0_EXPORTED(m0_rm_revoke_commit);
 static bool owner_group_conflict(struct m0_rm_owner    *o,
 				 struct m0_rm_incoming *in)
 {
-	return !m0_uint128_eq(&o->ro_group_id, &standalone_group_id) &&
+	return !m0_uint128_eq(&o->ro_group_id, &m0_rm_standalone_grp_id) &&
 		m0_uint128_eq(&o->ro_group_id, &in->rin_want.cr_group_id);
 }
 
@@ -1463,7 +1463,7 @@ static bool credit_group_conflict(struct m0_uint128 *g1,
 			   struct m0_uint128 *g2)
 {
 	return (m0_uint128_eq(g1, g2) &&
-		m0_uint128_eq(g1, &standalone_group_id)) ||
+		m0_uint128_eq(g1, &m0_rm_standalone_grp_id)) ||
 		!m0_uint128_eq(g1, g2);
 }
 
@@ -1823,6 +1823,7 @@ static int incoming_check_with(struct m0_rm_incoming *in,
 	struct m0_rm_owner  *o    = want->cr_owner;
 	struct m0_rm_credit *r;
 	struct m0_rm_loan   *loan;
+	bool                 group_mismatch;
 	int                  i;
 	int                  wait = 0;
 	int		     rc   = 0;
@@ -1868,9 +1869,9 @@ static int incoming_check_with(struct m0_rm_incoming *in,
 			loan = bob_of(r, struct m0_rm_loan, rl_credit,
 				      &loan_bob);
 			M0_ASSERT(!credit_is_empty(r));
-			if (credit_group_conflict(&r->cr_group_id,
-						  &rest->cr_group_id) &&
-			    in->rin_flags & RIF_MAY_REVOKE) {
+			group_mismatch = credit_group_conflict(&r->cr_group_id,
+						&rest->cr_group_id);
+			if (group_mismatch && in->rin_flags & RIF_MAY_REVOKE) {
 				/*
 				 * It is possible that this loop emits multiple
 				 * outgoing requests toward the same remote
@@ -1887,15 +1888,16 @@ static int incoming_check_with(struct m0_rm_incoming *in,
 				rc = revoke_send(in, loan, r) ?:
 					credit_diff(rest, r);
 				if (rc != 0) {
-					RM_ADDB_FUNCFAIL(-EREMOTE, REVOKE_FAIL,
+					RM_ADDB_FUNCFAIL(rc, REVOKE_FAIL,
 							 &m0_rm_addb_ctx);
 					M0_RETURN(rc);
 				}
-			} else if (!credit_group_conflict(&r->cr_group_id,
-							  &rest->cr_group_id) &&
+			} else if (!group_mismatch &&
 				   in->rin_flags & RIF_MAY_BORROW) {
 				rc = rc ?: credit_diff(rest, r);
-			}
+			} else if (group_mismatch &&
+				   in->rin_flags & RIF_MAY_BORROW)
+				rc = -EREMOTE;
 
 			if (rc != 0)
 				M0_RETURN(rc);
diff --git a/rm/rm.h b/rm/rm.h
index 6f831e4..234e69c 100644
--- a/rm/rm.h
+++ b/rm/rm.h
@@ -236,6 +236,7 @@ enum {
 enum m0_rm_group_id {
 	M0_RM_NO_GROUP  = 0,
 };
+extern const struct m0_uint128 m0_rm_standalone_grp_id;
 
 /**
  * Domain of resource management.
@@ -466,8 +467,7 @@ struct m0_rm_credit {
 	struct m0_rm_owner            *cr_owner;
 	const struct m0_rm_credit_ops *cr_ops;
 	/**
-	 * Group id of the credit. For example, M0_RM_SNS_GROUP for SNS
-	 * and M0_RM_NO_GROUP for stand-alone (no-group).
+	 * Group id of the credit.
 	 */
 	struct m0_uint128              cr_group_id;
 	/**
@@ -1634,10 +1634,10 @@ m0_rm_resource_initial_credit(const struct m0_rm_resource *resource,
  * @post M0_IN(owner->ro_state, (ROS_INITIALISING, ROS_ACTIVE)) &&
  *       owner->ro_resource == res)
  */
-M0_INTERNAL void m0_rm_owner_init(struct m0_rm_owner *owner,
-				  enum m0_rm_group_id grp_id,
-				  struct m0_rm_resource *res,
-				  struct m0_rm_remote *creditor);
+M0_INTERNAL void m0_rm_owner_init(struct m0_rm_owner      *owner,
+				  const struct m0_uint128 *grp_id,
+				  struct m0_rm_resource   *res,
+				  struct m0_rm_remote     *creditor);
 
 /**
  * Loans a credit to an owner from itself.
diff --git a/rm/rm_foms.c b/rm/rm_foms.c
index a7469ed..fd5480f 100644
--- a/rm/rm_foms.c
+++ b/rm/rm_foms.c
@@ -621,7 +621,7 @@ static int process_cancel(struct m0_fom *fom)
 	M0_ASSERT(loan != NULL);
 
 	owner = loan->rl_credit.cr_owner;
-	m0_rev_session_wait(loan->rl_other);
+	m0_rm_rev_session_wait(loan->rl_other);
 	rc = m0_rm_loan_settle(owner, loan);
 
 	m0_fom_phase_set(fom, FOPH_RM_REQ_FINISH);
diff --git a/rm/rm_fops.c b/rm/rm_fops.c
index b97715e..6655b27 100644
--- a/rm/rm_fops.c
+++ b/rm/rm_fops.c
@@ -315,7 +315,7 @@ int m0_rm_request_out(enum m0_rm_outgoing_type  otype,
 		rc = borrow_fop_fill(outreq, in, credit);
 		break;
 	case M0_ROT_REVOKE:
-		m0_rev_session_wait(other);
+		m0_rm_rev_session_wait(other);
 		rc = revoke_fop_fill(outreq, in, loan, other, credit);
 		break;
 	case M0_ROT_CANCEL:
diff --git a/rm/rm_internal.h b/rm/rm_internal.h
index 2074d9d..5abe18e 100644
--- a/rm/rm_internal.h
+++ b/rm/rm_internal.h
@@ -205,7 +205,7 @@ M0_INTERNAL int
 m0_rm_reverse_session_get(struct m0_rm_remote_incoming *rem_in,
 			  struct m0_rm_remote          *remote);
 
-M0_INTERNAL void m0_rev_session_wait(struct m0_rm_remote *remote);
+M0_INTERNAL void m0_rm_rev_session_wait(struct m0_rm_remote *remote);
 /** @} end of rm-fop interface. */
 
 /**
diff --git a/rm/rm_service.c b/rm/rm_service.c
index fc5b645..a1555a0 100644
--- a/rm/rm_service.c
+++ b/rm/rm_service.c
@@ -300,7 +300,8 @@ M0_INTERNAL int m0_rm_svc_owner_create(struct m0_reqh_service *service,
 				 * we need to introduce function to source
 				 * the group id.
 				 */
-				m0_rm_owner_init(owner, M0_RM_NO_GROUP,
+				m0_rm_owner_init(owner,
+						 &m0_rm_standalone_grp_id,
 						 resource, NULL);
 
 				RM_ALLOC_PTR(ow_cr, OWNER_CREDIT_ALLOC,
diff --git a/rm/ut/file.c b/rm/ut/file.c
index 620e893..53a82f7 100644
--- a/rm/ut/file.c
+++ b/rm/ut/file.c
@@ -114,7 +114,7 @@ static void fl_owner_set(struct rm_ut_data *self)
 	M0_ALLOC_PTR(owner);
 	M0_UT_ASSERT(owner != NULL);
 	flock = container_of(self->rd_res, struct m0_file, fi_res);
-	m0_file_owner_init(owner, M0_RM_NO_GROUP, flock, NULL);
+	m0_file_owner_init(owner, &m0_rm_standalone_grp_id, flock, NULL);
 	self->rd_owner = owner;
 }
 
diff --git a/rm/ut/rcredits.c b/rm/ut/rcredits.c
index c2510f2..efaa684 100644
--- a/rm/ut/rcredits.c
+++ b/rm/ut/rcredits.c
@@ -266,7 +266,8 @@ static void test4_run(void)
 	m0_rm_owner_fini(so3);
 	M0_SET0(rm_ctx[SERVER_3].rc_test_data.rd_owner);
 	m0_rm_owner_init(rm_ctx[SERVER_3].rc_test_data.rd_owner,
-			 M0_RM_NO_GROUP, rm_ctx[SERVER_3].rc_test_data.rd_res,
+			 &m0_rm_standalone_grp_id,
+			 rm_ctx[SERVER_3].rc_test_data.rd_res,
 			 NULL);
 }
 
diff --git a/rm/ut/rings.c b/rm/ut/rings.c
index 050c620..0525fef 100644
--- a/rm/ut/rings.c
+++ b/rm/ut/rings.c
@@ -299,7 +299,7 @@ static void rings_owner_set(struct rm_ut_data *self)
 
 	M0_ALLOC_PTR(owner);
 	M0_ASSERT(owner != NULL);
-	m0_rm_owner_init(owner, M0_RM_NO_GROUP, self->rd_res, NULL);
+	m0_rm_owner_init(owner, &m0_rm_standalone_grp_id, self->rd_res, NULL);
 	self->rd_owner = owner;
 }
 
diff --git a/rm/ut/rm_service.c b/rm/ut/rm_service.c
index 97539d8..1fe2f81 100644
--- a/rm/ut/rm_service.c
+++ b/rm/ut/rm_service.c
@@ -104,7 +104,7 @@ static void test_flock(struct m0_rm_owner *owner, struct m0_file *file,
 	struct m0_rm_incoming  in;
 
 	m0_file_init(file, fid, &rm_test_data.rd_dom);
-	m0_file_owner_init(owner, M0_RM_NO_GROUP, file, NULL);
+	m0_file_owner_init(owner, &m0_rm_standalone_grp_id, file, NULL);
 	owner->ro_creditor = creditor;
 	m0_file_lock(owner, &in);
 	m0_rm_owner_lock(owner);
-- 
1.8.3.2

