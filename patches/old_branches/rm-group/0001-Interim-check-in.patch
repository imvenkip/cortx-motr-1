From eef2658b8b2c887cb77a236cd92f2caa0c224cf5 Mon Sep 17 00:00:00 2001
From: Rajesh Bhalerao <Rajesh_Bhalerao@xyratex.com>
Date: Fri, 26 Jul 2013 17:15:24 +0530
Subject: [PATCH 01/24] Interim check-in.

---
 mero/magic.h |   3 +
 rm/rm.c      | 202 ++++++++++++++++++++++++++++++++++++++---------------------
 rm/rm.h      |  42 +++++++++----
 rm/rm_fops.c | 109 ++++++++++++++++----------------
 4 files changed, 221 insertions(+), 135 deletions(-)

diff --git a/mero/magic.h b/mero/magic.h
index 3e1500c..69bebe2 100644
--- a/mero/magic.h
+++ b/mero/magic.h
@@ -622,6 +622,9 @@ enum m0_magic_satchel {
 	/* rmsvc_owner_tl::td_head_magic (scalic seabed) */
 	M0_RM_OWNER_LIST_HEAD_MAGIC = 0x335CA11C5EABED77,
 
+	/* m0_loans_tl::td_head_magic (scalable scaffold) */
+	M0_RM_LOAN_TO_REMOTES_HEAD_MAGIC = 0x5CA1AB1E5CAFF01D,
+
 /* RPC */
 	/* m0_rpc_service_type::svt_magix (seedless seel) */
 	M0_RPC_SERVICE_TYPE_MAGIC = 0x335eed1e555ee177,
diff --git a/rm/rm.c b/rm/rm.c
index 821e3ab..0757b9e 100644
--- a/rm/rm.c
+++ b/rm/rm.c
@@ -127,10 +127,20 @@ M0_TL_DESCR_DEFINE(m0_rm_ur, "usage credits", , struct m0_rm_credit,
 M0_TL_DEFINE(m0_rm_ur, M0_INTERNAL, struct m0_rm_credit);
 
 M0_TL_DESCR_DEFINE(m0_remotes, "remote owners", , struct m0_rm_remote,
-		   rem_linkage, rem_magix,
+		   rem_res_linkage, rem_magix,
 		   M0_RM_REMOTE_MAGIC, M0_RM_REMOTE_OWNER_HEAD_MAGIC);
 M0_TL_DEFINE(m0_remotes, M0_INTERNAL, struct m0_rm_remote);
 
+M0_TL_DESCR_DEFINE(m0_loans, "loans to remotes", , struct m0_rm_remote,
+		   rem_loan_linkage, rem_magix,
+		   M0_RM_REMOTE_MAGIC, M0_RM_LOAN_TO_REMOTES_HEAD_MAGIC);
+M0_TL_DEFINE(m0_loans, M0_INTERNAL, struct m0_rm_remote);
+
+M0_TL_DESCR_DEFINE(m0_debtors, "debtors", , struct m0_rm_loan,
+		   rl_lothers, rl_magix,
+		   M0_RM_LOAN_MAGIC, M0_RM_DEBTORS_HEAD_MAGIC);
+M0_TL_DEFINE(m0_debtors, M0_INTERNAL, struct m0_rm_loan);
+
 static const struct m0_bob_type credit_bob = {
         .bt_name         = "credit",
         .bt_magix_offset = offsetof(struct m0_rm_credit, cr_magix),
@@ -192,6 +202,7 @@ M0_BOB_DEFINE(M0_INTERNAL, &rem_bob, m0_rm_remote);
 struct m0_addb_ctx m0_rm_addb_ctx;
 static m0_time_t   rm_addb_update_interval =
 	M0_MKTIME(M0_ADDB_DEF_STAT_PERIOD_S, 0);
+static const struct m0_uint128 no_group_id = M0_UINT128(0, 0);
 
 static struct m0_addb_rec_type *rm_cntr_rts[] = {
 	/* borrow */
@@ -576,6 +587,7 @@ M0_INTERNAL void m0_rm_owner_unlock(struct m0_rm_owner *owner)
 M0_EXPORTED(m0_rm_owner_unlock);
 
 M0_INTERNAL void m0_rm_owner_init(struct m0_rm_owner    *owner,
+				  enum m0_rm_group_id    grp_id,
 				  struct m0_rm_resource *res,
 				  struct m0_rm_remote   *creditor)
 {
@@ -589,7 +601,7 @@ M0_INTERNAL void m0_rm_owner_init(struct m0_rm_owner    *owner,
 	m0_rm_owner_lock(owner);
 	owner_state_set(owner, ROS_INITIALISING);
 	m0_rm_owner_unlock(owner);
-	owner->ro_group = NULL;
+	owner->cr_group_id = M0_UINT128(0, grp_id);
 
 	m0_rm_ur_tlist_init(&owner->ro_borrowed);
 	m0_rm_ur_tlist_init(&owner->ro_sublet);
@@ -1033,12 +1045,12 @@ M0_INTERNAL int m0_rm_loan_init(struct m0_rm_loan         *loan,
 	m0_cookie_new(&loan->rl_id);
 	m0_rm_credit_init(&loan->rl_credit, credit->cr_owner);
 	m0_rm_loan_bob_init(loan);
-	loan->rl_other = creditor;
-	if (loan->rl_other != NULL)
-		resource_get(loan->rl_other->rem_resource);
+	m0_debtors_tlist_init(&loan->rl_others);
+	m0_debtors_tlist_add(&loan->rl_others, creditor);
+	if (creditor != NULL)
+		resource_get(creditor->rem_resource);
 
-	M0_LEAVE();
-	return m0_rm_credit_copy(&loan->rl_credit, credit);
+	M0_RETURN(m0_rm_credit_copy(&loan->rl_credit, credit));
 }
 M0_EXPORTED(m0_rm_loan_init);
 
@@ -1050,7 +1062,7 @@ M0_INTERNAL void m0_rm_loan_fini(struct m0_rm_loan *loan)
 	m0_rm_credit_fini(&loan->rl_credit);
 	if (loan->rl_other != NULL)
 		resource_put(loan->rl_other->rem_resource);
-	loan->rl_other = NULL;
+	m0_debtors_tlist_init(&loan->rl_others);
 	loan->rl_id = 0;
 	m0_rm_loan_bob_fini(loan);
 	M0_LEAVE();
@@ -1108,6 +1120,7 @@ M0_INTERNAL void m0_rm_remote_init(struct m0_rm_remote   *rem,
 	rem->rem_resource = res;
 	m0_chan_init(&rem->rem_signal, &res->r_type->rt_lock);
 	m0_remotes_tlink_init(rem);
+	m0_loan_tlink_init(rem);
 	m0_rm_remote_bob_init(rem);
 	resource_get(res);
 	M0_LEAVE();
@@ -1124,6 +1137,7 @@ M0_INTERNAL void m0_rm_remote_fini(struct m0_rm_remote *rem)
 	rem->rem_state = REM_FREED;
 	m0_chan_fini_lock(&rem->rem_signal);
 	m0_remotes_tlink_fini(rem);
+	m0_loans_tlink_fini(rem);
 	resource_put(rem->rem_resource);
 	m0_rm_remote_bob_fini(rem);
 	M0_LEAVE();
@@ -1269,6 +1283,7 @@ M0_INTERNAL int m0_rm_borrow_commit(struct m0_rm_remote_incoming *rem_in)
 	struct m0_rm_owner    *owner = in->rin_want.cr_owner;
 	struct m0_rm_loan     *loan = NULL;
 	struct m0_rm_remote   *debtor = NULL;
+	struct m0_rm_credit   *r;
 	int                    rc;
 
 	M0_ENTRY("owner: %p credit: %llu", owner,
@@ -1280,26 +1295,41 @@ M0_INTERNAL int m0_rm_borrow_commit(struct m0_rm_remote_incoming *rem_in)
 	 * Clear the credits cache and remove incoming credits from the cache.
 	 * If everything succeeds add loan to the sublet list.
 	 */
-	rc = remote_find(&debtor, rem_in, owner->ro_resource) ?:
-		m0_rm_loan_alloc(&loan, &in->rin_want, debtor);
-	rc = rc ?: cached_credits_remove(in);
-	if (rc == 0) {
-		/*
-		 * Store the loan in the sublet list.
-		 */
-		m0_rm_ur_tlist_add(&owner->ro_sublet, &loan->rl_credit);
-		/*
-		 * Store loan cookie locally. Copy it into
-		 * rem_in->ri_loan_cookie.
-		 */
-		m0_cookie_init(&loan->rl_cookie, &loan->rl_id);
+	rc = remote_find(&debtor, rem_in, owner->ro_resource);
+	if (rc == 0 && !pi_tlist_is_empty(&in->rin_pins)) {
+		rc = m0_rm_loan_alloc(&loan, &in->rin_want, debtor) ?:
+			cached_credits_remove(in);
+		if (rc != 0 && loan != NULL) {
+			m0_rm_loan_fini(loan);
+			m0_free(loan);
+		} else if (rc == 0) {
+			/*
+			 * Store the loan in the sublet list.
+			 */
+			m0_rm_ur_tlist_add(&owner->ro_sublet, &loan->rl_credit);
+			/*
+			 * Store loan cookie locally. Copy it into
+			 * rem_in->ri_loan_cookie.
+			 */
+			m0_cookie_init(&loan->rl_cookie, &loan->rl_id);
+			rm_addb_req_counter_update(M0_RIT_BORROW, rem_in);
+		}
+	} else {
+		/* Find matching loan */
+		m0_tl_for(m0_rm_ur, &o->ro_sublet, r) {
+			if(r->cr_ops->cro_is_subset(r, &in->rin_want)) {
+				loan = bob_of(r, struct m0_rm_loan, rl_credit,
+					      &loan_bob);
+				break;
+			}
+		}
+		M0_ASSERT(loan != NULL);
+		m0_debtors_tlist_add(&loan->rl_others, debtor);
+		resource_get(debtor->rem_resource);
 		rem_in->ri_loan_cookie = loan->rl_cookie;
-	} else if (loan != NULL) {
-		m0_rm_loan_fini(loan);
-		m0_free(loan);
+		rm_addb_req_counter_update(M0_RIT_BORROW, rem_in);
 	}
 	M0_POST(owner_invariant(owner));
-	rm_addb_req_counter_update(M0_RIT_BORROW, rem_in);
 	M0_RETURN(rc);
 }
 M0_EXPORTED(m0_rm_borrow_commit);
@@ -1427,6 +1457,31 @@ M0_EXPORTED(m0_rm_revoke_commit);
  */
 /** @{ */
 
+static bool incoming_group_conflict(struct m0_rm_owner    *owner,
+				    struct m0_rm_incoming *in)
+{
+	return !m0_uint128_eq(owner->cr_group_id, no_group_id) &&
+	       m0_uint128_eq(owner->cr_group_id, in->rin_want.cr_group_id);
+}
+
+static void incoming_failure_set(struct m0_rm_incoming *in, int err)
+{
+	m0_sm_move(&in->rin_sm, err, RI_FAILURE);
+	in->rin_rc = err;
+	RM_ADDB_FUNCFAIL(in->rin_rc, CREDIT_GET_FAIL, &m0_rm_addb_ctx);
+}
+
+static void incoming_queue(struct m0_rm_owner *owner, struct m0_rm_incoming *in)
+{
+	/*
+	 * Mark incoming request "excited". owner_balance() will process it.
+	 */
+	m0_rm_ur_tlist_add(&owner->ro_incoming[in->rin_priority][OQS_EXCITED],
+			   &in->rin_want);
+	in->rin_req_time = in->rin_want.cr_get_time = m0_time_now();
+	owner_balance(owner);
+}
+
 /**
    External resource manager entry point: request a credit from the resource
    owner.
@@ -1449,21 +1504,14 @@ M0_INTERNAL void m0_rm_credit_get(struct m0_rm_incoming *in)
 	 * of races between owner state transition and credit requests.
 	 */
 	if (owner_state(owner) == ROS_ACTIVE) {
-		/*
-		 * Mark incoming request "excited". owner_balance() will
-		 * process it.
-		 */
-		m0_rm_ur_tlist_add(
-			&owner->ro_incoming[in->rin_priority][OQS_EXCITED],
-			&in->rin_want);
-		in->rin_req_time = in->rin_want.cr_get_time = m0_time_now();
-		owner_balance(owner);
+		if (incoming_group_conflict(owner, in->rin_want.cr_group_id))
+			incoming_failure_set(in, -EINVAL);
+		else
+			incoming_queue(owner, in);	
 	} else {
 		M0_LOG(M0_DEBUG, "Incoming req: %p, state change:[%d -> %d]",
 				 in, in->rin_sm.sm_state, RI_FAILURE);
-		m0_sm_move(&in->rin_sm, -ENODEV, RI_FAILURE);
-		in->rin_rc = -ENODEV;
-		RM_ADDB_FUNCFAIL(in->rin_rc, CREDIT_GET_FAIL, &m0_rm_addb_ctx);
+		incoming_failure_set(in, -ENODEV);
 	}
 
 	m0_rm_owner_unlock(owner);
@@ -1813,30 +1861,36 @@ static int incoming_check_with(struct m0_rm_incoming *in,
 			M0_ASSERT(m0_rm_credit_bob_check(r));
 			if (!credit_intersects(r, rest))
 				continue;
-			if (!(in->rin_flags & RIF_MAY_REVOKE))
+			if (!m0_uint128_eq(r->cr_group_id, rest->cr_group_id) &&
+			    !(in->rin_flags & RIF_MAY_REVOKE))
 				return -EREMOTE;
 			loan = bob_of(r, struct m0_rm_loan, rl_credit,
 				      &loan_bob);
-			/*
-			 * It is possible that this loop emits multiple
-			 * outgoing requests toward the same remote
-			 * owner. Don't bother to coalesce them here. The rpc
-			 * layer would do this more efficiently.
-			 *
-			 * @todo use rpc grouping here.
-			 */
-			wait++;
-			/*
-			 * @todo - Revoke entire loan?? rest could be subset
-			 * of r
-			 */
 			M0_ASSERT(!credit_is_empty(r));
-			rc = revoke_send(in, loan, r) ?: credit_diff(rest, r);
-			if (rc != 0) {
-				RM_ADDB_FUNCFAIL(-EREMOTE, REVOKE_FAIL,
-						 &m0_rm_addb_ctx);
-				M0_RETURN(rc);
+			if (!m0_uint128_eq(r->cr_group_id, rest->cr_group_id)) {
+				/*
+				 * It is possible that this loop emits multiple
+				 * outgoing requests toward the same remote
+				 * owner. Don't bother to coalesce them here.
+				 * The rpc layer would do this more efficiently.
+				 *
+				 * @todo use rpc grouping here.
+				 */
+				/*
+				 * @todo - Revoke entire loan?? rest could be
+				 * subset of r.
+				 */
+				wait++;
+				rc = revoke_send(in, loan, r);
+				if (rc != 0) {
+					RM_ADDB_FUNCFAIL(-EREMOTE, REVOKE_FAIL,
+							 &m0_rm_addb_ctx);
+					M0_RETURN(rc);
+				}
 			}
+			rc = rc ?: credit_diff(rest, r);
+			if (rc != 0)
+				M0_RETURN(rc);
 		} m0_tl_endfor;
 	}
 
@@ -1909,6 +1963,7 @@ static void incoming_complete(struct m0_rm_incoming *in, int32_t rc)
 		incoming_release(in);
 		m0_rm_ur_tlist_del(&in->rin_want);
 		M0_ASSERT(pi_tlist_is_empty(&in->rin_pins));
+		RM_ADDB_FUNCFAIL(in->rin_rc, CREDIT_GET_FAIL, &m0_rm_addb_ctx);
 	}
 	M0_ASSERT(incoming_invariant(in));
 	in->rin_ops->rio_complete(in, rc);
@@ -1990,8 +2045,9 @@ static int revoke_send(struct m0_rm_incoming *in,
 		       struct m0_rm_loan     *loan,
 		       struct m0_rm_credit   *credit)
 {
-	struct m0_rm_credit rest;
-	int                 rc;
+	struct m0_rm_credit  rest;
+	struct m0_rm_remote *other;
+	int                  rc;
 
 	M0_ENTRY("incoming: %p credit: %llu", in,
 		 (long long unsigned)credit->cr_datum);
@@ -2001,12 +2057,16 @@ static int revoke_send(struct m0_rm_incoming *in,
 	 * outgoing_check() destructively modifies outgoing credit. Hence,
 	 * make a copy.
 	 */
-	m0_rm_credit_init(&rest, in->rin_want.cr_owner);
-	rc = m0_rm_credit_copy(&rest, credit) ?:
-		outgoing_check(in, M0_ROT_REVOKE, &rest, loan->rl_other);
-	if (!credit_is_empty(&rest) && rc == 0)
-		rc = m0_rm_request_out(M0_ROT_REVOKE, in, loan, &rest);
-	m0_rm_credit_fini(&rest);
+	m0_tl_for(m0_debtors, &loan->rl_others, other) {
+		m0_rm_credit_init(&rest, in->rin_want.cr_owner);
+		rc = m0_rm_credit_copy(&rest, credit) ?:
+			outgoing_check(in, M0_ROT_REVOKE, &rest, other);
+		if (!credit_is_empty(&rest) && rc == 0)
+			rc = m0_rm_request_out(M0_ROT_REVOKE, in,
+					       loan, &rest, other);
+
+		m0_rm_credit_fini(&rest);
+	}
 	M0_RETURN(rc);
 }
 
@@ -2016,24 +2076,25 @@ static int revoke_send(struct m0_rm_incoming *in,
  */
 static int borrow_send(struct m0_rm_incoming *in, struct m0_rm_credit *credit)
 {
-	int rc;
+	int                  rc;
+	struct m0_rm_remote *other = in->rin_want.cr_owner->ro_creditor;
 
 	M0_ENTRY("incoming: %p credit: %llu", in,
 		 (long long unsigned) credit->cr_datum);
-	M0_PRE(in->rin_want.cr_owner->ro_creditor != NULL);
+	M0_PRE(other != NULL);
 
 	/*
 	 * Borrow sends the remaining credit request to the creditor. It's
 	 * ok if outgoing_check() modifies it. It goes well with
 	 * incoming_check_with() - which keeps on reducing the request set.
 	 */
-	rc = outgoing_check(in, M0_ROT_BORROW, credit,
-				in->rin_want.cr_owner->ro_creditor);
+	rc = outgoing_check(in, M0_ROT_BORROW, credit, other);
 	/*
 	 * Sends the entire credit request to the creditor. Empty the credit.
 	 */
 	if (!credit_is_empty(credit) && rc == 0)
-		rc = m0_rm_request_out(M0_ROT_BORROW, in, NULL, credit) ?:
+		rc = m0_rm_request_out(M0_ROT_BORROW, in,
+				       NULL, credit, other) ?:
 			credit_diff(credit, credit);
 	M0_RETURN(rc);
 }
@@ -2469,7 +2530,8 @@ static bool credit_conflicts(const struct m0_rm_credit *A,
 	M0_PRE(A->cr_ops != NULL);
 	M0_PRE(A->cr_ops->cro_conflicts != NULL);
 
-	return A->cr_ops->cro_conflicts(A, B);
+	return !m0_uint128_eq(A->cr_group_id, B->cr_group_id) ||
+	       A->cr_ops->cro_conflicts(A, B);
 }
 
 
diff --git a/rm/rm.h b/rm/rm.h
index e15fdf4..a4c0d2a 100644
--- a/rm/rm.h
+++ b/rm/rm.h
@@ -217,6 +217,11 @@ enum {
 	M0_RM_RESOURCE_TYPE_ID_INVALID = ~0
 };
 
+enum m0_rm_group_id {
+	M0_RM_NO_GROUP  = 0,
+	M0_RM_SNS_GROUP = 1,
+};
+
 /**
  * Domain of resource management.
  *
@@ -446,6 +451,11 @@ struct m0_rm_credit {
 	struct m0_rm_owner            *cr_owner;
 	const struct m0_rm_credit_ops *cr_ops;
 	/**
+	 * Group id of the credit. For example, M0_RM_SNS_GROUP for SNS
+	 * and M0_RM_NO_GROUP for stand-alone (no-group).
+	 */
+	struct m0_uint128              cr_group_id;
+	/**
 	 * Time when request for this credit acquisition was raised
 	 */
 	m0_time_t                      cr_get_time;
@@ -701,7 +711,12 @@ struct m0_rm_remote {
 	 * A linkage into the list of remotes for a given resource hanging off
 	 * m0_rm_resource::r_remote.
 	 */
-	struct m0_tlink         rem_linkage;
+	struct m0_tlink         rem_res_linkage;
+	/**
+	 * A linkage into the list of remotes for a given rloan hanging off
+	 * m0_rm_loan::rl_others.
+	 */
+	struct m0_tlink         rem_loan_linkage;
 	/** An identifier of the remote owner within the service. Valid in
 	 *  REM_OWNER_LOCATED state. This identifier is generated by the
 	 *  resource manager service.
@@ -940,10 +955,10 @@ struct m0_rm_owner {
 	/**
 	 * A group this owner is part of.
 	 *
-	 * If this is NULL, the owner is not a member of any group (a
-	 * "standalone" owner).
+	 * If this is M0_RM_NO_GROUP (0), the owner is not a member of any
+	 * group (a  "standalone" owner).
 	 */
-	struct m0_rm_group    *ro_group;
+	struct m0_uint128      cr_group_id;
 	/**
 	 * An upward creditor, from where this owner borrows credits.
 	 */
@@ -1012,20 +1027,23 @@ enum {
  * creditor and which is debtor is determined by the list the loan is on.
  */
 struct m0_rm_loan {
-	struct m0_rm_credit   rl_credit;
+	struct m0_rm_credit rl_credit;
 	/**
-	 * Other party in the loan. Either an "upward" creditor or "downward"
-	 * debtor, or "self" in case of a fake loan issued by the top-level
-	 * creditor to maintain its invariants.
+	 * Other party (or parties) in the loan. Either an "upward" creditor
+	 * or "downward" debtor, or "self" in case of a fake loan issued by
+	 * the top-level creditor to maintain its invariants.
+	 *
+	 * There are multiple parties when a group of debtors is granted the
+	 * same loan.
 	 */
-	struct m0_rm_remote *rl_other;
+	struct m0_tl        rl_others;
 	/**
 	 * An identifier generated by the remote end that should be passed back
 	 * whenever operating on a loan (think loan agreement number).
 	 */
-	struct m0_cookie     rl_cookie;
-	uint64_t             rl_id;
-	uint64_t             rl_magix;
+	struct m0_cookie    rl_cookie;
+	uint64_t            rl_id;
+	uint64_t            rl_magix;
 };
 
 /**
diff --git a/rm/rm_fops.c b/rm/rm_fops.c
index 2d216f7..ac45dcf 100644
--- a/rm/rm_fops.c
+++ b/rm/rm_fops.c
@@ -217,58 +217,73 @@ static int revoke_fop_fill(struct rm_out *outreq,
 	M0_RETURN(rc);
 }
 
-int m0_rm_request_out(enum m0_rm_outgoing_type otype,
-		      struct m0_rm_incoming   *in,
-		      struct m0_rm_loan       *loan,
-		      struct m0_rm_credit     *credit)
+static void rev_seesion_wait(struct m0_rm_remote *remote)
 {
-	struct m0_rpc_session *session = NULL;
-	struct rm_out	      *outreq;
-	struct m0_rm_remote   *other;
-	int		       rc;
+	struct m0_clink *clink;
+
+	M0_ASSERT(remote != NULL);
+
+	clink = &remote->rem_rev_sess_clink;
+	/*
+	 * Check whether remote session is established or not.
+	 * If a situation comes when we have to send revoke
+	 * request even before the session is established,
+	 * we need to wait till the session is established.
+	 */
+	if (m0_clink_is_armed(clink)) {
+		m0_chan_wait(clink);
+		m0_clink_del_lock(clink);
+		m0_clink_fini(clink);
+	}
+}
+
+static void outgoing_queue(enum m0_rm_outgoing_type  otype,
+			   struct m0_rm_out         *outreq,
+			   struct m0_rm_incoming    *in)
+{
+	outreq->ou_ast.sa_cb = otype == M0_ROT_BORROW ? &borrow_ast :
+							&revoke_ast;
+	pin_add(in, &outreq->ou_req.rog_want.rl_credit, M0_RPF_TRACK);
+	m0_rm_ur_tlist_add(&in->rin_want.cr_owner->ro_outgoing[OQS_GROUND],
+			   &outreq->ou_req.rog_want.rl_credit);
+	outreq->ou_fop.f_item.ri_session =
+		outreq->ou_req.rog_want.rl_other->rem_session;
+	outreq->ou_fop.f_item.ri_ops = &rm_request_rpc_ops;
+
+	if (M0_FI_ENABLED("no-rpc"))
+		goto out;
+
+	M0_LOG(M0_DEBUG, "sending request:%p over session: %p",
+			 outreq, session);
+	m0_rpc_post(&outreq->ou_fop.f_item);
+
+out:
+	return;
+}
+
+int m0_rm_request_out(enum m0_rm_outgoing_type  otype,
+		      struct m0_rm_incoming    *in,
+		      struct m0_rm_loan        *loan,
+		      struct m0_rm_credit      *credit,
+		      struct m0_rm_remote      *other)
+{
+	struct rm_out *outreq;
+	int            rc = 0;
 
 	M0_ENTRY("sending request type: %d for incoming: %p credit value: %llu",
 		 otype, in, (long long unsigned) credit->cr_datum);
+	M0_PRE(loan != NULL);
 	M0_PRE(M0_IN(otype, (M0_ROT_BORROW, M0_ROT_REVOKE)));
 
-	other = otype == M0_ROT_BORROW ? in->rin_want.cr_owner->ro_creditor :
-					 loan->rl_other;
-
 	rc = rm_out_create(&outreq, otype, other, credit);
 	if (rc != 0)
 		goto out;
 
-	switch (otype) {
-	case M0_ROT_BORROW:
+	if (otype == M0_ROT_BORROW)
 		rc = borrow_fop_fill(outreq, in, credit);
-		outreq->ou_ast.sa_cb = &borrow_ast;
-		break;
-	case M0_ROT_REVOKE: {
-		struct m0_clink *clink;
-
-		M0_ASSERT(loan != NULL);
-		M0_ASSERT(loan->rl_other != NULL);
-
-		clink = &loan->rl_other->rem_rev_sess_clink;
-		/*
-		 * Check whether remote session is established or not.
-		 * If a situation comes when we have to send revoke
-		 * request even before the session is established,
-		 * we need to wait till the session is established.
-		 */
-		if (m0_clink_is_armed(clink)) {
-			m0_chan_wait(clink);
-			m0_clink_del_lock(clink);
-			m0_clink_fini(clink);
-		}
+	else if (otype == M0_ROT_REVOKE) {
+		rev_session_wait(other);
 		rc = revoke_fop_fill(outreq, in, loan, credit);
-		session = loan->rl_other->rem_session;
-		outreq->ou_ast.sa_cb = &revoke_ast;
-		break;
-	}
-	default:
-		M0_IMPOSSIBLE("No such RM outgoing request type");
-		break;
 	}
 
 	if (rc != 0) {
@@ -276,19 +291,7 @@ int m0_rm_request_out(enum m0_rm_outgoing_type otype,
 		m0_fop_put(&outreq->ou_fop);
 		goto out;
 	}
-
-	pin_add(in, &outreq->ou_req.rog_want.rl_credit, M0_RPF_TRACK);
-	m0_rm_ur_tlist_add(&in->rin_want.cr_owner->ro_outgoing[OQS_GROUND],
-			   &outreq->ou_req.rog_want.rl_credit);
-	if (M0_FI_ENABLED("no-rpc"))
-		goto out;
-
-	M0_LOG(M0_DEBUG, "sending request:%p over session: %p",
-			 outreq, session);
-	outreq->ou_fop.f_item.ri_session =
-		outreq->ou_req.rog_want.rl_other->rem_session;
-	outreq->ou_fop.f_item.ri_ops = &rm_request_rpc_ops;
-	m0_rpc_post(&outreq->ou_fop.f_item);
+	outgoing_queue(otype, outreq, in);
 
 out:
 	M0_RETURN(rc);
-- 
1.8.3.2

