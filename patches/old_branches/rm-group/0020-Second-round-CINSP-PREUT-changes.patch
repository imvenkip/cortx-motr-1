From 49240eb0b4500a17a231907a28fc49b39b8e8c99 Mon Sep 17 00:00:00 2001
From: Rajesh Bhalerao <Rajesh_Bhalerao@xyratex.com>
Date: Fri, 6 Sep 2013 14:21:54 +0530
Subject: [PATCH 20/24] Second round CINSP-PREUT changes.

---
 m0t1fs/linux_kernel/inode.c |  3 ++-
 rm/rm.c                     | 13 ++++++-------
 rm/rm.h                     | 40 ++++++++++++++++++----------------------
 rm/rm_foms.c                |  6 +++---
 rm/rm_service.c             |  3 +--
 rm/ut/file.c                |  2 +-
 rm/ut/group.c               | 10 +++++-----
 rm/ut/rcredits.c            |  2 +-
 rm/ut/rings.c               |  2 +-
 rm/ut/rm_service.c          |  2 +-
 10 files changed, 39 insertions(+), 44 deletions(-)

diff --git a/m0t1fs/linux_kernel/inode.c b/m0t1fs/linux_kernel/inode.c
index 85246a8..94412ab 100644
--- a/m0t1fs/linux_kernel/inode.c
+++ b/m0t1fs/linux_kernel/inode.c
@@ -111,7 +111,8 @@ M0_INTERNAL void m0t1fs_file_lock_init(struct m0t1fs_inode    *ci,
 	M0_ASSERT(rdom != NULL);
 	m0_file_init(&ci->ci_flock, &ci->ci_fid, rdom);
 	m0_rm_remote_init(&ci->ci_creditor, &ci->ci_flock.fi_res);
-	m0_file_owner_init(&ci->ci_fowner, M0_RM_NO_GROUP, &ci->ci_flock, NULL);
+	m0_file_owner_init(&ci->ci_fowner, &m0_rm_no_group,
+			   &ci->ci_flock, NULL);
 	ci->ci_fowner.ro_creditor = &ci->ci_creditor;
 	ci->ci_creditor.rem_session =
 		m0t1fs_container_id_to_session(csb, m0t1fs_rm_container(csb));
diff --git a/rm/rm.c b/rm/rm.c
index be60b3a..2926509 100644
--- a/rm/rm.c
+++ b/rm/rm.c
@@ -188,7 +188,7 @@ M0_BOB_DEFINE(M0_INTERNAL, &rem_bob, m0_rm_remote);
 struct m0_addb_ctx m0_rm_addb_ctx;
 static m0_time_t   rm_addb_update_interval =
 	M0_MKTIME(M0_ADDB_DEF_STAT_PERIOD_S, 0);
-const struct m0_uint128 m0_rm_standalone_grp_id = M0_UINT128(0, M0_RM_NO_GROUP);
+const struct m0_uint128 m0_rm_no_group = M0_UINT128(0, 0);
 
 static struct m0_addb_rec_type *rm_cntr_rts[] = {
 	/* borrow */
@@ -583,7 +583,7 @@ M0_INTERNAL void m0_rm_owner_unlock(struct m0_rm_owner *owner)
 M0_EXPORTED(m0_rm_owner_unlock);
 
 M0_INTERNAL void m0_rm_owner_init(struct m0_rm_owner      *owner,
-				  const struct m0_uint128 *grp_id,
+				  const struct m0_uint128 *group,
 				  struct m0_rm_resource   *res,
 				  struct m0_rm_remote     *creditor)
 {
@@ -597,7 +597,7 @@ M0_INTERNAL void m0_rm_owner_init(struct m0_rm_owner      *owner,
 	m0_rm_owner_lock(owner);
 	owner_state_set(owner, ROS_INITIALISING);
 	m0_rm_owner_unlock(owner);
-	owner->ro_group_id = *grp_id;
+	owner->ro_group_id = *group;
 
 	m0_rm_ur_tlist_init(&owner->ro_borrowed);
 	m0_rm_ur_tlist_init(&owner->ro_sublet);
@@ -798,7 +798,7 @@ M0_INTERNAL void m0_rm_credit_init(struct m0_rm_credit *credit,
 	M0_PRE(owner->ro_resource->r_ops->rop_credit_init != NULL);
 
 	credit->cr_datum = 0;
-	credit->cr_group_id = m0_rm_standalone_grp_id;
+	credit->cr_group_id = m0_rm_no_group;
 	m0_rm_ur_tlink_init(credit);
 	pr_tlist_init(&credit->cr_pins);
 	m0_rm_credit_bob_init(credit);
@@ -1455,7 +1455,7 @@ M0_EXPORTED(m0_rm_revoke_commit);
 static bool same_group(struct m0_rm_owner    *o,
 				 struct m0_rm_incoming *in)
 {
-	return !m0_uint128_eq(&o->ro_group_id, &m0_rm_standalone_grp_id) &&
+	return !m0_uint128_eq(&o->ro_group_id, &m0_rm_no_group) &&
 		m0_uint128_eq(&o->ro_group_id, &in->rin_want.cr_group_id);
 }
 
@@ -1463,8 +1463,7 @@ static bool credit_group_conflict(struct m0_uint128 *g1,
 			   struct m0_uint128 *g2)
 {
 	return (m0_uint128_eq(g1, g2) &&
-		m0_uint128_eq(g1, &m0_rm_standalone_grp_id)) ||
-		!m0_uint128_eq(g1, g2);
+		m0_uint128_eq(g1, &m0_rm_no_group)) || !m0_uint128_eq(g1, g2);
 }
 
 static void incoming_failure_set(struct m0_rm_incoming *in, int err)
diff --git a/rm/rm.h b/rm/rm.h
index 234e69c..d9f67ac 100644
--- a/rm/rm.h
+++ b/rm/rm.h
@@ -154,6 +154,21 @@
  *
  * Lock ordering: these locks do not nest.
  *
+ * A group of cooperating owners.
+ *
+ * The owners in a group coordinate their activities internally (by means
+ * outside of resource manager control) as far as resource management is
+ * concerned.
+ *
+ * Resource manager assumes that credits granted to the owners from the same
+ * group never conflict.
+ *
+ * Typical usage is to assign all owners from the same distributed
+ * transaction (or from the same network client) to a group. The decision
+ * about a group scope has concurrency related implications, because the
+ * owners within a group must coordinate access between themselves to
+ * maintain whatever scheduling properties are desired, like serialisability.
+ *
  * @b Liveness.
  *
  * None of the resource manager structures, except for m0_rm_resource, require
@@ -217,26 +232,7 @@ enum {
 	M0_RM_RESOURCE_TYPE_ID_INVALID = ~0
 };
 
-/**
- * A group of cooperating owners.
- *
- * The owners in a group coordinate their activities internally (by means
- * outside of resource manager control) as far as resource management is
- * concerned.
- *
- * Resource manager assumes that credits granted to the owners from the same
- * group never conflict.
- *
- * Typical usage is to assign all owners from the same distributed
- * transaction (or from the same network client) to a group. The decision
- * about a group scope has concurrency related implications, because the
- * owners within a group must coordinate access between themselves to
- * maintain whatever scheduling properties are desired, like serialisability.
- */
-enum m0_rm_group_id {
-	M0_RM_NO_GROUP  = 0,
-};
-extern const struct m0_uint128 m0_rm_standalone_grp_id;
+extern const struct m0_uint128 m0_rm_no_group;
 
 /**
  * Domain of resource management.
@@ -946,7 +942,7 @@ struct m0_rm_owner {
 	/**
 	 * A group this owner is part of.
 	 *
-	 * If this is M0_RM_NO_GROUP (0), the owner is not a member of any
+	 * If this is m0_rm_no_group (0), the owner is not a member of any
 	 * group (a  "standalone" owner).
 	 */
 	struct m0_uint128      ro_group_id;
@@ -1635,7 +1631,7 @@ m0_rm_resource_initial_credit(const struct m0_rm_resource *resource,
  *       owner->ro_resource == res)
  */
 M0_INTERNAL void m0_rm_owner_init(struct m0_rm_owner      *owner,
-				  const struct m0_uint128 *grp_id,
+				  const struct m0_uint128 *group,
 				  struct m0_rm_resource   *res,
 				  struct m0_rm_remote     *creditor);
 
diff --git a/rm/rm_foms.c b/rm/rm_foms.c
index fd5480f..6da1ec2 100644
--- a/rm/rm_foms.c
+++ b/rm/rm_foms.c
@@ -56,7 +56,7 @@ static int    cancel_fom_create(struct m0_fop *fop, struct m0_fom **out,
 static void   cancel_fom_fini(struct m0_fom *fom);
 static int    borrow_fom_tick(struct m0_fom *);
 static int    revoke_fom_tick(struct m0_fom *);
-static int    process_cancel(struct m0_fom *fom);
+static int    cancel_process(struct m0_fom *fom);
 static int    cancel_fom_tick(struct m0_fom *);
 static size_t locality(const struct m0_fom *fom);
 
@@ -560,7 +560,7 @@ static int request_fom_tick(struct m0_fom           *fom,
 		switch (m0_fom_phase(fom)) {
 		case FOPH_RM_REQ_START:
 			if (type == FRT_CANCEL)
-				rc = process_cancel(fom);
+				rc = cancel_process(fom);
 			else
 				rc = request_pre_process(fom, type);
 			break;
@@ -605,7 +605,7 @@ static int revoke_fom_tick(struct m0_fom *fom)
 	return request_fom_tick(fom, FRT_REVOKE);
 }
 
-static int process_cancel(struct m0_fom *fom)
+static int cancel_process(struct m0_fom *fom)
 {
 	struct m0_rm_fop_cancel  *cfop;
 	struct rm_request_fom	 *rfom;
diff --git a/rm/rm_service.c b/rm/rm_service.c
index a1555a0..8ce2eb6 100644
--- a/rm/rm_service.c
+++ b/rm/rm_service.c
@@ -300,8 +300,7 @@ M0_INTERNAL int m0_rm_svc_owner_create(struct m0_reqh_service *service,
 				 * we need to introduce function to source
 				 * the group id.
 				 */
-				m0_rm_owner_init(owner,
-						 &m0_rm_standalone_grp_id,
+				m0_rm_owner_init(owner, &m0_rm_no_group,
 						 resource, NULL);
 
 				RM_ALLOC_PTR(ow_cr, OWNER_CREDIT_ALLOC,
diff --git a/rm/ut/file.c b/rm/ut/file.c
index 69975bd..bfbe0e4 100644
--- a/rm/ut/file.c
+++ b/rm/ut/file.c
@@ -114,7 +114,7 @@ static void fl_owner_set(struct rm_ut_data *self)
 	M0_ALLOC_PTR(owner);
 	M0_UT_ASSERT(owner != NULL);
 	flock = container_of(self->rd_res, struct m0_file, fi_res);
-	m0_file_owner_init(owner, &m0_rm_standalone_grp_id, flock, NULL);
+	m0_file_owner_init(owner, &m0_rm_no_group, flock, NULL);
 	self->rd_owner = owner;
 }
 
diff --git a/rm/ut/group.c b/rm/ut/group.c
index c8c2f0b..a5aff32 100644
--- a/rm/ut/group.c
+++ b/rm/ut/group.c
@@ -30,7 +30,7 @@
 /* Maximum test servers for this testcase */
 static enum rm_server  test_servers_nr;
 static struct m0_clink group_tests_clink[GROUP_TESTS_NR];
-static enum m0_rm_group_id M0_RM_SNS_GROUP = 1;
+static uint64_t M0_RM_SNS_GROUP = 1;
 
 static void rmg_in_complete(struct m0_rm_incoming *in, int32_t rc)
 {
@@ -46,7 +46,7 @@ static const struct m0_rm_incoming_ops rmg_incoming_ops = {
 };
 
 static void ring_get(enum rm_server            srv_id,
-		     enum m0_rm_group_id       grp_id,
+		     uint64_t                  group,
 		     enum m0_rm_incoming_flags in_flag,
 		     int                       which_ring)
 {
@@ -66,7 +66,7 @@ static void ring_get(enum rm_server            srv_id,
 			    RIP_NONE, RIF_LOCAL_WAIT | in_flag);
 	in->rin_want.cr_datum = which_ring;
 	in->rin_ops = &rmg_incoming_ops;
-	in->rin_want.cr_group_id = M0_UINT128(0, grp_id);
+	in->rin_want.cr_group_id = M0_UINT128(0, group);
 	m0_rm_credit_get(in);
 	m0_rm_owner_lock(owner);
 	rc = m0_sm_timedwait(&in->rin_sm, M0_BITS(RI_SUCCESS), M0_TIME_NEVER);
@@ -90,7 +90,7 @@ static void standalone_borrow_verify(void)
 
 static void standalone_borrow_run(void)
 {
-	ring_get(SERVER_3, M0_RM_NO_GROUP, RIF_MAY_BORROW, DURIN);
+	ring_get(SERVER_3, 0, RIF_MAY_BORROW, DURIN);
 }
 
 static void group_revoke_verify(void)
@@ -113,7 +113,7 @@ static void group_revoke_run(void)
 {
 	loan_session_set(SERVER_3, SERVER_1);
 	loan_session_set(SERVER_3, SERVER_2);
-	ring_get(SERVER_3, M0_RM_NO_GROUP, RIF_MAY_REVOKE, NENYA);
+	ring_get(SERVER_3, 0, RIF_MAY_REVOKE, NENYA);
 }
 
 static void group_borrow_verify(enum rm_server srv_id)
diff --git a/rm/ut/rcredits.c b/rm/ut/rcredits.c
index efaa684..37c4d3b 100644
--- a/rm/ut/rcredits.c
+++ b/rm/ut/rcredits.c
@@ -266,7 +266,7 @@ static void test4_run(void)
 	m0_rm_owner_fini(so3);
 	M0_SET0(rm_ctx[SERVER_3].rc_test_data.rd_owner);
 	m0_rm_owner_init(rm_ctx[SERVER_3].rc_test_data.rd_owner,
-			 &m0_rm_standalone_grp_id,
+			 &m0_rm_no_group,
 			 rm_ctx[SERVER_3].rc_test_data.rd_res,
 			 NULL);
 }
diff --git a/rm/ut/rings.c b/rm/ut/rings.c
index 0525fef..5e94605 100644
--- a/rm/ut/rings.c
+++ b/rm/ut/rings.c
@@ -299,7 +299,7 @@ static void rings_owner_set(struct rm_ut_data *self)
 
 	M0_ALLOC_PTR(owner);
 	M0_ASSERT(owner != NULL);
-	m0_rm_owner_init(owner, &m0_rm_standalone_grp_id, self->rd_res, NULL);
+	m0_rm_owner_init(owner, &m0_rm_no_group, self->rd_res, NULL);
 	self->rd_owner = owner;
 }
 
diff --git a/rm/ut/rm_service.c b/rm/ut/rm_service.c
index 1fe2f81..0cb80c9 100644
--- a/rm/ut/rm_service.c
+++ b/rm/ut/rm_service.c
@@ -104,7 +104,7 @@ static void test_flock(struct m0_rm_owner *owner, struct m0_file *file,
 	struct m0_rm_incoming  in;
 
 	m0_file_init(file, fid, &rm_test_data.rd_dom);
-	m0_file_owner_init(owner, &m0_rm_standalone_grp_id, file, NULL);
+	m0_file_owner_init(owner, &m0_rm_no_group, file, NULL);
 	owner->ro_creditor = creditor;
 	m0_file_lock(owner, &in);
 	m0_rm_owner_lock(owner);
-- 
1.8.3.2

