From cc480690597d4b71d484673a19368252d5f0bd40 Mon Sep 17 00:00:00 2001
From: Rajesh Bhalerao <Rajesh_Bhalerao@xyratex.com>
Date: Wed, 18 Sep 2013 09:57:21 +0530
Subject: [PATCH 22/24] Fixed inspection comments.

---
 lib/cookie.c |  7 +++++++
 lib/cookie.h |  6 ++++++
 rm/rm.c      | 14 ++++----------
 rm/rm.h      |  2 +-
 rm/ut/rmut.c |  4 +---
 5 files changed, 19 insertions(+), 14 deletions(-)

diff --git a/lib/cookie.c b/lib/cookie.c
index ae7b3ee..f125192 100644
--- a/lib/cookie.c
+++ b/lib/cookie.c
@@ -113,6 +113,13 @@ M0_INTERNAL bool m0_cookie_is_null(const struct m0_cookie cookie)
 		cookie.co_addr == M0_COOKIE_NULL.co_addr;
 }
 
+M0_INTERNAL bool m0_cookie_is_eq(const struct m0_cookie *cookie1,
+				 const struct m0_cookie *cookie2)
+{
+	return cookie1->co_generation == cookie2->co_generation &&
+		cookie1->co_addr == cookie2->co_addr;
+}
+
 M0_INTERNAL void m0_cookie_global_fini(void)
 {
 	m0_arch_cookie_global_fini();
diff --git a/lib/cookie.h b/lib/cookie.h
index 9e3cc0a..8419bb9 100644
--- a/lib/cookie.h
+++ b/lib/cookie.h
@@ -100,6 +100,12 @@ M0_INTERNAL bool m0_addr_is_sane(const uint64_t * addr);
 M0_INTERNAL bool m0_cookie_is_null(const struct m0_cookie cookie);
 
 /**
+ * Compares two cookies.
+ */
+M0_INTERNAL bool m0_cookie_is_eq(const struct m0_cookie *cookie1,
+				 const struct m0_cookie *cookie2);
+
+/**
  * A macro to retrive address of a parent structure, associated with an object
  * embedded in a cookie.
  */
diff --git a/rm/rm.c b/rm/rm.c
index 2926509..3ddbcc7 100644
--- a/rm/rm.c
+++ b/rm/rm.c
@@ -1078,8 +1078,7 @@ static int remote_find(struct m0_rm_remote          **rem,
 	m0_tl_for (m0_remotes, &res->r_remote, other) {
 		M0_ASSERT(other->rem_resource == res &&
 			  m0_rm_remote_bob_check(other));
-		if (other->rem_cookie.co_addr == cookie->co_addr &&
-		    other->rem_cookie.co_generation == cookie->co_generation)
+		if (m0_cookie_is_eq(&other->rem_cookie, cookie))
 			break;
 	} m0_tl_endfor;
 
@@ -1374,11 +1373,8 @@ M0_INTERNAL int m0_rm_revoke_commit(struct m0_rm_remote_incoming *rem_in)
 	m0_tl_for (m0_rm_ur, &owner->ro_borrowed, credit) {
 		brwd_loan = bob_of(credit, struct m0_rm_loan,
 				  rl_credit, &loan_bob);
-		if (brwd_loan->rl_cookie.co_addr == cookie->co_addr &&
-		    brwd_loan->rl_cookie.co_generation ==
-			cookie->co_generation) {
+		if (m0_cookie_is_eq(&brwd_loan->rl_cookie, cookie))
 			break;
-		}
 	} m0_tl_endfor;
 
 	M0_ASSERT(brwd_loan != NULL);
@@ -2151,10 +2147,8 @@ M0_INTERNAL int m0_rm_owner_loan_debit(struct m0_rm_owner *owner,
 		else {
 			loan = bob_of(cr, struct m0_rm_loan,
 				      rl_credit, &loan_bob);
-			if (loan->rl_cookie.co_addr !=
-				paid_loan->rl_cookie.co_addr &&
-			    loan->rl_cookie.co_generation !=
-				paid_loan->rl_cookie.co_generation) {
+			if (!m0_cookie_is_eq(&loan->rl_cookie,
+					     &paid_loan->rl_cookie)) {
 				m0_rm_ur_tlist_move(&retain_list, cr);
 				continue;
 			}
diff --git a/rm/rm.h b/rm/rm.h
index d9f67ac..2974416 100644
--- a/rm/rm.h
+++ b/rm/rm.h
@@ -154,7 +154,7 @@
  *
  * Lock ordering: these locks do not nest.
  *
- * A group of cooperating owners.
+ * <b>A group of cooperating owners.</b>
  *
  * The owners in a group coordinate their activities internally (by means
  * outside of resource manager control) as far as resource management is
diff --git a/rm/ut/rmut.c b/rm/ut/rmut.c
index f64c299..ec93432 100644
--- a/rm/ut/rmut.c
+++ b/rm/ut/rmut.c
@@ -316,9 +316,7 @@ void loan_session_set(enum rm_server csrv_id,
 		m0_cookie_init(&dcookie,
 			       &rm_ctx[dsrv_id].rc_test_data.rd_owner->ro_id);
 		remote = loan->rl_other;
-		if (dcookie.co_addr == remote->rem_cookie.co_addr &&
-		    dcookie.co_generation ==
-			remote->rem_cookie.co_generation)
+		if (m0_cookie_is_eq(&dcookie, &remote->rem_cookie))
 			remote->rem_session = &rm_ctx[csrv_id].rc_sess[dsrv_id];
 	} m0_tl_endfor;
 }
-- 
1.8.3.2

