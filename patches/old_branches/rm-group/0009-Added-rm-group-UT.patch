From 3c759c64a536fa6f33a4b29af7347faa1a7ce7fc Mon Sep 17 00:00:00 2001
From: Rajesh Bhalerao <Rajesh_Bhalerao@xyratex.com>
Date: Fri, 23 Aug 2013 16:52:57 +0530
Subject: [PATCH 09/24] Added rm-group UT.

---
 rm/rm.c       |   8 +-
 rm/ut/group.c | 306 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 rm/ut/rmut.c  |  15 ++-
 rm/ut/rmut.h  |  13 +++
 4 files changed, 335 insertions(+), 7 deletions(-)
 create mode 100644 rm/ut/group.c

diff --git a/rm/rm.c b/rm/rm.c
index e2f0368..76718e1 100644
--- a/rm/rm.c
+++ b/rm/rm.c
@@ -975,15 +975,15 @@ M0_EXPORTED(m0_rm_outgoing_fini);
 static int loan_dup(const struct m0_rm_loan  *src_loan,
 		    struct m0_rm_loan       **dest_loan)
 {
-	int                  rc;
-	struct m0_rm_remote *other;
+	int                       rc;
+	struct m0_rm_remote_link *rrl;
 
 	rc =  m0_rm_loan_alloc(dest_loan, &src_loan->rl_credit);
 	if (rc != 0)
 		goto out;
 
-	m0_tl_for(m0_proxies, &src_loan->rl_others, other) {
-		m0_rm_loan_proxy_add(*dest_loan, other);
+	m0_tl_for(m0_proxies, &src_loan->rl_others, rrl) {
+		m0_rm_loan_proxy_add(*dest_loan, rrl->rrl_ptr);
 	} m0_tl_endfor;
 
 out:
diff --git a/rm/ut/group.c b/rm/ut/group.c
new file mode 100644
index 0000000..9a70af3
--- /dev/null
+++ b/rm/ut/group.c
@@ -0,0 +1,306 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Rajesh Bhalerao <rajesh_bhalerao@xyratex.com>
+ * Original creation date: 08/22/2013
+ */
+
+#include "rm/rm.h"
+#include "rm/rm_internal.h"
+#include "rm/rm_fops.h"
+#include "rm/ut/rmut.h"
+#include "rm/ut/rings.h"
+
+const char *db_name[] = {"ut-rm-cob_1",
+			 "ut-rm-cob_2",
+			 "ut-rm-cob_3"
+};
+
+/*
+ * Hierarchy description:
+ * SERVER_1 is downward debtor for SERVER_3 and belongs to group
+ *          M0_RM_SNS_GROUP.
+ * SERVER_2 is downward debtor for SERVER_3 and also belongs to group
+ *          M0_RM_SNS_GROUP.
+ * SERVER_3 is upward creditor for SERVER_1 and SERVER_2.
+ */
+const char *serv_addr[] = { "0@lo:12345:34:1",
+			    "0@lo:12345:34:2",
+			    "0@lo:12345:34:3"
+};
+
+const int cob_ids[] = { 20, 30, 40 };
+/* Maximum test servers for this testcase */
+static enum rm_server test_servers_nr;
+
+struct m0_chan    group_tests_chan;
+struct m0_clink   tests_clink[GROUP_TESTS_NR];
+struct rm_context rm_ctx[SERVER_NR];
+struct m0_mutex   group_tests_chan_mutex;
+
+static void rmg_in_complete(struct m0_rm_incoming *in, int32_t rc)
+{
+}
+
+static void rmg_in_conflict(struct m0_rm_incoming *in)
+{
+}
+
+const struct m0_rm_incoming_ops rmg_incoming_ops = {
+	.rio_complete = rmg_in_complete,
+	.rio_conflict = rmg_in_conflict
+};
+
+static void ring_get(enum rm_server       srv_id,
+		     enum m0_rm_group_id  grp_id,
+		     m0_rm_incoming_flags in_flag,
+		     int                  which_ring)
+{
+	struct m0_rm_incoming *in    = &rm_ctx[srv_id].rc_test_data.rd_in;
+	struct m0_rm_owner    *owner = rm_ctx[srv_id].rc_test_data.rd_owner;
+	int                    rc;
+
+	/*
+	 * Test-case - Setup creditor cookie. Group credit request should
+	 *             succeed.
+	 */
+	/* Server-3 is upward creditor for Server with id 'srv_id'*/
+	if (srv_id != SERVER_3)
+		creditor_cookie_setup(srv_id, SERVER_3);
+
+	m0_rm_incoming_init(in, owner, M0_RIT_LOCAL,
+			    RIP_NONE, RIF_LOCAL_WAIT | in_flag);
+	in->rin_want.cr_datum = which_ring;
+	in->rin_ops = &rmg_incoming_ops;
+	in->rin_want.cr_group_id = M0_UINT128(0, grp_id);
+
+	m0_rm_credit_get(in);
+	m0_rm_owner_lock(owner);
+	rc = m0_sm_timedwait(&in->rin_sm, M0_BITS(RI_SUCCESS), M0_TIME_NEVER);
+	m0_rm_owner_unlock(owner);
+	M0_UT_ASSERT(rc == 0);
+	M0_UT_ASSERT(in->rin_rc == 0);
+	m0_rm_credit_put(in);
+	m0_rm_incoming_fini(in);
+}
+
+static void standalone_borrow_verify(void)
+{
+	struct m0_rm_owner *so2 = rm_ctx[SERVER_2].rc_test_data.rd_owner;
+	struct m0_rm_owner *so1 = rm_ctx[SERVER_1].rc_test_data.rd_owner;
+
+	M0_UT_ASSERT(!m0_rm_ur_tlist_is_empty(&so2->ro_borrowed));
+	M0_UT_ASSERT(m0_rm_ur_tlist_is_empty(&so2->ro_owned[OWOS_CACHED]));
+	M0_UT_ASSERT(!m0_rm_ur_tlist_is_empty(&so1->ro_borrowed));
+	M0_UT_ASSERT(!m0_rm_ur_tlist_is_empty(&so1->ro_owned[OWOS_CACHED]));
+}
+
+static void standalone_borrow_run(void)
+{
+	ring_get(SERVER_3, M0_RM_NO_GROUP, RIF_MAY_BORROW, DURIN);
+}
+
+static void group_revoke_verify(void)
+{
+	struct m0_rm_owner *so3 = rm_ctx[SERVER_3].rc_test_data.rd_owner;
+	struct m0_rm_owner *so2 = rm_ctx[SERVER_2].rc_test_data.rd_owner;
+	struct m0_rm_owner *so1 = rm_ctx[SERVER_1].rc_test_data.rd_owner;
+
+	M0_UT_ASSERT(m0_rm_ur_tlist_is_empty(&so3->ro_sublet));
+	M0_UT_ASSERT(m0_rm_ur_tlist_is_empty(&so2->ro_borrowed));
+	M0_UT_ASSERT(m0_rm_ur_tlist_is_empty(&so2->ro_owned[OWOS_CACHED]));
+	M0_UT_ASSERT(m0_rm_ur_tlist_is_empty(&so1->ro_borrowed));
+	M0_UT_ASSERT(m0_rm_ur_tlist_is_empty(&so1->ro_owned[OWOS_CACHED]));
+}
+
+/*
+ * Test group revoke
+ */
+static void group_revoke_run(void)
+{
+	loan_session_set(SERVER_3, SERVER_1);
+	loan_session_set(SERVER_3, SERVER_2);
+	ring_get(SERVER_3, M0_RM_NO_GROUP, RIF_MAY_REVOKE, NENYA);
+}
+
+static void group_borrow_verify(enum rm_server srv_id)
+{
+	struct m0_rm_owner *cso = rm_ctx[SERVER_3].rc_test_data.rd_owner;
+	struct m0_rm_owner *dso = rm_ctx[srv_id].rc_test_data.rd_owner;
+
+	M0_UT_ASSERT(!m0_rm_ur_tlist_is_empty(&cso->ro_sublet));
+	M0_UT_ASSERT(!m0_rm_ur_tlist_is_empty(&dso->ro_borrowed));
+	M0_UT_ASSERT(!m0_rm_ur_tlist_is_empty(&dso->ro_owned[OWOS_CACHED]));
+}
+
+/*
+ * Test group borrow
+ */
+static void group_borrow_run(enum rm_server srv_id)
+{
+	ring_get(srv_id, M0_RM_SNS_GROUP, RIF_MAY_BORROW, NENYA);
+}
+
+static void server1_tests(void)
+{
+	m0_chan_wait(&tests_clink[GROUP_BORROW_TEST1]);
+	group_borrow_run(SERVER_1);
+	group_borrow_verify(SERVER_1);
+
+	/* Begin next test */
+	m0_chan_signal_lock(&group_tests_chan);
+}
+
+static void server2_tests(void)
+{
+	m0_chan_wait(&tests_clink[GROUP_BORROW_TEST2]);
+	group_borrow_run(SERVER_2);
+	group_borrow_verify(SERVER_2);
+
+	/* Begin next test */
+	m0_chan_signal_lock(&group_tests_chan);
+
+}
+
+static void server3_tests(void)
+{
+	m0_chan_wait(&tests_clink[STAND_ALONE_BORROW_TEST]);
+	standalone_borrow_run();
+	standalone_borrow_verify();
+
+	group_revoke_run();
+	group_revoke_verify();
+}
+
+static void rm_server_start(const int tid)
+{
+	if (tid < test_servers_nr) {
+		rings_utdata_ops_set(&rm_ctx[tid].rc_test_data);
+		rm_ctx_server_start(tid);
+	}
+
+	switch(tid) {
+	case SERVER_1:
+		server1_tests();
+		break;
+	case SERVER_2:
+		server2_tests();
+		break;
+	case SERVER_3:
+		server3_tests();
+		break;
+	default:
+		break;
+	}
+}
+
+/*
+ * Configure server hierarchy.
+ */
+static void server_hier_config(void)
+{
+	rm_ctx[SERVER_1].creditor_id = SERVER_3;
+	rm_ctx[SERVER_1].debtor_id[0] = SERVER_INVALID;
+	rm_ctx[SERVER_1].rc_debtors_nr = 1;
+
+	rm_ctx[SERVER_2].creditor_id = SERVER_3;
+	rm_ctx[SERVER_2].debtor_id[0] = SERVER_INVALID;
+	rm_ctx[SERVER_2].rc_debtors_nr = 1;
+
+	rm_ctx[SERVER_3].creditor_id = SERVER_INVALID;
+	rm_ctx[SERVER_3].debtor_id[0] = SERVER_1;
+	rm_ctx[SERVER_3].debtor_id[1] = SERVER_2;
+	rm_ctx[SERVER_3].rc_debtors_nr = 1;
+}
+
+static void rm_group_utinit(void)
+{
+	uint32_t i;
+
+	test_servers_nr = SERVER_NR;
+	for (i = 0; i < test_servers_nr; ++i)
+		rm_ctx_config(i);
+
+	server_hier_config();
+	m0_mutex_init(&group_tests_chan_mutex);
+	m0_chan_init(&group_tests_chan, &group_tests_chan_mutex);
+
+	/* Set up test sync points */
+	for (i = 0; i < GROUP_TESTS_NR; ++i) {
+		m0_clink_init(&tests_clink[i], NULL);
+		m0_clink_add_lock(&group_tests_chan, &tests_clink[i]);
+	}
+}
+
+static void rm_group_utfini(void)
+{
+	uint32_t i;
+
+	/*
+	 * Following loops cannot be combined.
+	 * The ops within the loops need sync points. Hence they are separate.
+	 */
+	/* De-construct RM objects hierarchy */
+	for (i = 0; i < test_servers_nr; ++i) {
+		rm_ctx_server_windup(i);
+	}
+	/* Disconnect the servers */
+	for (i = 0; i < test_servers_nr; ++i) {
+		rm_ctx_server_stop(i);
+	}
+	/* Finalise the servers */
+	for (i = 0; i < test_servers_nr; ++i) {
+		rm_ctx_fini(&rm_ctx[i]);
+	}
+	for (i = 0; i < GROUP_TESTS_NR; ++i) {
+		m0_clink_del_lock(&tests_clink[i]);
+		m0_clink_fini(&tests_clink[i]);
+	}
+	m0_chan_fini_lock(&group_tests_chan);
+	m0_mutex_fini(&group_tests_chan_mutex);
+}
+
+void rm_group_test(void)
+{
+	int rc;
+	int i;
+
+	rm_group_utinit();
+	/* Start RM servers */
+	for (i = 0; i < test_servers_nr; ++i) {
+		rc = M0_THREAD_INIT(&rm_ctx[i].rc_thr, int, NULL,
+				    &rm_server_start, i, "rm_server_%d", i);
+		M0_UT_ASSERT(rc == 0);
+	}
+
+	/* Now start the tests - wait till all the servers are ready */
+	m0_chan_signal_lock(&group_tests_chan);
+	for (i = 0; i < test_servers_nr; ++i) {
+		m0_thread_join(&rm_ctx[i].rc_thr);
+		m0_thread_fini(&rm_ctx[i].rc_thr);
+	}
+	rm_group_utfini();
+}
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/rm/ut/rmut.c b/rm/ut/rmut.c
index f5510dd..6f666c3 100644
--- a/rm/ut/rmut.c
+++ b/rm/ut/rmut.c
@@ -19,6 +19,7 @@
  */
 
 #include "lib/memory.h"
+#include "lib/cookie.h"
 #include "lib/misc.h"
 #include "ut/ut.h"
 #include "lib/ub.h"
@@ -291,6 +292,7 @@ void loan_session_set(enum rm_server csrv_id,
 	struct m0_rm_loan        *loan;
 	struct m0_rm_credit      *credit;
 	struct m0_rm_remote      *remote;
+	struct m0_cookie          dcookie;
 	struct m0_rm_remote_link *rrl;
 
 	M0_UT_ASSERT(!m0_rm_ur_tlist_is_empty(&owner->ro_sublet));
@@ -299,9 +301,16 @@ void loan_session_set(enum rm_server csrv_id,
 		M0_UT_ASSERT(loan != NULL);
 		M0_UT_ASSERT(!m0_proxies_tlist_is_empty(&loan->rl_others));
 		M0_UT_ASSERT(m0_proxies_tlist_length(&loan->rl_others) == 1);
-		rrl = m0_proxies_tlist_head(&loan->rl_others);
-		remote = rrl->rrl_ptr;
-		remote->rem_session = &rm_ctx[csrv_id].rc_sess[dsrv_id];
+		m0_cookie_init(&dcookie,
+			       &rm_ctx[dsrv_id].rc_test_data.rd_owner->ro_id);
+		m0_tl_for(m0_proxies, &loan->rl_others, rrl) {
+			remote = rrl->rrl_ptr;
+			if (dcookie.co_addr == remote->rem_cookie.co_addr &&
+			    dcookie.co_generation ==
+				remote->rem_cookie.co_generation)
+				remote->rem_session =
+					&rm_ctx[csrv_id].rc_sess[dsrv_id];
+		} m0_tl_endfor;
 	} m0_tl_endfor;
 }
 
diff --git a/rm/ut/rmut.h b/rm/ut/rmut.h
index e9f8bc1..4faf5db 100644
--- a/rm/ut/rmut.h
+++ b/rm/ut/rmut.h
@@ -66,6 +66,19 @@ enum flock_tests {
 	LOCK_TESTS_NR,
 };
 
+enum group_tests {
+	/* A group of debtors borrowing the same credit */
+	GROUP_BORROW_TEST1 = 0,
+	GROUP_BORROW_TEST2,
+	/*
+	 * A stand-alone debtor borrowing a credit other than the group credit.
+	 */
+	STAND_ALONE_BORROW_TEST,
+	/* Revoking a credit from a group of debtors */
+	GROUP_REVOKE_TEST,
+	GROUP_TESTS_NR,
+};
+
 /* Forward declaration */
 struct rm_ut_data;
 
-- 
1.8.3.2

