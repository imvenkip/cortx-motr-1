From 8818be6b7014779320f63bfe332034328f457ffa Mon Sep 17 00:00:00 2001
From: Rajesh Bhalerao <Rajesh_Bhalerao@xyratex.com>
Date: Wed, 21 Aug 2013 16:53:24 +0530
Subject: [PATCH 04/24] Interim check-in.

---
 rm/rm.c          | 53 +++++++++++++++++++++++++++++++++--------------------
 rm/rm_foms.c     |  3 ++-
 rm/rm_fops.c     | 24 ++++++++++++++++--------
 rm/rm_internal.h | 11 ++++++-----
 4 files changed, 57 insertions(+), 34 deletions(-)

diff --git a/rm/rm.c b/rm/rm.c
index 1b89e95..8fa6540 100644
--- a/rm/rm.c
+++ b/rm/rm.c
@@ -1223,7 +1223,7 @@ static int cached_credits_remove(struct m0_rm_incoming *in)
 	struct m0_rm_credit *credit;
 	struct m0_rm_credit *remnant_credit;
 	struct m0_rm_owner  *owner = in->rin_want.cr_owner;
-	struct m0_tl	     diff_list;
+	struct m0_tl	     retain_list;
 	struct m0_tl	     remove_list;
 	int		     rc = 0;
 
@@ -1232,7 +1232,7 @@ static int cached_credits_remove(struct m0_rm_incoming *in)
 	/* Credits can be removed for remote requests */
 	M0_PRE(in->rin_type != M0_RIT_LOCAL);
 
-	m0_rm_ur_tlist_init(&diff_list);
+	m0_rm_ur_tlist_init(&retain_list);
 	m0_rm_ur_tlist_init(&remove_list);
 	m0_tl_for (pi, &in->rin_pins, pin) {
 		M0_ASSERT(m0_rm_pin_bob_check(pin));
@@ -1241,8 +1241,10 @@ static int cached_credits_remove(struct m0_rm_incoming *in)
 
 		pin_del(pin);
 		M0_ASSERT(credit_pin_nr(credit, M0_RPF_TRACK) == 0);
-		m0_rm_ur_tlist_move(&remove_list, credit);
-		if (!credit->cr_ops->cro_is_subset(credit, &in->rin_want)) {
+		if (!credit->cr_ops->cro_intersects(credit, &in->rin_want))
+			m0_rm_ur_tlist_move(&retain_list, credit);
+		else {
+			m0_rm_ur_tlist_move(&remove_list, credit);
 			/*
 			 * The cached credit does not completely intersect
 			 * incoming credit.
@@ -1252,9 +1254,15 @@ static int cached_credits_remove(struct m0_rm_incoming *in)
 			 * the difference in the remnant credit.
 			 */
 			rc = remnant_credit_get(credit, &in->rin_want,
-					       &remnant_credit);
-			if (rc == 0)
-				m0_rm_ur_tlist_add(&diff_list, remnant_credit);
+					        &remnant_credit);
+			if (rc == 0) {
+				if (credit_is_empty(remnant_credit))
+					m0_rm_ur_tlist_add(&remove_list,
+							   remnant_credit);
+				else
+					m0_rm_ur_tlist_add(&retain_list,
+							   remnant_credit);
+			}
 		}
 
 	} m0_tl_endfor;
@@ -1264,16 +1272,16 @@ static int cached_credits_remove(struct m0_rm_incoming *in)
 	 * and move the remnant credits to the OWOS_CACHED. Do the opposite
 	 * on failure.
 	 */
-	m0_tl_teardown(m0_rm_ur, rc ? &diff_list : &remove_list, credit) {
+	m0_tl_teardown(m0_rm_ur, rc ? &retain_list : &remove_list, credit) {
 		     m0_rm_credit_fini(credit);
 		     m0_free(credit);
 	}
 
-	m0_tl_for (m0_rm_ur, rc ? &remove_list : &diff_list, credit) {
+	m0_tl_for (m0_rm_ur, rc ? &remove_list : &retain_list, credit) {
 		m0_rm_ur_tlist_move(&owner->ro_owned[OWOS_CACHED], credit);
 	} m0_tl_endfor;
 
-	m0_rm_ur_tlist_fini(&diff_list);
+	m0_rm_ur_tlist_fini(&retain_list);
 	m0_rm_ur_tlist_fini(&remove_list);
 	M0_RETURN(rc);
 }
@@ -2261,32 +2269,37 @@ M0_INTERNAL int m0_rm_loan_settle(struct m0_rm_owner  *owner,
 }
 
 M0_INTERNAL bool m0_rm_loan_pay_n_check(struct m0_rm_owner *owner,
-					struct m0_rm_loan  *loan,
+					struct m0_rm_loan  *paid_loan,
+					struct m0_tl       *list,
 					struct m0_cookie   *rem_cookie)
 {
-	struct m0_rm_loan        *sublet = NULL;
-	struct m0_rm_credit      *loaned_cr = &loan->rl_credit;
+	struct m0_rm_loan        *onrecord_loan = NULL;
+	struct m0_rm_credit      *loaned_cr = &paid_loan->rl_credit;
 	struct m0_rm_credit      *cr;
 	struct m0_rm_remote      *other;
 	struct m0_rm_remote_link *rrl;
 
-	/* Find matching loan from sublet list */
-	m0_tl_for (m0_rm_ur, &owner->ro_sublet, cr) {
+	/* Find matching loan from the list */
+	m0_tl_for (m0_rm_ur, list, cr) {
 		if (cr->cr_ops->cro_is_subset(loaned_cr, cr)) {
-			sublet = bob_of(cr, struct m0_rm_loan,
-					rl_credit, &loan_bob);
+			onrecord_loan = bob_of(cr, struct m0_rm_loan,
+					       rl_credit, &loan_bob);
+			M0_ASSERT(onrecord_loan->rl_cookie.co_addr ==
+				  paid_loan->rl_cookie.co_addr &&
+				  onrecord_loan->rl_cookie.co_generation ==
+				  paid_loan->rl_cookie.co_generation);
 			break;
 		}
 	} m0_tl_endfor;
 
-	if (sublet == NULL)
+	if (onrecord_loan == NULL)
 		return false;
 
 	/*
  	 * Delete the remote from the remote list of the loan
  	 * and check if all the revokes are complete?
  	 */
-	m0_tl_for(m0_proxies, &sublet->rl_others, rrl) {
+	m0_tl_for(m0_proxies, &onrecord_loan->rl_others, rrl) {
 		other = rrl->rrl_ptr;
 		if (other->rem_cookie.co_addr == rem_cookie->co_addr &&
 		    other->rem_cookie.co_generation ==
@@ -2296,7 +2309,7 @@ M0_INTERNAL bool m0_rm_loan_pay_n_check(struct m0_rm_owner *owner,
 		}
 	} m0_tl_endfor;
 
-	return m0_proxies_tlist_is_empty(&sublet->rl_others);
+	return m0_proxies_tlist_is_empty(&onrecord_loan->rl_others);
 }
 
 /** @} end of Owner state machine group */
diff --git a/rm/rm_foms.c b/rm/rm_foms.c
index 39b645e..42ba436 100644
--- a/rm/rm_foms.c
+++ b/rm/rm_foms.c
@@ -627,7 +627,8 @@ static int process_cancel(struct m0_fom *fom)
 	owner = loan->rl_credit.cr_owner;
 	rrl = m0_proxies_tlist_head(&loan->rl_others);
 	m0_rev_session_wait(rrl->rrl_ptr);
-	rc = m0_rm_loan_pay_n_check(owner, loan, &rrl->rrl_ptr->rem_cookie) ?
+	rc = m0_rm_loan_pay_n_check(owner, loan, &owner->ro_sublet,
+				    &rrl->rrl_ptr->rem_cookie) ?
 		m0_rm_loan_settle(owner, loan, rrl->rrl_ptr) : 0;
 
 	m0_fom_phase_set(fom, FOPH_RM_REQ_FINISH);
diff --git a/rm/rm_fops.c b/rm/rm_fops.c
index cdcaefb..e64acb0 100644
--- a/rm/rm_fops.c
+++ b/rm/rm_fops.c
@@ -251,10 +251,13 @@ static int cancel_fop_fill(struct rm_out     *outreq,
 }
 
 static void outgoing_queue(enum m0_rm_outgoing_type  otype,
+			   struct m0_rm_owner       *owner,
 			   struct rm_out            *outreq,
 			   struct m0_rm_incoming    *in,
 			   struct m0_rm_remote      *other)
 {
+	M0_ASSERT(owner != NULL);
+
 	switch (otype) {
 	case M0_ROT_BORROW:
 		outreq->ou_ast.sa_cb = &borrow_ast;
@@ -268,11 +271,11 @@ static void outgoing_queue(enum m0_rm_outgoing_type  otype,
 	default:
 		break;
 	}
-	if (in != NULL) {
+	if (in != NULL)
 		pin_add(in, &outreq->ou_req.rog_want.rl_credit, M0_RPF_TRACK);
-		m0_rm_ur_tlist_add(&in->rin_want.cr_owner->ro_outgoing[OQS_GROUND],
-				   &outreq->ou_req.rog_want.rl_credit);
-	}
+
+	m0_rm_ur_tlist_add(&owner->ro_outgoing[OQS_GROUND],
+			   &outreq->ou_req.rog_want.rl_credit);
 	outreq->ou_fop.f_item.ri_session = other->rem_session;
 	outreq->ou_fop.f_item.ri_ops     = &rm_request_rpc_ops;
 
@@ -306,6 +309,9 @@ int m0_rm_request_out(enum m0_rm_outgoing_type  otype,
 	if (rc != 0)
 		goto out;
 
+	if (loan != NULL)
+		outreq->ou_req.rog_want.rl_cookie = loan->rl_cookie;
+
 	switch (otype) {
 	case M0_ROT_BORROW:
 		rc = borrow_fop_fill(outreq, in, credit);
@@ -328,7 +334,7 @@ int m0_rm_request_out(enum m0_rm_outgoing_type  otype,
 		m0_fop_put(&outreq->ou_fop);
 		goto out;
 	}
-	outgoing_queue(otype, outreq, in, other);
+	outgoing_queue(otype, credit->cr_owner, outreq, in, other);
 
 out:
 	M0_RETURN(rc);
@@ -445,7 +451,7 @@ static void revoke_ast(struct m0_sm_group *grp, struct m0_sm_ast *ast)
 	}
 
 	owner = rvk_loan->rl_credit.cr_owner;
-	rc  = m0_rm_loan_pay_n_check(owner, rvk_loan,
+	rc  = m0_rm_loan_pay_n_check(owner, rvk_loan, &owner->ro_sublet,
 				     &rrl->rrl_ptr->rem_cookie) ?
 		m0_rm_loan_settle(owner, rvk_loan, rrl->rrl_ptr) : 0;
 
@@ -492,8 +498,10 @@ static void cancel_ast(struct m0_sm_group *grp, struct m0_sm_ast *ast)
 						      &cancel_loan->rl_credit))
 				m0_rm_ur_tlist_del(r);
 		} m0_tl_endfor;
-		rc = m0_rm_owner_loan_debit(o, &cancel_loan->rl_credit,
-					    &o->ro_sublet);
+		rc  = m0_rm_loan_pay_n_check(o, cancel_loan, &o->ro_borrowed,
+					     &rrl->rrl_ptr->rem_cookie) ?
+			m0_rm_owner_loan_debit(o, &cancel_loan->rl_credit,
+					       &o->ro_borrowed): 0;
 	}
 
 	outreq->ou_req.rog_rc = rc;
diff --git a/rm/rm_internal.h b/rm/rm_internal.h
index 7fad654..16c3473 100644
--- a/rm/rm_internal.h
+++ b/rm/rm_internal.h
@@ -192,13 +192,14 @@ M0_INTERNAL int m0_rm_loan_settle(struct m0_rm_owner  *owner,
 
 /**
  * Removes the remote proxy associated with the loan.
- * Checks if loan can be removed. When a group is using a credit of a resource,
- * multiple debtors may have the same loan. When such loan is revoked, each
- * remote proxy associated with loan is removed. When all proxies have been
- * removed, the loan could be settled.
+ * Checks if loan can be removed. When a group is using credit(s) of a resource,
+ * multiple debtors may have the same loan. When such loan is revoked or
+ * cancled, a * remote proxy associated with loan is removed. When all the
+ * proxies have been removed, the loan could be settled.
  */
 M0_INTERNAL bool m0_rm_loan_pay_n_check(struct m0_rm_owner *owner,
-					struct m0_rm_loan  *loan,
+					struct m0_rm_loan  *paid_loan,
+					struct m0_tl       *list,
 					struct m0_cookie   *rem_cookie);
 
 /**
-- 
1.8.3.2

