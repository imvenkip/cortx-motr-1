From 0094148026d421ca76f69dd83f40c6e15111bdcb Mon Sep 17 00:00:00 2001
From: Rajanikant Chirmade <rajanikant_chirmade@xyratex.com>
Date: Fri, 3 Jan 2014 17:02:05 +0530
Subject: [PATCH 01/20]  - Moved fop rate code to seperate files unser mero/fop
 directory.

---
 fop/Makefile.sub       |   6 +-
 fop/fom.c              | 129 +++--------------------------------
 fop/fop_rate_monitor.c | 178 +++++++++++++++++++++++++++++++++++++++++++++++++
 fop/fop_rate_monitor.h |  70 +++++++++++++++++++
 4 files changed, 261 insertions(+), 122 deletions(-)
 create mode 100644 fop/fop_rate_monitor.c
 create mode 100644 fop/fop_rate_monitor.h

diff --git a/fop/Makefile.sub b/fop/Makefile.sub
index de96b10..79d14e3 100644
--- a/fop/Makefile.sub
+++ b/fop/Makefile.sub
@@ -6,7 +6,8 @@ nobase_mero_include_HEADERS += fop/fop.h \
                                fop/fom_long_lock.h \
                                fop/fom_simple.h \
                                fop/fom_generic_xc.h \
-			       fop/fop_addb.h
+			       fop/fop_addb.h \
+			       fop/fop_rate_monitor.h
 
 mero_libmero_la_SOURCES  += fop/fop.c \
                             fop/fom.c \
@@ -15,6 +16,7 @@ mero_libmero_la_SOURCES  += fop/fop.c \
                             fop/fom_long_lock.c \
                             fop/fom_simple.c \
                             fop/fop_xc.c \
-                            fop/fom_generic_xc.c
+                            fop/fom_generic_xc.c \
+			    fop/fop_rate_monitor.c
 
 XC_FILES   += fop/fom_generic_xc.h fop/fop_xc.h
diff --git a/fop/fom.c b/fop/fom.c
index 3f3d0f4..5d076d3 100644
--- a/fop/fom.c
+++ b/fop/fom.c
@@ -37,6 +37,7 @@
 #include "reqh/reqh.h"
 #include "sm/sm.h"
 #include "fop/fop_addb.h"
+#include "fop/fop_rate_monitor.h"
 #include "rpc/rpc_machine.h"
 #include "addb/addb_monitor.h"
 
@@ -156,8 +157,7 @@ struct m0_loc_thread {
 	uint64_t                lt_magix;
 };
 
-extern uint32_t  fop_rate_monitor_key;
-static m0_time_t fop_rate_interval = M0_MKTIME(1, 0);
+extern m0_time_t fop_rate_interval;
 
 M0_TL_DESCR_DEFINE(thr, "fom thread", static, struct m0_loc_thread, lt_linkage,
 		   lt_magix, M0_FOM_THREAD_MAGIC, M0_FOM_THREAD_HEAD_MAGIC);
@@ -180,122 +180,10 @@ static void __fom_domain_fini(struct m0_fom_domain *dom);
  * Fom domain operations.
  * @todo Support fom timeout functionality.
  */
-
 static struct m0_fom_domain_ops m0_fom_dom_ops = {
 	.fdo_time_is_out = fom_wait_time_is_out
 };
 
-static struct fop_rate_stats_sum_rec {
-	uint64_t ssr_fop_rate;
-} fop_rate_stats_sum;
-
-static struct m0_addb_sum_rec *
-fop_rate_monitor_sum_rec(const struct m0_addb_monitor *mon,
-		         struct m0_reqh               *reqh)
-{
-	struct m0_addb_sum_rec *sum_rec;
-
-	M0_PRE(reqh != NULL);
-
-	m0_rwlock_read_lock(&reqh->rh_rwlock);
-	sum_rec = m0_reqh_lockers_get(reqh, fop_rate_monitor_key);
-	m0_rwlock_read_unlock(&reqh->rh_rwlock);
-
-	M0_ASSERT(sum_rec != NULL);
-
-	return sum_rec;
-}
-
-static void fop_rate_monitor_watch(const struct m0_addb_monitor *monitor,
-				   const struct m0_addb_rec     *rec,
-				   struct m0_reqh               *reqh)
-{
-#undef FOP_RATE
-#define FOP_RATE(sum_rec)					\
-	(struct fop_rate_stats_sum_rec *)sum_rec->asr_rec.ss_data.au64s_data
-
-	struct m0_addb_sum_rec        *sum_rec;
-	struct fop_rate_stats_sum_rec *f_rate;
-
-	M0_PRE(reqh != NULL);
-
-	if (m0_addb_rec_rid_make(M0_ADDB_BRT_CNTR,
-			         M0_ADDB_RECID_FOP_RATE_CNTR) == rec->ar_rid) {
-
-		sum_rec = monitor->am_ops->amo_sum_rec(monitor, reqh);
-		M0_ASSERT(sum_rec != NULL);
-
-		m0_mutex_lock(&sum_rec->asr_mutex);
-		M0_ASSERT(sum_rec->asr_rec.ss_id ==
-			  M0_ADDB_RECID_FOP_RATE);
-		f_rate = FOP_RATE(sum_rec);
-		M0_ASSERT(f_rate != NULL);
-		/*
-		 * fop_rate is ADDB counter.
-		 * rec->ar_data.au64s_data[1] is number of samples
-		 * rec->ar_data.au64s_data[2] is sum_samples
-		 */
-		f_rate->ssr_fop_rate =
-		rec->ar_data.au64s_data[2] / rec->ar_data.au64s_data[1];
-		sum_rec->asr_dirty = true;
-		m0_mutex_unlock(&sum_rec->asr_mutex);
-	}
-#undef FOP_RATE
-}
-
-const struct m0_addb_monitor_ops fop_rate_monitor_ops = {
-	.amo_watch = fop_rate_monitor_watch,
-	.amo_sum_rec = fop_rate_monitor_sum_rec
-};
-
-static int fop_rate_monitor_init(struct m0_reqh         *reqh,
-				 struct m0_addb_monitor *monitor,
-				 uint32_t                fop_rate_monitor_key)
-{
-#undef FOP_RATE_STATS_NR
-#define FOP_RATE_STATS_NR (sizeof(fop_rate_stats_sum) / sizeof(uint64_t))
-
-	struct m0_addb_sum_rec *sum_rec;
-
-	M0_PRE(monitor != NULL && reqh != NULL);
-
-	FOP_ALLOC_PTR(sum_rec, FOM_RATE_MON_INIT, &m0_fop_addb_ctx);
-	if (sum_rec == NULL)
-		return M0_RC(-ENOMEM);
-
-	m0_addb_monitor_init(monitor, &fop_rate_monitor_ops);
-	m0_addb_monitor_sum_rec_init(sum_rec, &m0_addb_rt_fop_rate,
-				     (uint64_t *)&fop_rate_stats_sum,
-				     FOP_RATE_STATS_NR);
-
-	m0_rwlock_write_lock(&reqh->rh_rwlock);
-	m0_reqh_lockers_set(reqh, fop_rate_monitor_key, sum_rec);
-	m0_rwlock_write_unlock(&reqh->rh_rwlock);
-
-	m0_addb_monitor_add(reqh, monitor);
-	return 0;
-}
-
-static void fop_rate_monitor_fini(struct m0_reqh         *reqh,
-				  struct m0_addb_monitor *monitor,
-				  uint32_t                fop_rate_monitor_key)
-{
-	struct m0_addb_sum_rec *sum_rec;
-
-	M0_PRE(monitor != NULL && reqh != NULL);
-
-	sum_rec = monitor->am_ops->amo_sum_rec(monitor, reqh);
-	m0_addb_monitor_del(reqh, monitor);
-
-	m0_rwlock_write_lock(&reqh->rh_rwlock);
-	m0_reqh_lockers_clear(reqh, fop_rate_monitor_key);
-	m0_rwlock_write_unlock(&reqh->rh_rwlock);
-
-	m0_addb_monitor_sum_rec_fini(sum_rec);
-	m0_free(sum_rec);
-
-	m0_addb_monitor_fini(monitor);
-}
 static void group_lock(struct m0_fom_locality *loc)
 {
 	m0_sm_group_lock(&loc->fl_group);
@@ -1069,9 +957,10 @@ M0_INTERNAL int m0_fom_domain_init(struct m0_fom_domain *dom)
 	}
 
 	m0_bitmap_fini(&onln_cpu_map);
-	return fop_rate_monitor_init(dom->fd_reqh,
-				     &dom->fd_fop_rate_monitor,
-				     fop_rate_monitor_key);
+	dom->fd_fop_rate_monitor_key = 0;
+	return m0_fop_rate_monitor_init(dom->fd_reqh,
+				        &dom->fd_fop_rate_monitor,
+				        &dom->fd_fop_rate_monitor_key);
 }
 
 static void __fom_domain_fini(struct m0_fom_domain *dom)
@@ -1096,9 +985,9 @@ static void __fom_domain_fini(struct m0_fom_domain *dom)
 M0_INTERNAL void m0_fom_domain_fini(struct m0_fom_domain *dom)
 {
 	__fom_domain_fini(dom);
-	fop_rate_monitor_fini(dom->fd_reqh,
-			      &dom->fd_fop_rate_monitor,
-			      fop_rate_monitor_key);
+	m0_fop_rate_monitor_fini(dom->fd_reqh,
+			         &dom->fd_fop_rate_monitor,
+			         dom->fd_fop_rate_monitor_key);
 }
 
 M0_INTERNAL bool m0_fom_domain_is_idle(const struct m0_fom_domain *dom)
diff --git a/fop/fop_rate_monitor.c b/fop/fop_rate_monitor.c
new file mode 100644
index 0000000..491e12e
--- /dev/null
+++ b/fop/fop_rate_monitor.c
@@ -0,0 +1,178 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2014 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Rajanikant Chirmade <Rajanikant_Chirmade@xyratex.com>
+ * Original creation date: 01/02/2014
+ */
+
+#include "lib/misc.h"
+#include "lib/errno.h"
+#include "lib/assert.h"
+#include "lib/memory.h"
+#include "lib/locality.h"
+#include "lib/processor.h"
+#include "lib/time.h"
+#include "lib/timer.h"
+#include "lib/arith.h"
+#include "addb/addb.h"
+#include "mero/magic.h"
+#include "fop/fop.h"
+#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_FOP
+#include "lib/trace.h"
+#include "fop/fom_long_lock.h"
+#include "reqh/reqh.h"
+#include "sm/sm.h"
+#include "fop/fop_addb.h"
+#include "rpc/rpc_machine.h"
+#include "addb/addb_monitor.h"
+
+/**
+ * @addtogroup fom
+ * @{
+ */
+m0_time_t fop_rate_interval = M0_MKTIME(1, 0);
+
+#undef FOM_RATE_KEY
+#define FOM_RATE_KEY(reqh)	(reqh->rh_fom_dom.fd_fop_rate_monitor_key)
+
+static struct fop_rate_stats_sum_rec {
+	uint64_t ssr_fop_rate;
+} fop_rate_stats_sum;
+
+static struct m0_addb_sum_rec *
+fop_rate_monitor_sum_rec(const struct m0_addb_monitor *mon,
+		         struct m0_reqh               *reqh)
+{
+	struct m0_addb_sum_rec *sum_rec;
+
+	M0_PRE(reqh != NULL);
+
+	m0_rwlock_read_lock(&reqh->rh_rwlock);
+	sum_rec = m0_reqh_lockers_get(reqh, FOM_RATE_KEY(reqh));
+	m0_rwlock_read_unlock(&reqh->rh_rwlock);
+
+	M0_ASSERT(sum_rec != NULL);
+
+	return sum_rec;
+}
+
+static void fop_rate_monitor_watch(const struct m0_addb_monitor *monitor,
+				   const struct m0_addb_rec     *rec,
+				   struct m0_reqh               *reqh)
+{
+#undef FOP_RATE
+#define FOP_RATE(sum_rec)					\
+	(struct fop_rate_stats_sum_rec *)sum_rec->asr_rec.ss_data.au64s_data
+
+	struct m0_addb_sum_rec        *sum_rec;
+	struct fop_rate_stats_sum_rec *f_rate;
+
+	M0_PRE(reqh != NULL);
+
+	if (m0_addb_rec_rid_make(M0_ADDB_BRT_CNTR,
+			         M0_ADDB_RECID_FOP_RATE_CNTR) == rec->ar_rid) {
+
+		sum_rec = monitor->am_ops->amo_sum_rec(monitor, reqh);
+		M0_ASSERT(sum_rec != NULL);
+
+		m0_mutex_lock(&sum_rec->asr_mutex);
+		M0_ASSERT(sum_rec->asr_rec.ss_id ==
+			  M0_ADDB_RECID_FOP_RATE);
+		f_rate = FOP_RATE(sum_rec);
+		M0_ASSERT(f_rate != NULL);
+		/*
+		 * fop_rate is ADDB counter.
+		 * rec->ar_data.au64s_data[1] is number of samples
+		 * rec->ar_data.au64s_data[2] is sum_samples
+		 */
+		f_rate->ssr_fop_rate =
+		rec->ar_data.au64s_data[2] / rec->ar_data.au64s_data[1];
+		sum_rec->asr_dirty = true;
+		m0_mutex_unlock(&sum_rec->asr_mutex);
+	}
+#undef FOP_RATE
+}
+
+const struct m0_addb_monitor_ops fop_rate_monitor_ops = {
+	.amo_watch = fop_rate_monitor_watch,
+	.amo_sum_rec = fop_rate_monitor_sum_rec
+};
+
+M0_INTERNAL
+int m0_fop_rate_monitor_init(struct m0_reqh         *reqh,
+			     struct m0_addb_monitor *monitor,
+			     uint32_t               *fop_rate_monitor_key)
+{
+#undef FOP_RATE_STATS_NR
+#define FOP_RATE_STATS_NR (sizeof(fop_rate_stats_sum) / sizeof(uint64_t))
+
+	struct m0_addb_sum_rec *sum_rec;
+
+	M0_PRE(monitor != NULL && reqh != NULL);
+
+	FOP_ALLOC_PTR(sum_rec, FOM_RATE_MON_INIT, &m0_fop_addb_ctx);
+	if (sum_rec == NULL)
+		M0_RETURN(-ENOMEM);
+
+	m0_addb_monitor_init(monitor, &fop_rate_monitor_ops);
+	m0_addb_monitor_sum_rec_init(sum_rec, &m0_addb_rt_fop_rate,
+				     (uint64_t *)&fop_rate_stats_sum,
+				     FOP_RATE_STATS_NR);
+
+	*fop_rate_monitor_key = m0_reqh_lockers_allot();
+
+	m0_rwlock_write_lock(&reqh->rh_rwlock);
+	m0_reqh_lockers_set(reqh, *fop_rate_monitor_key, sum_rec);
+	m0_rwlock_write_unlock(&reqh->rh_rwlock);
+
+	m0_addb_monitor_add(reqh, monitor);
+	return 0;
+}
+
+M0_INTERNAL
+void m0_fop_rate_monitor_fini(struct m0_reqh         *reqh,
+			      struct m0_addb_monitor *monitor,
+			      uint32_t                fop_rate_monitor_key)
+{
+	struct m0_addb_sum_rec *sum_rec;
+
+	M0_PRE(monitor != NULL && reqh != NULL);
+
+	sum_rec = monitor->am_ops->amo_sum_rec(monitor, reqh);
+	m0_addb_monitor_del(reqh, monitor);
+
+	m0_rwlock_write_lock(&reqh->rh_rwlock);
+	m0_reqh_lockers_clear(reqh, fop_rate_monitor_key);
+	m0_rwlock_write_unlock(&reqh->rh_rwlock);
+
+	m0_addb_monitor_sum_rec_fini(sum_rec);
+	m0_free(sum_rec);
+
+	m0_addb_monitor_fini(monitor);
+}
+
+/** @} endgroup fom */
+#undef FOM_RATE_KEY
+#undef M0_TRACE_SUBSYSTEM
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/fop/fop_rate_monitor.h b/fop/fop_rate_monitor.h
new file mode 100644
index 0000000..04488a1
--- /dev/null
+++ b/fop/fop_rate_monitor.h
@@ -0,0 +1,70 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2014 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Rajanikant Chirmade <Rajanikant_Chirmade@xyratex.com>
+ * Original creation date: 01/02/2014
+ */
+
+#pragma once
+
+#ifndef __MERO_FOP_FOP_RATE_MONITOR_H__
+#define __MERO_FOP_FOP_RATE_MONITOR_H__
+
+/**
+   @addtogroup fop
+
+   This file contains definitions for fop rate monitor.
+   @{
+ */
+
+/*
+ * It initialise fop rate monitor.
+ * @param reqh pointer to request handler.
+ * @param monitor monitor object to intialise.
+ * @param fop_rate_monitor_key pointer to fop rate monitor key in request
+ * 			       handler lockers.
+ * @retval 0 if sucess
+ * 	   -ENOMEM if failed to allocate summary record.
+ */
+M0_INTERNAL
+int m0_fop_rate_monitor_init(struct m0_reqh         *reqh,
+			     struct m0_addb_monitor *monitor,
+			     uint32_t		    *fop_rate_monitor_key);
+/*
+ * It finalise fop rate monitor.
+ * @param reqh pointer to request handler.
+ * @param monitor monitor object to finalise.
+ * @param fop_rate_monitor_key fop rate monitor key in request handler lockers.
+ */
+M0_INTERNAL
+void m0_fop_rate_monitor_fini(struct m0_reqh         *reqh,
+			      struct m0_addb_monitor *monitor,
+			      uint32_t                fop_rate_monitor_key);
+
+/** @} end of fop group */
+
+/* __MERO_FOP_FOP_RATE_MONITOR_H__ */
+#endif
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
-- 
1.8.3.2

