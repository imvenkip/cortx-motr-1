From 71afdff6dba869df23cb3e3a58e1ef63df320dd6 Mon Sep 17 00:00:00 2001
From: Rajanikant Chirmade <rajanikant_chirmade@xyratex.com>
Date: Mon, 24 Mar 2014 17:53:43 +0530
Subject: [PATCH 13/20] - Some of code cleanup.

---
 addb/addb_monitor.h          |  10 +-
 addb/ut/addb_ut_mon_infra.c  |  10 +-
 fop/fom.c                    |  21 ++--
 fop/fom.h                    |  36 +++---
 fop/fop_rate_monitor.c       | 136 ++++++++-------------
 fop/fop_rate_monitor.h       |  13 +-
 m0t1fs/linux_kernel/m0t1fs.c | 282 ++++++++++++++++++++++++++++++++++++++++++-
 7 files changed, 382 insertions(+), 126 deletions(-)

diff --git a/addb/addb_monitor.h b/addb/addb_monitor.h
index d0b7934..436db21 100644
--- a/addb/addb_monitor.h
+++ b/addb/addb_monitor.h
@@ -244,12 +244,12 @@ struct m0_addb_monitor_ops {
 	/**
 	 * This method is called on each addb record.
 	 */
-	void                    (*amo_watch) (const struct m0_addb_monitor *mon,
-					      const struct m0_addb_rec     *rec,
-					      struct m0_reqh               *r);
+	void                    (*amo_watch) (struct m0_addb_monitor   *mon,
+					      const struct m0_addb_rec *rec,
+					      struct m0_reqh           *r);
 	/** Returns m0_addb_sum_rec, if any for this monitor. */
-	struct m0_addb_sum_rec *(*amo_sum_rec) (const struct m0_addb_monitor *m,
-					        struct m0_reqh               *r);
+	struct m0_addb_sum_rec *(*amo_sum_rec) (struct m0_addb_monitor *m,
+					        struct m0_reqh         *r);
 };
 
 struct m0_addb_monitor {
diff --git a/addb/ut/addb_ut_mon_infra.c b/addb/ut/addb_ut_mon_infra.c
index 885265e..a87d744 100644
--- a/addb/ut/addb_ut_mon_infra.c
+++ b/addb/ut/addb_ut_mon_infra.c
@@ -146,8 +146,8 @@ void *dprt_arrp[] = { NULL,
 #undef DPRTP
 #define DPRTP(n) &m0__addb_ut_rt_dp ## n
 
-static struct m0_addb_sum_rec *ut_mon_sum_rec(const struct m0_addb_monitor *mon,
-				              struct m0_reqh               *reqh)
+static struct m0_addb_sum_rec *ut_mon_sum_rec(struct m0_addb_monitor *mon,
+				              struct m0_reqh         *reqh)
 {
 	struct m0_addb_sum_rec *sum_rec;
 	int                     idx;
@@ -162,9 +162,9 @@ static struct m0_addb_sum_rec *ut_mon_sum_rec(const struct m0_addb_monitor *mon,
 	return sum_rec;
 }
 
-void ut_mon_watch(const struct m0_addb_monitor *monitor,
-		  const struct m0_addb_rec     *rec,
-		  struct m0_reqh               *reqh)
+void ut_mon_watch(struct m0_addb_monitor   *monitor,
+		  const struct m0_addb_rec *rec,
+		  struct m0_reqh           *reqh)
 {
 	struct m0_addb_sum_rec *sum_rec;
 	int                     idx;
diff --git a/fop/fom.c b/fop/fom.c
index 8b660c1..fd16f65 100644
--- a/fop/fom.c
+++ b/fop/fom.c
@@ -157,8 +157,6 @@ struct m0_loc_thread {
 	uint64_t                lt_magix;
 };
 
-extern int m0_fop_rate_monitor_key;
-
 M0_TL_DESCR_DEFINE(thr, "fom thread", static, struct m0_loc_thread, lt_linkage,
 		   lt_magix, M0_FOM_THREAD_MAGIC, M0_FOM_THREAD_HEAD_MAGIC);
 M0_TL_DEFINE(thr, static, struct m0_loc_thread);
@@ -861,14 +859,12 @@ err2:
 
 static void loc_ast_post_stats(struct m0_sm_group *grp, struct m0_sm_ast *ast)
 {
-	struct m0_fom_locality *loc = container_of(ast, struct m0_fom_locality,
-						   fl_post_stats_ast);
-	struct m0_fop_rate_monitor *fop_rate_monitor;
-	struct m0_addb_ctx *cv[] = {&loc->fl_addb_ctx, NULL};
-	struct m0_addb_mc  *mc   = &loc->fl_dom->fd_reqh->rh_addb_mc;
-
-	fop_rate_monitor = m0_fom_locality_lockers_get(loc,
-						       m0_fop_rate_monitor_key); 
+	struct m0_fom_locality     *loc = container_of(ast,
+						       struct m0_fom_locality,
+						       fl_post_stats_ast);
+	struct m0_fop_rate_monitor *fop_rate_monitor = m0_fop_rate_monitor(loc);
+	struct m0_addb_ctx         *cv[] = {&loc->fl_addb_ctx, NULL};
+	struct m0_addb_mc          *mc   = &loc->fl_dom->fd_reqh->rh_addb_mc;
 
 	if (m0_addb_counter_nr(&loc->fl_stat_run_times) > 0)
 		M0_ADDB_POST_CNTR(mc, cv, &loc->fl_stat_run_times);
@@ -1034,10 +1030,9 @@ void m0_fom_fini(struct m0_fom *fom)
 
 	M0_CNT_DEC(loc->fl_foms);
 
-	fop_rate_monitor = m0_fom_locality_lockers_get(loc,
-						       m0_fop_rate_monitor_key); 
+	fop_rate_monitor = m0_fop_rate_monitor(loc);
 	if (fop_rate_monitor != NULL)
-        	M0_CNT_INC(fop_rate_monitor->frm_fop_rate_count);
+		M0_CNT_INC(fop_rate_monitor->frm_fop_rate_count);
 	if (loc->fl_foms == 0)
 		m0_chan_signal_lock(&reqh->rh_sd_signal);
 }
diff --git a/fop/fom.h b/fop/fom.h
index ba90d07..e626df0 100644
--- a/fop/fom.h
+++ b/fop/fom.h
@@ -247,25 +247,25 @@ M0_LOCKERS_DECLARE(M0_EXTERN, m0_fom_locality, 16);
  * @see m0_locality_invaraint()
  */
 struct m0_fom_locality {
-	struct m0_fom_domain        *fl_dom;
+	struct m0_fom_domain          *fl_dom;
 
 	/** Run-queue */
-	struct m0_tl		     fl_runq;
-	size_t			     fl_runq_nr;
+	struct m0_tl		       fl_runq;
+	size_t			       fl_runq_nr;
 
 	/** Wait list */
-	struct m0_tl		     fl_wail;
-	size_t			     fl_wail_nr;
+	struct m0_tl		       fl_wail;
+	size_t			       fl_wail_nr;
 
 	/**
 	 * Total number of active foms in this locality. Equals the length of
 	 * runq plus the length of wail plus the number of M0_FOS_RUNNING foms
 	 * in all locality threads.
 	 */
-	unsigned                     fl_foms;
+	unsigned                       fl_foms;
 
 	/** State Machine (SM) group for AST call-backs */
-	struct m0_sm_group	     fl_group;
+	struct m0_sm_group	       fl_group;
 
 	/**
 	 *  Re-scheduling channel that the handler thread waits on for new work.
@@ -273,36 +273,36 @@ struct m0_fom_locality {
 	 *  @see http://www.tom-yam.or.jp/2238/src/slp.c.html#line2142 for
 	 *  the explanation of the name.
 	 */
-	struct m0_chan		     fl_runrun;
+	struct m0_chan		       fl_runrun;
 	/**
 	 * Set to true when the locality is finalised. This signals locality
 	 * threads to exit.
 	 */
-	bool                         fl_shutdown;
+	bool                           fl_shutdown;
 	/** Handler thread */
-	struct m0_loc_thread        *fl_handler;
+	struct m0_loc_thread          *fl_handler;
 	/** Idle threads */
-	struct m0_tl                 fl_threads;
-	struct m0_atomic64           fl_unblocking;
-	struct m0_chan               fl_idle;
+	struct m0_tl                   fl_threads;
+	struct m0_atomic64             fl_unblocking;
+	struct m0_chan                 fl_idle;
 
 	/** Resources allotted to the partition */
-	struct m0_bitmap	     fl_processors;
+	struct m0_bitmap	       fl_processors;
 
-	struct m0_addb_ctx           fl_addb_ctx;
+	struct m0_addb_ctx             fl_addb_ctx;
 	/**
 	   Accumulated run time of all foms. Is is updated from fom_exec()
 	   along with m0_fom::fo_exec_time.
 	 */
-	struct m0_addb_counter       fl_stat_run_times;
+	struct m0_addb_counter         fl_stat_run_times;
 	/**
 	   Accumulated scheduling overhead of all foms. It is updated from
 	   fom_dequeue() counting by m0_fom::fo_sched_epoch.
 	 */
-	struct m0_addb_counter       fl_stat_sched_wait_times;
+	struct m0_addb_counter         fl_stat_sched_wait_times;
 
 	/** AST which triggers the posting of statistics */
-	struct m0_sm_ast             fl_post_stats_ast;
+	struct m0_sm_ast               fl_post_stats_ast;
 
 	/** locker to store data pointers. */
 	struct m0_fom_locality_lockers fl_locker;
diff --git a/fop/fop_rate_monitor.c b/fop/fop_rate_monitor.c
index a09b5d3..9124812 100644
--- a/fop/fop_rate_monitor.c
+++ b/fop/fop_rate_monitor.c
@@ -18,25 +18,14 @@
  * Original creation date: 01/02/2014
  */
 
-#include "lib/misc.h"
 #include "lib/errno.h"
 #include "lib/assert.h"
 #include "lib/memory.h"
-#include "lib/locality.h"
-#include "lib/processor.h"
 #include "lib/time.h"
 #include "lib/timer.h"
-#include "lib/arith.h"
-#include "addb/addb.h"
-#include "mero/magic.h"
-#include "fop/fop.h"
 #define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_FOP
 #include "lib/trace.h"
-#include "fop/fom_long_lock.h"
-#include "reqh/reqh.h"
-#include "sm/sm.h"
 #include "fop/fop_addb.h"
-#include "rpc/rpc_machine.h"
 #include "addb/addb_monitor.h"
 #include "fop/fop_rate_monitor.h"
 
@@ -44,58 +33,63 @@
  * @addtogroup fom
  * @{
  */
-int m0_fop_rate_monitor_key = 0;
-static
-int fop_rate_monitor_timer_arm(struct m0_fop_rate_monitor *fop_rate_monitor);
+struct m0_reqh;
+
+int key = 0;
+static int
+fop_rate_monitor_timer_arm(struct m0_fop_rate_monitor *fop_rate_monitor);
 static void fop_rate_monitor_timer_rearm(struct m0_sm_group *grp,
-					 struct m0_sm_ast *ast);
+					 struct m0_sm_ast   *ast);
 static struct fop_rate_stats_sum_rec {
 	uint64_t ssr_fop_rate;
-} fop_rate_stats_sum;
+}fop_rate_stats_sum;
+
+M0_BASSERT((sizeof(fop_rate_stats_sum) / sizeof(uint64_t)) ==
+	   M0_FOP_RATE_MON_DATA_NR);
 
 static struct m0_addb_sum_rec *
-fop_rate_monitor_sum_rec(const struct m0_addb_monitor *mon,
-		         struct m0_reqh               *reqh)
+fop_rate_monitor_sum_rec(struct m0_addb_monitor *mon,
+		         struct m0_reqh         *reqh)
 {
 	struct m0_fop_rate_monitor *fop_rate_monitor;
 
 	M0_PRE(mon != NULL && reqh != NULL);
 	fop_rate_monitor = container_of(mon, struct m0_fop_rate_monitor,
 					frm_monitor);
-	return (struct m0_addb_sum_rec *)fop_rate_monitor->frm_sum_rec;
+	return &fop_rate_monitor->frm_sum_rec;
 }
 
-static void fop_rate_monitor_watch(const struct m0_addb_monitor *monitor,
-				   const struct m0_addb_rec     *rec,
-				   struct m0_reqh               *reqh)
+static void fop_rate_monitor_watch(struct m0_addb_monitor   *monitor,
+				   const struct m0_addb_rec *rec,
+				   struct m0_reqh           *reqh)
 {
-	struct m0_fop_rate_monitor    *fop_rate_monitor;
-	struct fop_rate_stats_sum_rec *f_rate;
 
 	M0_PRE(monitor != NULL && reqh != NULL);
 
 	if (m0_addb_rec_rid_make(M0_ADDB_BRT_CNTR,
 			         M0_ADDB_RECID_FOP_RATE_CNTR) == rec->ar_rid) {
+		struct m0_fop_rate_monitor    *fop_rate_monitor;
+		struct fop_rate_stats_sum_rec *f_rate;
+		struct m0_addb_sum_rec        *sum_rec;
 
 		fop_rate_monitor = container_of(monitor,
 						struct m0_fop_rate_monitor,
 						frm_monitor);
+		sum_rec = &fop_rate_monitor->frm_sum_rec;
 
-		m0_mutex_lock(&fop_rate_monitor->frm_sum_rec->asr_mutex);
-		M0_ASSERT(fop_rate_monitor->frm_sum_rec->asr_rec.ss_id ==
-			  M0_ADDB_RECID_FOP_RATE);
+		m0_mutex_lock(&sum_rec->asr_mutex);
+		M0_ASSERT(sum_rec->asr_rec.ss_id == M0_ADDB_RECID_FOP_RATE);
 		f_rate = (struct fop_rate_stats_sum_rec *)
-			 fop_rate_monitor->frm_sum_rec->asr_rec.ss_data.au64s_data;
+			 sum_rec->asr_rec.ss_data.au64s_data;
 		M0_ASSERT(f_rate != NULL);
 		/*
-		 * fop_rate is ADDB counter.
 		 * rec->ar_data.au64s_data[1] is number of samples
 		 * rec->ar_data.au64s_data[2] is sum_samples
 		 */
 		f_rate->ssr_fop_rate =
-		rec->ar_data.au64s_data[2] / rec->ar_data.au64s_data[1];
-		fop_rate_monitor->frm_sum_rec->asr_dirty = true;
-		m0_mutex_unlock(&fop_rate_monitor->frm_sum_rec->asr_mutex);
+			rec->ar_data.au64s_data[2] / rec->ar_data.au64s_data[1];
+		sum_rec->asr_dirty = true;
+		m0_mutex_unlock(&sum_rec->asr_mutex);
 	}
 }
 
@@ -108,30 +102,12 @@ M0_INTERNAL
 int m0_fop_rate_monitor_init(struct m0_fom_locality *loc)
 {
 	struct m0_fop_rate_monitor *fop_rate_monitor;
-	struct m0_addb_sum_rec     *sum_rec;
-	const size_t                fop_rate_stats_nr =
-				    sizeof(fop_rate_stats_sum) /
-				    sizeof(uint64_t);
-	uint64_t                   *md;
 	int                         result;
 
 	FOP_ALLOC_PTR(fop_rate_monitor, FOM_RATE_MON_INIT, &m0_fop_addb_ctx);
 	if (fop_rate_monitor == NULL)
 		M0_RETURN(-ENOMEM);
 
-	FOP_ALLOC_PTR(sum_rec, FOM_RATE_MON_INIT, &m0_fop_addb_ctx);
-	if (sum_rec == NULL) {
-		result = -ENOMEM;
-		goto err3;
-	}
-
-	FOP_ALLOC_ARR(md, fop_rate_stats_nr, FOM_RATE_MON_INIT,
-		      &m0_fop_addb_ctx);
-	if (md == NULL) {
-		result = -ENOMEM;
-		goto err2;
-	}
-
 	result = m0_addb_counter_init(&fop_rate_monitor->frm_stat_fop_rate,
 				      &m0_addb_rt_fop_rate_cntr);
 	if (result != 0)
@@ -144,14 +120,13 @@ int m0_fop_rate_monitor_init(struct m0_fom_locality *loc)
 	m0_addb_monitor_init(&fop_rate_monitor->frm_monitor,
 			     &fop_rate_monitor_ops);
 
-	m0_addb_monitor_sum_rec_init(sum_rec, &m0_addb_rt_fop_rate, md,
-				     fop_rate_stats_nr);
-	fop_rate_monitor->frm_sum_rec = sum_rec;
+	m0_addb_monitor_sum_rec_init(&fop_rate_monitor->frm_sum_rec,
+				     &m0_addb_rt_fop_rate,
+				     fop_rate_monitor->frm_md,
+				     M0_FOP_RATE_MON_DATA_NR);
 	fop_rate_monitor->frm_loc = loc;
 
-	m0_fom_locality_lockers_set(loc, m0_fop_rate_monitor_key,
-				    fop_rate_monitor);
-
+	m0_fom_locality_lockers_set(loc, key, fop_rate_monitor);
 	m0_addb_monitor_add(loc->fl_dom->fd_reqh,
 			    &fop_rate_monitor->frm_monitor);
 	return 0;
@@ -159,10 +134,6 @@ int m0_fop_rate_monitor_init(struct m0_fom_locality *loc)
 err0:
 	m0_addb_counter_fini(&fop_rate_monitor->frm_stat_fop_rate);
 err1:
-	m0_free(md);
-err2:
-	m0_free(sum_rec);
-err3:
 	m0_free(fop_rate_monitor);
 	M0_RETURN(result);
 }
@@ -170,11 +141,9 @@ err3:
 M0_INTERNAL
 void m0_fop_rate_monitor_fini(struct m0_fom_locality *loc)
 {
-	struct m0_fop_rate_monitor *fop_rate_monitor;
+	struct m0_fop_rate_monitor *fop_rate_monitor = m0_fop_rate_monitor(loc);
 
-	fop_rate_monitor = m0_fom_locality_lockers_get(loc,
-						       m0_fop_rate_monitor_key);
-	m0_fom_locality_lockers_clear(loc, m0_fop_rate_monitor_key);
+	m0_fom_locality_lockers_clear(loc, key);
 	m0_addb_monitor_del(loc->fl_dom->fd_reqh,
 			    &fop_rate_monitor->frm_monitor);
 	m0_addb_monitor_fini(&fop_rate_monitor->frm_monitor);
@@ -182,9 +151,7 @@ void m0_fop_rate_monitor_fini(struct m0_fom_locality *loc)
 	m0_timer_stop(&fop_rate_monitor->frm_fop_rate_timer);
 	m0_timer_fini(&fop_rate_monitor->frm_fop_rate_timer);
 
-	m0_addb_monitor_sum_rec_fini(fop_rate_monitor->frm_sum_rec);
-	m0_free(fop_rate_monitor->frm_sum_rec->asr_rec.ss_data.au64s_data);
-	m0_free(fop_rate_monitor->frm_sum_rec);
+	m0_addb_monitor_sum_rec_fini(&fop_rate_monitor->frm_sum_rec);
 	m0_free(fop_rate_monitor);
 }
 
@@ -204,8 +171,8 @@ static unsigned long fop_rate_monitor_timer_callback(unsigned long arg)
 	return 0;
 }
 
-static
-int fop_rate_monitor_timer_arm(struct m0_fop_rate_monitor *fop_rate_monitor)
+static int
+fop_rate_monitor_timer_arm(struct m0_fop_rate_monitor *fop_rate_monitor)
 {
 	int              result;
 	m0_time_t        expire;
@@ -224,28 +191,31 @@ int fop_rate_monitor_timer_arm(struct m0_fop_rate_monitor *fop_rate_monitor)
 }
 
 static void fop_rate_monitor_timer_rearm(struct m0_sm_group *grp,
-					 struct m0_sm_ast *ast)
+					 struct m0_sm_ast   *ast)
 {
-	struct m0_fom_locality *loc = container_of(ast, struct m0_fom_locality,
-						   fl_post_stats_ast);
-	int                     result;
-	struct m0_fop_rate_monitor *fop_rate_monitor;
-
-	M0_PRE(m0_locality_invariant(loc));
-
-	fop_rate_monitor = m0_fom_locality_lockers_get(loc,
-						       m0_fop_rate_monitor_key);
+	int                         result = 0;
+	struct m0_fom_locality     *loc = container_of(ast,
+						       struct m0_fom_locality,
+						       fl_post_stats_ast);
+	struct m0_fop_rate_monitor *fop_rate_monitor = m0_fop_rate_monitor(loc);
 
 	if (fop_rate_monitor != NULL) {
 		m0_timer_stop(&fop_rate_monitor->frm_fop_rate_timer);
 		m0_timer_fini(&fop_rate_monitor->frm_fop_rate_timer);
 
 		result = fop_rate_monitor_timer_arm(fop_rate_monitor);
-		if (result != 0)
-			M0_LOG(M0_WARN, "Failed to re-arm fop_rate timer.");
-	} else {
-			M0_LOG(M0_WARN, "Failed to re-arm fop_rate timer.");
 	}
+
+	if (fop_rate_monitor == NULL || result != 0)
+		M0_LOG(M0_WARN, "Failed to re-arm fop_rate timer.");
+}
+
+M0_INTERNAL
+struct m0_fop_rate_monitor *m0_fop_rate_monitor(struct m0_fom_locality *loc)
+{
+	M0_PRE(m0_locality_invariant(loc));
+
+	return m0_fom_locality_lockers_get(loc, key);
 }
 
 /** @} endgroup fom */
diff --git a/fop/fop_rate_monitor.h b/fop/fop_rate_monitor.h
index 89c05f4..9b0abad 100644
--- a/fop/fop_rate_monitor.h
+++ b/fop/fop_rate_monitor.h
@@ -32,6 +32,7 @@
 
 enum {
 	M0_FOP_RATE_INTERVAL_SECOND = 1,
+	M0_FOP_RATE_MON_DATA_NR = 1
 };
 
 /**
@@ -40,7 +41,9 @@ enum {
 struct m0_fop_rate_monitor {
 	uint64_t                frm_magic;
 	uint64_t                frm_fop_rate_count;
-	struct m0_addb_sum_rec *frm_sum_rec;
+	/** Fop rate monitor data. */
+	uint64_t                frm_md[M0_FOP_RATE_MON_DATA_NR];
+	struct m0_addb_sum_rec  frm_sum_rec;
 	struct m0_fom_locality *frm_loc;
 	/** Timer to calculate fop_rate */
 	struct m0_timer	        frm_fop_rate_timer;
@@ -66,6 +69,14 @@ int m0_fop_rate_monitor_init(struct m0_fom_locality *loc);
 M0_INTERNAL
 void m0_fop_rate_monitor_fini(struct m0_fom_locality *loc);
 
+/**
+ * It returns instance of fop_rate_monitor for locality "loc".
+ * @param loc pointer to fom locality.
+ * @retval ptr to fop_rate_monitor.
+ */
+M0_INTERNAL
+struct m0_fop_rate_monitor *m0_fop_rate_monitor(struct m0_fom_locality *loc);
+
 /** @} end of fop group */
 
 /* __MERO_FOP_FOP_RATE_MONITOR_H__ */
diff --git a/m0t1fs/linux_kernel/m0t1fs.c b/m0t1fs/linux_kernel/m0t1fs.c
index 5148b76..e2438a2 100644
--- a/m0t1fs/linux_kernel/m0t1fs.c
+++ b/m0t1fs/linux_kernel/m0t1fs.c
@@ -149,4 +149,284 @@ M0_INTERNAL void m0t1fs_fini(void)
 
 	M0_LEAVE();
 }
-#undef M0_TRACE_SUBSYSTEM
+
+static int m0t1fs_net_init(void)
+{
+	struct m0_net_xprt   *xprt;
+	struct m0_net_domain *ndom;
+	int		      rc;
+
+	M0_ENTRY();
+
+	xprt =  m0t1fs_globals.g_xprt;
+	ndom = &m0t1fs_globals.g_ndom;
+
+	rc = m0_net_xprt_init(xprt);
+	if (rc != 0)
+		goto out;
+
+	/** @todo replace &m0_addb_proc_ctx */
+	rc = m0_net_domain_init(ndom, xprt, &m0_addb_proc_ctx);
+	if (rc != 0)
+		m0_net_xprt_fini(xprt);
+out:
+	M0_LEAVE("rc: %d", rc);
+	return rc;
+}
+
+static void m0t1fs_net_fini(void)
+{
+	M0_ENTRY();
+
+	m0_net_domain_fini(&m0t1fs_globals.g_ndom);
+	m0_net_xprt_fini(m0t1fs_globals.g_xprt);
+
+	M0_LEAVE();
+}
+
+static int m0t1fs_rpc_init(void)
+{
+	struct m0_dbenv           *dbenv       = &m0t1fs_globals.g_dbenv;
+	char                      *db_name     =  m0t1fs_globals.g_db_name;
+	struct m0_rpc_machine     *rpc_machine = &m0t1fs_globals.g_rpc_machine;
+	struct m0_reqh            *reqh        = &m0t1fs_globals.g_reqh;
+	struct m0_net_domain      *ndom        = &m0t1fs_globals.g_ndom;
+	const char                *laddr       =  m0t1fs_globals.g_laddr;
+	struct m0_net_buffer_pool *buffer_pool = &m0t1fs_globals.g_buffer_pool;
+	struct m0_fol             *fol         = &m0t1fs_globals.g_fol;
+	struct m0_net_transfer_mc *tm;
+	int                        rc;
+	uint32_t		   bufs_nr;
+	uint32_t		   tms_nr;
+
+	M0_ENTRY();
+
+	tms_nr	 = 1;
+	bufs_nr  = m0_rpc_bufs_nr(tm_recv_queue_min_len, tms_nr);
+
+	rc = m0_rpc_net_buffer_pool_setup(ndom, buffer_pool,
+					  bufs_nr, tms_nr);
+	if (rc != 0)
+		goto pool_fini;
+
+	rc = m0_dbenv_init(dbenv, db_name, 0);
+	if (rc != 0)
+		goto pool_fini;
+
+	rc = M0_REQH_INIT(reqh,
+			  .rhia_dtm          = (void*)1,
+			  .rhia_db           = NULL,
+			  .rhia_mdstore      = (void*)1,
+			  .rhia_fol          = fol,
+			  .rhia_svc          = (void*)1);
+	if (rc != 0)
+		goto dbenv_fini;
+	rc = m0_rpc_machine_init(rpc_machine, ndom, laddr, reqh,
+				 buffer_pool, M0_BUFFER_ANY_COLOUR,
+				 max_rpc_msg_size, tm_recv_queue_min_len);
+	if (rc != 0)
+		goto reqh_fini;
+
+	m0_reqh_start(reqh);
+	tm = &rpc_machine->rm_tm;
+	M0_ASSERT(tm->ntm_recv_pool == buffer_pool);
+
+	m0_reqh_rpc_mach_tlink_init_at_tail(rpc_machine,
+					    &reqh->rh_rpc_machines);
+
+	/* Start resource manager service */
+	rc = m0t1fs_reqh_services_start();
+	if (rc != 0)
+		goto reqh_fini;
+	M0_RETURN(0);
+
+reqh_fini:
+	m0_reqh_fini(reqh);
+dbenv_fini:
+	m0_dbenv_fini(dbenv);
+pool_fini:
+	m0_rpc_net_buffer_pool_cleanup(buffer_pool);
+	M0_LEAVE("rc: %d", rc);
+	M0_ASSERT(rc != 0);
+	return rc;
+}
+
+static void m0t1fs_mon_rw_io_watch(struct m0_addb_monitor   *mon,
+				   const struct m0_addb_rec *rec,
+				   struct m0_reqh           *reqh)
+{
+	struct m0_addb_sum_rec                  *sum_rec;
+	struct m0t1fs_addb_mon_sum_data_io_size *sum_data =
+				&m0t1fs_globals.g_addb_mon_sum_data_rw_io_size;
+
+	if (m0_addb_rec_rid_make(M0_ADDB_BRT_DP, M0T1FS_ADDB_RECID_IO_FINISH)
+	    == rec->ar_rid) {
+		sum_rec = mon->am_ops->amo_sum_rec(mon, reqh);
+		M0_ASSERT(sum_rec != NULL);
+
+		m0_mutex_lock(&sum_rec->asr_mutex);
+		if (rec->ar_data.au64s_data[0] == IRT_READ) {
+			sum_data->sd_rio += rec->ar_data.au64s_data[1];
+			sum_rec->asr_dirty = true;
+		} else if (rec->ar_data.au64s_data[0] == IRT_WRITE) {
+			sum_data->sd_wio += rec->ar_data.au64s_data[1];
+			sum_rec->asr_dirty = true;
+		}
+		else
+			M0_IMPOSSIBLE("Invalid IO state");
+		m0_mutex_unlock(&sum_rec->asr_mutex);
+
+	}
+}
+
+static struct m0_addb_sum_rec *
+m0t1fs_mon_rw_io_sum_rec(struct m0_addb_monitor *mon,
+		         struct m0_reqh         *reqh)
+{
+	struct m0_addb_sum_rec *sum_rec;
+
+	m0_rwlock_read_lock(&reqh->rh_rwlock);
+	sum_rec = m0_reqh_lockers_get(reqh,
+			m0t1fs_globals.g_addb_mon_rw_io_size_key);
+	m0_rwlock_read_unlock(&reqh->rh_rwlock);
+
+	return sum_rec;
+}
+
+const struct m0_addb_monitor_ops m0t1fs_addb_mon_rw_io_ops = {
+	.amo_watch   = m0t1fs_mon_rw_io_watch,
+	.amo_sum_rec = m0t1fs_mon_rw_io_sum_rec
+};
+
+static int m0t1fs_addb_mon_total_io_size_init(void)
+{
+	struct m0_addb_sum_rec *sum_rec;
+	struct m0_reqh         *reqh = &m0t1fs_globals.g_reqh;
+	uint32_t               *key = &m0t1fs_globals.g_addb_mon_rw_io_size_key;
+	uint64_t               *sum_data =
+		     (uint64_t *)&m0t1fs_globals.g_addb_mon_sum_data_rw_io_size;
+	uint32_t                sum_rec_nr =
+		     sizeof (m0t1fs_globals.g_addb_mon_sum_data_rw_io_size) /
+					     sizeof (uint64_t);
+	M0_ALLOC_PTR(sum_rec);
+	if (sum_rec == NULL)
+		M0_RETURN(-ENOMEM);
+
+	m0_addb_monitor_init(&m0t1fs_globals.g_addb_mon_rw_io_size,
+			     &m0t1fs_addb_mon_rw_io_ops);
+
+	m0_addb_monitor_sum_rec_init(sum_rec, &m0_addb_rt_m0t1fs_mon_io_size,
+				     sum_data, sum_rec_nr);
+
+	*key = m0_reqh_lockers_allot();
+
+	m0_rwlock_write_lock(&reqh->rh_rwlock);
+	m0_reqh_lockers_set(reqh, *key, sum_rec);
+	m0_rwlock_write_unlock(&reqh->rh_rwlock);
+
+	m0_addb_monitor_add(reqh, &m0t1fs_globals.g_addb_mon_rw_io_size);
+
+	return 0;
+}
+
+static void m0t1fs_addb_mon_total_io_size_fini(void)
+{
+	struct m0_addb_sum_rec *sum_rec;
+	struct m0_addb_monitor *mon = &m0t1fs_globals.g_addb_mon_rw_io_size;
+	struct m0_reqh         *reqh = &m0t1fs_globals.g_reqh;
+
+	sum_rec = mon->am_ops->amo_sum_rec(mon, &m0t1fs_globals.g_reqh);
+
+	m0_addb_monitor_del(reqh, mon);
+
+	m0_rwlock_write_lock(&reqh->rh_rwlock);
+	m0_reqh_lockers_clear(reqh, m0t1fs_globals.g_addb_mon_rw_io_size_key);
+	m0_rwlock_write_unlock(&reqh->rh_rwlock);
+	m0_addb_monitor_sum_rec_fini(sum_rec);
+	m0_free(sum_rec);
+	m0_addb_monitor_fini(mon);
+}
+
+static void m0t1fs_rpc_fini(void)
+{
+	M0_ENTRY();
+
+	m0t1fs_reqh_services_stop();
+	m0_reqh_rpc_mach_tlink_del_fini(&m0t1fs_globals.g_rpc_machine);
+	m0_rpc_machine_fini(&m0t1fs_globals.g_rpc_machine);
+	m0_reqh_fini(&m0t1fs_globals.g_reqh);
+	m0_dbenv_fini(&m0t1fs_globals.g_dbenv);
+	m0_rpc_net_buffer_pool_cleanup(&m0t1fs_globals.g_buffer_pool);
+
+	M0_LEAVE();
+}
+
+static int m0t1fs_layout_init(void)
+{
+	int rc;
+
+	M0_ENTRY();
+
+	rc = m0_layout_domain_init(&m0t1fs_globals.g_layout_dom,
+				   &m0t1fs_globals.g_dbenv);
+	if (rc == 0) {
+		rc = m0_layout_standard_types_register(
+						&m0t1fs_globals.g_layout_dom);
+		if (rc != 0)
+			m0_layout_domain_fini(&m0t1fs_globals.g_layout_dom);
+	}
+
+	M0_RETURN(rc);
+}
+
+static void m0t1fs_layout_fini(void)
+{
+	M0_ENTRY();
+
+	m0_layout_standard_types_unregister(&m0t1fs_globals.g_layout_dom);
+	m0_layout_domain_fini(&m0t1fs_globals.g_layout_dom);
+
+	M0_LEAVE();
+}
+
+static int m0t1fs_service_start(const char *sname)
+{
+	int                          rc;
+	struct m0_reqh              *reqh = &m0t1fs_globals.g_reqh;
+	struct m0_reqh_service_type *stype;
+	struct m0_reqh_service      *service;
+	struct m0_uint128            uuid;
+
+	stype = m0_reqh_service_type_find(sname);
+	if (stype == NULL)
+		M0_RETURN(-EINVAL);
+	rc = m0_reqh_service_allocate(&service, stype, NULL);
+	if (rc != 0)
+		M0_RETURN(rc);
+	m0_uuid_generate(&uuid);
+	m0_reqh_service_init(service, reqh, &uuid);
+	rc = m0_reqh_service_start(service);
+
+	M0_RETURN(rc);
+}
+
+static int m0t1fs_reqh_services_start(void)
+{
+	int rc;
+
+	rc = m0t1fs_service_start(M0_ADDB_SVC_NAME);
+	if (rc)
+		goto err;
+	rc = m0t1fs_service_start("rmservice");
+	if (rc)
+		goto err;
+	M0_RETURN(rc);
+err:
+	m0t1fs_reqh_services_stop();
+	M0_RETURN(rc);
+}
+
+static void m0t1fs_reqh_services_stop(void)
+{
+	m0_reqh_services_terminate(&m0t1fs_globals.g_reqh);
+}
-- 
1.8.3.2

