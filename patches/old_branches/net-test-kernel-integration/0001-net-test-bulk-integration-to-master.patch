From 49f1ad9cf022e2b1b36b0ab0a1ec73e1ed411bec Mon Sep 17 00:00:00 2001
From: Maxim Medved <Max_Medved@xyratex.com>
Date: Thu, 24 Jan 2013 13:50:21 +0200
Subject: [PATCH] net-test-bulk integration to master

---
 build_kernel_modules/Makefile.in |   13 +-
 configure.ac                     |    1 +
 desim/sim.h                      |    2 +-
 fop/fom_generic.h                |    2 +-
 lib/assert.c                     |    2 +-
 lib/timer.h                      |    4 +-
 lib/user_space/ugetopts.c        |    2 +-
 mero/magic.h                     |   39 +
 net/net.h                        |    1 -
 net/test/commands.c              |   57 +-
 net/test/commands.h              |   62 +-
 net/test/console.c               |  103 ++-
 net/test/console.h               |   43 +-
 net/test/initfini.c              |   97 +++
 net/test/initfini.h              |   57 ++
 net/test/linux_kernel/node_k.c   |    2 +-
 net/test/network.c               |  392 +++++-----
 net/test/network.h               |  109 +--
 net/test/node.c                  |  313 ++++++--
 net/test/node.h                  |   65 ++
 net/test/node_bulk.c             | 1524 +++++++++++++++++++++++++++++++++++++-
 net/test/node_bulk.h             |    3 +
 net/test/node_helper.c           |  169 +++++
 net/test/node_helper.h           |  152 ++++
 net/test/node_ping.c             |  242 +++---
 net/test/ringbuf.c               |    7 +
 net/test/ringbuf.h               |    9 +-
 net/test/serialize.c             |   17 +-
 net/test/serialize.h             |   19 +-
 net/test/service.c               |    4 +-
 net/test/service.h               |    2 +-
 net/test/slist.c                 |   43 +-
 net/test/st/.gitignore           |    1 +
 net/test/st/run-1x1.sh           |   89 +++
 net/test/st/st-bulk.sh           |   16 +
 net/test/st/st-config.sh.in      |   24 +
 net/test/st/st-ping.sh           |   12 +
 net/test/st/st.sh                |   10 +
 net/test/stats.c                 |   29 +-
 net/test/stats.h                 |   11 +-
 net/test/str.c                   |   22 +-
 net/test/str.h                   |    5 -
 net/test/user_space/console_u.c  |  343 ++++++---
 net/test/user_space/node_u.c     |   10 +-
 net/test/ut/client_server.c      |  155 ++--
 net/test/ut/commands.c           |   17 +-
 net/test/ut/main.c               |   30 +-
 net/test/ut/network.c            |  105 +--
 net/test/ut/ringbuf.c            |   15 +-
 net/test/ut/stats.c              |    2 +
 utils/linux_kernel/main.c        |    2 +
 51 files changed, 3606 insertions(+), 849 deletions(-)
 create mode 100644 net/test/initfini.c
 create mode 100644 net/test/initfini.h
 create mode 100644 net/test/node_helper.c
 create mode 100644 net/test/node_helper.h
 create mode 100644 net/test/st/.gitignore
 create mode 100644 net/test/st/run-1x1.sh
 create mode 100644 net/test/st/st-bulk.sh
 create mode 100644 net/test/st/st-config.sh.in
 create mode 100644 net/test/st/st-ping.sh
 create mode 100644 net/test/st/st.sh

diff --git a/build_kernel_modules/Makefile.in b/build_kernel_modules/Makefile.in
index 815fdb6..ae933af 100644
--- a/build_kernel_modules/Makefile.in
+++ b/build_kernel_modules/Makefile.in
@@ -153,12 +153,13 @@ net_lnet_SOURCES                := lnet_addb.c
 
 net_lnet_ut_SOURCES             := lnet_ut.c
 
-net_test_SOURCES                := commands.c console.c network.c node_bulk.c \
-                                   node.c node_ping.c ringbuf.c serialize.c   \
-                                   service.c slist.c stats.c str.c
-net_test_HEADERS                := commands.h console.h network.h node_bulk.h \
-                                   node.h node_ping.h ringbuf.h serialize.h   \
-                                   service.h slist.h stats.h str.h
+net_test_SOURCES		:= commands.c console.c initfini.c network.c  \
+				   node_bulk.c node_helper.c node_ping.c      \
+				   node.c ringbuf.c serialize.c service.c     \
+				   slist.c stats.c str.c
+net_test_HEADERS		:= commands.h console.h initfini.h network.h  \
+				   node_bulk.h node_helper.h node_ping.h      \
+				   node.h ringbuf.h serialize.h service.h     \
 
 net_test_ut_SOURCES             := client_server.c commands.c main.c          \
                                    network.c ringbuf.c serialize.c service.c  \
diff --git a/configure.ac b/configure.ac
index 9b9a521..ac4d524 100644
--- a/configure.ac
+++ b/configure.ac
@@ -545,6 +545,7 @@ AC_CONFIG_FILES([m0t1fs/linux_kernel/st/common.sh],
 AC_CONFIG_FILES([net/test/m0netperf.sh], [chmod + net/test/m0netperf.sh])
 AC_CONFIG_FILES([net/test/m0netperfd.sh], [chmod + net/test/m0netperfd.sh])
 AC_CONFIG_FILES([net/test/test-user.sh], [chmod + net/test/test-user.sh])
+AC_CONFIG_FILES([net/test/st/st-config.sh], [chmod + net/test/st/st-config.sh])
 AC_CONFIG_FILES([utils/ut.sh], [chmod +x utils/ut.sh])
 AC_CONFIG_FILES([utils/linux_kernel/ut.sh], [chmod +x utils/linux_kernel/ut.sh])
 
diff --git a/desim/sim.h b/desim/sim.h
index b0bf82b..88aa75a 100644
--- a/desim/sim.h
+++ b/desim/sim.h
@@ -21,7 +21,7 @@
  */
 
 /**
-   @defgroup desim Discreet Event Simulator
+   @defgroup desim Discrete Event Simulator
 
    <b>Concepts</b>
 
diff --git a/fop/fom_generic.h b/fop/fom_generic.h
index dac298a..a88df90 100644
--- a/fop/fom_generic.h
+++ b/fop/fom_generic.h
@@ -58,7 +58,7 @@ enum m0_fom_standard_phase {
 	M0_FOPH_AUTHORISATION_WAIT, /*< waiting for userdb cache miss. */
 	M0_FOPH_TXN_CONTEXT,        /*< creating local transactional context. */
 	M0_FOPH_TXN_CONTEXT_WAIT,   /*< waiting for log space. */
-	M0_FOPH_SUCCESS,            /*< fom execution completed succesfully. */
+	M0_FOPH_SUCCESS,            /*< fom execution completed successfully. */
 	M0_FOPH_FOL_REC_ADD,        /*< add a FOL transaction record. */
 	M0_FOPH_TXN_COMMIT,         /*< commit local transaction context. */
 	M0_FOPH_TXN_COMMIT_WAIT,    /*< waiting to commit local transaction
diff --git a/lib/assert.c b/lib/assert.c
index 3c06f3e..5fc32c3 100644
--- a/lib/assert.c
+++ b/lib/assert.c
@@ -67,7 +67,7 @@ void m0_panic(const char *expr, const char *func, const char *file, int lineno)
 		backtrace_symbols_fd(trace, nr, 2);
 	}
 #endif
-	M0_LOG(M0_FATAL, "panic: %s %s() (%s:%i)", expr, func, file, lineno);
+	M0_LOG(M0_FATAL, "panic: %s at %s() (%s:%i)", expr, func, file, lineno);
 	if (m0_debugger_args[0] != NULL) {
 		int rc;
 
diff --git a/lib/timer.h b/lib/timer.h
index 40561c9..b895f3b 100644
--- a/lib/timer.h
+++ b/lib/timer.h
@@ -147,7 +147,7 @@ M0_INTERNAL bool m0_timer_is_started(const struct m0_timer *timer);
 /**
    Destroy the timer.
 
-   @pre m0_timer_init() for this timer was succesfully called.
+   @pre m0_timer_init() for this timer was successfully called.
    @pre timer is not running.
  */
 M0_INTERNAL int m0_timer_fini(struct m0_timer *timer);
@@ -160,7 +160,7 @@ M0_INTERNAL void m0_timer_locality_init(struct m0_timer_locality *loc);
 /**
    Fini timer locality.
 
-   @pre m0_timer_locality_init() succesfully called.
+   @pre m0_timer_locality_init() successfully called.
    @pre locality is empty
  */
 M0_INTERNAL void m0_timer_locality_fini(struct m0_timer_locality *loc);
diff --git a/lib/user_space/ugetopts.c b/lib/user_space/ugetopts.c
index 106e1ac..b27fc88 100644
--- a/lib/user_space/ugetopts.c
+++ b/lib/user_space/ugetopts.c
@@ -60,7 +60,7 @@ static void usage(const char *progname,
 			o->go_type == GOT_HELP ? "" :
 			o->go_type == GOT_FLAG ? "" :
 			o->go_type == GOT_FORMAT ? o->go_u.got_fmt.f_string :
-			o->go_type == GOT_SCALED ? "number of bytes" :
+			o->go_type == GOT_SCALED ? "scaled" :
 			o->go_type == GOT_NUMBER ? "number" : "string",
 			o->go_desc);
 	}
diff --git a/mero/magic.h b/mero/magic.h
index fabb77d..6c07b27 100644
--- a/mero/magic.h
+++ b/mero/magic.h
@@ -422,6 +422,45 @@ enum m0_magic_satchel {
 	/* nlx_xo_ep::xe_magic (failed fiasco) */
 	M0_NET_LNET_XE_MAGIC = 0x33fa11edf1a5c077,
 
+	/* bsb_tl::tl_head_magic (collides lail) */
+	M0_NET_TEST_BSB_HEAD_MAGIC = 0x33c0111de51a1177,
+
+	/* buf_status_bulk::bsb_magic (colloidal dal) */
+	M0_NET_TEST_BSB_MAGIC = 0x33c01101da1da177,
+
+	/* bsp_tl::tl_head_magic (delocalize so) */
+	M0_NET_TEST_BSP_HEAD_MAGIC = 0x33de10ca112e5077,
+
+	/* buf_status_ping::bsp_magic (lossless bafo) */
+	M0_NET_TEST_BSP_MAGIC = 0x3310551e55baf077,
+
+	/* buf_state_tl::tl_head_magic (official oecd) */
+	M0_NET_TEST_BS_HEAD_MAGIC = 0x330ff1c1a10ecd77,
+
+	/* buf_state::bs_link_magic (decibel aedes) */
+	M0_NET_TEST_BS_LINK_MAGIC = 0x33dec1be1aede577,
+
+	/* net_test_network_bds_header::ntnbh_magic (boldfaces esd) */
+	M0_NET_TEST_NETWORK_BDS_MAGIC = 0x33b01dface5e5d77,
+
+	/* net_test_network_bd::ntnbd_magic (socialized io) */
+	M0_NET_TEST_NETWORK_BD_MAGIC = 0x3350c1a112ed1077,
+
+	/* slist_params::sp_magic (sodaless adze) */
+	M0_NET_TEST_SLIST_MAGIC = 0x3350da1e55ad2e77,
+
+	/* ssb_tl::tl_head_magic (coloss caball) */
+	M0_NET_TEST_SSB_HEAD_MAGIC = 0x33c01055caba1177,
+
+	/* server_status_bulk::ssb_magic (closes doddie) */
+	M0_NET_TEST_SSB_MAGIC = 0x33c105e5d0dd1e77,
+
+	/* net_test_str_len::ntsl_magic (boldfaced sao) */
+	M0_NET_TEST_STR_MAGIC = 0x33b01dfaced5a077,
+
+	/* m0_net_test_timestamp::ntt_magic (allied cabiai) */
+	M0_NET_TEST_TIMESTAMP_MAGIC = 0x33a111edcab1a177,
+
 /* Request handler */
 	/* m0_reqh_service::rs_magix (bacilli babel) */
 	M0_REQH_SVC_MAGIC = 0x33bac1111babe177,
diff --git a/net/net.h b/net/net.h
index 7f5e4c7..e317343 100644
--- a/net/net.h
+++ b/net/net.h
@@ -987,7 +987,6 @@ struct m0_net_transfer_mc {
 
    All fields in the structure other then the above will be set to their
    appropriate initial values.
-   @note An initialized TM cannot be fini'd without first starting it.
    @param dom     Network domain pointer.
    @param addb_mc Pointer to the ADDB machine to use with this transfer machine
    for non-exception related posts.  The global ADDB machine, ::m0_addb_gmc,
diff --git a/net/test/commands.c b/net/test/commands.c
index ed94710..9ced63b 100644
--- a/net/test/commands.c
+++ b/net/test/commands.c
@@ -18,12 +18,12 @@
  * Original creation date: 05/05/2012
  */
 
-/* @todo remove */
+/** @todo remove */
 #ifndef __KERNEL__
 #include <stdio.h>		/* printf */
 #endif
 
-/* @todo debug only, remove it */
+/** @todo debug only, remove it */
 #ifndef __KERNEL__
 /*
 #define LOGD(format, ...) printf(format, ##__VA_ARGS__)
@@ -70,8 +70,12 @@ TYPE_DESCR(m0_net_test_cmd_init) = {
 	FIELD_DESCR(struct m0_net_test_cmd_init, ntci_type),
 	FIELD_DESCR(struct m0_net_test_cmd_init, ntci_msg_nr),
 	FIELD_DESCR(struct m0_net_test_cmd_init, ntci_msg_size),
-	FIELD_DESCR(struct m0_net_test_cmd_init, ntci_concurrency),
+	FIELD_DESCR(struct m0_net_test_cmd_init, ntci_bd_buf_nr),
+	FIELD_DESCR(struct m0_net_test_cmd_init, ntci_bd_buf_size),
+	FIELD_DESCR(struct m0_net_test_cmd_init, ntci_bd_nr_max),
+	FIELD_DESCR(struct m0_net_test_cmd_init, ntci_msg_concurrency),
 	FIELD_DESCR(struct m0_net_test_cmd_init, ntci_buf_send_timeout),
+	FIELD_DESCR(struct m0_net_test_cmd_init, ntci_buf_bulk_timeout),
 };
 
 /* m0_net_test_msg_nr_descr */
@@ -101,6 +105,9 @@ cmd_status_data_serialize(enum m0_net_test_serialize_op op,
 	const struct m0_net_test_msg_nr *msg_nr[] = {
 			&sd->ntcsd_msg_nr_send,
 			&sd->ntcsd_msg_nr_recv,
+			&sd->ntcsd_bulk_nr_send,
+			&sd->ntcsd_bulk_nr_recv,
+			&sd->ntcsd_transfers,
 	};
 	const struct m0_net_test_stats  *stats[] = {
 			&sd->ntcsd_mps_send.ntmps_stats,
@@ -113,22 +120,23 @@ cmd_status_data_serialize(enum m0_net_test_serialize_op op,
 	if (op == M0_NET_TEST_DESERIALIZE)
 		M0_SET0(sd);
 
-	len_total = len = m0_net_test_serialize(op, sd,
-			  USE_TYPE_DESCR(m0_net_test_cmd_status_data),
-			  bv, offset);
+	len = m0_net_test_serialize(op, sd,
+				    USE_TYPE_DESCR(m0_net_test_cmd_status_data),
+				    bv, offset);
+	len_total = net_test_len_accumulate(0, len);
 
-	for (i = 0; i < ARRAY_SIZE(msg_nr) && len != 0; ++i) {
+	for (i = 0; i < ARRAY_SIZE(msg_nr) && len_total != 0; ++i) {
 		len = m0_net_test_serialize(op, (void *) msg_nr[i],
 					    USE_TYPE_DESCR(m0_net_test_msg_nr),
 					    bv, offset + len_total);
-		len_total += len;
+		len_total = net_test_len_accumulate(len_total, len);
 	}
-	for (i = 0; i < ARRAY_SIZE(stats) && len != 0; ++i) {
+	for (i = 0; i < ARRAY_SIZE(stats) && len_total != 0; ++i) {
 		len = m0_net_test_stats_serialize(op, (void *) stats[i], bv,
 						  offset + len_total);
-		len_total += len;
+		len_total = net_test_len_accumulate(len_total, len);
 	}
-	return len == 0 ? 0 : len_total;
+	return len_total;
 }
 
 /**
@@ -151,10 +159,11 @@ static int cmd_serialize(enum m0_net_test_serialize_op op,
 	m0_bcount_t	  len_total;
 
 	M0_PRE(cmd != NULL);
-	len = len_total = m0_net_test_serialize(op, cmd,
-				  USE_TYPE_DESCR(m0_net_test_cmd), bv, offset);
-	if (len_total == 0)
+	len = m0_net_test_serialize(op, cmd, USE_TYPE_DESCR(m0_net_test_cmd),
+				    bv, offset);
+	if (len == 0)
 		return -EINVAL;
+	len_total = net_test_len_accumulate(0, len);
 
 	switch (cmd->ntc_type) {
 	case M0_NET_TEST_CMD_INIT:
@@ -163,13 +172,13 @@ static int cmd_serialize(enum m0_net_test_serialize_op op,
 					bv, offset + len_total);
 		if (len == 0)
 			break;
-		len_total += len;
+		len_total = net_test_len_accumulate(len_total, len);
 
 		len = m0_net_test_str_serialize(op, &cmd->ntc_init.ntci_tm_ep,
 						bv, offset + len_total);
 		if (len == 0)
 			break;
-		len_total += len;
+		len_total = net_test_len_accumulate(len_total, len);
 
 		len = m0_net_test_slist_serialize(op, &cmd->ntc_init.ntci_ep,
 						  bv, offset + len_total);
@@ -193,11 +202,12 @@ static int cmd_serialize(enum m0_net_test_serialize_op op,
 		return -ENOSYS;
 	};
 
-	return len == 0 ? -EINVAL : 0;
+	len_total = net_test_len_accumulate(len_total, len);
+	return len_total == 0 ? -EINVAL : 0;
 }
 
 /**
-   Free m0_net_test_cmd after succesful
+   Free m0_net_test_cmd after successful
    cmd_serialize(M0_NET_TEST_DESERIALIZE, ...).
  */
 static void cmd_free(struct m0_net_test_cmd *cmd)
@@ -391,16 +401,13 @@ static int commands_initfini(struct m0_net_test_cmd_ctx *ctx,
 					  2 * ctx->ntcc_ep_nr,
 					  0, 0,
 					  ep_list->ntsl_nr,
-					  &timeouts);
+					  &timeouts, false);
 	if (rc != 0)
 		goto free_buf_status;
 
-	for (i = 0; i < ep_list->ntsl_nr; ++i) {
-		rc = m0_net_test_network_ep_add(&ctx->ntcc_net,
-						ep_list->ntsl_list[i]);
-		if (rc < 0)
-			goto free_net_ctx;
-	}
+	rc = m0_net_test_network_ep_add_slist(&ctx->ntcc_net, ep_list);
+	if (rc != 0)
+		goto free_net_ctx;
 	for (i = 0; i < ctx->ntcc_ep_nr; ++i) {
 		rc = commands_recv_enqueue(ctx, ctx->ntcc_ep_nr + i);
 		if (rc != 0) {
diff --git a/net/test/commands.h b/net/test/commands.h
index 0beec0e..4204f07 100644
--- a/net/test/commands.h
+++ b/net/test/commands.h
@@ -91,27 +91,55 @@ struct m0_net_test_cmd_done {
    @see m0_net_test_cmd
  */
 struct m0_net_test_cmd_init {
-	/** node role */
+	/** Node role */
 	enum m0_net_test_role	 ntci_role;
-	/** node type */
+	/** Node type */
 	enum m0_net_test_type	 ntci_type;
-	/** number of test messages for the test client */
-	unsigned long		 ntci_msg_nr;
-	/** test message size */
+	/**
+	 * Number of test messages for the test client.
+	 * It is number of ping messages for the ping test and
+	 * number of bulk messages for the bulk test.
+	 */
+	uint64_t		 ntci_msg_nr;
+	/**
+	 * Test message size.
+	 * It is size of ping buffer for the ping test and
+	 * size for bulk buffer for the bulk test.
+	 */
 	m0_bcount_t		 ntci_msg_size;
 	/**
+	 * Number of message buffers for bulk buffer descriptors
+	 * in the bulk test.
+	 * @note Unused in ping test.
+	 */
+	uint64_t		 ntci_bd_buf_nr;
+	/**
+	 * Size of message buffer for bulk buffer descriptors
+	 * in the bulk test.
+	 * @note Unused in ping test.
+	 */
+	m0_bcount_t		 ntci_bd_buf_size;
+	/**
+	 * Maximum number of bulk message descriptors in
+	 * the message buffer in the bulk test.
+	 * @note Unused in ping test.
+	 */
+	uint64_t		 ntci_bd_nr_max;
+	/**
 	 * Test messages concurrency.
-	 * Test server will allocate ntci_concurrency buffers.
-	 * Test client will allocate (ntci_concurrency * 2) buffers (one for
+	 * Test server will allocate ntci_msg_concurrency buffers.
+	 * Test client will allocate (ntci_msg_concurrency * 2) buffers (one for
 	 * sending and another for receiving) for each test server
 	 * from endpoints list ntci_ep.
 	 */
-	size_t			 ntci_concurrency;
-	/** buffer send timeout */
+	uint64_t		 ntci_msg_concurrency;
+	/** Buffer send timeout for M0_NET_QT_MSG_SEND queue */
 	m0_time_t		 ntci_buf_send_timeout;
-	/** transfer machine endpoint for data transfers */
+	/** Bulk buffers timeout for all bulk queues */
+	m0_time_t		 ntci_buf_bulk_timeout;
+	/** Transfer machine endpoint for data transfers */
 	char			*ntci_tm_ep;
-	/** endpoints list */
+	/** Endpoints list */
 	struct m0_net_test_slist ntci_ep;
 };
 
@@ -124,6 +152,12 @@ struct m0_net_test_cmd_status_data {
 	struct m0_net_test_msg_nr ntcsd_msg_nr_send;
 	/** number of received messages (total/failed/bad) */
 	struct m0_net_test_msg_nr ntcsd_msg_nr_recv;
+	/** number of sent bulk messages (total/failed/bad) */
+	struct m0_net_test_msg_nr ntcsd_bulk_nr_send;
+	/** number of received bulk messages (total/failed/bad) */
+	struct m0_net_test_msg_nr ntcsd_bulk_nr_recv;
+	/** number of transfers (in both directions) (total/failed/bad) */
+	struct m0_net_test_msg_nr ntcsd_transfers;
 	/** Test start time */
 	m0_time_t		  ntcsd_time_start;
 	/** Test finish time */
@@ -132,9 +166,9 @@ struct m0_net_test_cmd_status_data {
 	m0_time_t		  ntcsd_time_now;
 	/** Test was finished */
 	bool			  ntcsd_finished;
-	/** 'send' packets per second statistics with 1s interval */
+	/** 'send' messages per second statistics with 1s interval */
 	struct m0_net_test_mps	  ntcsd_mps_send;
-	/** 'receive' packets per second statistics with 1s interval */
+	/** 'receive' messages per second statistics with 1s interval */
 	struct m0_net_test_mps	  ntcsd_mps_recv;
 	/** RTT statistics (without lost messages) (test client only) */
 	struct m0_net_test_stats  ntcsd_rtt;
@@ -251,7 +285,7 @@ struct m0_net_test_cmd_ctx {
      call to m0_net_test_commands_recv();
    - m0_net_test_commands_recv() can allocate resources while decoding
      command from buffer, so m0_net_test_received_free() must be called
-     for command after succesful m0_net_test_commads_recv().
+     for command after successful m0_net_test_commads_recv().
  */
 int m0_net_test_commands_init(struct m0_net_test_cmd_ctx *ctx,
 			      const char *cmd_ep,
diff --git a/net/test/console.c b/net/test/console.c
index 95a2f84..d80bb4b 100644
--- a/net/test/console.c
+++ b/net/test/console.c
@@ -18,12 +18,12 @@
  * Original creation date: 09/03/2012
  */
 
-/* @todo remove */
+/** @todo remove */
 #ifndef __KERNEL__
 #include <stdio.h>		/* printf */
 #endif
 
-/* @todo debug only, remove it */
+/** @todo debug only, remove it */
 #ifndef __KERNEL__
 /*
 #define LOGD(format, ...) printf(format, ##__VA_ARGS__)
@@ -33,6 +33,7 @@
 #define LOGD(format, ...) do {} while (0)
 #endif
 
+#include "lib/arith.h"		/* min_check */
 #include "lib/memory.h"		/* M0_ALLOC_PTR */
 #include "lib/misc.h"		/* M0_SET0 */
 #include "lib/errno.h"		/* ETIMEDOUT */
@@ -143,10 +144,17 @@ static void console_cmd_init_fill(struct m0_net_test_console_cfg *cfg,
 	cinit->ntci_type	     = cfg->ntcc_test_type;
 	cinit->ntci_msg_nr	     = cfg->ntcc_msg_nr;
 	cinit->ntci_msg_size	     = cfg->ntcc_msg_size;
-	cinit->ntci_concurrency      = role == M0_NET_TEST_ROLE_CLIENT ?
+	cinit->ntci_bd_buf_nr	     = role == M0_NET_TEST_ROLE_CLIENT ?
+				       cfg->ntcc_bd_buf_nr_client :
+				       cfg->ntcc_bd_buf_nr_server;
+	cinit->ntci_bd_buf_size	     = cfg->ntcc_bd_buf_size;
+	cinit->ntci_bd_nr_max	     = cfg->ntcc_bd_nr_max;
+	cinit->ntci_msg_concurrency  = role == M0_NET_TEST_ROLE_CLIENT ?
 				       cfg->ntcc_concurrency_client :
 				       cfg->ntcc_concurrency_server;
+	/** @todo other timeouts */
 	cinit->ntci_buf_send_timeout = cfg->ntcc_buf_send_timeout;
+	cinit->ntci_buf_bulk_timeout = cfg->ntcc_buf_bulk_timeout;
 	cinit->ntci_ep		     = role == M0_NET_TEST_ROLE_CLIENT ?
 				       cfg->ntcc_data_servers :
 				       cfg->ntcc_data_clients;
@@ -154,50 +162,79 @@ static void console_cmd_init_fill(struct m0_net_test_console_cfg *cfg,
 
 static void status_data_reset(struct m0_net_test_cmd_status_data *sd)
 {
+	/* Statistics reset order is not important here */
+	struct m0_net_test_msg_nr * const msg_nr[] = {
+		&sd->ntcsd_msg_nr_send,
+		&sd->ntcsd_msg_nr_recv,
+		&sd->ntcsd_bulk_nr_send,
+		&sd->ntcsd_bulk_nr_recv,
+		&sd->ntcsd_transfers,
+	};
+	struct m0_net_test_stats * const stats[] = {
+		&sd->ntcsd_mps_send.ntmps_stats,
+		&sd->ntcsd_mps_recv.ntmps_stats,
+		&sd->ntcsd_rtt,
+	};
+	size_t i;
+
 	M0_SET0(sd);
-	m0_net_test_msg_nr_reset(&sd->ntcsd_msg_nr_send);
-	m0_net_test_msg_nr_reset(&sd->ntcsd_msg_nr_recv);
-	m0_net_test_stats_reset(&sd->ntcsd_mps_send.ntmps_stats);
-	m0_net_test_stats_reset(&sd->ntcsd_mps_recv.ntmps_stats);
-	m0_net_test_stats_reset(&sd->ntcsd_rtt);
+	for (i = 0; i < ARRAY_SIZE(msg_nr); ++i)
+		m0_net_test_msg_nr_reset(msg_nr[i]);
+	for (i = 0; i < ARRAY_SIZE(stats); ++i)
+		m0_net_test_stats_reset(stats[i]);
 	sd->ntcsd_finished    = true;
 	sd->ntcsd_time_start  = M0_TIME_NEVER;
 	sd->ntcsd_time_finish = M0_MKTIME(0, 0);
 }
 
-static m0_time_t time_min(m0_time_t t1, m0_time_t t2)
-{
-	return t1 < t2 ? t1 : t2;
-}
-
-static m0_time_t time_max(m0_time_t t1, m0_time_t t2)
-{
-	return t1 > t2 ? t1 : t2;
-}
-
-static void status_data_add(struct m0_net_test_cmd_status_data *sd,
+static void status_data_add(struct m0_net_test_cmd_status_data *all_sd,
 			    const struct m0_net_test_cmd_status_data *cmd_sd)
 {
+	/* Parts of statistics are independent here, so order isn't important */
+	const struct {
+		struct m0_net_test_msg_nr	*nr_all;
+		const struct m0_net_test_msg_nr *nr_node;
+	} msg_nr[] = {
+		{	.nr_all  = &all_sd->ntcsd_msg_nr_send,
+			.nr_node = &cmd_sd->ntcsd_msg_nr_send	},
+		{	.nr_all  = &all_sd->ntcsd_msg_nr_recv,
+			.nr_node = &cmd_sd->ntcsd_msg_nr_recv	},
+		{	.nr_all  = &all_sd->ntcsd_bulk_nr_send,
+			.nr_node = &cmd_sd->ntcsd_bulk_nr_send	},
+		{	.nr_all  = &all_sd->ntcsd_bulk_nr_recv,
+			.nr_node = &cmd_sd->ntcsd_bulk_nr_recv	},
+		{	.nr_all  = &all_sd->ntcsd_transfers,
+			.nr_node = &cmd_sd->ntcsd_transfers	},
+	};
+	const struct {
+		struct m0_net_test_stats       *s_all;
+		const struct m0_net_test_stats *s_node;
+	} stats[] = {
+		{	.s_all  = &all_sd->ntcsd_mps_send.ntmps_stats,
+			.s_node = &cmd_sd->ntcsd_mps_send.ntmps_stats	},
+		{	.s_all  = &all_sd->ntcsd_mps_recv.ntmps_stats,
+			.s_node = &cmd_sd->ntcsd_mps_recv.ntmps_stats	},
+		{	.s_all  = &all_sd->ntcsd_rtt,
+			.s_node = &cmd_sd->ntcsd_rtt,			},
+	};
+	size_t i;
+
 	LOGD("new STATUS_DATA:\n");
 	LOGD("send total = %lu\n", cmd_sd->ntcsd_msg_nr_send.ntmn_total);
 	LOGD("recv total = %lu\n", cmd_sd->ntcsd_msg_nr_recv.ntmn_total);
 	LOGD("finished = %d\n", cmd_sd->ntcsd_finished);
 	LOGD("end of STATUS_DATA\n");
-	m0_net_test_msg_nr_add(&sd->ntcsd_msg_nr_send,
-			       &cmd_sd->ntcsd_msg_nr_send);
-	m0_net_test_msg_nr_add(&sd->ntcsd_msg_nr_recv,
-			       &cmd_sd->ntcsd_msg_nr_recv);
-	m0_net_test_stats_add_stats(&sd->ntcsd_mps_send.ntmps_stats,
-				    &cmd_sd->ntcsd_mps_send.ntmps_stats);
-	m0_net_test_stats_add_stats(&sd->ntcsd_mps_recv.ntmps_stats,
-				    &cmd_sd->ntcsd_mps_recv.ntmps_stats);
-	m0_net_test_stats_add_stats(&sd->ntcsd_rtt, &cmd_sd->ntcsd_rtt);
-	sd->ntcsd_finished &= cmd_sd->ntcsd_finished;
+	for (i = 0; i < ARRAY_SIZE(msg_nr); ++i)
+		m0_net_test_msg_nr_add(msg_nr[i].nr_all, msg_nr[i].nr_node);
+	for (i = 0; i < ARRAY_SIZE(stats); ++i)
+		m0_net_test_stats_add_stats(stats[i].s_all, stats[i].s_node);
+	all_sd->ntcsd_finished &= cmd_sd->ntcsd_finished;
 	if (cmd_sd->ntcsd_finished) {
-		sd->ntcsd_time_start = time_min(sd->ntcsd_time_start,
-						cmd_sd->ntcsd_time_start);
-		sd->ntcsd_time_finish = time_max(sd->ntcsd_time_finish,
-						 cmd_sd->ntcsd_time_finish);
+		all_sd->ntcsd_time_start = min_check(all_sd->ntcsd_time_start,
+						     cmd_sd->ntcsd_time_start);
+		all_sd->ntcsd_time_finish =
+			max_check(all_sd->ntcsd_time_finish,
+				  cmd_sd->ntcsd_time_finish);
 	}
 }
 
diff --git a/net/test/console.h b/net/test/console.h
index df4ed81..a622a49 100644
--- a/net/test/console.h
+++ b/net/test/console.h
@@ -73,30 +73,59 @@ struct m0_net_test_console_cfg {
 	 * @see m0_net_test_console_cfg.ntcc_data_servers
 	 */
 	struct m0_net_test_slist ntcc_data_clients;
-	/** Commands send timeout for the test nodes */
+	/** Commands send timeout for the test nodes and test console */
 	m0_time_t		 ntcc_cmd_send_timeout;
-	/** Commands receive timeout for the test nodes */
+	/** Commands receive timeout for the test nodes and test console */
 	m0_time_t		 ntcc_cmd_recv_timeout;
 	/** Test messages send timeout for the test nodes */
 	m0_time_t		 ntcc_buf_send_timeout;
 	/** Test messages receive timeout for the test nodes */
 	m0_time_t		 ntcc_buf_recv_timeout;
+	/**
+	 * Test messages receive timeout for the bulk transfers
+	 * in bulk testing on the test nodes
+	 */
+	m0_time_t		 ntcc_buf_bulk_timeout;
 	/** Test type */
 	enum m0_net_test_type	 ntcc_test_type;
 	/** Number of test messages for the test client */
-	size_t			 ntcc_msg_nr;
+	uint64_t		 ntcc_msg_nr;
 	/** Test messages size */
 	m0_bcount_t		 ntcc_msg_size;
 	/**
+	 * Number of buffers for bulk buffer network descriptors
+	 * for the test server.
+	 * @note Used in bulk testing only.
+	 */
+	uint64_t		 ntcc_bd_buf_nr_server;
+	/**
+	 * Number of buffers for bulk buffer network descriptors
+	 * for the test client.
+	 * @note Used in bulk testing only.
+	 */
+	uint64_t		 ntcc_bd_buf_nr_client;
+	/**
+	 * Size of buffer for bulk buffer network descriptors.
+	 * @note Used in bulk testing only.
+	 */
+	m0_bcount_t		 ntcc_bd_buf_size;
+	/**
+	 * Maximum number of bulk buffer network descriptors in
+	 * msg buffer.
+	 * @see node_bulk_ctx.nbc_bd_nr_max
+	 * @note Used in bulk testing only.
+	 */
+	uint64_t		 ntcc_bd_nr_max;
+	/**
 	 * Test server concurrency.
-	 * @see m0_net_test_cmd_init.ntci_concurrency
+	 * @see m0_net_test_cmd_init.ntci_msg_concurrency
 	 */
-	size_t			 ntcc_concurrency_server;
+	uint64_t		 ntcc_concurrency_server;
 	/**
 	 * Test client concurrency.
-	 * @see m0_net_test_cmd_init.ntci_concurrency
+	 * @see m0_net_test_cmd_init.ntci_msg_concurrency
 	 */
-	size_t			 ntcc_concurrency_client;
+	uint64_t		 ntcc_concurrency_client;
 };
 
 /** Test console context for the node role */
diff --git a/net/test/initfini.c b/net/test/initfini.c
new file mode 100644
index 0000000..eefb791
--- /dev/null
+++ b/net/test/initfini.c
@@ -0,0 +1,97 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Maxim Medved <max_medved@xyratex.com>
+ * Original creation date: 11/26/2012
+ */
+
+#include "lib/cdefs.h"			/* ARRAY_SIZE */
+
+#include "net/test/network.h"		/* m0_net_test_network_init */
+#include "net/test/node_bulk.h"		/* m0_net_test_node_bulk_init */
+
+#include "net/test/initfini.h"
+
+/**
+   @defgroup NetTestInitFiniInternals Initialization/finalization of net-test
+   @ingroup NetTestInternals
+
+   @see
+   @ref net-test
+
+   @{
+ */
+
+struct init_fini {
+	int  (*if_init)(void);
+	void (*if_fini)(void);
+};
+
+static const struct init_fini if_list[] = {
+#define NET_TEST_MODULE(name) {			  \
+	.if_init = m0_net_test_ ## name ## _init, \
+	.if_fini = m0_net_test_ ## name ## _fini, \
+}
+	NET_TEST_MODULE(network),
+	NET_TEST_MODULE(node_bulk),
+#undef NET_TEST_MODULE
+};
+
+static int net_test_initfini(bool init)
+{
+	size_t i = ARRAY_SIZE(if_list);
+	int    rc = 0;
+
+	if (init) {
+		for (i = 0; i < ARRAY_SIZE(if_list); ++i) {
+			rc = if_list[i].if_init();
+			if (rc != 0) {
+				init = false;
+				break;
+			}
+		}
+	}
+	if (!init) {
+		for (; i != 0; --i)
+			if_list[i - 1].if_fini();
+	}
+	return rc;
+}
+
+int m0_net_test_init(void)
+{
+	return net_test_initfini(true);
+}
+
+void m0_net_test_fini(void)
+{
+	int rc = net_test_initfini(false);
+	M0_POST(rc == 0);
+}
+
+/**
+   @} end of NetTestInitFiniInternals group
+ */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 79
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/net/test/initfini.h b/net/test/initfini.h
new file mode 100644
index 0000000..377cffe
--- /dev/null
+++ b/net/test/initfini.h
@@ -0,0 +1,57 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Maxim Medved <max_medved@xyratex.com>
+ * Original creation date: 11/26/2012
+ */
+
+#pragma once
+
+#ifndef __MERO_NET_TEST_INITFINI_H__
+#define __MERO_NET_TEST_INITFINI_H__
+
+#include "net/test/serialize.h"
+
+
+/**
+   @defgroup NetTestInitFiniDFS Initialization/finalization of net-test
+   @ingroup NetTestDFS
+
+   @see
+   @ref net-test
+
+   @{
+ */
+
+/** Initialize net-test */
+int m0_net_test_init(void);
+void m0_net_test_fini(void);
+
+/**
+   @} end of NetTestInitFiniDFS group
+ */
+
+#endif /*  __MERO_NET_TEST_INITFINI_H__ */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 79
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/net/test/linux_kernel/node_k.c b/net/test/linux_kernel/node_k.c
index c062372..376ac7d 100644
--- a/net/test/linux_kernel/node_k.c
+++ b/net/test/linux_kernel/node_k.c
@@ -18,7 +18,7 @@
  * Original creation date: 4/10/2012
  */
 
-/* @todo proper kernel module init */
+/** @todo proper kernel module init */
 /* node_config_k.h */
 #if 0
 #include "net/test/node_config.h"
diff --git a/net/test/network.c b/net/test/network.c
index b926288..4c144f5 100644
--- a/net/test/network.c
+++ b/net/test/network.c
@@ -31,6 +31,8 @@
 #include "lib/misc.h"		/* M0_SET0 */
 #include "lib/vec.h"		/* M0_SEG_SHIFT */
 
+#include "mero/magic.h"	/* M0_NET_TEST_NETWORK_BD_MAGIC */
+
 #include "net/net.h"
 #include "net/lnet/lnet.h"	/* m0_net_lnet_xprt */
 
@@ -56,14 +58,6 @@
 #endif
 #endif
 
-/* see buf_desc_decode() and m0_net_test_network_bd_encode() */
-M0_BASSERT(sizeof(unsigned)	 == sizeof(uint32_t));
-M0_BASSERT(sizeof(unsigned long) == sizeof(m0_bcount_t));
-
-enum {
-	M0_NET_TEST_STRLEN_NBD_HEADER = 32,
-};
-
 int m0_net_test_network_init(void)
 {
 	return m0_net_xprt_init(&m0_net_lnet_xprt);
@@ -288,10 +282,11 @@ int m0_net_test_network_ctx_init(struct m0_net_test_network_ctx *ctx,
 				 uint32_t buf_bulk_nr,
 				 uint32_t ep_max,
 				 const struct m0_net_test_network_timeouts
-				 *timeouts)
+				 *timeouts,
+				 bool sync)
 {
-	int		       rc;
-	struct m0_clink        tmwait;
+	struct m0_clink tmwait;
+	int		rc;
 
 	M0_PRE(ctx     != NULL);
 	M0_PRE(tm_addr != NULL);
@@ -435,6 +430,30 @@ int m0_net_test_network_ep_add(struct m0_net_test_network_ctx *ctx,
 	return rc;
 }
 
+int m0_net_test_network_ep_add_slist(struct m0_net_test_network_ctx *ctx,
+				     const struct m0_net_test_slist *eps)
+{
+	int    rc = 0;
+	size_t i;
+
+	M0_PRE(m0_net_test_network_ctx_invariant(ctx));
+	M0_PRE(m0_net_test_slist_invariant(eps));
+
+	for (i = 0; i < eps->ntsl_nr; ++i) {
+		rc = m0_net_test_network_ep_add(ctx, eps->ntsl_list[i]);
+		if (rc < 0)
+			break;
+	}
+	if (rc < 0) {
+		/* m0_net_end_point_put() for last i endpoints */
+		for (; i != 0; --i)
+			m0_net_end_point_put(ctx->ntc_ep[--ctx->ntc_ep_nr]);
+	}
+	M0_POST(m0_net_test_network_ctx_invariant(ctx));
+
+	return rc >= 0 ? 0 : rc;
+}
+
 static int net_test_buf_queue(struct m0_net_test_network_ctx *ctx,
 			      struct m0_net_buffer *nb,
 			      enum m0_net_queue_type q)
@@ -502,8 +521,7 @@ int m0_net_test_network_bulk_enqueue(struct m0_net_test_network_ctx *ctx,
 
 	buf = &ctx->ntc_buf_bulk[buf_bulk_index];
 	if (q == M0_NET_QT_PASSIVE_BULK_SEND ||
-			q == M0_NET_QT_PASSIVE_BULK_RECV) {
-
+	    q == M0_NET_QT_PASSIVE_BULK_RECV) {
 		M0_PRE(ep_index < ctx->ntc_ep_nr);
 		buf->nb_ep = ctx->ntc_ep[ep_index];
 	} else
@@ -522,208 +540,218 @@ void m0_net_test_network_buffer_dequeue(struct m0_net_test_network_ctx *ctx,
 			  ctx->ntc_tm);
 }
 
-void m0_net_test_network_bd_reset(struct m0_net_test_network_ctx *ctx,
-				  int32_t buf_ping_index)
-{
-	M0_PRE(m0_net_test_network_ctx_invariant(ctx));
+/** Structure to help m0_net_buf_desc serialization */
+struct net_test_network_bd {
+	/** M0_NET_TEST_NETWORK_BD_MAGIC */
+	uint64_t    ntnbd_magic;
+	/** Passive buffer size */
+	m0_bcount_t ntnbd_buf_size;
+	/** m0_net_buf_desc.nbd_len */
+	uint32_t    ntnbd_len;
+};
 
-	ctx->ntc_buf_ping[buf_ping_index].nb_length = 0;
-}
+/** net_test_network_bd_descr */
+TYPE_DESCR(net_test_network_bd) = {
+	FIELD_DESCR(struct net_test_network_bd, ntnbd_magic),
+	FIELD_DESCR(struct net_test_network_bd, ntnbd_buf_size),
+	FIELD_DESCR(struct net_test_network_bd, ntnbd_len),
+};
 
-static m0_bcount_t bufvec_append(struct m0_bufvec_cursor *dcur,
-				 void *data,
-				 m0_bcount_t length)
-{
-	struct m0_bufvec	data_bv = M0_BUFVEC_INIT_BUF(&data, &length);
-	struct m0_bufvec_cursor data_cur;
+/** Header for ping buffer with serialized m0_net_buf_desc's */
+struct net_test_network_bds_header {
+	/** M0_NET_TEST_NETWORK_BDS_MAGIC */
+	uint64_t ntnbh_magic;
+	/** Number of buffer descriptors in ping buffer */
+	uint64_t ntnbh_nr;
+};
 
-	m0_bufvec_cursor_init(&data_cur, &data_bv);
-	return m0_bufvec_cursor_copy(dcur, &data_cur, length);
-}
+/** net_test_network_bds_header_descr */
+TYPE_DESCR(net_test_network_bds_header) = {
+	FIELD_DESCR(struct net_test_network_bds_header, ntnbh_magic),
+	FIELD_DESCR(struct net_test_network_bds_header, ntnbh_nr),
+};
 
-static m0_bcount_t bufvec_read(struct m0_bufvec_cursor *scur,
-			       void *data,
-			       m0_bcount_t length)
+/** @see m0_net_test_serialize() */
+static m0_bcount_t network_bd_serialize(enum m0_net_test_serialize_op op,
+					struct m0_net_buffer *buf,
+					struct m0_bufvec *bv,
+					m0_bcount_t bv_offset)
 {
-	struct m0_bufvec        data_bv = M0_BUFVEC_INIT_BUF(&data, &length);
-	struct m0_bufvec_cursor data_cur;
+	struct net_test_network_bd bd;
+	m0_bcount_t		   len;
+	m0_bcount_t		   len_total;
 
-	m0_bufvec_cursor_init(&data_cur, &data_bv);
-	return m0_bufvec_cursor_copy(&data_cur, scur, length);
-}
+	M0_PRE(buf != NULL);
+	M0_PRE(bv != NULL);
 
-static bool buf_desc_decode(struct m0_bufvec_cursor *cur,
-			    m0_bcount_t offset,
-			    m0_bcount_t buf_len,
-			    m0_bcount_t *passive_len,
-			    int32_t *desc_len)
-{
-	char	    str[M0_NET_TEST_STRLEN_NBD_HEADER];
-	m0_bcount_t rc_bcount;
-	int	    rc;
+	bd.ntnbd_magic	  = M0_NET_TEST_NETWORK_BD_MAGIC;
+	bd.ntnbd_buf_size = buf->nb_length;
+	bd.ntnbd_len	  = buf->nb_desc.nbd_len;
 
-	if (offset + M0_NET_TEST_STRLEN_NBD_HEADER > buf_len)
-		return false;
+	len = m0_net_test_serialize(op, &bd,
+				    USE_TYPE_DESCR(net_test_network_bd),
+				    bv, bv_offset);
+	if (len == 0)
+		return 0;
+	len_total = net_test_len_accumulate(0, len);
 
-	rc_bcount = bufvec_read(cur, str, M0_NET_TEST_STRLEN_NBD_HEADER);
-	if (rc_bcount != M0_NET_TEST_STRLEN_NBD_HEADER)
-		return false;
+	/* optimizing memory allocation */
+	if (op == M0_NET_TEST_DESERIALIZE &&
+	    buf->nb_desc.nbd_len != bd.ntnbd_len) {
+		/* free old */
+		m0_free(buf->nb_desc.nbd_data);
+		buf->nb_desc.nbd_len = 0;
+		/* alloc new */
+		buf->nb_desc.nbd_data = m0_alloc(bd.ntnbd_len);
+		if (buf->nb_desc.nbd_data == NULL)
+			return 0;
+		buf->nb_desc.nbd_len = bd.ntnbd_len;
+	}
 
-	/* note Linux uses the LP64 standard */
-	rc = sscanf(str, "%lu %u",
-		    (unsigned long *) passive_len, desc_len);
-#ifdef DEBUG_NET_TEST_NETWORK
-	printf("rc = %d, passive_len = %"PRIu64", desc_len = %"PRIu32", "
-		"str = %s\n", rc, *passive_len, *desc_len, str);
-#endif
-	return rc == 2 &&
-		offset + M0_NET_TEST_STRLEN_NBD_HEADER + *desc_len <= buf_len;
+	len = m0_net_test_serialize_data(op, buf->nb_desc.nbd_data,
+					 buf->nb_desc.nbd_len, true,
+					 bv, bv_offset + len_total);
+	len_total = net_test_len_accumulate(len_total, len);
+	return len_total;
 }
 
-uint32_t m0_net_test_network_bd_count(struct m0_net_test_network_ctx *ctx,
-				      int32_t buf_ping_index)
+static m0_bcount_t network_bds_serialize(enum m0_net_test_serialize_op op,
+					 size_t *nr,
+					 struct m0_bufvec *bv)
 {
-	struct m0_net_buffer   *buf_ping;
-	struct m0_bufvec_cursor cur_buf;
-	uint32_t		result = 0;
-	m0_bcount_t		offset;
-	m0_bcount_t		buf_len;
-	m0_bcount_t		passive_len;
-	int32_t			desc_len;
-	bool			decoded;
+	struct net_test_network_bds_header header;
+	m0_bcount_t			   len;
 
-	M0_PRE(m0_net_test_network_ctx_invariant(ctx));
-	M0_PRE(buf_ping_index < ctx->ntc_buf_ping_nr);
+	M0_PRE(nr != NULL);
+	M0_PRE(bv != NULL);
 
-	buf_ping = &ctx->ntc_buf_ping[buf_ping_index];
-	m0_bufvec_cursor_init(&cur_buf, &buf_ping->nb_buffer);
-	m0_bufvec_cursor_move(&cur_buf,  buf_ping->nb_offset);
+	if (op == M0_NET_TEST_SERIALIZE) {
+		header.ntnbh_magic = M0_NET_TEST_NETWORK_BDS_MAGIC;
+		header.ntnbh_nr	   = *nr;
+	}
 
-	offset  = 0;
-	buf_len = buf_ping->nb_length;
-	while (offset < buf_len) {
-		decoded = buf_desc_decode(&cur_buf, offset, buf_len,
-					  &passive_len, &desc_len);
-		if (!decoded)
-			break;
-		result++;
-		m0_bufvec_cursor_move(&cur_buf, desc_len);
-		offset += M0_NET_TEST_STRLEN_NBD_HEADER + desc_len;
+	len = m0_net_test_serialize(op, &header,
+				USE_TYPE_DESCR(net_test_network_bds_header),
+				    bv, 0);
+
+	if (op == M0_NET_TEST_DESERIALIZE) {
+		if (header.ntnbh_magic == M0_NET_TEST_NETWORK_BDS_MAGIC)
+			*nr = header.ntnbh_nr;
+		else
+			len = 0;
 	}
 
-	return result;
+	return len;
 }
 
-int m0_net_test_network_bd_encode(struct m0_net_test_network_ctx *ctx,
-				  int32_t buf_ping_index,
-				  int32_t buf_bulk_index)
-{
-	int			rc;
-	m0_bcount_t		rc_bcount;
-	struct m0_net_buffer   *buf_bulk;
-	struct m0_net_buffer   *buf_ping;
-	struct m0_bufvec_cursor cur_buf;
-	m0_bcount_t	        desc_len;
-	const m0_bcount_t	str_len = 20 + 1 + 10 + 1;
-	/*				  ^    ^   ^    ^
-		passive side buffer size -+   ' '  |  '\0'
-		m0_net_buf_desc .nbd_len ----------+
-	 */
-	char			str[str_len];
-
-	M0_ASSERT(str_len == M0_NET_TEST_STRLEN_NBD_HEADER);
-	M0_PRE(m0_net_test_network_ctx_invariant(ctx));
-	M0_PRE(buf_bulk_index < ctx->ntc_buf_bulk_nr);
-	M0_PRE(buf_ping_index < ctx->ntc_buf_ping_nr);
+/**
+   Number of serialized network buffer descriptors in ping buffer
+   is stored inside ping buffer in serialized form. This function
+   modifies this number.
+   @param ctx Network context
+   @param buf_ping_index Index of ping buffer
+   @param value This value will be added to the number of serialized
+		network buffer descriptors. Can be -1, 0, 1. If it is
+		-1, then function will M0_ASSERT() that number will
+		not underflow.
+   @return New value of number of serialized network buffer descriptors.
+ */
+static size_t network_bd_nr_add(struct m0_net_test_network_ctx *ctx,
+				uint32_t buf_ping_index,
+				int32_t value)
+{
+	struct m0_bufvec *bv;
+	m0_bcount_t	  len;
+	size_t		  nr;
 
-	buf_bulk = &ctx->ntc_buf_bulk[buf_bulk_index];
-	buf_ping = &ctx->ntc_buf_ping[buf_ping_index];
+	M0_PRE(ctx != NULL);
+	M0_PRE(buf_ping_index < ctx->ntc_buf_ping_nr);
+	M0_PRE(M0_IN(value, (-1, 0, 1)));
 
-	desc_len = buf_bulk->nb_desc.nbd_len;
+	bv = &m0_net_test_network_buf(ctx, M0_NET_TEST_BUF_PING,
+				      buf_ping_index)->nb_buffer;
+	len = network_bds_serialize(M0_NET_TEST_DESERIALIZE, &nr, bv);
+	M0_ASSERT(len != 0);
+	/* simply "get number of network bd" */
+	if (value == 0)
+		return nr;
 
-	m0_bufvec_cursor_init(&cur_buf, &buf_ping->nb_buffer);
-	m0_bufvec_cursor_move(&cur_buf, buf_ping->nb_offset +
-					buf_ping->nb_length);
+	M0_ASSERT(ergo(value == -1, nr > 0));
+	nr += value;
+	len = network_bds_serialize(M0_NET_TEST_SERIALIZE, &nr, bv);
+	M0_ASSERT(len != 0);
 
-	/* check for space left in buf_ping */
-	if (m0_vec_count(&buf_ping->nb_buffer.ov_vec) <
-	    buf_ping->nb_offset + buf_ping->nb_length + str_len + desc_len)
-		return -E2BIG;
+	return nr;
+}
 
-	/* fill str[] */
-	/* note Linux uses the LP64 standard */
-	rc = snprintf(str, str_len, "%020lu %010u",
-		      (unsigned long) buf_bulk->nb_length,
-		      buf_bulk->nb_desc.nbd_len);
-	M0_ASSERT(rc == str_len - 1);
-	/* copy str[] to buf_ping */
-	rc_bcount = bufvec_append(&cur_buf, str, str_len);
-	if (rc_bcount != str_len)
-		return -E2BIG;
-	/* copy m0_net_buf_desc .nbd_data to buf_ping */
-	rc_bcount = bufvec_append(&cur_buf, buf_bulk->nb_desc.nbd_data,
-				  desc_len);
-	if (rc_bcount != desc_len)
-		return -E2BIG;
-	/* adjust buf_ping .nb_length */
-	buf_ping->nb_length += str_len + desc_len;
-	return 0;
-}
-
-/* see m0_net_test_network_bd_encode() */
-int m0_net_test_network_bd_decode(struct m0_net_test_network_ctx *ctx,
-				  int32_t buf_ping_index,
-				  int32_t buf_bulk_index)
-{
-	struct m0_net_buffer   *buf_bulk;
-	struct m0_net_buffer   *buf_ping;
-	struct m0_bufvec_cursor cur_buf;
-	m0_bcount_t		buf_ping_len;
-	m0_bcount_t		passive_len;
-	m0_bcount_t		offset;
-	int32_t			desc_len;
-	m0_bcount_t		rc_bcount;
-	bool			decoded;
+m0_bcount_t
+m0_net_test_network_bd_serialize(enum m0_net_test_serialize_op op,
+				 struct m0_net_test_network_ctx *ctx,
+				 uint32_t buf_bulk_index,
+				 uint32_t buf_ping_index,
+				 m0_bcount_t offset)
+{
+	struct m0_net_buffer *buf;
+	struct m0_bufvec     *bv;
+	m0_bcount_t	      len;
+	m0_bcount_t	      len_total;
+	size_t		      nr;
 
-	M0_PRE(m0_net_test_network_ctx_invariant(ctx));
+	M0_PRE(op == M0_NET_TEST_SERIALIZE || op == M0_NET_TEST_DESERIALIZE);
+	M0_PRE(ctx != NULL);
 	M0_PRE(buf_bulk_index < ctx->ntc_buf_bulk_nr);
 	M0_PRE(buf_ping_index < ctx->ntc_buf_ping_nr);
 
-	buf_bulk = &ctx->ntc_buf_bulk[buf_bulk_index];
-	buf_ping = &ctx->ntc_buf_ping[buf_ping_index];
-
-	m0_bufvec_cursor_init(&cur_buf, &buf_ping->nb_buffer);
-	m0_bufvec_cursor_move(&cur_buf, buf_ping->nb_offset +
-					buf_ping->nb_length);
-
-	offset  = buf_ping->nb_offset + buf_ping->nb_length;
-	buf_ping_len = m0_vec_count(&buf_ping->nb_buffer.ov_vec);
-	decoded = buf_desc_decode(&cur_buf, offset, buf_ping_len,
-				  &passive_len, &desc_len);
-	if (!decoded)
-		return -EBADMSG;
-
-	if (passive_len > m0_vec_count(&buf_bulk->nb_buffer.ov_vec))
-		return -E2BIG;
+	/*
+	M0_LOG(M0_DEBUG, "%d %s", op, ctx->ntc_tm->ntm_ep->nep_addr);
+	M0_LOG(M0_DEBUG, "bd_serialize: op = %d, tm_addr = %s, "
+			 "buf_bulk_index = %u, buf_ping_index = %u, "
+			 "offset = %lu",
+			 op, ctx->ntc_tm->ntm_ep->nep_addr,
+			 buf_bulk_index, buf_ping_index,
+			 (long unsigned) offset);
+	*/
+
+	bv = &m0_net_test_network_buf(ctx, M0_NET_TEST_BUF_PING,
+				      buf_ping_index)->nb_buffer;
+	M0_ASSERT(bv != NULL);
+	buf = m0_net_test_network_buf(ctx, M0_NET_TEST_BUF_BULK,
+				      buf_bulk_index);
+	M0_ASSERT(buf != NULL);
 
-	/* optimizing memory allocation */
-	if (buf_bulk->nb_desc.nbd_len != desc_len) {
-		/* free old */
-		m0_free(buf_bulk->nb_desc.nbd_data);
-		buf_bulk->nb_desc.nbd_len = 0;
-		/* alloc new */
-		buf_bulk->nb_desc.nbd_data = m0_alloc(desc_len);
-		if (buf_bulk->nb_desc.nbd_data == NULL)
-			return -ENOMEM;
-		buf_bulk->nb_desc.nbd_len = desc_len;
+	if (offset == 0) {
+		nr = 0;
+		/* include header length to the first descriptor length */
+		len = network_bds_serialize(op, &nr, bv);
+		if (len == 0)
+			return 0;
+		len_total = net_test_len_accumulate(0, len);
+	} else {
+		len_total = 0;
 	}
+	len = network_bd_serialize(op, buf, bv, offset + len_total);
+	len_total = net_test_len_accumulate(len_total, len);
+	/* increase number of descriptors for 'serialize' operation */
+	if (len_total != 0 && op == M0_NET_TEST_SERIALIZE)
+		network_bd_nr_add(ctx, buf_ping_index, 1);
 
-	rc_bcount = bufvec_read(&cur_buf, buf_bulk->nb_desc.nbd_data, desc_len);
-	if (rc_bcount != desc_len)
-		return -EBADMSG;
+	/*
+	M0_LOG(M0_DEBUG, "bd_serialize: len_total = %lu",
+	       (long unsigned) len_total);
+	*/
+	return len_total;
+}
 
-	buf_ping->nb_length += M0_NET_TEST_STRLEN_NBD_HEADER + desc_len;
-	return 0;
+size_t m0_net_test_network_bd_nr(struct m0_net_test_network_ctx *ctx,
+				 uint32_t buf_ping_index)
+{
+	return network_bd_nr_add(ctx, buf_ping_index, 0);
+}
+
+void m0_net_test_network_bd_nr_dec(struct m0_net_test_network_ctx *ctx,
+				   uint32_t buf_ping_index)
+{
+	network_bd_nr_add(ctx, buf_ping_index, -1);
 }
 
 struct m0_net_buffer *
diff --git a/net/test/network.h b/net/test/network.h
index ecb29c0..c8d4f42 100644
--- a/net/test/network.h
+++ b/net/test/network.h
@@ -24,6 +24,8 @@
 #define __MERO_NET_TEST_NETWORK_H__
 
 #include "net/net.h"
+#include "net/test/serialize.h"		/* m0_net_test_serialize_op */
+#include "net/test/slist.h"		/* m0_net_test_slist */
 
 /**
    @defgroup NetTestNetworkDFS Network
@@ -129,6 +131,10 @@ void m0_net_test_network_fini(void);
    Allocate ping and bulk buffers.
    @note timeouts parameter can be NULL, in this case it is assumed
    that all timeouts is M0_TIME_NEVER.
+   @note if sync parameter is set, then
+   m0_net_buffer_event_deliver_synchronously() will be called for transfer
+   machine and m0_net_buffer_event_deliver_all() should be used for buffer
+   event delivery.
    @see m0_net_test_network_ctx
    @pre ctx     != NULL
    @pre tm_addr != NULL
@@ -138,6 +144,7 @@ void m0_net_test_network_fini(void);
    @return 0 (success)
    @return -ECONNREFUSED m0_net_tm_start() failed.
    @return -errno (failire)
+   @todo create configuration structure instead a lot of parameters
  */
 int m0_net_test_network_ctx_init(struct m0_net_test_network_ctx *ctx,
 				 const char *tm_addr,
@@ -150,15 +157,18 @@ int m0_net_test_network_ctx_init(struct m0_net_test_network_ctx *ctx,
 				 uint32_t buf_bulk_nr,
 				 uint32_t ep_max,
 				 const struct m0_net_test_network_timeouts
-				 *timeouts);
+				 *timeouts,
+				 bool sync);
 void m0_net_test_network_ctx_fini(struct m0_net_test_network_ctx *ctx);
 bool m0_net_test_network_ctx_invariant(struct m0_net_test_network_ctx *ctx);
 
 /**
-   Add entry point to m0_net_test_network_ctx structure.
-   @return entry point number.
+   Add endpoint to m0_net_test_network_ctx structure.
+   @return endpoint number.
    @return -E2BIG ctx->ntc_ep already contains maximum number of endpoints.
    @return -errno (if failure)
+   @pre m0_net_test_network_ctx_invariant(ctx)
+   @pre ep_addr != NULL
 
    @see m0_net_test_network_init()
  */
@@ -166,6 +176,18 @@ int m0_net_test_network_ep_add(struct m0_net_test_network_ctx *ctx,
 			       const char *ep_addr);
 
 /**
+   Add endpoints to m0_net_test_network_ctx structure.
+   If some endpoint addition fails, then no endpoints will be added to
+   network context and all added endpoints will be m0_net_end_point_put()'ed.
+   @return -E2BIG ctx->ntc_ep already contains maximum number of endpoints.
+   @pre m0_net_test_network_ctx_invariant(ctx)
+   @pre m0_net_test_slist_invariant(eps)
+   @post m0_net_test_network_ctx_invariant(ctx)
+ */
+int m0_net_test_network_ep_add_slist(struct m0_net_test_network_ctx *ctx,
+				     const struct m0_net_test_slist *eps);
+
+/**
    Add message buffer to network messages send queue.
    @param ctx Net-test network context.
    @param buf_ping_index Index of buffer in ctx->ntc_buf_ping array.
@@ -220,53 +242,52 @@ void m0_net_test_network_buffer_dequeue(struct m0_net_test_network_ctx *ctx,
 					int32_t buf_index);
 
 /**
-   Reset to 0 number of network buffer descriptors in the message buffer.
-   @see @ref m0_net_test_network_bd_encode().
- */
-void m0_net_test_network_bd_reset(struct m0_net_test_network_ctx *ctx,
-				  int32_t buf_ping_index);
-/**
-   Get the number of network buffer descriptors in the message buffer.
-   @see @ref m0_net_test_network_bd_encode().
+   Serialize or deserialize bulk buffer network transport descriptor
+   to/from ping buffer.
+   @see @ref net-test-fspec-usecases-bd
+   @param op Serialization operation.
+   @param ctx Net-test network context.
+   @param buf_bulk_index Bulk buffer index. Buffer descriptor will be taken
+			 from this buffer for serialization and set for this
+			 buffer after deserialization.
+   @param buf_ping_index Ping buffer index. This buffer will be used as
+			 container to serialized buffer descriptors.
+   @param offset Offset in the ping buffer to serialize/deserialize
+		 network descriptor. Should have value 0 for the first
+		 descriptor when serializing/deserializing.
+   @return length of serialized/deserialized buffer descriptor.
+   @pre op == M0_NET_TEST_SERIALIZE || op == M0_NET_TEST_DESERIALIZE
+   @pre ctx != NULL
+   @pre buf_bulk_index < ctx->ntc_buf_bulk_nr
+   @pre buf_ping_index < ctx->ntc_buf_ping_nr
+   @todo possible security vulnerability because bounds are not checked
  */
-uint32_t m0_net_test_network_bd_count(struct m0_net_test_network_ctx *ctx,
-				      int32_t buf_ping_index);
+m0_bcount_t
+m0_net_test_network_bd_serialize(enum m0_net_test_serialize_op op,
+				 struct m0_net_test_network_ctx *ctx,
+				 uint32_t buf_bulk_index,
+				 uint32_t buf_ping_index,
+				 m0_bcount_t offset);
 
 /**
-   Store network buffer descriptor (m0_net_buf_desc) in the message buffer.
-   m0_net_buf_desc is serialized and is stored in the message buffer
-   one after the other. Buffer length is adjusted on every encoding.
-   So, to send some number of network descriptors over the network
-   there is a simple steps:
-   - @b passive: call m0_net_test_network_bd_reset() to reset to 0 number of
-     network descriptors in the ping buffer;
-   - @b passive: call m0_net_test_network_bd_encode() as many times as needed
-     to serialize bulk buffer descriptors (from buffers, previously added
-     to passive bulk queues) to ping buffer;
-   - @b passive: send ping buffer to active side;
-   - @b active: receive ping buffer;
-   - @b active: determine number of network buffer descriptors inside ping
-     buffer using m0_net_test_network_bd_count();
-   - @b active: reset number of network buffer desriptors in the ping buffer
-     using m0_net_test_network_bd_reset();
-   - @b active: sequentially call m0_net_test_network_bd_encode() as many times
-     as there is network buffer descriptors, encoded in this ping buffer,
-     to set appropriate network buffer descriptors for a bulk buffers to
-     perform active send/receive.
-   @param ctx Net-test network context.
-   @param buf_ping_index Index of message buffer in ctx->ntc_buf_ping array.
-   @param buf_bulk_index Index of bulk buffer in ctx->ntc_buf_bulk array.
+   Get number of stored network buffer descriptors in ping buffer.
+   @see @ref net-test-fspec-usecases-bd
+   @see m0_net_test_network_bd_serialize()
+   @pre ctx != NULL
+   @pre buf_ping_index < ctx->ntc_buf_ping_nr
  */
-int m0_net_test_network_bd_encode(struct m0_net_test_network_ctx *ctx,
-				  int32_t buf_ping_index,
-				  int32_t buf_bulk_index);
+size_t m0_net_test_network_bd_nr(struct m0_net_test_network_ctx *ctx,
+				 uint32_t buf_ping_index);
+
 /**
-   Recover a network descriptor from the message buffer.
-   @see @ref m0_net_test_network_bd_encode().
+   Decrease number of network buffer descriptors in ping buffer.
+   This function simply decreases number of network buffer descriptors
+   stored in ping buffer.
+   @see @ref net-test-fspec-usecases-bd
+   @see m0_net_test_network_bd_serialize()
  */
-int m0_net_test_network_bd_decode(struct m0_net_test_network_ctx *ctx,
-				  int32_t buf_ping_index,
-				  int32_t buf_bulk_index);
+void m0_net_test_network_bd_nr_dec(struct m0_net_test_network_ctx *ctx,
+				   uint32_t buf_ping_index);
 
 /**
    Accessor to buffers in net-test network context.
diff --git a/net/test/node.c b/net/test/node.c
index 17974ac..77debf9 100644
--- a/net/test/node.c
+++ b/net/test/node.c
@@ -18,12 +18,12 @@
  * Original creation date: 03/22/2012
  */
 
-/* @todo remove */
+/** @todo remove */
 #ifndef __KERNEL__
 #include <stdio.h>		/* printf */
 #endif
 
-/* @todo debug only, remove it */
+/** @todo debug only, remove it */
 #ifndef __KERNEL__
 //#define LOGD(format, ...) printf(format, ##__VA_ARGS__)
 #define LOGD(format, ...) do {} while (0)
@@ -132,8 +132,10 @@
    - @ref net-test-lspec-comps
      - @ref net-test-lspec-ping
      - @ref net-test-lspec-bulk
-     - @ref net-test-lspec-algo-client
-     - @ref net-test-lspec-algo-server
+     - @ref net-test-lspec-algo-client-ping
+     - @ref net-test-lspec-algo-client-bulk
+     - @ref net-test-lspec-algo-server-ping
+     - @ref net-test-lspec-algo-server-bulk
      - @ref net-test-lspec-console
      - @ref net-test-lspec-misc
    - @ref net-test-lspec-state
@@ -151,6 +153,7 @@
      stats	[label="stats.c"];
      node_ping	[label="node_ping.c"];
      node_bulk	[label="node_bulk.c"];
+     node_help	[label="node_helper.c"];
      node_	[label="node.c"];
      node_u	[label="user_space/node_u.c"];
      node_k	[label="linux_kernel/node_k.c"];
@@ -162,12 +165,15 @@
      node_ping	-> network;
      node_ping	-> service;
      node_ping	-> stats;
+     node_ping	-> node_help;
      node_bulk	-> network;
      node_bulk	-> service;
      node_bulk	-> stats;
+     node_bulk	-> node_help;
      node_	-> node_ping;
      node_	-> node_bulk;
      node_	-> commands;
+     node_	-> service;
      node_u	-> node_;
      node_k	-> node_;
      console	-> commands;
@@ -216,6 +222,11 @@
 
    @subsubsection net-test-lspec-bulk Bulk Test
 
+   RTT is measured as length of time interval
+   [time of transition to transfer start state,
+    time of transition to transfer finish state]. See
+   @ref net-test-lspec-algo-client-bulk, @ref net-test-lspec-algo-server-bulk.
+
    One test message travel:
    @msc
    c [label = "Test Client"],
@@ -244,7 +255,7 @@
    |||;
    @endmsc
 
-   @subsubsection net-test-lspec-algo-client Test Client Algorithm
+   @subsubsection net-test-lspec-algo-client-ping Ping Test Client Algorithm
 
    @todo Outdated and not used now.
 
@@ -295,25 +306,113 @@ finished.up();\l", shape=box];
      - update stats
      - buf_free.up()
 
-   Callbacks for bulk test
-   - M0_NET_QT_MSG_SEND
-     - nothing
-   - M0_NET_QT_PASSIVE_BULK_SEND
-     - update stats
-   - M0_NET_QT_PASSIVE_BULK_RECV
-     - update stats
-     - buf_free.up()
+   @subsubsection net-test-lspec-algo-sm-legend State Machine Legend
+   - Red solid arrow - state transition to "error" states.
+   - Green bold arrow - state transition for "successful" operation.
+   - Black dashed arrow - auto state transition (shouldn't be explicit).
+   - State name in double oval - final state.
 
-   External variables and interrupts
-   - semaphore stop = 0;
-   - semaphore finished = 0;
-   - client_stop()
-     - stop.up()
-   - stop and block until finish
-     - client_stop()
-     - finished.down()
+   @subsubsection net-test-lspec-algo-client-bulk Bulk Test Client Algorithm
+
+   @dot
+   digraph {
+	label = "Bulk Test Client Buffer States";
+	unused	    [label="UNUSED"];
+	queued	    [label="QUEUED"];
+	bd_sent	    [label="BD_SENT"];
+	cb_left2    [label="CB_LEFT2"];
+	cb_left1    [label="CB_LEFT1"];
+	failed2	    [label="FAILED2", color="red"];
+	failed1	    [label="FAILED1", color="red"];
+	transferred [label="TRANSFERRED", peripheries=2];
+	failed	    [label="FAILED", peripheries=2];
+
+	unused	    -> queued	   [color="green", style="bold"];
+	queued	    -> bd_sent	   [color="green", style="bold"];
+	queued	    -> failed	   [color="red", style="solid"];
+	queued	    -> failed1	   [color="red", style="solid"];
+	queued	    -> failed2	   [color="red", style="solid"];
+	bd_sent	    -> cb_left2	   [color="green", style="bold"];
+	bd_sent	    -> failed2	   [color="red", style="solid"];
+	cb_left2    -> cb_left1	   [color="green", style="bold"];
+	cb_left2    -> failed1	   [color="red", style="solid"];
+	cb_left1    -> transferred [color="green", style="bold"];
+	cb_left1    -> failed	   [color="red", style="solid"];
+	failed2	    -> failed1	   [color="red", style="solid"];
+	failed1	    -> failed	   [color="red", style="solid"];
+	transferred -> unused	   [color="black", style="dashed"];
+	failed	    -> unused	   [color="black", style="dashed"];
+   }
+   @enddot
 
-   @subsubsection net-test-lspec-algo-server Test Server Algorithm
+   @see @ref net-test-lspec-algo-sm-legend
+
+   Bulk buffer pair states
+   - UNUSED - buffer pair is not used in buffer operations now.
+     It is initial state of buffer pair.
+   - QUEUED - buffer pair is queued or almost added to network bulk queue.
+     See @ref net-test-lspec-bulk-buf-states "RECEIVING state".
+   - BD_SENT - buffer descriptors for bulk buffer pair are sent or almost sent
+     to the test server.  See @ref net-test-lspec-bulk-buf-states "RECEIVING state".
+   - CB_LEFT2(CB_LFET1) - there are 2 (or 1) network buffer callback(s) left
+     for this buffer pair (including network buffer callback for the message
+     with buffer descriptor).
+   - TRANSFERRED - all buffer for this buffer pair and message with buffer
+     descriptors was successfully executed.
+   - FAILED2(FAILED1, FAILED) - some operation failed. Also 2 (1, 0) callbacks
+     left for this buffer pair (like CB_LEFT2, CB_LEFT1).
+
+   Initial state: UNUSED.
+
+   Final states: TRANSFERRED, FAILED.
+
+   Transfer start state: QUEUED.
+
+   Transfer finish state: TRANSFERRED.
+
+   Bulk buffer pair state transitions
+   - UNUSED -> QUEUED
+     - client_process_unused_bulk()
+       - add bulk buffer to passive bulk send queue, then add
+         another bulk buffer in pair to passive recv queue
+   - QUEUED -> BD_SENT
+     - client_process_queued_bulk()
+       - send msg buffer with bulk buffer descriptors
+   - QUEUED -> FAILED
+     - client_process_unused_bulk()
+       - addition to passive send queue failed
+   - QUEUED -> FAILED1
+     - client_process_unused_bulk()
+       - addition to passive recv queue failed
+         - remove from passive send queue already queued buffer
+   - QUEUED -> FAILED2
+     - client_process_queued_bulk()
+       - bulk buffer network descriptors to ping buffer encoding failed
+         - dequeue already queued bulk buffers
+       - addition msg with bulk buffer descriptors to network queue failed
+         - dequeue already queued bulk buffers
+   - BD_SENT -> CB_LEFT2
+   - CB_LEFT2 -> CB_LEFT1
+   - CB_LEFT1 -> TRANSFERRED
+     - network buffer callback
+       - ev->nbe_status == 0
+   - BD_SENT -> FAILED2
+   - CB_LEFT2 -> FAILED1
+   - CB_LEFT1 -> FAILED
+     - network buffer callback
+       - ev->nbe_status != 0
+   - FAILED2 -> FAILED1
+   - FAILED1 -> FAILED
+     - network buffer callback
+   - TRANSFERRED -> UNUSED
+     - node_bulk_state_transition_auto_all()
+       - stats: increase total number of number messages
+   - FAILED -> UNUSED
+     - node_bulk_state_transition_auto_all()
+       - stats: increase total number of test messages and
+         number of failed messages
+
+   @subsubsection net-test-lspec-algo-server-ping Ping Test Server Algorithm
 
    @todo Outdated and not used now.
 
@@ -327,49 +426,139 @@ finished.up();\l", shape=box];
    - M0_NET_QT_MSG_SEND
      - add buffer to msg recv queue
 
-   Bulk test callbacks
-   - M0_NET_QT_MSG_RECV
-     - add first buffer descriptor to ACTIVE_BULK_RECV queue
-     - add msg buffer to MSG_RECV queue
-   - M0_NET_QT_ACTIVE_BULK_RECV
-     - add second buffer descriptor to ACTIVE_BULK_SEND queue
-     (to send just received buffer)
-   - M0_NET_QT_ACTIVE_BULK_SEND
-     - add sent buffer to ACTIVE_BULK_RECV queue
+   @subsubsection net-test-lspec-algo-server-bulk Bulk Test Server Algorithm
+
+   - Every bulk buffer have its own state.
+   - Bulk test server maintains unused bulk buffers queue - the bulk buffer
+     for messages transfer will be taken from this queue when buffer
+     descriptor arrives. If there are no buffers in queue -
+     then buffer descriptor will be discarded, and number of failed and total
+     test messages will be increased.
+
+   @dot
+   digraph {
+	label = "Bulk Test Server Buffer States";
+	unused	    [label="UNUSED"];
+	bd_received [label="BD_RECEIVED"];
+	receiving   [label="RECEIVING"];
+	sending	    [label="SENDING"];
+	transferred [label="TRANSFERRED", peripheries=2];
+	failed	    [label="FAILED", peripheries=2];
+	badmsg	    [label="BADMSG", peripheries=2];
+
+	unused	    -> bd_received [color="green", style="bold"];
+	bd_received -> badmsg	   [color="red", style="solid"];
+	bd_received -> receiving   [color="green", style="bold"];
+	receiving   -> sending	   [color="green", style="bold"];
+	receiving   -> failed	   [color="red", style="solid"];
+	sending	    -> transferred [color="green", style="bold"];
+	sending	    -> failed	   [color="red", style="solid"];
+	transferred -> unused	   [color="black", style="dashed"];
+	failed	    -> unused	   [color="black", style="dashed"];
+	badmsg	    -> unused	   [color="black", style="dashed"];
+   }
+   @enddot
+
+   @see @ref net-test-lspec-algo-sm-legend
+
+   @anchor net-test-lspec-bulk-buf-states
+   Bulk buffer states
+   - UNUSED - bulk buffer isn't currently used in network operations and
+     can be used when passive bulk buffer decriptors arrive.
+   - BD_RECEIVED - message with buffer descriptors was received from the test
+     client.
+   - RECEIVING - bulk buffer added to the active bulk receive queue. Bulk
+     buffer enters this state just before adding to the network queue because
+     network buffer callback may be executed before returning from
+     'add to network buffer queue' function.
+   - SENDING - bulk buffer added to the active bulk send queue. Bulk buffer
+     enters this state as well as for the RECEIVING state.
+   - TRANSFERRED - bulk buffer was successfully received and sent.
+   - FAILED - some operation failed.
+   - BADMSG - message with buffer descriptors contains invalid data.
+
+   Initial state: UNUSED.
+
+   Final states: TRANSFERRED, FAILED, BADMSG.
+
+   Transfer start state: RECEIVING.
+
+   Transfer finish state: TRANSFERRED.
+
+   Bulk buffer state transitions
+
+   - UNUSED -> BD_RECEIVED
+     - M0_NET_QT_MSG_RECV callback
+       - message with buffer decriptors was received from the test client
+   - BD_RECEIVED -> BADMSG
+     - M0_NET_QT_MSG_RECV callback
+       - message with buffer decscriptors contains invalid data
+   - BD_RECEIVED -> RECEIVING
+     - M0_NET_QT_MSG_RECV callback
+       - bulk buffer was successfully added to active bulk receive queue.
+   - RECEIVING -> SENDING
+     - M0_NET_QT_ACTIVE_BULK_RECV callback
+       - bulk buffer was successfully received from the test client.
+   - RECEIVING -> FAILED
+     - M0_NET_QT_MSG_RECV callback
+       - addition to the active bulk receive queue failed.
+     - M0_NET_QT_ACTIVE_BULK_RECV callback
+       - bulk buffer receiving failed.
+   - SENDING -> TRANSFERRED
+     - M0_NET_QT_ACTIVE_BULK_SEND callback
+       - bulk buffer was successfully sent to the test client.
+   - SENDING -> FAILED
+     - M0_NET_QT_ACTIVE_BULK_RECV callback
+       - addition to the active bulk send queue failed.
+     - M0_NET_QT_ACTIVE_BULK_SEND callback
+       - active bulk sending failed.
+   - TRANSFERRED -> UNUSED
+     - node_bulk_state_transition_auto_all()
+       - stats: increase total number of number messages
+   - FAILED -> UNUSED
+     - node_bulk_state_transition_auto_all()
+       - stats: increase total number of test messages and
+         number of failed messages
+   - BADMSG -> UNUSED
+     - node_bulk_state_transition_auto_all()
+       - stats: increase total number of test messages and
+         number of bad messages
 
    @subsubsection net-test-lspec-console Test Console
    @msc
-   console, client, server;
+   console [label="Test Console"],
+   clients [label="Test Clients"],
+   servers [label="Test Servers"];
 
    |||;
-   client rbox client [label = "Listening for console commands"],
-   server rbox server [label = "Listening for console commands"];
-   console => server  [label = "INIT command"];
-   server => console  [label = "INIT DONE response"];
-   ---                [label = "waiting for all servers"];
-   console => client  [label = "INIT command"];
-   client => console  [label = "INIT DONE response"];
-   ---                [label = "waiting for all clients"];
-   console => server  [label = "START command"];
-   server => console  [label = "START ACK response"];
-   ---                [label = "waiting for all servers"];
-   console => client  [label = "START command"];
-   client => console  [label = "START ACK response"];
-   ---                [label = "waiting for all clients"];
-   ---                [label = "running..."];
-   console => client  [label = "STATUS command"];
-   client => console  [label = "STATUS DATA response"];
-   console => server  [label = "STATUS command"];
-   server => console  [label = "STATUS DATA response"];
-   ---                [label = "console wants to stop client&server"];
-   console => client  [label = "STOP command"];
-   client => console  [label = "STOP DONE response"];
-   client rbox client [label = "clients cleanup"];
-   ---                [label = "waiting for all clients"];
-   console => server  [label = "STOP command"];
-   server => console  [label = "STOP DONE response"];
-   server rbox server [label = "server cleanup"];
-   ---                [label = "waiting for all servers"];
+   clients rbox clients	[label = "Listening for console commands"],
+   server rbox server	[label = "Listening for console commands"];
+   console => servers	[label = "INIT command"];
+   servers => console	[label = "INIT DONE response"];
+   ---			[label = "waiting for all servers"];
+   console => clients	[label = "INIT command"];
+   clients => console	[label = "INIT DONE response"];
+   ---			[label = "waiting for all clients"];
+   console => servers	[label = "START command"];
+   servers => console	[label = "START ACK response"];
+   ---			[label = "waiting for all servers"];
+   console => clients	[label = "START command"];
+   clients => console	[label = "START ACK response"];
+   ---			[label = "waiting for all clients"];
+   ---			[label = "running..."];
+   console => clients	[label = "STATUS command"];
+   clients => console	[label = "STATUS DATA response"];
+   console => servers	[label = "STATUS command"];
+   servers => console	[label = "STATUS DATA response"];
+   ---			[label = "console wants to stop client&server"];
+   console => clients	[label = "STOP command"];
+   clients => console	[label = "STOP DONE response"];
+   clients rbox clients	[label = "clients cleanup"];
+   ---			[label = "waiting for all clients"];
+   console => servers	[label = "STOP command"];
+   servers => console	[label = "STOP DONE response"];
+   servers rbox servers	[label = "servers cleanup"];
+   ---			[label = "waiting for all servers"];
    @endmsc
 
    @subsubsection net-test-lspec-misc Misc
@@ -394,12 +583,12 @@ finished.up();\l", shape=box];
    @dot
    digraph {
      node [style=box];
-     label = "Test Client and Test Server States";
+     label = "Test Service States";
      S0 [label="Uninitialized"];
      S1 [label="Ready"];
      S2 [label="Finished"];
      S3 [label="Failed"];
-     S0 -> S1 [label="succesful m0_net_test_service_init()"];
+     S0 -> S1 [label="successful m0_net_test_service_init()"];
      S1 -> S0 [label="m0_net_test_service_fini()"];
      S1 -> S2 [label="service state change: service was finished"];
      S1 -> S3 [label="service state change: service was failed"];
diff --git a/net/test/node.h b/net/test/node.h
index 3b24c3a..7f11445 100644
--- a/net/test/node.h
+++ b/net/test/node.h
@@ -36,6 +36,8 @@
      - @subpage net-test-fspec-cli-node-user "Userspace node"
      - @subpage net-test-fspec-cli-console "Console"
    - @ref net-test-fspec-usecases
+     - @ref net-test-fspec-usecases-bd
+     - @ref net-test-fspec-usecases-serialize
      - @ref net-test-fspec-usecases-kernel
      - @ref net-test-fspec-usecases-console "Console"
    - @ref NetTestDFS "Detailed Functional Specification"
@@ -78,7 +80,70 @@
 
    @section net-test-fspec-usecases Recipes
 
+   @subsection net-test-fspec-usecases-bd Using bulk buffer network descriptors
+
+   Usage pattern for passive side:
+   @code
+   m0_bcount_t offset = 0;
+   m0_bcount_t len;
+   <...>
+   for (bulk buffers) {
+	<add bulk buffer to passive bulk queue>
+	using m0_net_test_network_bulk_enqueue()>
+	len = m0_net_test_network_bd_serialize(M0_NET_TEST_SERIALIZE,
+					       ctx, <buf_bulk_index>,
+					       buf_ping_index, offset);
+	<check for len == 0>
+	offset += len;
+   }
+   @endcode
+   Usage pattern for active side:
+   @code
+   m0_bcount_t offset = 0;
+   m0_bcount_t len;
+   size_t desc_nr;
+   <...>
+   desc_nr = m0_net_test_network_bd_nr(ctx, buf_ping_index);
+   for (i = 0; i < desc_nr; ++i) {
+	len = m0_net_test_network_bd_serialize(M0_NET_TEST_DESERIALIZE,
+					       ctx, <buf_bulk_index>,
+					       buf_ping_index, offset);
+	<check for len == 0>
+	offset += len;
+	<add bulk buffer to active bulk queue>
+   }
+   @endcode
+
+   @subsection net-test-fspec-usecases-serialize Complex serialization
+
+   Usage pattern:
+   @code
+	m0_bcount_t len;
+	m0_bcount_t len_total;
+
+	len = serialize_first_part(...);
+	if (len == 0)
+		return 0;
+	len_total = net_test_len_accumulate(0, len);
+	len = serialize_second_part(...);
+	if (len == 0)
+		return 0;
+	len_total = net_test_len_accumulate(len_total, len);
+	...
+	for (i = 0; i < number_of_items && len_total != 0; ++i) {
+		len = serialize_item(i, ...);
+		len_total = net_test_len_accumulate(len_total, len);
+	}
+	if (len_total == 0)
+		return 0;
+	...
+	len = serialize_last_part(...);
+	len_total = net_test_len_accumulate(len_total, len);
+	return len_total;
+   @endcode
+
    @subsection net-test-fspec-usecases-kernel Kernel module parameters example
+   @todo Outdated and not used now
 
    @code
    node_role=client test_type=ping count=10 target=s1,s2,s3
diff --git a/net/test/node_bulk.c b/net/test/node_bulk.c
index 51cd24b..809cb13 100644
--- a/net/test/node_bulk.c
+++ b/net/test/node_bulk.c
@@ -18,11 +18,20 @@
  * Original creation date: 09/03/2012
  */
 
-#include "lib/errno.h"		/* ENOSYS */
+#include "lib/arith.h"			/* M0_SWAP */
+#include "lib/errno.h"			/* EALREADY */
+#include "lib/memory.h"			/* M0_ALLOC_PTR */
+#include "lib/cdefs.h"			/* ergo */
+#include "lib/trace.h"			/* M0_LOG */
+#include "lib/misc.h"			/* M0_IN */
 
-#include "net/test/network.h"	/* m0_net_test_network_ctx */
-#include "net/test/node.h"	/* m0_net_test_node_ctx */
-#include "net/test/service.h"	/* m0_net_test_service */
+#include "mero/magic.h"		/* M0_NET_TEST_BSB_MAGIC */
+
+#include "net/test/network.h"		/* m0_net_test_network_ctx */
+#include "net/test/node.h"		/* m0_net_test_node_ctx */
+#include "net/test/node_helper.h"	/* m0_net_test_node_ctx */
+#include "net/test/service.h"		/* m0_net_test_service */
+#include "net/test/ringbuf.h"		/* m0_net_test_ringbuf */
 
 #include "net/test/node_bulk.h"
 
@@ -30,9 +39,250 @@
    @defgroup NetTestBulkNodeInternals Bulk Node
    @ingroup NetTestInternals
 
+   Bulk node service m0_net_test_service_ops:
+   - ntso_init
+     - allocate bulk node context
+   - ntso_fini
+     - finalize network context if it was initialized;
+     - free bulk node context
+   - ntso_step
+     - the same as node_ping
+   - ntso_cmd_handler
+     - M0_NET_TEST_CMD_INIT
+       - initialize network context
+       - reset statistics
+       - send M0_NET_TEST_CMD_INIT_DONE reply
+     - M0_NET_TEST_CMD_START
+       - the same as node_ping
+     - M0_NET_TEST_CMD_STOP
+       - the same as node_ping
+     - M0_NET_TEST_CMD_STATUS
+       - fill and send M0_NET_TEST_CMD_STATUS_DATA reply
+
+  Test client:
+  - bulk-buffer-not-in-net-queue queue
+  - ping-buffer-not-in-net-queue queue
+  - enqueue pair <send buf, recv buf> (with m0_net level timeouts)
+  - max_bd_in_one_message (parameter)
+  - send bd list to the test server without waiting for reply
+    or delivery confirmation
+  - number of ping buffers
+  - number of bulk buffers
+
+  Test server:
+  - number of ping buffers
+  - number of bulk buffers
+  - all bulk and ping buffers in recv queue with M0_TIME_NEVER timeout
+
    @{
  */
 
+/**
+ * Test message transfer state.
+ * @see @ref net-test-lspec-algo-client-bulk,
+ *	@ref net-test-lspec-algo-server-bulk.
+ */
+enum transfer_state {
+	TS_UNUSED = 0,		/**< client & server state */
+	TS_QUEUED,		/**< client state */
+	TS_BD_SENT,		/**< client state */
+	TS_CB_LEFT2,		/**< client state */
+	TS_CB_LEFT1,		/**< client state */
+	TS_FAILED2,		/**< client state */
+	TS_FAILED1,		/**< client state */
+	TS_BD_RECEIVED,		/**< server state */
+	TS_SENDING,		/**< server state */
+	TS_RECEIVING,		/**< server state */
+	TS_BADMSG,		/**< client & server state */
+	TS_FAILED,		/**< client & server state */
+	TS_TRANSFERRED,		/**< client & server state */
+};
+
+/**
+ * Return values for network operations.
+ * @todo add timestamp
+ */
+struct buf_status_errno {
+	int bse_func_rc;	/**< Network buffer addition to queue */
+	int bse_cb_rc;		/**< Network buffer callback */
+};
+
+/** Bulk transfer status */
+struct buf_status_bulk {
+	/** Magic for bsb_tlink */
+	uint64_t		bsb_magic;
+	/** State of bulk transfer */
+	enum transfer_state	bsb_ts;
+	/**
+	 * Bulk buffer index for the test server and
+	 * bulk buffer pair index for the test client.
+	 */
+	size_t			bsb_index;
+	/** Link for server_status_bulk.ssb_buffers */
+	struct m0_tlink		bsb_tlink;
+	/** M0_NET_QT_MSG_SEND, M0_NET_QT_MSG_RECV functions and callbacks. */
+	struct buf_status_errno bsb_msg;
+	/**
+	 * M0_NET_QT_ACTIVE_SEND, M0_NET_QT_PASSIVE_SEND
+	 * functions and callbacks.
+	 */
+	struct buf_status_errno bsb_send;
+	/**
+	 * M0_NET_QT_ACTIVE_RECV, M0_NET_QT_PASSIVE_RECV
+	 * functions and callbacks.
+	 */
+	struct buf_status_errno bsb_recv;
+	/**
+	 * Bulk buffer network descriptor for M0_NET_QT_ACTIVE_BULK_SEND
+	 * network queue (test server).
+	 */
+	struct m0_net_buf_desc  bsb_desc_send;
+	/** Transfer start time */
+	m0_time_t		bsb_time_start;
+	/** Transfer finish time */
+	m0_time_t		bsb_time_finish;
+};
+
+/** Buffer of message with bulk buffer network descriptors status */
+struct buf_status_ping {
+	/** Magic for bsp_tlink */
+	uint64_t	bsp_magic;
+	/** Ping buffer index */
+	size_t		bsp_index;
+	/**
+	 * Message contains network descriptors for the buffer
+	 * pairs for the test client (or buffers for the test server)
+	 * from this list.
+	 */
+	struct m0_tl	bsp_buffers;
+	/** Link for ping buffer list */
+	struct m0_tlink bsp_tlink;
+};
+
+/** Server status for the test client */
+struct server_status_bulk {
+	/** Magic for ssb_tlink */
+	uint64_t	ssb_magic;
+	/** Server index */
+	size_t		ssb_index;
+	/** Link for list of servers */
+	struct m0_tlink ssb_tlink;
+	/** List of queued buffers for this server */
+	struct m0_tl	ssb_buffers;
+};
+
+/**
+ * State transition. Used in state transition checks instead of
+ * transition matrix because number of allowed state transitions is
+ * less than total number of possible state transitions in a few times.
+ * @see transfer_state
+ */
+struct state_transition {
+	enum transfer_state sta_from;	/**< Current state */
+	enum transfer_state sta_to;	/**< New state */
+};
+
+M0_TL_DESCR_DEFINE(bsb, "buf_status_bulk", static,
+		   struct buf_status_bulk, bsb_tlink, bsb_magic,
+		   M0_NET_TEST_BSB_MAGIC, M0_NET_TEST_BSB_HEAD_MAGIC);
+M0_TL_DEFINE(bsb, static, struct buf_status_bulk);
+
+M0_TL_DESCR_DEFINE(ssb, "server_status_bulk", static,
+		   struct server_status_bulk, ssb_tlink, ssb_magic,
+		   M0_NET_TEST_SSB_MAGIC, M0_NET_TEST_SSB_HEAD_MAGIC);
+M0_TL_DEFINE(ssb, static, struct server_status_bulk);
+
+M0_TL_DESCR_DEFINE(bsp, "buf_status_ping", static,
+		   struct buf_status_ping, bsp_tlink, bsp_magic,
+		   M0_NET_TEST_BSP_MAGIC, M0_NET_TEST_BSP_HEAD_MAGIC);
+M0_TL_DEFINE(bsp, static, struct buf_status_ping);
+
+/**
+ * Bulk test context.
+ * Buffer mapping for the test client:
+ * even buffers - for sending
+ * odd buffers - for receiving
+ * first (nbc_client_concurrency * 2) buffers for server #0, next
+ * (nbc_client_concurrency * 2) buffers for server #1 and so on.
+ * Buffer mapping for the test server:
+ * All buffers are used for receiving and sending.
+ * @todo move equal parts from node_bulk_ctx & node_ping_ctx to single struct
+ */
+struct node_bulk_ctx {
+	/** Node helper */
+	struct m0_net_test_nh		   nbc_nh;
+	/** Network context for testing */
+	struct m0_net_test_network_ctx	   nbc_net;
+	/** Test service. Used when changing service state. */
+	struct m0_net_test_service	  *nbc_svc;
+	/** Worker thread */
+	struct m0_thread		   nbc_thread;
+	/** Number of ping buffers */
+	size_t				   nbc_buf_ping_nr;
+	/** Number of bulk buffers */
+	size_t				   nbc_buf_bulk_nr;
+	/** Ping buffer size */
+	m0_bcount_t			   nbc_buf_size_ping;
+	/** Bulk buffer size */
+	m0_bcount_t			   nbc_buf_size_bulk;
+	/** Maximum number of buffer descriptors, stored to ping buffer */
+	size_t				   nbc_bd_nr_max;
+	/** Bulk buffer states */
+	struct buf_status_bulk		  *nbc_bs;
+	/** Number of bulk buffer states */
+	size_t				   nbc_bs_nr;
+	/** Ping buffer states */
+	struct buf_status_ping		  *nbc_bsp;
+	/** List of unused message buffers */
+	struct m0_net_test_ringbuf	   nbc_rb_ping_unused;
+	/** List of unused bulk buffers */
+	struct m0_net_test_ringbuf	   nbc_rb_bulk_unused;
+	/**
+	 * List of added to passive network queue buffers.
+	 * Network buffer descriptors wasn't sent yet for these buffers.
+	 */
+	struct m0_net_test_ringbuf	   nbc_rb_bulk_queued;
+	/**
+	 * List of bulk transfers, that are in final state.
+	 */
+	struct m0_net_test_ringbuf	   nbc_rb_bulk_final;
+	/**
+	 * Test client concurrency.
+	 * Test client will send nbc_client_concurrency test messages to
+	 * every server simultaneously.
+	 */
+	size_t				   nbc_client_concurrency;
+	/** Per server status for the test client */
+	struct server_status_bulk	  *nbc_sstatus;
+	/**
+	 * Channel for bulk testing inner loop.
+	 * STOP command will send signal to this channel.
+	 */
+	struct m0_chan			   nbc_stop_chan;
+	/**
+	 * Clink for bulk testing inner loop.
+	 * This clink is head for clink group, consists of this clink
+	 * and network transfer machine notification clink.
+	 */
+	struct m0_clink			   nbc_stop_clink;
+	/** Stop flag */
+	bool				   nbc_stop_flag;
+	/**
+	 * At least one callback was executed.
+	 * Set to true in every callback.
+	 */
+	bool				   nbc_callback_executed;
+};
+
+/** Wrapper for m0_net_test_nh_sd_update() with smaller name */
+static void sd_update(struct node_bulk_ctx *ctx,
+		      enum m0_net_test_nh_msg_type type,
+		      enum m0_net_test_nh_msg_status status,
+		      enum m0_net_test_nh_msg_direction direction)
+{
+	m0_net_test_nh_sd_update(&ctx->nbc_nh, type, status, direction);
+}
+
 static void node_bulk_tm_event_cb(const struct m0_net_tm_event *ev)
 {
 	/* nothing for now */
@@ -42,32 +292,1133 @@ static const struct m0_net_tm_callbacks node_bulk_tm_cb = {
 	.ntc_event_cb = node_bulk_tm_event_cb
 };
 
-static void node_bulk_msg_cb(struct m0_net_test_network_ctx *net_ctx,
-			     const uint32_t buf_index,
-			     enum m0_net_queue_type q,
-			     const struct m0_net_buffer_event *ev)
+static struct node_bulk_ctx *
+node_bulk_ctx_from_net_ctx(struct m0_net_test_network_ctx *net_ctx)
+{
+	return container_of(net_ctx, struct node_bulk_ctx, nbc_net);
+}
+
+static bool
+node_bulk_state_change_allowed(enum transfer_state from,
+			       enum transfer_state to,
+			       const struct state_transition allowed[],
+			       size_t allowed_size)
+{
+	size_t i;
+
+	M0_PRE(allowed != NULL);
+	M0_PRE(allowed_size > 0);
+
+	for (i = 0; i < allowed_size; ++i) {
+		if (allowed[i].sta_from == from && allowed[i].sta_to == to)
+			break;
+	}
+	return i < allowed_size;
+}
+
+static void node_bulk_state_change(struct node_bulk_ctx *ctx,
+				   size_t bs_index,
+				   enum transfer_state state)
+{
+	static const struct state_transition allowed_client[] = {
+		{ .sta_from = TS_UNUSED,	.sta_to = TS_QUEUED },
+		{ .sta_from = TS_QUEUED,	.sta_to = TS_BD_SENT },
+		{ .sta_from = TS_QUEUED,	.sta_to = TS_FAILED },
+		{ .sta_from = TS_QUEUED,	.sta_to = TS_FAILED1 },
+		{ .sta_from = TS_QUEUED,	.sta_to = TS_FAILED2 },
+		{ .sta_from = TS_BD_SENT,	.sta_to = TS_CB_LEFT2 },
+		{ .sta_from = TS_BD_SENT,	.sta_to = TS_FAILED2 },
+		{ .sta_from = TS_CB_LEFT2,	.sta_to = TS_CB_LEFT1 },
+		{ .sta_from = TS_CB_LEFT2,	.sta_to = TS_FAILED1 },
+		{ .sta_from = TS_CB_LEFT1,	.sta_to = TS_TRANSFERRED },
+		{ .sta_from = TS_CB_LEFT1,	.sta_to = TS_FAILED },
+		{ .sta_from = TS_FAILED2,	.sta_to = TS_FAILED1 },
+		{ .sta_from = TS_FAILED1,	.sta_to = TS_FAILED },
+		{ .sta_from = TS_TRANSFERRED,	.sta_to = TS_UNUSED },
+		{ .sta_from = TS_FAILED,	.sta_to = TS_UNUSED },
+	};
+	static const struct state_transition allowed_server[] = {
+		{ .sta_from = TS_UNUSED,	.sta_to = TS_BD_RECEIVED },
+		{ .sta_from = TS_BD_RECEIVED,	.sta_to = TS_BADMSG },
+		{ .sta_from = TS_BD_RECEIVED,	.sta_to = TS_RECEIVING },
+		{ .sta_from = TS_RECEIVING,	.sta_to = TS_SENDING },
+		{ .sta_from = TS_RECEIVING,	.sta_to = TS_FAILED },
+		{ .sta_from = TS_SENDING,	.sta_to = TS_TRANSFERRED },
+		{ .sta_from = TS_SENDING,	.sta_to = TS_FAILED },
+		{ .sta_from = TS_TRANSFERRED,	.sta_to = TS_UNUSED },
+		{ .sta_from = TS_FAILED,	.sta_to = TS_UNUSED },
+		{ .sta_from = TS_BADMSG,	.sta_to = TS_UNUSED },
+	};
+	enum m0_net_test_role	role;
+	struct buf_status_bulk *bs;
+	bool			can_change;
+	bool			role_client;
+
+	M0_PRE(ctx != NULL);
+	M0_PRE(bs_index < ctx->nbc_bs_nr);
+	M0_PRE(ctx->nbc_bs != NULL);
+
+	/*
+	M0_LOG(M0_DEBUG, "state_change: role = %d, bs_index = %lu, state = %d",
+	       ctx->nbc_nh.ntnh_role, bs_index, state);
+	*/
+
+	role = ctx->nbc_nh.ntnh_role;
+	bs = &ctx->nbc_bs[bs_index];
+	role_client = role == M0_NET_TEST_ROLE_CLIENT;
+	can_change = node_bulk_state_change_allowed(bs->bsb_ts, state,
+			role_client ? allowed_client : allowed_server,
+			role_client ? ARRAY_SIZE(allowed_client) :
+				      ARRAY_SIZE(allowed_server));
+	M0_ASSERT(can_change);
+	bs->bsb_ts = state;
+
+	/* add to ringbufs if needed */
+	if (state == TS_UNUSED)
+		m0_net_test_ringbuf_push(&ctx->nbc_rb_bulk_unused, bs_index);
+	if (M0_IN(state, (TS_FAILED, TS_TRANSFERRED, TS_BADMSG)))
+		m0_net_test_ringbuf_push(&ctx->nbc_rb_bulk_final, bs_index);
+	/* set start & finish timestamp */
+	if (M0_IN(state, (TS_RECEIVING, TS_QUEUED)))
+		bs->bsb_time_start = m0_time_now();
+	if (state == TS_TRANSFERRED)
+		bs->bsb_time_finish = m0_time_now();
+	/* reset buf_status_errno if needed */
+	if (state == TS_UNUSED) {
+		M0_SET0(&bs->bsb_msg);
+		M0_SET0(&bs->bsb_send);
+		M0_SET0(&bs->bsb_recv);
+	}
+}
+
+static const struct state_transition node_bulk_client_success[] = {
+	{ .sta_from = TS_BD_SENT,	.sta_to = TS_CB_LEFT2 },
+	{ .sta_from = TS_CB_LEFT2,	.sta_to = TS_CB_LEFT1 },
+	{ .sta_from = TS_CB_LEFT1,	.sta_to = TS_TRANSFERRED },
+	{ .sta_from = TS_FAILED2,	.sta_to = TS_FAILED1 },
+	{ .sta_from = TS_FAILED1,	.sta_to = TS_FAILED },
+};
+static const struct state_transition node_bulk_client_failure[] = {
+	{ .sta_from = TS_BD_SENT,	.sta_to = TS_FAILED2 },
+	{ .sta_from = TS_CB_LEFT2,	.sta_to = TS_FAILED1 },
+	{ .sta_from = TS_CB_LEFT1,	.sta_to = TS_FAILED },
+	{ .sta_from = TS_FAILED2,	.sta_to = TS_FAILED1 },
+	{ .sta_from = TS_FAILED1,	.sta_to = TS_FAILED },
+};
+static const struct state_transition node_bulk_server_success[] = {
+	{ .sta_from = TS_RECEIVING,	.sta_to = TS_SENDING },
+	{ .sta_from = TS_SENDING,	.sta_to = TS_TRANSFERRED },
+};
+static const struct state_transition node_bulk_server_failure[] = {
+	{ .sta_from = TS_RECEIVING,	.sta_to = TS_FAILED },
+	{ .sta_from = TS_SENDING,	.sta_to = TS_FAILED },
+};
+
+static const struct {
+	const struct state_transition *nbst_transition;
+	const size_t		       nbst_nr;
+} node_bulk_state_transitions[] = {
+#define TRANSITION(name) {		\
+	.nbst_transition = name,	\
+	.nbst_nr = ARRAY_SIZE(name),	\
+}
+	TRANSITION(node_bulk_client_success),
+	TRANSITION(node_bulk_client_failure),
+	TRANSITION(node_bulk_server_success),
+	TRANSITION(node_bulk_server_failure),
+#undef TRANSITION
+};
+
+/** Check for unique "from" state in the list */
+static void node_bulk_state_check(const struct state_transition state_list[],
+				  size_t state_nr)
+{
+	size_t i;
+	size_t j;
+
+	for (i = 0; i < state_nr; ++i) {
+		for (j = i + 1; j < state_nr; ++j) {
+			M0_ASSERT(state_list[i].sta_from !=
+				  state_list[j].sta_from);
+		}
+	}
+}
+
+/** Check for unique "from" state in all state transitions */
+static void node_bulk_state_check_all(void)
 {
+	size_t i;
+
+	for (i = 0; i < ARRAY_SIZE(node_bulk_state_transitions); ++i) {
+		node_bulk_state_check(
+			node_bulk_state_transitions[i].nbst_transition,
+			node_bulk_state_transitions[i].nbst_nr);
+	}
+}
+
+static enum transfer_state
+node_bulk_state_search(enum transfer_state state,
+		       const struct state_transition state_list[],
+		       size_t state_nr)
+{
+	size_t i;
+
+	for (i = 0; i < state_nr; ++i) {
+		if (state_list[i].sta_from == state)
+			return state_list[i].sta_to;
+	}
+	M0_IMPOSSIBLE("Invalid 'from' state in net-test bulk testing.");
+}
+
+static void node_bulk_state_change_cb(struct node_bulk_ctx *ctx,
+				      size_t bs_index,
+				      bool success)
+{
+	const struct state_transition *transition;
+	size_t			       transition_size;
+	enum transfer_state	       state;
+
+	M0_PRE(ctx != NULL);
+	M0_PRE(bs_index < ctx->nbc_bs_nr);
+	M0_PRE(ctx->nbc_bs != NULL);
+
+	if (ctx->nbc_nh.ntnh_role == M0_NET_TEST_ROLE_CLIENT) {
+		transition	= success ?
+				  node_bulk_client_success :
+				  node_bulk_client_failure;
+		transition_size = success ?
+				  ARRAY_SIZE(node_bulk_client_success) :
+				  ARRAY_SIZE(node_bulk_client_failure);
+	} else if (ctx->nbc_nh.ntnh_role == M0_NET_TEST_ROLE_SERVER) {
+		transition	= success ?
+				  node_bulk_server_success :
+				  node_bulk_server_failure;
+		transition_size = success ?
+				  ARRAY_SIZE(node_bulk_server_success) :
+				  ARRAY_SIZE(node_bulk_server_failure);
+	} else {
+		M0_IMPOSSIBLE("Invalid node role in net-test bulk testing");
+	}
+	state = node_bulk_state_search(ctx->nbc_bs[bs_index].bsb_ts,
+				       transition, transition_size);
+	node_bulk_state_change(ctx, bs_index, state);
+}
+
+void node_bulk_state_transition_auto(struct node_bulk_ctx *ctx,
+				     size_t bs_index)
+{
+	struct buf_status_bulk *bs;
+	bool			role_client;
+	m0_time_t		rtt;
+
+	M0_PRE(ctx != NULL);
+	M0_PRE(bs_index < ctx->nbc_bs_nr);
+
+	role_client = ctx->nbc_nh.ntnh_role == M0_NET_TEST_ROLE_CLIENT;
+	bs = &ctx->nbc_bs[bs_index];
+	/* Check final states */
+	M0_ASSERT(M0_IN(bs->bsb_ts, (TS_TRANSFERRED, TS_FAILED)) ||
+		  (!role_client && bs->bsb_ts == TS_BADMSG));
+	switch (bs->bsb_ts) {
+	case TS_TRANSFERRED:
+		rtt = m0_time_sub(bs->bsb_time_finish, bs->bsb_time_start);
+		sd_update(ctx, MT_TRANSFER, MS_SUCCESS, MD_BOTH);
+		m0_net_test_nh_sd_update_rtt(&ctx->nbc_nh, rtt);
+		break;
+	case TS_FAILED:
+		sd_update(ctx, MT_TRANSFER, MS_FAILED, MD_BOTH);
+		break;
+	case TS_BADMSG:
+		sd_update(ctx, MT_MSG, MS_BAD, MD_RECV);
+		break;
+	default:
+		M0_IMPOSSIBLE("Impossible final state in "
+			      "net-test bulk testing");
+	}
+	node_bulk_state_change(ctx, bs_index, TS_UNUSED);
+}
+
+void node_bulk_state_transition_auto_all(struct node_bulk_ctx *ctx)
+{
+	size_t bs_index;
+	size_t i;
+	size_t nr;
+
+	M0_PRE(ctx != NULL);
+
+	nr = m0_net_test_ringbuf_nr(&ctx->nbc_rb_bulk_final);
+	for (i = 0; i < nr; ++i) {
+		bs_index = m0_net_test_ringbuf_pop(&ctx->nbc_rb_bulk_final);
+		node_bulk_state_transition_auto(ctx, bs_index);
+	}
+	M0_POST(m0_net_test_ringbuf_is_empty(&ctx->nbc_rb_bulk_final));
+}
+
+static void server_process_unused_ping(struct node_bulk_ctx *ctx)
+{
+	size_t index;
+	size_t i;
+	size_t nr;
+	int    rc;
+
+	M0_PRE(ctx != NULL);
+
+	nr = m0_net_test_ringbuf_nr(&ctx->nbc_rb_ping_unused);
+	for (i = 0; i < nr; ++i) {
+		index = m0_net_test_ringbuf_pop(&ctx->nbc_rb_ping_unused);
+		rc = m0_net_test_network_msg_recv(&ctx->nbc_net, index);
+		if (rc != 0) {
+			sd_update(ctx, MT_MSG, MS_FAILED, MD_RECV);
+			m0_net_test_ringbuf_push(&ctx->nbc_rb_ping_unused,
+						 index);
+		}
+	}
+}
+
+static struct m0_net_buffer *net_buf_bulk_get(struct node_bulk_ctx *ctx,
+					      size_t buf_bulk_index)
+{
+	return m0_net_test_network_buf(&ctx->nbc_net, M0_NET_TEST_BUF_BULK,
+				       buf_bulk_index);
+}
+
+static void buf_desc_set0(struct node_bulk_ctx *ctx,
+			  size_t buf_bulk_index)
+{
+	M0_PRE(ctx != NULL);
+	M0_PRE(buf_bulk_index < ctx->nbc_buf_bulk_nr);
+
+	M0_SET0(&net_buf_bulk_get(ctx, buf_bulk_index)->nb_desc);
+	M0_SET0(&ctx->nbc_bs[buf_bulk_index].bsb_desc_send);
 }
 
 /**
-@todo static
-*/
-struct m0_net_test_network_buffer_callbacks node_bulk_buf_cb = {
+ * Swap contents of network buf descriptors for bulk network buffer
+ * buf_index and buf_status_bulk.bsb_desc_send for this buffer.
+ */
+static void buf_desc_swap(struct node_bulk_ctx *ctx,
+			  size_t buf_bulk_index)
+{
+	M0_PRE(ctx != NULL);
+	M0_PRE(buf_bulk_index < ctx->nbc_buf_bulk_nr);
+
+	M0_SWAP(net_buf_bulk_get(ctx, buf_bulk_index)->nb_desc,
+		ctx->nbc_bs[buf_bulk_index].bsb_desc_send);
+}
+
+static void buf_desc_free(struct node_bulk_ctx *ctx,
+			  size_t buf_bulk_index)
+{
+	M0_PRE(ctx != NULL);
+	M0_PRE(buf_bulk_index < ctx->nbc_buf_bulk_nr);
+
+	m0_net_desc_free(&net_buf_bulk_get(ctx, buf_bulk_index)->nb_desc);
+	m0_net_desc_free(&ctx->nbc_bs[buf_bulk_index].bsb_desc_send);
+}
+
+static m0_bcount_t buf_desc_deserialize(struct node_bulk_ctx *ctx,
+					size_t buf_bulk_index,
+					size_t buf_ping_index,
+					m0_bcount_t offset)
+{
+	m0_bcount_t len;
+	m0_bcount_t len_total;
+
+	M0_PRE(ctx != NULL);
+	M0_PRE(buf_ping_index < ctx->nbc_buf_ping_nr);
+	M0_PRE(buf_bulk_index < ctx->nbc_buf_bulk_nr);
+
+	buf_desc_set0(ctx, buf_bulk_index);
+	/* decode network buffer descriptors for active bulk receiving */
+	len = m0_net_test_network_bd_serialize(M0_NET_TEST_DESERIALIZE,
+					       &ctx->nbc_net, buf_bulk_index,
+					       buf_ping_index, offset);
+	if (len == 0)
+		return 0;
+	len_total = net_test_len_accumulate(0, len);
+
+	/*
+	 * buf->nb_desc = zero descriptor
+	 * bs->bsb_desc_send = descriptor for active bulk receiving
+	 */
+	buf_desc_swap(ctx, buf_bulk_index);
+
+	len = m0_net_test_network_bd_serialize(M0_NET_TEST_DESERIALIZE,
+					       &ctx->nbc_net, buf_bulk_index,
+					       buf_ping_index,
+					       offset + len_total);
+	if (len == 0) {
+		/* free already allocated network descriptor */
+		buf_desc_free(ctx, buf_bulk_index);
+		return 0;
+	}
+	len_total = net_test_len_accumulate(len_total, len);
+
+	/*
+	 * buf->nb_desc = descriptor for active bulk receiving
+	 * bs->bsb_desc_send = descriptor for active bulk sending
+	 */
+	buf_desc_swap(ctx, buf_bulk_index);
+
+	return len_total;
+}
+
+/**
+ * Start network transfer. Take two network buffer descriptors from
+ * buf_ping_index in ctx->nbc_net with given offset in buffer.
+ * @return number of bytes read.
+ * @return 0 if no free bulk buffer found or deserializing failed.
+ */
+static m0_bcount_t node_bulk_server_transfer_start(struct node_bulk_ctx *ctx,
+						   size_t buf_ping_index,
+						   m0_bcount_t offset)
+{
+	struct buf_status_bulk *bs;
+	struct m0_net_buffer   *buf;
+	m0_bcount_t		len;
+	size_t			buf_bulk_index;
+	bool			no_unused_buf;
+	int			rc;
+
+	no_unused_buf = m0_net_test_ringbuf_is_empty(&ctx->nbc_rb_bulk_unused);
+	if (no_unused_buf) {
+		M0_LOG(M0_DEBUG, "--- NO UNUSED BUFS");
+		sd_update(ctx, MT_TRANSFER, MS_FAILED, MD_BOTH);
+		return 0;
+	}
+
+	/* get unused buf */
+	buf_bulk_index = m0_net_test_ringbuf_pop(&ctx->nbc_rb_bulk_unused);
+	M0_ASSERT(buf_bulk_index < ctx->nbc_buf_bulk_nr);
+	node_bulk_state_change(ctx, buf_bulk_index, TS_BD_RECEIVED);
+	/* deserialize network buffer descriptors */
+	len = buf_desc_deserialize(ctx, buf_bulk_index, buf_ping_index, offset);
+	if (len == 0) {
+		M0_LOG(M0_DEBUG, "BADMSG: buf_bulk_index = %lu, "
+				 "buf_ping_index = %lu, "
+				 "offset = %lu",
+				 buf_bulk_index, buf_ping_index,
+				 (unsigned long) offset);
+		/* ping buffer contains invalid data */
+		node_bulk_state_change(ctx, buf_bulk_index, TS_BADMSG);
+		return 0;
+	}
+	node_bulk_state_change(ctx, buf_bulk_index, TS_RECEIVING);
+	/* start active bulk receiving */
+	rc = m0_net_test_network_bulk_enqueue(&ctx->nbc_net, buf_bulk_index, 0,
+					      M0_NET_QT_ACTIVE_BULK_RECV);
+	bs = &ctx->nbc_bs[buf_bulk_index];
+	buf = m0_net_test_network_buf(&ctx->nbc_net, M0_NET_TEST_BUF_BULK,
+				      buf_bulk_index);
+	bs->bsb_recv.bse_func_rc = rc;
+	if (rc != 0) {
+		/*
+		 * Addition buffer to network queue failed.
+		 * Free allocated (when deserialized) network descriptors.
+		 */
+		node_bulk_state_change(ctx, buf_bulk_index, TS_FAILED);
+		m0_net_desc_free(&bs->bsb_desc_send);
+		m0_net_desc_free(&buf->nb_desc);
+		sd_update(ctx, MT_BULK, MS_FAILED, MD_RECV);
+	}
+	return rc == 0 ? len : 0;
+}
+
+static void node_bulk_cb_server(struct node_bulk_ctx *ctx,
+				size_t buf_index,
+				enum m0_net_queue_type q,
+				const struct m0_net_buffer_event *ev)
+{
+	m0_bcount_t offset;
+	m0_bcount_t len;
+	size_t	    nr;
+	size_t	    i;
+	int	    rc;
+
+	M0_PRE(ctx != NULL);
+	M0_PRE(ctx->nbc_nh.ntnh_role == M0_NET_TEST_ROLE_SERVER);
+	M0_PRE(ergo(q == M0_NET_QT_MSG_RECV, buf_index < ctx->nbc_buf_ping_nr));
+	M0_PRE(ergo(q == M0_NET_QT_ACTIVE_BULK_RECV ||
+		    q == M0_NET_QT_ACTIVE_BULK_SEND,
+		    buf_index < ctx->nbc_buf_bulk_nr));
+
+	if (q == M0_NET_QT_MSG_RECV) {
+		if (ev->nbe_status != 0)
+			return;
+		nr = m0_net_test_network_bd_nr(&ctx->nbc_net, buf_index);
+		if (nr % 2 != 0) {
+			M0_LOG(M0_DEBUG, "MS_BAD: nr = %lu", nr);
+			sd_update(ctx, MT_MSG, MS_BAD, MD_RECV);
+			return;
+		}
+		nr /= 2;
+		offset = 0;
+		for (i = 0; i < nr; ++i) {
+			len = node_bulk_server_transfer_start(ctx, buf_index,
+							      offset);
+			offset += len;
+		}
+	} else if (q == M0_NET_QT_ACTIVE_BULK_RECV) {
+		if (ev->nbe_status != 0) {
+			M0_LOG(M0_DEBUG, "--- active bulk recv FAILED!");
+			buf_desc_free(ctx, buf_index);
+			return;
+		}
+		/*
+		 * Don't free m0_net_buf_desc here to avoid
+		 * memory allocator delays.
+		 */
+		buf_desc_swap(ctx, buf_index);
+		rc = m0_net_test_network_bulk_enqueue(&ctx->nbc_net,
+						      buf_index, 0,
+						M0_NET_QT_ACTIVE_BULK_SEND);
+		ctx->nbc_bs[buf_index].bsb_send.bse_func_rc = rc;
+		if (rc != 0) {
+			M0_LOG(M0_DEBUG, "--- active bulk send FAILED!");
+			buf_desc_free(ctx, buf_index);
+			node_bulk_state_change(ctx, buf_index, TS_FAILED);
+			sd_update(ctx, MT_BULK, MS_FAILED, MD_SEND);
+		}
+	} else if (q == M0_NET_QT_ACTIVE_BULK_SEND) {
+		buf_desc_free(ctx, buf_index);
+	}
+}
+
+static void node_bulk_cb(struct m0_net_test_network_ctx *net_ctx,
+			 const uint32_t buf_index,
+			 enum m0_net_queue_type q,
+			 const struct m0_net_buffer_event *ev)
+{
+	struct buf_status_bulk	*bs;
+	size_t			 bs_index;
+	struct buf_status_errno *bs_e;
+	struct node_bulk_ctx	*ctx = node_bulk_ctx_from_net_ctx(net_ctx);
+	bool			 role_client;
+	bool			 buf_send;
+	bool			 buf_bulk;
+
+	/*
+	M0_LOG(M0_DEBUG, "node_bulk_cb: tm_addr = %s, buf_index = %u, q = %d"
+			 ", ev-nbe_status = %d",
+	       net_ctx->ntc_tm->ntm_ep->nep_addr, buf_index, q, ev->nbe_status);
+	*/
+	M0_PRE(net_ctx != NULL);
+	role_client = ctx->nbc_nh.ntnh_role == M0_NET_TEST_ROLE_CLIENT;
+	M0_PRE(ergo(q == M0_NET_QT_MSG_RECV, !role_client));
+	M0_PRE(ergo(q == M0_NET_QT_MSG_SEND, role_client));
+	M0_PRE(ergo(q == M0_NET_QT_PASSIVE_BULK_RECV, role_client));
+	M0_PRE(ergo(q == M0_NET_QT_PASSIVE_BULK_SEND, role_client));
+	M0_PRE(ergo(q == M0_NET_QT_ACTIVE_BULK_RECV, !role_client));
+	M0_PRE(ergo(q == M0_NET_QT_ACTIVE_BULK_SEND, !role_client));
+	M0_PRE(ergo(q == M0_NET_QT_MSG_RECV || q == M0_NET_QT_MSG_SEND,
+		    buf_index < ctx->nbc_buf_ping_nr));
+
+	if (ev->nbe_status != 0 && ev->nbe_status != -ECANCELED) {
+		M0_LOG(M0_DEBUG, "--CALLBACK ERROR! errno = %d",
+		       ev->nbe_status);
+		M0_LOG(M0_DEBUG, "node_bulk_cb: tm_addr = %s, "
+				 "buf_index = %u, q = %d"
+				 ", ev-nbe_status = %d",
+	       net_ctx->ntc_tm->ntm_ep->nep_addr, buf_index, q, ev->nbe_status);
+	}
+
+	ctx->nbc_callback_executed = true;
+	buf_bulk = false;
+	if (M0_IN(q,
+		  (M0_NET_QT_PASSIVE_BULK_RECV, M0_NET_QT_ACTIVE_BULK_RECV,
+		   M0_NET_QT_PASSIVE_BULK_SEND, M0_NET_QT_ACTIVE_BULK_SEND))) {
+		buf_bulk = true;
+		bs_index = role_client ? buf_index / 2 : buf_index;
+		M0_ASSERT(bs_index < ctx->nbc_bs_nr);
+		bs = &ctx->nbc_bs[bs_index];
+		bs_e = q == M0_NET_QT_PASSIVE_BULK_RECV ||
+		       q == M0_NET_QT_ACTIVE_BULK_RECV ? &bs->bsb_recv :
+		       q == M0_NET_QT_PASSIVE_BULK_SEND ||
+		       q == M0_NET_QT_ACTIVE_BULK_SEND ? &bs->bsb_send : NULL;
+		M0_ASSERT(bs_e != NULL);
+		bs_e->bse_cb_rc = ev->nbe_status;
+		node_bulk_state_change_cb(ctx, bs_index, ev->nbe_status == 0);
+	}
+	if (role_client && q == M0_NET_QT_MSG_SEND) {
+		/*
+		 * Change state for every bulk buffer, which
+		 * descriptor is stored in current message.
+		 */
+		m0_tl_for(bsb, &ctx->nbc_bsp[buf_index].bsp_buffers, bs) {
+			bs->bsb_msg.bse_cb_rc = ev->nbe_status;
+			node_bulk_state_change_cb(ctx, bs->bsb_index,
+						  ev->nbe_status == 0);
+			bsb_tlist_del(bs);
+		} m0_tl_endfor;
+	}
+	if (!role_client)
+		node_bulk_cb_server(ctx, buf_index, q, ev);
+	if (q == M0_NET_QT_MSG_SEND || q == M0_NET_QT_MSG_RECV) {
+		/* ping buffer can be reused now */
+		m0_net_test_ringbuf_push(&ctx->nbc_rb_ping_unused, buf_index);
+	}
+	if (!role_client && q == M0_NET_QT_MSG_RECV) {
+		/*
+		 * @todo nbc_stop_flag isn't protected here with lock.
+		 * is it safe?
+		 */
+		if (!ctx->nbc_stop_flag)
+			server_process_unused_ping(ctx);
+	}
+	/* update stats */
+	buf_send = q == M0_NET_QT_PASSIVE_BULK_SEND ||
+		   q == M0_NET_QT_ACTIVE_BULK_SEND || q == M0_NET_QT_MSG_SEND;
+	sd_update(ctx, buf_bulk ? MT_BULK : MT_MSG,
+		  ev->nbe_status == 0 ? MS_SUCCESS : MS_FAILED,
+		  buf_send ? MD_SEND : MD_RECV);
+	/* state transitions from final states */
+	node_bulk_state_transition_auto_all(ctx);
+	/* reuse ping buffer on the test server */
+}
+
+static struct m0_net_test_network_buffer_callbacks node_bulk_buf_cb = {
 	.ntnbc_cb = {
-		[M0_NET_QT_MSG_RECV]		= node_bulk_msg_cb,
-		[M0_NET_QT_MSG_SEND]		= node_bulk_msg_cb,
-		[M0_NET_QT_PASSIVE_BULK_RECV]	= node_bulk_msg_cb,
-		[M0_NET_QT_PASSIVE_BULK_SEND]	= node_bulk_msg_cb,
-		[M0_NET_QT_ACTIVE_BULK_RECV]	= node_bulk_msg_cb,
-		[M0_NET_QT_ACTIVE_BULK_SEND]	= node_bulk_msg_cb,
+		[M0_NET_QT_MSG_RECV]		= node_bulk_cb,
+		[M0_NET_QT_MSG_SEND]		= node_bulk_cb,
+		[M0_NET_QT_PASSIVE_BULK_RECV]	= node_bulk_cb,
+		[M0_NET_QT_PASSIVE_BULK_SEND]	= node_bulk_cb,
+		[M0_NET_QT_ACTIVE_BULK_RECV]	= node_bulk_cb,
+		[M0_NET_QT_ACTIVE_BULK_SEND]	= node_bulk_cb,
 	}
 };
 
+/** Get server index for a given buffer index */
+static size_t client_server_index(struct node_bulk_ctx *ctx, size_t buf_index)
+{
+	M0_PRE(ctx != NULL);
+	M0_PRE(ctx->nbc_client_concurrency > 0);
+
+	return buf_index / (2 * ctx->nbc_client_concurrency);
+}
+
+/** Enqueue passive send/recv buffers for the test client */
+static int client_bulk_enqueue(struct node_bulk_ctx *ctx,
+			       size_t buf_index)
+{
+	enum m0_net_queue_type q;
+	size_t		       server_index;
+
+	q = buf_index % 2 == 0 ? M0_NET_QT_PASSIVE_BULK_SEND :
+				 M0_NET_QT_PASSIVE_BULK_RECV;
+	server_index = client_server_index(ctx, buf_index / 2);
+	return m0_net_test_network_bulk_enqueue(&ctx->nbc_net, buf_index,
+						server_index, q);
+}
+
+static void client_bulk_dequeue(struct node_bulk_ctx *ctx,
+				size_t buf_index)
+{
+	m0_net_test_network_buffer_dequeue(&ctx->nbc_net, M0_NET_TEST_BUF_BULK,
+					   buf_index);
+}
+
+static void client_transfer_start(struct node_bulk_ctx *ctx,
+				  size_t bs_index)
+{
+	struct buf_status_bulk *bs;
+	int			rc;
+
+	M0_PRE(ctx != NULL);
+	M0_PRE(bs_index < ctx->nbc_bs_nr);
+
+	bs = &ctx->nbc_bs[bs_index];
+	node_bulk_state_change(ctx, bs_index, TS_QUEUED);
+	rc = client_bulk_enqueue(ctx, bs_index * 2);
+	bs->bsb_send.bse_func_rc = rc;
+	if (rc != 0) {
+		M0_LOG(M0_DEBUG, "123");
+		node_bulk_state_change(ctx, bs_index, TS_FAILED);
+		sd_update(ctx, MT_BULK, MS_FAILED, MD_SEND);
+		return;
+	}
+	rc = client_bulk_enqueue(ctx, bs_index * 2 + 1);
+	bs->bsb_recv.bse_func_rc = rc;
+	if (rc != 0) {
+		M0_LOG(M0_DEBUG, "456");
+		node_bulk_state_change(ctx, bs_index, TS_FAILED1);
+		client_bulk_dequeue(ctx, bs_index * 2);
+		sd_update(ctx, MT_BULK, MS_FAILED, MD_RECV);
+		return;
+	}
+	m0_net_test_ringbuf_push(&ctx->nbc_rb_bulk_queued, bs_index);
+}
+
+static void client_process_unused_bulk(struct node_bulk_ctx *ctx)
+{
+	size_t i;
+	size_t nr;
+	size_t bs_index;
+	bool   transfer_next;
+
+	M0_PRE(ctx != NULL);
+
+	nr = m0_net_test_ringbuf_nr(&ctx->nbc_rb_bulk_unused);
+	for (i = 0; i < nr; ++i) {
+		/* Check stop conditions */
+		transfer_next = m0_net_test_nh_transfer_next(&ctx->nbc_nh);
+		/*
+		M0_LOG(M0_DEBUG, "client: transfer_next = %s",
+		       transfer_next ? (char *) "true" : (char *) "false");
+		*/
+		if (!transfer_next)
+			break;
+		/* Start next transfer */
+		bs_index = m0_net_test_ringbuf_pop(&ctx->nbc_rb_bulk_unused);
+		/*
+		M0_LOG(M0_DEBUG, "client: next transfer bs_index = %lu",
+		       bs_index);
+		*/
+		client_transfer_start(ctx, bs_index);
+	}
+}
+
+static m0_bcount_t client_bds_serialize2(struct m0_net_test_network_ctx *net,
+					 size_t bsb_index,
+					 size_t msg_buf_index,
+					 m0_bcount_t offset)
+{
+	m0_bcount_t len;
+	m0_bcount_t len_total;
+
+	len = m0_net_test_network_bd_serialize(M0_NET_TEST_SERIALIZE,
+					       net, bsb_index * 2,
+					       msg_buf_index, offset);
+	if (len == 0)
+		return 0;
+	len_total = net_test_len_accumulate(0, len);
+
+	len = m0_net_test_network_bd_serialize(M0_NET_TEST_SERIALIZE,
+					       net, bsb_index * 2 + 1,
+					       msg_buf_index,
+					       offset + len_total);
+	if (len == 0) {
+		/*
+		 * If first buffer descriptor serializing succeed,
+		 * then number of serialized network buffer descriptors
+		 * is increased. But if second serializing fails, then
+		 * number of network buffer descriptors inside ping
+		 * buffer should be decreased because these two
+		 * descriptors should be added both or should not be
+		 * added at all.
+		 */
+		m0_net_test_network_bd_nr_dec(net, msg_buf_index);
+	}
+	len_total = net_test_len_accumulate(len_total, len);
+	return len_total;
+}
+
+
+static void client_bulk_bufs_dequeue(struct node_bulk_ctx *ctx,
+				     struct buf_status_bulk *bs)
+{
+	client_bulk_dequeue(ctx, bs->bsb_index * 2);
+	client_bulk_dequeue(ctx, bs->bsb_index * 2 + 1);
+}
+
+static void client_bds_send(struct node_bulk_ctx *ctx,
+			    struct server_status_bulk *ss)
+{
+	struct m0_net_test_ringbuf *rb_ping = &ctx->nbc_rb_ping_unused;
+	struct buf_status_bulk	   *bs;
+	/* Message buffer was taken from unused list */
+	bool			   msg_taken;
+	/* Message buffer index, makes sense iff (msg_taken) */
+	size_t			   msg_index;
+	/* Number of buffer descriptors in selected message buffer */
+	size_t			   msg_bd_nr;
+	struct buf_status_ping	  *msg_bs;
+	m0_bcount_t		   msg_offset;
+	m0_bcount_t		   len;
+	bool			   buf_last;
+	int			   rc;
+	struct m0_tl		   messages;
+	bool			   list_is_empty;
+
+	M0_PRE(ctx != NULL);
+	M0_PRE(ss != NULL);
+	M0_PRE(ctx->nbc_bd_nr_max > 0 && ctx->nbc_bd_nr_max % 2 == 0);
+
+	bsp_tlist_init(&messages);
+	msg_taken = false;
+	m0_tl_for(bsb, &ss->ssb_buffers, bs) {
+take_msg:
+		if (!msg_taken && m0_net_test_ringbuf_is_empty(rb_ping)) {
+			/*
+			 * No free message to transfer bulk buffer
+			 * network descriptors. Cancel tranfers.
+			 */
+			node_bulk_state_change(ctx, bs->bsb_index, TS_FAILED2);
+			client_bulk_bufs_dequeue(ctx, bs);
+			sd_update(ctx, MT_MSG, MS_FAILED, MD_SEND);
+			bsb_tlist_del(bs);
+			continue;
+		}
+		/* Take unused msg buf number if it wasn't taken before */
+		if (!msg_taken) {
+			msg_index     = m0_net_test_ringbuf_pop(rb_ping);
+			msg_taken     = true;
+			msg_bd_nr     = 0;
+			msg_offset    = 0;
+			msg_bs	      = &ctx->nbc_bsp[msg_index];
+			list_is_empty =
+				bsb_tlist_is_empty(&msg_bs->bsp_buffers);
+			M0_ASSERT(list_is_empty);
+		}
+		/* Try to serialize two buffer descriptors */
+		len = client_bds_serialize2(&ctx->nbc_net, bs->bsb_index,
+					    msg_index, msg_offset);
+		/*
+		M0_LOG(M0_DEBUG, "msg_index = %lu, len = %lu, msg_offset = %lu",
+		       (unsigned long ) msg_index, (unsigned long ) len,
+		       (unsigned long ) msg_offset);
+		*/
+		msg_offset += len;
+		if (len == 0) {
+			if (msg_bd_nr > 0) {
+				/* No free space in ping buffer */
+				bsp_tlist_add_tail(&messages, msg_bs);
+				msg_taken = false;
+				goto take_msg;
+			} else {
+				/*
+				 * Serializing failed for unknown reason
+				 * (or ping buffer is smaller than
+				 * size of two serialized bulk
+				 * network buffer descriptors)
+				 */
+				node_bulk_state_change(ctx, bs->bsb_index,
+						       TS_FAILED2);
+				client_bulk_bufs_dequeue(ctx, bs);
+				bsb_tlist_del(bs);
+				msg_taken = false;
+			}
+		} else {
+			buf_last = bsb_tlist_next(&ss->ssb_buffers, bs) == NULL;
+			bsb_tlist_del(bs);
+			bsb_tlist_add_tail(&msg_bs->bsp_buffers, bs);
+			msg_bd_nr += 2;
+			if (msg_bd_nr == ctx->nbc_bd_nr_max || buf_last) {
+				bsp_tlist_add_tail(&messages, msg_bs);
+				msg_taken = false;
+			}
+		}
+	} m0_tl_endfor;
+	M0_ASSERT(!msg_taken);
+	m0_tl_for(bsp, &messages, msg_bs) {
+		list_is_empty = bsb_tlist_is_empty(&msg_bs->bsp_buffers);
+		M0_ASSERT(!list_is_empty);
+		/*
+		 * Change state to BD_SENT for every bulk buffer, which
+		 * descriptor is stored in current message.
+		 */
+		m0_tl_for(bsb, &msg_bs->bsp_buffers, bs) {
+			node_bulk_state_change(ctx, bs->bsb_index, TS_BD_SENT);
+		} m0_tl_endfor;
+		rc = m0_net_test_network_msg_send(&ctx->nbc_net,
+						  msg_bs->bsp_index,
+						  ss->ssb_index);
+		if (rc != 0) {
+			M0_LOG(M0_DEBUG, "--- msg send FAILED!");
+			sd_update(ctx, MT_MSG, MS_FAILED, MD_SEND);
+		}
+		/* Save rc for future analysis */
+		m0_tl_for(bsb, &msg_bs->bsp_buffers, bs) {
+			bs->bsb_msg.bse_func_rc = rc;
+			/* Change state if msg sending failed */
+			if (rc != 0) {
+				node_bulk_state_change(ctx, bs->bsb_index,
+						       TS_FAILED2);
+				client_bulk_bufs_dequeue(ctx, bs);
+				bsb_tlist_del(bs);
+			}
+		} m0_tl_endfor;
+		bsp_tlist_del(msg_bs);
+	} m0_tl_endfor;
+	bsp_tlist_fini(&messages);
+}
+
+static void client_process_queued_bulk(struct node_bulk_ctx *ctx)
+{
+	struct server_status_bulk *ss;
+	struct buf_status_bulk	  *bs;
+	struct m0_tl		   servers;
+	size_t			   index;
+	size_t			   i;
+	size_t			   nr;
+
+	M0_PRE(ctx != NULL);
+
+	ssb_tlist_init(&servers);
+	nr = m0_net_test_ringbuf_nr(&ctx->nbc_rb_bulk_queued);
+	/* Add queued buffer to per server list of queued buffers */
+	for (i = 0; i < nr; ++i) {
+		index = m0_net_test_ringbuf_pop(&ctx->nbc_rb_bulk_queued);
+		bs = &ctx->nbc_bs[index];
+		ss = &ctx->nbc_sstatus[client_server_index(ctx, index)];
+		bsb_tlist_add_tail(&ss->ssb_buffers, bs);
+		if (!ssb_tlink_is_in(ss))
+			ssb_tlist_add_tail(&servers, ss);
+	}
+	/* Send message with buffer descriptors to every server */
+	m0_tl_for(ssb, &servers, ss) {
+		client_bds_send(ctx, ss);
+		ssb_tlist_del(ss);
+	} m0_tl_endfor;
+	ssb_tlist_fini(&servers);
+}
+
+static void node_bulk_buf_unused(struct node_bulk_ctx *ctx)
+{
+	size_t i;
+
+	M0_PRE(ctx != NULL);
+
+	for (i = 0; i < ctx->nbc_bs_nr; ++i) {
+		ctx->nbc_bs[i].bsb_ts = TS_UNUSED;
+		m0_net_test_ringbuf_push(&ctx->nbc_rb_bulk_unused, i);
+	}
+	for (i = 0; i < ctx->nbc_buf_ping_nr; ++i)
+		m0_net_test_ringbuf_push(&ctx->nbc_rb_ping_unused, i);
+}
+
+static void node_bulk_buf_dequeue(struct node_bulk_ctx *ctx)
+{
+	size_t i;
+
+	M0_PRE(ctx != NULL);
+	for (i = 0; i < ctx->nbc_buf_ping_nr; ++i) {
+		m0_net_test_network_buffer_dequeue(&ctx->nbc_net,
+						   M0_NET_TEST_BUF_PING, i);
+	}
+	for (i = 0; i < ctx->nbc_buf_bulk_nr; ++i) {
+		m0_net_test_network_buffer_dequeue(&ctx->nbc_net,
+						   M0_NET_TEST_BUF_BULK, i);
+	}
+}
+
+static void node_bulk_worker(struct node_bulk_ctx *ctx)
+{
+	struct m0_clink	tm_clink;
+	struct m0_chan	tm_chan;
+	bool		notify;
+
+	M0_PRE(ctx != NULL);
+
+	/* all buffers are unused */
+	node_bulk_buf_unused(ctx);
+	/* attach tm_clink to clink group to wait for two signals at once */
+	m0_clink_attach(&tm_clink, &ctx->nbc_stop_clink, NULL);
+	/*
+	 * Init wait channel and clink.
+	 * Transfer machine will signal to this channel.
+	 */
+	m0_chan_init(&tm_chan);
+	m0_clink_add(&tm_chan, &tm_clink);
+	/* main loop */
+	notify = true;
+	while (1) {
+		if (ctx->nbc_nh.ntnh_role == M0_NET_TEST_ROLE_CLIENT) {
+			client_process_unused_bulk(ctx);
+			client_process_queued_bulk(ctx);
+		} else {
+			server_process_unused_ping(ctx);
+		}
+		/* notification for buffer events */
+		if (notify) {
+			m0_net_buffer_event_notify(ctx->nbc_net.ntc_tm,
+						   &tm_chan);
+			notify = false;
+		}
+		ctx->nbc_callback_executed = false;
+		/* execute network buffer callbacks in this thread context */
+		m0_net_buffer_event_deliver_all(ctx->nbc_net.ntc_tm);
+		/* state transitions from final states */
+		node_bulk_state_transition_auto_all(ctx);
+		/* update copy of statistics */
+		m0_net_test_nh_sd_copy_locked(&ctx->nbc_nh);
+		/* wait for STOP command or buffer event */
+		if (!ctx->nbc_callback_executed)
+			m0_chan_wait(&ctx->nbc_stop_clink);
+		/* it was STOP command */
+		if (ctx->nbc_stop_flag)
+			break;
+		if (!ctx->nbc_callback_executed)
+			notify = true;
+	}
+	/* dequeue all queued network buffers */
+	node_bulk_buf_dequeue(ctx);
+	m0_net_buffer_event_deliver_all(ctx->nbc_net.ntc_tm);
+	node_bulk_state_transition_auto_all(ctx);
+	m0_net_test_nh_sd_copy_locked(&ctx->nbc_nh);
+}
+
 static void *node_bulk_init_fini(struct m0_net_test_service *svc,
 				 void *ctx_,
 				 bool init)
 {
-	return NULL;
+	struct node_bulk_ctx *ctx;
+
+	M0_PRE(ergo(init, ctx_ == NULL));
+	M0_PRE(ergo(init, svc != NULL));
+	if (init) {
+		M0_ALLOC_PTR(ctx);
+		if (ctx != NULL) {
+			ctx->nbc_svc			  = svc;
+			ctx->nbc_nh.ntnh_test_initialized = false;
+		}
+	} else {
+		ctx = NULL;
+	}
+	return ctx;
+}
+
+static int node_bulk_test_init_fini(struct node_bulk_ctx *ctx,
+				    const struct m0_net_test_cmd *cmd,
+				    bool init)
+{
+	struct m0_net_test_network_timeouts timeouts;
+	const struct m0_net_test_cmd_init  *icmd;
+	struct server_status_bulk	   *ss;
+	struct buf_status_ping		   *msg_bs;
+	int				    rc;
+	size_t				    i;
+	bool				    role_client;
+	m0_time_t			    to_send;
+	m0_time_t			    to_bulk;
+	size_t				    nr;
+
+	M0_PRE(ctx != NULL);
+	M0_PRE(equi(init, cmd != NULL));
+
+	if (!init)
+		goto fini;
+	icmd	    = &cmd->ntc_init;
+	role_client = icmd->ntci_role == M0_NET_TEST_ROLE_CLIENT;
+
+	rc = -ENOMEM;
+	M0_ALLOC_ARR(ctx->nbc_bs, ctx->nbc_bs_nr);
+	if (ctx->nbc_bs == NULL)
+		goto fail;
+	for (i = 0; i < ctx->nbc_bs_nr; ++i) {
+		ctx->nbc_bs[i].bsb_index = i;
+		bsb_tlink_init(&ctx->nbc_bs[i]);
+		M0_SET0(&ctx->nbc_bs[i].bsb_desc_send);
+	}
+
+	if (role_client) {
+		M0_ALLOC_ARR(ctx->nbc_sstatus, icmd->ntci_ep.ntsl_nr);
+		if (ctx->nbc_sstatus == NULL)
+			goto free_bs_bulk;
+		for (i = 0; i < icmd->ntci_ep.ntsl_nr; ++i) {
+			ss = &ctx->nbc_sstatus[i];
+			ss->ssb_index = i;
+			bsb_tlist_init(&ss->ssb_buffers);
+			ssb_tlink_init(ss);
+		}
+		M0_ALLOC_ARR(ctx->nbc_bsp, ctx->nbc_buf_ping_nr);
+		if (ctx->nbc_bsp == NULL)
+			goto free_sstatus;
+		for (i = 0; i < ctx->nbc_buf_ping_nr; ++i) {
+			msg_bs = &ctx->nbc_bsp[i];
+			msg_bs->bsp_index = i;
+			bsb_tlist_init(&msg_bs->bsp_buffers);
+			bsp_tlink_init(msg_bs);
+		}
+	}
+
+	M0_ASSERT(equi(role_client, ctx->nbc_sstatus != NULL));
+
+	rc = m0_net_test_ringbuf_init(&ctx->nbc_rb_ping_unused,
+				      ctx->nbc_buf_ping_nr);
+	if (rc != 0)
+		goto free_bsp;
+	rc = m0_net_test_ringbuf_init(&ctx->nbc_rb_bulk_unused,
+				      ctx->nbc_bs_nr);
+	if (rc != 0)
+		goto free_rb_ping_unused;
+	rc = m0_net_test_ringbuf_init(&ctx->nbc_rb_bulk_queued,
+				      ctx->nbc_bs_nr);
+	if (rc != 0)
+		goto free_rb_bulk_unused;
+	rc = m0_net_test_ringbuf_init(&ctx->nbc_rb_bulk_final,
+				      ctx->nbc_bs_nr);
+	if (rc != 0)
+		goto free_rb_bulk_queued;
+
+	to_send  = icmd->ntci_buf_send_timeout;
+	to_bulk  = icmd->ntci_buf_bulk_timeout;
+	timeouts = m0_net_test_network_timeouts_never();
+	timeouts.ntnt_timeout[M0_NET_QT_MSG_SEND]	   = to_send;
+	timeouts.ntnt_timeout[M0_NET_QT_PASSIVE_BULK_RECV] = to_bulk;
+	timeouts.ntnt_timeout[M0_NET_QT_PASSIVE_BULK_SEND] = to_bulk;
+	timeouts.ntnt_timeout[M0_NET_QT_ACTIVE_BULK_RECV]  = to_bulk;
+	timeouts.ntnt_timeout[M0_NET_QT_ACTIVE_BULK_SEND]  = to_bulk;
+
+	rc = m0_net_test_network_ctx_init(&ctx->nbc_net,
+					  icmd->ntci_tm_ep,
+					  &node_bulk_tm_cb,
+					  &node_bulk_buf_cb,
+					  ctx->nbc_buf_size_ping,
+					  ctx->nbc_buf_ping_nr,
+					  ctx->nbc_buf_size_bulk,
+					  ctx->nbc_buf_bulk_nr,
+					  icmd->ntci_ep.ntsl_nr,
+					  &timeouts, true);
+	if (rc != 0)
+		goto free_rb_bulk_final;
+	rc = m0_net_test_network_ep_add_slist(&ctx->nbc_net, &icmd->ntci_ep);
+	if (rc != 0)
+		goto fini;
+	m0_chan_init(&ctx->nbc_stop_chan);
+	m0_clink_init(&ctx->nbc_stop_clink, NULL);
+	m0_clink_add(&ctx->nbc_stop_chan, &ctx->nbc_stop_clink);
+	goto success;
+fini:
+	icmd = NULL;
+	rc = 0;
+	m0_clink_del(&ctx->nbc_stop_clink);
+	m0_clink_fini(&ctx->nbc_stop_clink);
+	m0_chan_fini(&ctx->nbc_stop_chan);
+	m0_net_test_network_ctx_fini(&ctx->nbc_net);
+free_rb_bulk_final:
+	m0_net_test_ringbuf_fini(&ctx->nbc_rb_bulk_final);
+free_rb_bulk_queued:
+	m0_net_test_ringbuf_fini(&ctx->nbc_rb_bulk_queued);
+free_rb_bulk_unused:
+	m0_net_test_ringbuf_fini(&ctx->nbc_rb_bulk_unused);
+free_rb_ping_unused:
+	m0_net_test_ringbuf_fini(&ctx->nbc_rb_ping_unused);
+free_bsp:
+	if (ctx->nbc_nh.ntnh_role == M0_NET_TEST_ROLE_CLIENT) {
+		for (i = 0; i < ctx->nbc_buf_ping_nr; ++i) {
+			msg_bs = &ctx->nbc_bsp[i];
+			bsp_tlink_init(msg_bs);
+			bsb_tlist_fini(&msg_bs->bsp_buffers);
+		}
+		m0_free(ctx->nbc_bsp);
+	}
+free_sstatus:
+	if (ctx->nbc_nh.ntnh_role == M0_NET_TEST_ROLE_CLIENT) {
+		nr = init ? icmd->ntci_ep.ntsl_nr : ctx->nbc_net.ntc_ep_nr;
+		for (i = 0; i < nr; ++i) {
+			ss = &ctx->nbc_sstatus[i];
+			ssb_tlink_fini(ss);
+			bsb_tlist_fini(&ss->ssb_buffers);
+		}
+		m0_free(ctx->nbc_sstatus);
+	}
+free_bs_bulk:
+	for (i = 0; i < ctx->nbc_bs_nr; ++i)
+		bsb_tlink_fini(&ctx->nbc_bs[i]);
+	m0_free(ctx->nbc_bs);
+fail:
+success:
+	return rc;
 }
 
 static void *node_bulk_init(struct m0_net_test_service *svc)
@@ -83,35 +1434,146 @@ static void node_bulk_fini(void *ctx_)
 
 static int node_bulk_step(void *ctx_)
 {
-	return -ENOSYS;
+	return 0;
 }
 
 static int node_bulk_cmd_init(void *ctx_,
 			      const struct m0_net_test_cmd *cmd,
 			      struct m0_net_test_cmd *reply)
 {
-	return -ENOSYS;
+	const struct m0_net_test_cmd_init *icmd;
+	struct node_bulk_ctx		  *ctx = ctx_;
+	int				   rc;
+	bool				   role_client;
+
+	M0_PRE(ctx != NULL);
+	M0_PRE(cmd != NULL);
+	M0_PRE(reply != NULL);
+
+	if (ctx->nbc_nh.ntnh_test_initialized) {
+		rc = -EALREADY;
+		goto reply;
+	}
+	icmd		       = &cmd->ntc_init;
+	m0_net_test_nh_init(&ctx->nbc_nh, icmd);
+	role_client	       = icmd->ntci_role == M0_NET_TEST_ROLE_CLIENT;
+	ctx->nbc_buf_size_bulk = icmd->ntci_msg_size;
+	ctx->nbc_buf_ping_nr   = icmd->ntci_bd_buf_nr;
+	ctx->nbc_buf_size_ping = icmd->ntci_bd_buf_size;
+	ctx->nbc_bd_nr_max     = icmd->ntci_bd_nr_max;
+	ctx->nbc_bs_nr	       = icmd->ntci_msg_concurrency;
+	ctx->nbc_buf_bulk_nr   = ctx->nbc_bs_nr;
+
+	if (role_client) {
+		ctx->nbc_client_concurrency  = icmd->ntci_msg_concurrency;
+		ctx->nbc_buf_bulk_nr	    *= 2 * icmd->ntci_ep.ntsl_nr;
+		ctx->nbc_bs_nr		     = ctx->nbc_buf_bulk_nr / 2;
+	}
+
+	/* do sanity check */
+	rc = -EINVAL;
+	if (!ergo(role_client, ctx->nbc_buf_bulk_nr % 2 == 0) ||
+	    ctx->nbc_buf_bulk_nr < 1 || ctx->nbc_buf_size_bulk < 1 ||
+	    ctx->nbc_buf_ping_nr < 1 || ctx->nbc_buf_size_ping < 1 ||
+	    ctx->nbc_bd_nr_max < 1 || ctx->nbc_bs_nr < 1 ||
+	    (ctx->nbc_nh.ntnh_role != M0_NET_TEST_ROLE_CLIENT &&
+	     ctx->nbc_nh.ntnh_role != M0_NET_TEST_ROLE_SERVER) ||
+	    !ergo(role_client, ctx->nbc_client_concurrency != 0) ||
+	    !ergo(!role_client, ctx->nbc_bs_nr == ctx->nbc_buf_bulk_nr) ||
+	    !ergo(role_client, 2 * ctx->nbc_bs_nr == ctx->nbc_buf_bulk_nr))
+		goto reply;
+
+	rc = node_bulk_test_init_fini(ctx, cmd, true);
+reply:
+	/* fill reply */
+	reply->ntc_type = M0_NET_TEST_CMD_INIT_DONE;
+	reply->ntc_done.ntcd_errno = rc;
+	return rc;
 }
 
-static int node_bulk_cmd_start(void *ctx,
+/** @todo copy-paste from node_ping.c. refactor it. */
+static int node_bulk_cmd_start(void *ctx_,
 			       const struct m0_net_test_cmd *cmd,
 			       struct m0_net_test_cmd *reply)
 {
-	return -ENOSYS;
+	struct m0_net_test_cmd_status_data *sd;
+	int				    rc;
+	struct node_bulk_ctx		   *ctx = ctx_;
+	const m0_time_t			    _1s = M0_MKTIME(1, 0);
+
+	M0_PRE(ctx != NULL);
+	M0_PRE(cmd != NULL);
+	M0_PRE(reply != NULL);
+
+	sd = &ctx->nbc_nh.ntnh_sd;
+
+	/** @todo copy-paste from node_ping.c */
+	/* fill test start time */
+	sd->ntcsd_time_start = m0_time_now();
+	/* initialize stats */
+	m0_net_test_mps_init(&sd->ntcsd_mps_send, 0, sd->ntcsd_time_start, _1s);
+	m0_net_test_mps_init(&sd->ntcsd_mps_recv, 0, sd->ntcsd_time_start, _1s);
+	ctx->nbc_stop_flag = false;
+	rc = M0_THREAD_INIT(&ctx->nbc_thread, struct node_bulk_ctx *, NULL,
+			    &node_bulk_worker, ctx,
+			    "net-test-bulk-worker#%s",
+			    ctx->nbc_net.ntc_tm->ntm_ep->nep_addr);
+	if (rc != 0) {
+		/* change service state */
+		m0_net_test_service_state_change(ctx->nbc_svc,
+						 M0_NET_TEST_SERVICE_FAILED);
+	}
+	/* fill reply */
+	reply->ntc_type = M0_NET_TEST_CMD_START_DONE;
+	reply->ntc_done.ntcd_errno = rc;
+	return rc;
 }
 
-static int node_bulk_cmd_stop(void *ctx,
+/** @todo copy-paste from node_ping.c. refactor it. */
+static int node_bulk_cmd_stop(void *ctx_,
 			      const struct m0_net_test_cmd *cmd,
 			      struct m0_net_test_cmd *reply)
 {
-	return -ENOSYS;
+	struct node_bulk_ctx *ctx = ctx_;
+	int		      rc;
+
+	M0_PRE(ctx != NULL);
+	M0_PRE(cmd != NULL);
+	M0_PRE(reply != NULL);
+
+	if (!ctx->nbc_nh.ntnh_test_initialized) {
+		reply->ntc_done.ntcd_errno = -EINVAL;
+		goto reply;
+	}
+	/* stop worker thread */
+	ctx->nbc_stop_flag = true;
+	m0_chan_signal(&ctx->nbc_stop_chan);
+	rc = m0_thread_join(&ctx->nbc_thread);
+	M0_ASSERT(rc == 0);
+	m0_thread_fini(&ctx->nbc_thread);
+	/* finalize test structures */
+	rc = node_bulk_test_init_fini(ctx, NULL, false);
+	M0_ASSERT(rc == 0);
+	/* change service state */
+	m0_net_test_service_state_change(ctx->nbc_svc,
+					 M0_NET_TEST_SERVICE_FINISHED);
+	/* fill reply */
+	reply->ntc_done.ntcd_errno = 0;
+reply:
+	reply->ntc_type = M0_NET_TEST_CMD_STOP_DONE;
+	return 0;
 }
 
-static int node_bulk_cmd_status(void *ctx,
+static int node_bulk_cmd_status(void *ctx_,
 				const struct m0_net_test_cmd *cmd,
 				struct m0_net_test_cmd *reply)
 {
-	return -ENOSYS;
+	struct node_bulk_ctx *ctx = ctx_;
+
+	M0_PRE(ctx != NULL);
+
+	m0_net_test_nh_cmd_status(&ctx->nbc_nh, cmd, reply);
+	return 0;
 }
 
 static struct m0_net_test_service_cmd_handler node_bulk_cmd_handler[] = {
@@ -141,6 +1603,16 @@ struct m0_net_test_service_ops m0_net_test_node_bulk_ops = {
 	.ntso_cmd_handler_nr = ARRAY_SIZE(node_bulk_cmd_handler),
 };
 
+int m0_net_test_node_bulk_init(void)
+{
+	node_bulk_state_check_all();
+	return 0;
+}
+
+void m0_net_test_node_bulk_fini(void)
+{
+}
+
 /**
    @} end of NetTestBulkNodeInternals group
  */
diff --git a/net/test/node_bulk.h b/net/test/node_bulk.h
index 48d7632..8ca6c28 100644
--- a/net/test/node_bulk.h
+++ b/net/test/node_bulk.h
@@ -34,6 +34,9 @@
 
 extern struct m0_net_test_service_ops m0_net_test_node_bulk_ops;
 
+int m0_net_test_node_bulk_init(void);
+void m0_net_test_node_bulk_fini(void);
+
 /**
    @} end of NetTestBulkNodeDFS group
  */
diff --git a/net/test/node_helper.c b/net/test/node_helper.c
new file mode 100644
index 0000000..4b045e7
--- /dev/null
+++ b/net/test/node_helper.c
@@ -0,0 +1,169 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Maxim Medved <max_medved@xyratex.com>
+ * Original creation date: 11/07/2012
+ */
+
+#include "lib/trace.h"			/* M0_LOG */
+#include "lib/misc.h"			/* M0_IN */
+
+#include "net/test/node_helper.h"
+
+/**
+   @defgroup NetTestNodeHelperInternals Node helper
+   @ingroup NetTestInternals
+
+   @{
+ */
+
+void m0_net_test_nh_init(struct m0_net_test_nh *nh,
+			 const struct m0_net_test_cmd_init *icmd)
+{
+	M0_PRE(nh != NULL);
+	M0_PRE(!nh->ntnh_test_initialized);
+
+	M0_SET0(nh);
+	m0_mutex_init(&nh->ntnh_sd_copy_lock);
+	nh->ntnh_role		  = icmd->ntci_role;
+	nh->ntnh_type		  = icmd->ntci_type;
+	nh->ntnh_test_initialized = true;
+	nh->ntnh_transfers_max_nr = icmd->ntci_msg_nr == 0 ?
+				    UINT64_MAX : icmd->ntci_msg_nr;
+	/** @todo reset all stats */
+	m0_net_test_stats_reset(&nh->ntnh_sd.ntcsd_rtt);
+}
+
+bool m0_net_test_nh__invariant(struct m0_net_test_nh *nh)
+{
+	return nh != NULL;
+}
+
+void m0_net_test_nh_fini(struct m0_net_test_nh *nh)
+{
+	M0_PRE(m0_net_test_nh__invariant(nh));
+
+	m0_mutex_fini(&nh->ntnh_sd_copy_lock);
+}
+
+void m0_net_test_nh_sd_copy_locked(struct m0_net_test_nh *nh)
+{
+	M0_PRE(m0_net_test_nh__invariant(nh));
+
+	m0_mutex_lock(&nh->ntnh_sd_copy_lock);
+	nh->ntnh_sd_copy = nh->ntnh_sd;
+	m0_mutex_unlock(&nh->ntnh_sd_copy_lock);
+}
+
+void m0_net_test_nh_sd_get_locked(struct m0_net_test_nh *nh,
+				struct m0_net_test_cmd_status_data *sd)
+{
+	M0_PRE(m0_net_test_nh__invariant(nh));
+
+	m0_mutex_lock(&nh->ntnh_sd_copy_lock);
+	*sd = nh->ntnh_sd_copy;
+	sd->ntcsd_time_now = m0_time_now();
+	m0_mutex_unlock(&nh->ntnh_sd_copy_lock);
+}
+
+void m0_net_test_nh_sd_update(struct m0_net_test_nh *nh,
+			      enum m0_net_test_nh_msg_type type,
+			      enum m0_net_test_nh_msg_status status,
+			      enum m0_net_test_nh_msg_direction direction)
+{
+	struct m0_net_test_cmd_status_data *sd = &nh->ntnh_sd;
+	struct m0_net_test_msg_nr	   *msg_nr;
+	struct m0_net_test_mps		   *mps;
+
+	M0_PRE(m0_net_test_nh__invariant(nh));
+	M0_PRE(M0_IN(type, (MT_MSG, MT_BULK, MT_TRANSFER)));
+	M0_PRE(M0_IN(status, (MS_SUCCESS, MS_FAILED, MS_BAD)));
+	M0_PRE(M0_IN(direction, (MD_SEND, MD_RECV, MD_BOTH)));
+	M0_PRE(equi(type == MT_TRANSFER, direction == MD_BOTH));
+
+	if (type == MT_MSG) {
+		msg_nr = direction == MD_SEND ? &sd->ntcsd_msg_nr_send :
+						&sd->ntcsd_msg_nr_recv;
+	} else if (type == MT_BULK) {
+		msg_nr = direction == MD_SEND ? &sd->ntcsd_bulk_nr_send :
+						&sd->ntcsd_bulk_nr_recv;
+	} else {
+		msg_nr = &sd->ntcsd_transfers;
+	}
+
+	/* update 'number of messages' statistics */
+	++msg_nr->ntmn_total;
+	msg_nr->ntmn_failed += status == MS_FAILED;
+	msg_nr->ntmn_bad    += status == MS_BAD;
+	/* update 'messages per second' statistics */
+	if (type != MT_TRANSFER &&
+	    equi(type == MT_MSG, nh->ntnh_type == M0_NET_TEST_TYPE_PING)) {
+		mps = direction == MD_SEND ? &sd->ntcsd_mps_send :
+					     &sd->ntcsd_mps_recv;
+		m0_net_test_mps_add(mps, msg_nr->ntmn_total, m0_time_now());
+	}
+	if (type == MT_TRANSFER && nh->ntnh_role == M0_NET_TEST_ROLE_CLIENT) {
+		/* update 'finished' flag */
+		M0_ASSERT(msg_nr->ntmn_total <= nh->ntnh_transfers_max_nr);
+		if (msg_nr->ntmn_total == nh->ntnh_transfers_max_nr) {
+			sd->ntcsd_time_finish = m0_time_now();
+			sd->ntcsd_finished = true;
+		}
+	}
+}
+
+void m0_net_test_nh_sd_update_rtt(struct m0_net_test_nh *nh, m0_time_t rtt)
+{
+	M0_PRE(m0_net_test_nh__invariant(nh));
+
+	m0_net_test_stats_time_add(&nh->ntnh_sd.ntcsd_rtt, rtt);
+}
+
+bool m0_net_test_nh_transfer_next(struct m0_net_test_nh *nh)
+{
+	M0_PRE(m0_net_test_nh__invariant(nh));
+
+	if (nh->ntnh_transfers_started_nr == nh->ntnh_transfers_max_nr)
+		return false;
+	++nh->ntnh_transfers_started_nr;
+	return true;
+}
+
+void m0_net_test_nh_cmd_status(struct m0_net_test_nh *nh,
+			       const struct m0_net_test_cmd *cmd,
+			       struct m0_net_test_cmd *reply)
+{
+	M0_PRE(m0_net_test_nh__invariant(nh));
+	M0_PRE(cmd != NULL && cmd->ntc_type == M0_NET_TEST_CMD_STATUS);
+	M0_PRE(reply != NULL);
+
+	reply->ntc_type = M0_NET_TEST_CMD_STATUS_DATA;
+	m0_net_test_nh_sd_get_locked(nh, &reply->ntc_status_data);
+}
+
+/**
+   @} end of NetTestNodeHelperInternals group
+ */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 79
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/net/test/node_helper.h b/net/test/node_helper.h
new file mode 100644
index 0000000..52cea0d
--- /dev/null
+++ b/net/test/node_helper.h
@@ -0,0 +1,152 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Maxim Medved <max_medved@xyratex.com>
+ * Original creation date: 11/07/2012
+ */
+
+#pragma once
+
+#ifndef __MERO_NET_TEST_NODE_HELPER_H__
+#define __MERO_NET_TEST_NODE_HELPER_H__
+
+#include "net/test/commands.h"		/* m0_net_test_role */
+
+/**
+   @defgroup NetTestNodeHelperDFS Node helper
+   @ingroup NetTestDFS
+
+   Naming in enum is without M0_xxx_xxx prefix because this file
+   should be included in .c files only, and long prefixes will destroy
+   usability of m0_net_test_nh_sd_update() function.
+
+   @{
+ */
+
+/** Test message status */
+enum m0_net_test_nh_msg_status {
+	MS_SUCCESS,	/**< message was successfully sent&received */
+	MS_FAILED,	/**< message transfer failed */
+	MS_BAD,		/**< received message contains invalid data */
+};
+
+enum m0_net_test_nh_msg_type {
+	MT_MSG,		/**< message with buffer descriptors */
+	MT_BULK,	/**< bulk test message */
+	MT_TRANSFER,
+};
+
+/** Single test message transfer direction */
+enum m0_net_test_nh_msg_direction {
+	MD_SEND,	/**< message was sent */
+	MD_RECV,	/**< message was received */
+	MD_BOTH,	/**< test message transfer in both directions */
+};
+
+/** Node helper */
+struct m0_net_test_nh {
+	/** Node role */
+	enum m0_net_test_role		   ntnh_role;
+	/** Test type */
+	enum m0_net_test_type		   ntnh_type;
+	/**
+	 * Node stats.
+	 * Usage pattern: use ntnh_sd as primary status data structure.
+	 * All statistics should go directly to this structure
+	 * in thread-safe manner (from one thread or using external lock).
+	 * In some inner loop m0_net_test_nh_sd_copy_lock() should be called
+	 * periodically to copy ntnh_sd to ntnh_sd_copy with ntnh_sd_copy_lock
+	 * locked. When status data is requested (in other thread etc.)
+	 * m0_net_test_nh_sd_get_lock() should be called. It will
+	 * copy ntnh_sd_copy to provided structure while holding
+	 * ntnh_sd_copy_lock.  This pattern will eliminate locking when
+	 * updating statistics in critical testing paths at cost
+	 * of delayed live stats.
+	 * @todo XXX check grammar
+	 */
+	struct m0_net_test_cmd_status_data ntnh_sd;
+	/** Copy of stats */
+	struct m0_net_test_cmd_status_data ntnh_sd_copy;
+	/** Lock for the copy of stats ntnh_sd_copy */
+	struct m0_mutex			   ntnh_sd_copy_lock;
+	/** Test was initialized. Set to true in m0_net_test_nh_init() */
+	bool				   ntnh_test_initialized;
+	/**
+	 * Maximum number of message transfers (in both direction).
+	 * Value UINT64_MAX means no limit.
+	 */
+	uint64_t			   ntnh_transfers_max_nr;
+	/** Number of started transfers (including failed) */
+	uint64_t			   ntnh_transfers_started_nr;
+};
+
+/** Initialize node helper structure. Take some information from icmd */
+void m0_net_test_nh_init(struct m0_net_test_nh *nh,
+			 const struct m0_net_test_cmd_init *icmd);
+/** Invariant for m0_net_test_nh */
+bool m0_net_test_nh__invariant(struct m0_net_test_nh *nh);
+/** Finalize node helper structure */
+void m0_net_test_nh_fini(struct m0_net_test_nh *nh);
+
+/**
+ * nh->ntnh_sd_copy = nh->ntnh_sd while holding nh->ntnh_sd_copy_lock.
+ * @see m0_net_test_nh.ntnh_sd
+ */
+void m0_net_test_nh_sd_copy_locked(struct m0_net_test_nh *nh);
+/**
+ * *sd = nh->ntnh_sd_copy while holding nh->ntnh_sd_copy_lock.
+ * Also set sd->ntcsd_time_now to the current time.
+ * @see m0_net_test_nh.ntnh_sd
+ */
+void m0_net_test_nh_sd_get_locked(struct m0_net_test_nh *nh,
+				  struct m0_net_test_cmd_status_data *sd);
+
+/**
+ * Update statistics for message numbers.
+ */
+void m0_net_test_nh_sd_update(struct m0_net_test_nh *nh,
+			      enum m0_net_test_nh_msg_type type,
+			      enum m0_net_test_nh_msg_status status,
+			      enum m0_net_test_nh_msg_direction direction);
+/** Update round-trip statistics */
+void m0_net_test_nh_sd_update_rtt(struct m0_net_test_nh *nh, m0_time_t rtt);
+/**
+ * Increase number of started transfers.
+ * @return false if transfers limit reached
+ * @return true otherwise
+ */
+bool m0_net_test_nh_transfer_next(struct m0_net_test_nh *nh);
+
+/** M0_NET_TEST_CMD_STATUS handler */
+void m0_net_test_nh_cmd_status(struct m0_net_test_nh *nh,
+			       const struct m0_net_test_cmd *cmd,
+			       struct m0_net_test_cmd *reply);
+
+/**
+   @} end of NetTestNodeHelperDFS group
+ */
+
+#endif /*  __MERO_NET_TEST_NODE_HELPER_H__ */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 79
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/net/test/node_ping.c b/net/test/node_ping.c
index 1be5826..8b0db9e 100644
--- a/net/test/node_ping.c
+++ b/net/test/node_ping.c
@@ -18,12 +18,12 @@
  * Original creation date: 09/03/2012
  */
 
-/* @todo remove */
+/** @todo remove */
 #ifndef __KERNEL__
 #include <stdio.h>		/* printf */
 #endif
 
-/* @todo debug only, remove it */
+/** @todo debug only, remove it */
 #ifndef __KERNEL__
 /*
 #define LOGD(format, ...) printf(format, ##__VA_ARGS__)
@@ -33,15 +33,18 @@
 #define LOGD(format, ...) do {} while (0)
 #endif
 
-#include "lib/memory.h"		/* M0_ALLOC_PTR */
-#include "lib/misc.h"		/* M0_SET0 */
-#include "lib/time.h"		/* m0_time_t */
-#include "lib/errno.h"		/* ENOMEM */
-#include "lib/thread.h"		/* M0_THREAD_INIT */
-#include "lib/tlist.h"		/* m0_tlist */
+#include "lib/memory.h"			/* M0_ALLOC_PTR */
+#include "lib/misc.h"			/* M0_SET0 */
+#include "lib/time.h"			/* m0_time_t */
+#include "lib/errno.h"			/* ENOMEM */
+#include "lib/thread.h"			/* M0_THREAD_INIT */
+#include "lib/tlist.h"			/* m0_tlist */
 
-#include "net/test/network.h"	/* m0_net_test_network_ctx */
-#include "net/test/node.h"	/* m0_net_test_node_ctx */
+#include "mero/magic.h"		/* M0_NET_TEST_BS_LINK_MAGIC */
+
+#include "net/test/network.h"		/* m0_net_test_network_ctx */
+#include "net/test/node.h"		/* m0_net_test_node_ctx */
+#include "net/test/node_helper.h"	/* m0_net_test_node_ctx */
 
 #include "net/test/node_ping.h"
 
@@ -82,16 +85,14 @@
  */
 
 enum {
-	/** @todo change after merging to master and move to lib/magic.h */
-	BS_LINK_MAGIC	  = 0x1213141516,
-	/** @todo change after merging to master and move to lib/magic.h */
-	BS_HEAD_MAGIC	  = 0x1718191A1B,
 	/** Timeout checking interval, ms */
 	TO_CHECK_INTERVAL = 10,
 };
 
 /** Buffer state */
 struct buf_state {
+	/** Magic for messages timeout list */
+	uint64_t		   bs_link_magic;
 	/** Queue type */
 	enum m0_net_queue_type	   bs_q;
 	/**
@@ -125,12 +126,11 @@ struct buf_state {
 	size_t			   bs_index_pair;
 	/** Link for messages timeout list */
 	struct m0_tlink		   bs_link;
-	/** Magic for typed list */
-	uint64_t		   bs_link_magic;
 };
 
 M0_TL_DESCR_DEFINE(buf_state, "buf_state", static, struct buf_state, bs_link,
-		   bs_link_magic, BS_LINK_MAGIC, BS_HEAD_MAGIC);
+		   bs_link_magic, M0_NET_TEST_BS_LINK_MAGIC,
+		   M0_NET_TEST_BS_HEAD_MAGIC);
 M0_TL_DEFINE(buf_state, static, struct buf_state);
 
 /**
@@ -144,8 +144,6 @@ M0_TL_DEFINE(buf_state, static, struct buf_state);
  *   server with index 1 etc.).
  */
 struct node_ping_client_ctx {
-	/** Number of added to send queue messages */
-	size_t	     npcc_msg_sent;
 	/**
 	 * Number of test messages sent to test server and received back
 	 * (including failed) for the test client.
@@ -169,12 +167,12 @@ struct node_ping_server_ctx {
 
 /** Ping node context */
 struct node_ping_ctx {
+	/** Node helper */
+	struct m0_net_test_nh		    npc_nh;
 	/** Network context for testing */
 	struct m0_net_test_network_ctx	    npc_net;
 	/** Test service. Used when changing service state. */
 	struct m0_net_test_service	   *npc_svc;
-	/** Node role */
-	enum m0_net_test_role		    npc_node_role;
 	/**
 	   Number of network buffers to send/receive test messages.
 	   @see m0_net_test_cmd_init.ntci_concurrency
@@ -184,25 +182,17 @@ struct node_ping_ctx {
 	m0_bcount_t			    npc_buf_size;
 	/** Timeout for test message sending */
 	m0_time_t			    npc_buf_send_timeout;
-	/** Test was initialized (succesful node_ping_cmd_start() */
+	/** Test was initialized (successful node_ping_cmd_start()) */
 	bool				    npc_test_initialized;
-	/** All needed statistics */
-	struct m0_net_test_cmd_status_data  npc_status_data;
-	/** @todo use spinlock instead of mutex
-	 *  @todo make copy of status data, protect it with mutex.
-	 *  N times per secound update this copy from original status data,
-	 *  but leave original status data updates without mutex.
-	 */
-	struct m0_mutex			    npc_status_data_lock;
 	/**
 	 * Buffer enqueue semaphore.
 	 * - initial value - number of buffers;
 	 * - up() in network buffer callback;
 	 * - (down() * number_of_buffers) in node_ping_cmd_stop();
-	 * - down() after succesful addition to network buffer queue;
+	 * - down() after successful addition to network buffer queue;
 	 * - trydown() before addition to queue. if failed -
 	 *   then don't add to queue;
-	 * - up() after unsuccesful addition to queue.
+	 * - up() after unsuccessful addition to queue.
 	 * @todo problem with semaphore max value can be here
 	 */
 	struct m0_semaphore		    npc_buf_q_sem;
@@ -214,7 +204,7 @@ struct node_ping_ctx {
 	bool				    npc_buf_rb_done;
 	/** Array of buffer states */
 	struct buf_state		   *npc_buf_state;
-	/* Worker thread */
+	/** Worker thread */
 	struct m0_thread		    npc_thread;
 	union {
 		struct node_ping_client_ctx npc__client;
@@ -231,6 +221,15 @@ struct node_ping_ctx {
 	struct node_ping_server_ctx	   *npc_server;
 };
 
+/** Wrapper for m0_net_test_nh_sd_update() with smaller name */
+static void sd_update(struct node_ping_ctx *ctx,
+		      enum m0_net_test_nh_msg_type type,
+		      enum m0_net_test_nh_msg_status status,
+		      enum m0_net_test_nh_msg_direction direction)
+{
+	m0_net_test_nh_sd_update(&ctx->npc_nh, type, status, direction);
+}
+
 static void node_ping_tm_event_cb(const struct m0_net_tm_event *ev)
 {
 	/* nothing for now */
@@ -243,8 +242,7 @@ static const struct m0_net_tm_callbacks node_ping_tm_cb = {
 static struct node_ping_ctx *
 node_ping_ctx_from_net_ctx(struct m0_net_test_network_ctx *net_ctx)
 {
-	return (struct node_ping_ctx *)
-	       ((char *) net_ctx - offsetof(struct node_ping_ctx, npc_net));
+	return container_of(net_ctx, struct node_ping_ctx, npc_net);
 }
 
 static m0_time_t node_ping_timestamp_put(struct m0_net_test_network_ctx *net_ctx,
@@ -380,6 +378,7 @@ static void node_ping_client_send(struct node_ping_ctx *ctx,
 	struct buf_state	    *bs;
 	size_t			     ep_index;
 	m0_time_t		     begin;
+	bool			     transfer_next;
 
 	M0_PRE(ctx != NULL && ctx->npc_client != NULL);
 	M0_PRE(buf_index < ctx->npc_buf_nr / 2);
@@ -388,10 +387,11 @@ static void node_ping_client_send(struct node_ping_ctx *ctx,
 	cctx	 = ctx->npc_client;
 	ep_index = buf_index / cctx->npcc_concurrency;
 	/* check for max number of messages */
-	if (cctx->npcc_msg_sent >= cctx->npcc_msg_rt_max)
+	transfer_next = m0_net_test_nh_transfer_next(&ctx->npc_nh);
+	if (!transfer_next)
 		return;
 	/* put timestamp and sequence number */
-	bs->bs_seq   = ++cctx->npcc_msg_sent;
+	bs->bs_seq   = ctx->npc_nh.ntnh_transfers_started_nr;
 	bs->bs_cb_nr = 0;
 	begin = node_ping_timestamp_put(&ctx->npc_net, buf_index, bs->bs_seq);
 	bs->bs_deadline = m0_time_add(begin, ctx->npc_buf_send_timeout);
@@ -399,7 +399,7 @@ static void node_ping_client_send(struct node_ping_ctx *ctx,
 	node_ping_buf_enqueue(ctx, buf_index, M0_NET_QT_MSG_SEND,
 			      NULL, ep_index);
 	if (bs->bs_errno != 0)
-		--cctx->npcc_msg_sent;
+		sd_update(ctx, MT_MSG, MS_FAILED, MD_SEND);
 }
 
 static void node_ping_client_cb2(struct node_ping_ctx *ctx,
@@ -429,7 +429,7 @@ static bool node_ping_client_recv_cb(struct node_ping_ctx *ctx,
 	ssize_t			      server_index;
 	ssize_t			      buf_index_send;
 	bool			      decoded;
-	bool			      finished;
+	m0_time_t		      rtt;
 
 	M0_PRE(ctx != NULL && ctx->npc_client != NULL);
 	M0_PRE(buf_index >= ctx->npc_buf_nr / 2 &&
@@ -461,24 +461,13 @@ static bool node_ping_client_recv_cb(struct node_ping_ctx *ctx,
 	bs_send->bs_index_pair = buf_index;
 	bs->bs_index_pair      = buf_index_send;
 	/* successfully received message */
-	++ctx->npc_client->npcc_msg_rt;
-	finished = ctx->npc_client->npcc_msg_rt >=
-		   ctx->npc_client->npcc_msg_rt_max;
-	m0_mutex_lock(&ctx->npc_status_data_lock);
+	sd_update(ctx, MT_TRANSFER, MS_SUCCESS, MD_BOTH);
 	/* update RTT statistics */
-	m0_net_test_stats_time_add(&ctx->npc_status_data.ntcsd_rtt,
-				   m0_time_sub(bs->bs_time, ts.ntt_time));
-	/* set 'client is finished' flag */
-	if (equi(finished, !ctx->npc_status_data.ntcsd_finished)) {
-		ctx->npc_status_data.ntcsd_finished = true;
-		ctx->npc_status_data.ntcsd_time_finish = m0_time_now();
-	}
-	m0_mutex_unlock(&ctx->npc_status_data_lock);
+	rtt = m0_time_sub(bs->bs_time, ts.ntt_time);
+	m0_net_test_nh_sd_update_rtt(&ctx->npc_nh, rtt);
 	goto good_buf;
 bad_buf:
-	m0_mutex_lock(&ctx->npc_status_data_lock);
-	++ctx->npc_status_data.ntcsd_msg_nr_recv.ntmn_bad;
-	m0_mutex_unlock(&ctx->npc_status_data_lock);
+	sd_update(ctx, MT_TRANSFER, MS_BAD, MD_BOTH);
 good_buf:
 	/* enqueue recv buffer */
 	if (bs_send == NULL) {
@@ -502,7 +491,7 @@ static void node_ping_msg_cb(struct m0_net_test_network_ctx *net_ctx,
 	bs = &ctx->npc_buf_state[buf_index];
 
 	LOGD("%s,      role = %d, buf_index = %u, nbe_status = %d, q = %d",
-	     __FUNCTION__, ctx->npc_node_role, buf_index, ev->nbe_status, q);
+	     __FUNCTION__, ctx->npc_nh.ntnh_role, buf_index, ev->nbe_status, q);
 	LOGD(", ev->nbe_length = %lu", ev->nbe_length);
 
 	if (q == M0_NET_QT_MSG_RECV && ev->nbe_status == 0)
@@ -612,7 +601,6 @@ static void node_ping_server_handle(struct node_ping_ctx *ctx,
 
 static void node_ping_worker(struct node_ping_ctx *ctx)
 {
-	struct m0_net_test_msg_nr *msg_nr;
 	struct buf_state	  *bs;
 	size_t			  buf_index;
 	bool			  failed;
@@ -624,15 +612,15 @@ static void node_ping_worker(struct node_ping_ctx *ctx)
 
 	M0_PRE(ctx != NULL);
 
-	m0_time_set(&to_check_interval, TO_CHECK_INTERVAL / 1000,
-					TO_CHECK_INTERVAL * 1000000);
+	to_check_interval = M0_MKTIME(TO_CHECK_INTERVAL / 1000,
+				      TO_CHECK_INTERVAL * 1000000);
 	while (1) {
 		/* get buffer index from ringbuf */
 		deadline = m0_time_add(m0_time_now(), to_check_interval);
 		rb_is_empty = !m0_semaphore_timeddown(&ctx->npc_buf_rb_sem,
 						      deadline);
 		/* check timeout list */
-		if (ctx->npc_node_role == M0_NET_TEST_ROLE_CLIENT)
+		if (ctx->npc_nh.ntnh_role == M0_NET_TEST_ROLE_CLIENT)
 			node_ping_to_check(ctx);
 		if (rb_is_empty)
 			continue;
@@ -641,25 +629,22 @@ static void node_ping_worker(struct node_ping_ctx *ctx)
 		buf_index = m0_net_test_ringbuf_pop(&ctx->npc_buf_rb);
 		bs = &ctx->npc_buf_state[buf_index];
 		LOGD("POP from ringbuf: %lu, role = %d\n",
-		     buf_index, ctx->npc_node_role);
+		     buf_index, ctx->npc_nh.ntnh_role);
 		/* update total/failed stats */
 		failed = bs->bs_errno != 0 || bs->bs_ev.nbe_status != 0;
-		msg_nr = bs->bs_q == M0_NET_QT_MSG_RECV ?
-			 &ctx->npc_status_data.ntcsd_msg_nr_recv :
-			 &ctx->npc_status_data.ntcsd_msg_nr_send;
-		m0_mutex_lock(&ctx->npc_status_data_lock);
-		++msg_nr->ntmn_total;
-		msg_nr->ntmn_failed += failed;
-		m0_mutex_unlock(&ctx->npc_status_data_lock);
+		sd_update(ctx, MT_MSG, failed ? MS_FAILED : MS_SUCCESS,
+			  bs->bs_q == M0_NET_QT_MSG_RECV ? MD_RECV : MD_SEND);
 		ep = bs->bs_errno == 0 && bs->bs_ev.nbe_status == 0 &&
 		     bs->bs_q == M0_NET_QT_MSG_RECV ? bs->bs_ev.nbe_ep : NULL;
 		/* handle buffer */
-		if (ctx->npc_node_role == M0_NET_TEST_ROLE_CLIENT)
+		if (ctx->npc_nh.ntnh_role == M0_NET_TEST_ROLE_CLIENT)
 			node_ping_client_handle(ctx, bs, buf_index);
 		else
 			node_ping_server_handle(ctx, bs, buf_index);
 		if (ep != NULL)
 			m0_net_end_point_put(ep);
+		/* update copy of statistics */
+		m0_net_test_nh_sd_copy_locked(&ctx->npc_nh);
 	}
 	/* dequeue all buffers */
 	for (i = 0; i < ctx->npc_buf_nr; ++i) {
@@ -689,7 +674,7 @@ static void node_ping_rb_fill(struct node_ping_ctx *ctx)
 	size_t i;
 	size_t half_buf = ctx->npc_buf_nr / 2;
 
-	if (ctx->npc_node_role == M0_NET_TEST_ROLE_CLIENT) {
+	if (ctx->npc_nh.ntnh_role == M0_NET_TEST_ROLE_CLIENT) {
 		M0_ASSERT(ctx->npc_buf_nr % 2 == 0);
 		/* add recv buffers */
 		for (i = 0; i < half_buf; ++i)
@@ -706,14 +691,13 @@ static void node_ping_rb_fill(struct node_ping_ctx *ctx)
 static int node_ping_test_init_fini(struct node_ping_ctx *ctx,
 				    const struct m0_net_test_cmd *cmd)
 {
-	struct m0_net_test_network_timeouts  timeouts;
-	int				     rc;
-	int				     i;
-	char				    *ep_addr;
+	struct m0_net_test_network_timeouts timeouts;
+	int				    rc;
+	int				    i;
 
 	if (cmd == NULL) {
 		rc = 0;
-		if (ctx->npc_test_initialized)
+		if (ctx->npc_nh.ntnh_test_initialized)
 			goto fini;
 		else
 			goto exit;
@@ -743,26 +727,23 @@ static int node_ping_test_init_fini(struct node_ping_ctx *ctx,
 					  ctx->npc_buf_nr,
 					  0, 0,
 					  cmd->ntc_init.ntci_ep.ntsl_nr,
-					  &timeouts);
+					  &timeouts, false);
 	if (rc != 0)
 		goto free_buf_state;
 	/* add test node endpoints to the network context endpoint list */
-	for (i = 0; i < cmd->ntc_init.ntci_ep.ntsl_nr; ++i) {
-		ep_addr = cmd->ntc_init.ntci_ep.ntsl_list[i];
-		rc = m0_net_test_network_ep_add(&ctx->npc_net, ep_addr);
-		if (rc < 0)
-			goto fini;
-	}
-	if (ctx->npc_node_role == M0_NET_TEST_ROLE_CLIENT) {
+	rc = m0_net_test_network_ep_add_slist(&ctx->npc_net,
+					      &cmd->ntc_init.ntci_ep);
+	if (rc != 0)
+		goto fini;
+	if (ctx->npc_nh.ntnh_role == M0_NET_TEST_ROLE_CLIENT) {
 		buf_state_tlist_init(&ctx->npc_client->npcc_to);
 		for (i = 0; i < ctx->npc_buf_nr; ++i)
 			buf_state_tlink_init(&ctx->npc_buf_state[i]);
 	}
-	ctx->npc_test_initialized = true;
 	rc = 0;
 	goto exit;
 fini:
-	if (ctx->npc_node_role == M0_NET_TEST_ROLE_CLIENT) {
+	if (ctx->npc_nh.ntnh_role == M0_NET_TEST_ROLE_CLIENT) {
 		for (i = 0; i < ctx->npc_buf_nr; ++i)
 			buf_state_tlink_fini(&ctx->npc_buf_state[i]);
 		buf_state_tlist_fini(&ctx->npc_client->npcc_to);
@@ -793,11 +774,9 @@ static void *node_ping_init_fini(void *ctx_,
 		M0_ALLOC_PTR(ctx);
 		if (ctx != NULL) {
 			ctx->npc_svc = svc;
-			m0_mutex_init(&ctx->npc_status_data_lock);
 		}
 	} else {
 		node_ping_test_init_fini(ctx, NULL);
-		m0_mutex_fini(&ctx->npc_status_data_lock);
 		m0_free(ctx);
 	}
 	return init ? ctx : NULL;
@@ -816,36 +795,6 @@ static void node_ping_fini(void *ctx_)
 
 static int node_ping_step(void *ctx_)
 {
-	struct m0_net_test_cmd_status_data *sd;
-	struct m0_net_test_msg_nr	    msg_send;
-	struct m0_net_test_msg_nr	    msg_recv;
-	struct node_ping_ctx		   *ctx = ctx_;
-	m0_time_t			    now;
-	bool				    finished;
-
-	M0_PRE(ctx != NULL);
-	sd = &ctx->npc_status_data;
-
-	/* update MPS stats */
-	m0_mutex_lock(&ctx->npc_status_data_lock);
-	msg_send = sd->ntcsd_msg_nr_send;
-	msg_recv = sd->ntcsd_msg_nr_recv;
-	now	 = m0_time_now();
-	finished = sd->ntcsd_finished;
-	m0_mutex_unlock(&ctx->npc_status_data_lock);
-
-	if (!finished) {
-		/*
-		 * MPS stats can be updated without lock because
-		 * they are used in node_ping_step() and
-		 * node_ping_cmd_status(), which are serialized.
-		 */
-		m0_net_test_mps_add(&sd->ntcsd_mps_send,
-				    msg_send.ntmn_total, now);
-		m0_net_test_mps_add(&sd->ntcsd_mps_recv,
-				    msg_recv.ntmn_total, now);
-	}
-
 	return 0;
 }
 
@@ -853,8 +802,10 @@ static int node_ping_cmd_init(void *ctx_,
 			      const struct m0_net_test_cmd *cmd,
 			      struct m0_net_test_cmd *reply)
 {
-	struct node_ping_ctx *ctx = ctx_;
-	int		      rc;
+	const struct m0_net_test_cmd_init *icmd;
+	struct node_ping_ctx		  *ctx = ctx_;
+	int				   rc;
+	bool				   role_client;
 
 	M0_PRE(ctx != NULL);
 	M0_PRE(cmd != NULL);
@@ -862,37 +813,36 @@ static int node_ping_cmd_init(void *ctx_,
 
 	LOGD("%s\n", __FUNCTION__);
 
+	icmd	    = &cmd->ntc_init;
+	role_client = icmd->ntci_role == M0_NET_TEST_ROLE_CLIENT;
+
 	/* ep wasn't recognized */
 	if (cmd->ntc_ep_index == -1) {
 		rc = -ENOENT;
 		goto reply;
 	}
 	/* network context already initialized */
-	if (ctx->npc_test_initialized) {
+	if (ctx->npc_nh.ntnh_test_initialized) {
 		rc = -EALREADY;
 		goto reply;
 	}
 	/* check command type */
-	M0_ASSERT(cmd->ntc_init.ntci_type == M0_NET_TEST_TYPE_PING);
+	M0_ASSERT(icmd->ntci_type == M0_NET_TEST_TYPE_PING);
 	/* parse INIT command */
-	ctx->npc_node_role	  = cmd->ntc_init.ntci_role;
-	ctx->npc_buf_size	  = cmd->ntc_init.ntci_msg_size;
-	ctx->npc_buf_send_timeout = cmd->ntc_init.ntci_buf_send_timeout;
+	m0_net_test_nh_init(&ctx->npc_nh, icmd);
+	ctx->npc_buf_size	  = icmd->ntci_msg_size;
+	ctx->npc_buf_send_timeout = icmd->ntci_buf_send_timeout;
 
-	ctx->npc_buf_nr	 = cmd->ntc_init.ntci_concurrency;
-	ctx->npc_buf_nr *= ctx->npc_node_role == M0_NET_TEST_ROLE_CLIENT ?
-			   2 * cmd->ntc_init.ntci_ep.ntsl_nr : 1;
+	ctx->npc_buf_nr	 = icmd->ntci_msg_concurrency;
+	ctx->npc_buf_nr *= role_client ?  2 * icmd->ntci_ep.ntsl_nr : 1;
 
-	ctx->npc_client = ctx->npc_node_role == M0_NET_TEST_ROLE_CLIENT ?
-			  &ctx->npc__client : NULL;
-	ctx->npc_server = ctx->npc_node_role == M0_NET_TEST_ROLE_SERVER ?
-			  &ctx->npc__server : NULL;
+	ctx->npc_client = role_client  ? &ctx->npc__client : NULL;
+	ctx->npc_server = !role_client ? &ctx->npc__server : NULL;
 
-	if (ctx->npc_node_role == M0_NET_TEST_ROLE_CLIENT) {
+	if (role_client) {
 		M0_SET0(ctx->npc_client);
-		ctx->npc_client->npcc_msg_rt_max = cmd->ntc_init.ntci_msg_nr;
-		ctx->npc_client->npcc_concurrency =
-			cmd->ntc_init.ntci_concurrency;
+		ctx->npc_client->npcc_msg_rt_max  = icmd->ntci_msg_nr;
+		ctx->npc_client->npcc_concurrency = icmd->ntci_msg_concurrency;
 	}
 
 	/* do sanity check */
@@ -922,7 +872,7 @@ static int node_ping_cmd_start(void *ctx_,
 	struct m0_net_test_cmd_status_data *sd;
 	struct node_ping_ctx		   *ctx = ctx_;
 	int				    rc;
-	m0_time_t			    _1s = M0_MKTIME(1, 0);
+	const m0_time_t			    _1s = M0_MKTIME(1, 0);
 
 	M0_PRE(ctx != NULL);
 	M0_PRE(cmd != NULL);
@@ -930,7 +880,7 @@ static int node_ping_cmd_start(void *ctx_,
 
 	LOGD("%s\n", __FUNCTION__);
 
-	sd = &ctx->npc_status_data;
+	sd = &ctx->npc_nh.ntnh_sd;
 	M0_SET0(sd);
 
 	/* fill test start time */
@@ -938,14 +888,13 @@ static int node_ping_cmd_start(void *ctx_,
 	/* initialize stats */
 	m0_net_test_mps_init(&sd->ntcsd_mps_send, 0, sd->ntcsd_time_start, _1s);
 	m0_net_test_mps_init(&sd->ntcsd_mps_recv, 0, sd->ntcsd_time_start, _1s);
-	m0_net_test_stats_reset(&sd->ntcsd_rtt);
 	/* add buffer indexes to ringbuf */
 	node_ping_rb_fill(ctx);
 	/* start test */
 	ctx->npc_buf_rb_done = false;
 	rc = M0_THREAD_INIT(&ctx->npc_thread, struct node_ping_ctx *, NULL,
 			    &node_ping_worker, ctx,
-			    "net-test-worker#%s",
+			    "net-test-ping-worker#%s",
 			    ctx->npc_net.ntc_tm->ntm_ep->nep_addr);
 	if (rc != 0) {
 		/* change service state */
@@ -990,24 +939,13 @@ static int node_ping_cmd_status(void *ctx_,
 				const struct m0_net_test_cmd *cmd,
 				struct m0_net_test_cmd *reply)
 {
-	struct m0_net_test_cmd_status_data *sd;
-	struct node_ping_ctx		   *ctx = ctx_;
+	struct node_ping_ctx *ctx = ctx_;
 
 	M0_PRE(ctx != NULL);
-	M0_PRE(cmd != NULL);
-	M0_PRE(reply != NULL);
-
-	sd  = &reply->ntc_status_data;
-
-	reply->ntc_type = M0_NET_TEST_CMD_STATUS_DATA;
-
-	m0_mutex_lock(&ctx->npc_status_data_lock);
-	*sd = ctx->npc_status_data;
-	m0_mutex_unlock(&ctx->npc_status_data_lock);
 
-	sd->ntcsd_time_now = m0_time_now();
+	m0_net_test_nh_cmd_status(&ctx->npc_nh, cmd, reply);
 
-	if (ctx->npc_node_role == M0_NET_TEST_ROLE_CLIENT) {
+	if (ctx->npc_nh.ntnh_role == M0_NET_TEST_ROLE_CLIENT) {
 		LOGD("ctx->npc_client->npcc_msg_rt = %lu\n",
 		     ctx->npc_client->npcc_msg_rt);
 		LOGD("ctx->npc_client->npcc_msg_sent = %lu\n",
diff --git a/net/test/ringbuf.c b/net/test/ringbuf.c
index 71bb005..dc244b2 100644
--- a/net/test/ringbuf.c
+++ b/net/test/ringbuf.c
@@ -101,6 +101,13 @@ bool m0_net_test_ringbuf_is_empty(struct m0_net_test_ringbuf *rb)
 	return m0_atomic64_get(&rb->ntr_end) == m0_atomic64_get(&rb->ntr_start);
 }
 
+size_t m0_net_test_ringbuf_nr(struct m0_net_test_ringbuf *rb)
+{
+	M0_PRE(m0_net_test_ringbuf_invariant(rb));
+
+	return m0_atomic64_get(&rb->ntr_end) - m0_atomic64_get(&rb->ntr_start);
+}
+
 /**
    @} end of NetTestRingbufInternals group
  */
diff --git a/net/test/ringbuf.h b/net/test/ringbuf.h
index 21775e4..7878176 100644
--- a/net/test/ringbuf.h
+++ b/net/test/ringbuf.h
@@ -39,7 +39,7 @@
    absolute indices.
  */
 struct m0_net_test_ringbuf {
-	size_t		    ntr_size;	/**< Number of elements in ringbuf */
+	size_t		    ntr_size;	/**< Maximum number of elements */
 	size_t		   *ntr_buf;	/**< Ringbuf array */
 	struct m0_atomic64  ntr_start;	/**< Start pointer */
 	struct m0_atomic64  ntr_end;	/**< End pointer */
@@ -82,6 +82,13 @@ size_t m0_net_test_ringbuf_pop(struct m0_net_test_ringbuf *rb);
 bool m0_net_test_ringbuf_is_empty(struct m0_net_test_ringbuf *rb);
 
 /**
+   Get current number of elements in the ring buffer.
+   @note This function is not thread-safe.
+   @pre m0_net_test_ringbuf_invariant(rb)
+ */
+size_t m0_net_test_ringbuf_nr(struct m0_net_test_ringbuf *rb);
+
+/**
    @} end of NetTestRingbufDFS group
  */
 
diff --git a/net/test/serialize.c b/net/test/serialize.c
index 2701d6e..c770e3c 100644
--- a/net/test/serialize.c
+++ b/net/test/serialize.c
@@ -18,7 +18,6 @@
  * Original creation date: 06/28/2012
  */
 
-#include "lib/cdefs.h"		/* container_of */
 #include "lib/misc.h"		/* M0_SET0 */
 #include "lib/memory.h"		/* m0_alloc */
 #include "lib/errno.h"		/* ENOMEM */
@@ -183,7 +182,7 @@ m0_bcount_t m0_net_test_serialize(enum m0_net_test_serialize_op op,
 	const struct m0_net_test_descr *d_i;
 	void			       *addr;
 	m0_bcount_t			len_total = 0;
-	m0_bcount_t			len_current = 0;
+	m0_bcount_t			len;
 	m0_bcount_t			bv_length;
 
 	M0_PRE(op == M0_NET_TEST_SERIALIZE || op == M0_NET_TEST_DESERIALIZE);
@@ -195,15 +194,15 @@ m0_bcount_t m0_net_test_serialize(enum m0_net_test_serialize_op op,
 	for (i = 0; i < descr_nr; ++i) {
 		d_i = &descr[i];
 		addr = &((char *) obj)[d_i->ntd_offset];
-		len_current = net_test_serialize_data(op, addr, d_i->ntd_length,
-						      d_i->ntd_plain_data,
-						      bv, bv_offset + len_total,
-						      bv_length);
-		len_total += len_current;
-		if (len_current == 0)
+		len = net_test_serialize_data(op, addr, d_i->ntd_length,
+					      d_i->ntd_plain_data,
+					      bv, bv_offset + len_total,
+					      bv_length);
+		len_total = net_test_len_accumulate(len_total, len);
+		if (len_total == 0)
 			break;
 	}
-	return len_current == 0 ? 0 : len_total;
+	return len_total;
 }
 
 /**
diff --git a/net/test/serialize.h b/net/test/serialize.h
index d4c70a3..84b02fa 100644
--- a/net/test/serialize.h
+++ b/net/test/serialize.h
@@ -57,6 +57,7 @@ struct m0_net_test_descr {
 
 #define FIELD_SIZE(type, field) (sizeof ((type *) 0)->field)
 
+/** Recommended to use in field declaration order */
 #define FIELD_DESCR(type, field) {					\
 	.ntd_offset	= offsetof(type, field),			\
 	.ntd_length	= FIELD_SIZE(type, field),			\
@@ -91,7 +92,7 @@ m0_bcount_t m0_net_test_serialize_data(enum m0_net_test_serialize_op op,
    @param descr_nr Described fields number in descr.
    @param bv m0_bufvec. Can be NULL - in this case bv_offset is ignored.
    @param bv_offset Offset in bv.
-   @return 0 No space in buffer or descr_nr == 0.
+   @return 0 No free space in buffer or descr_nr == 0.
    @return >0 Number of bytes read/written/will be written to/from buffer.
    @pre op == M0_NET_TEST_SERIALIZE || op == M0_NET_TEST_DESERIALIZE
    @pre obj != NULL
@@ -107,6 +108,22 @@ m0_bcount_t m0_net_test_serialize(enum m0_net_test_serialize_op op,
 				  m0_bcount_t bv_offset);
 
 /**
+   Get new len_total value after serializing part of data.
+   @see @ref net-test-fspec-usecases-serialize
+   @param accumulator Total serialized length before serializing current
+		      part of data.
+   @param addend Length of serialized current part of data.
+		 0 means serializing failed.
+   @return 0 if addend == 0
+	   accumulator + addend otherwise.
+ */
+static inline m0_bcount_t net_test_len_accumulate(m0_bcount_t accumulator,
+						  m0_bcount_t addend)
+{
+	return addend == 0 ? 0 : accumulator + addend;
+}
+
+/**
    @} end of NetTestSerializeDFS group
  */
 
diff --git a/net/test/service.c b/net/test/service.c
index 045f1c3..b49921d 100644
--- a/net/test/service.c
+++ b/net/test/service.c
@@ -18,12 +18,12 @@
  * Original creation date: 09/03/2012
  */
 
-/* @todo remove */
+/** @todo remove */
 #ifndef __KERNEL__
 #include <stdio.h>		/* printf */
 #endif
 
-/* @todo debug only, remove it */
+/** @todo debug only, remove it */
 #ifndef __KERNEL__
 #define LOGD(format, ...) printf(format, ##__VA_ARGS__)
 #else
diff --git a/net/test/service.h b/net/test/service.h
index d75230a..fd5fec4 100644
--- a/net/test/service.h
+++ b/net/test/service.h
@@ -111,7 +111,7 @@ struct m0_net_test_service {
    m0_net_test_service_fini();
    @endcode
 
-   @note Service state will not be changed it ops->ntso_init returns
+   @note Service state will not be changed if ops->ntso_init returns
    non-zero result and will be changed to M0_NET_TEST_SERVICE_READY
    otherwise.
 
diff --git a/net/test/slist.c b/net/test/slist.c
index d249c74..14a2ede 100644
--- a/net/test/slist.c
+++ b/net/test/slist.c
@@ -22,6 +22,8 @@
 #include "lib/memory.h"		/* M0_ALLOC_ARR */
 #include "lib/errno.h"		/* ENOMEM */
 
+#include "mero/magic.h"	/* M0_NET_TEST_SLIST_MAGIC */
+
 #include "net/test/slist.h"
 
 /**
@@ -31,11 +33,6 @@
    @{
  */
 
-enum {
-	/** NT_SLIST @todo move to lib/magic.h */
-	SLIST_SERIALIZE_MAGIC =  0x5453494C535F544E,
-};
-
 static bool slist_alloc(struct m0_net_test_slist *slist,
 		        size_t string_nr,
 		        size_t arr_len)
@@ -141,15 +138,15 @@ bool m0_net_test_slist_unique(const struct m0_net_test_slist *slist)
 }
 
 struct slist_params {
+	uint64_t sp_magic;	/**< M0_NET_TEST_SLIST_MAGIC */
 	size_t   sp_nr;		/**< number if strings in the list */
 	size_t   sp_len;	/**< length of string array */
-	uint64_t sp_magic;	/**< SLIST_XCODE_MAGIC */
 };
 
 TYPE_DESCR(slist_params) = {
+	FIELD_DESCR(struct slist_params, sp_magic),
 	FIELD_DESCR(struct slist_params, sp_nr),
 	FIELD_DESCR(struct slist_params, sp_len),
-	FIELD_DESCR(struct slist_params, sp_magic),
 };
 
 static m0_bcount_t slist_encode(struct m0_net_test_slist *slist,
@@ -165,18 +162,19 @@ static m0_bcount_t slist_encode(struct m0_net_test_slist *slist,
 		      slist->ntsl_list[slist->ntsl_nr - 1] -
 		      slist->ntsl_list[0] +
 		      strlen(slist->ntsl_list[slist->ntsl_nr - 1]) + 1;
-	sp.sp_magic = SLIST_SERIALIZE_MAGIC;
+	sp.sp_magic = M0_NET_TEST_SLIST_MAGIC;
 
-	len_total = m0_net_test_serialize(M0_NET_TEST_SERIALIZE, &sp,
-				          USE_TYPE_DESCR(slist_params),
-					  bv, offset);
-	if (len_total == 0 || slist->ntsl_nr == 0)
-		return len_total;
+	len = m0_net_test_serialize(M0_NET_TEST_SERIALIZE, &sp,
+				    USE_TYPE_DESCR(slist_params), bv, offset);
+	if (len == 0 || slist->ntsl_nr == 0)
+		return len;
+	len_total = net_test_len_accumulate(0, len);
 
 	len = m0_net_test_serialize_data(M0_NET_TEST_SERIALIZE, slist->ntsl_str,
 					 sp.sp_len, true,
 					 bv, offset + len_total);
-	return len == 0 ? 0 : len_total + len;
+	len_total = net_test_len_accumulate(len_total, len);
+	return len_total;
 }
 
 static m0_bcount_t slist_decode(struct m0_net_test_slist *slist,
@@ -190,11 +188,12 @@ static m0_bcount_t slist_decode(struct m0_net_test_slist *slist,
 	bool		    allocated;
 
 
-	len_total = m0_net_test_serialize(M0_NET_TEST_DESERIALIZE, &sp,
-					  USE_TYPE_DESCR(slist_params),
-					  bv, offset);
-	if (len_total == 0 || sp.sp_magic != SLIST_SERIALIZE_MAGIC)
+	len = m0_net_test_serialize(M0_NET_TEST_DESERIALIZE, &sp,
+				    USE_TYPE_DESCR(slist_params),
+				    bv, offset);
+	if (len == 0 || sp.sp_magic != M0_NET_TEST_SLIST_MAGIC)
 		return 0;
+	len_total = net_test_len_accumulate(0, len);
 
 	M0_SET0(slist);
 	slist->ntsl_nr = sp.sp_nr;
@@ -206,10 +205,12 @@ static m0_bcount_t slist_decode(struct m0_net_test_slist *slist,
 	if (!allocated)
 		return 0;
 
-	len = m0_net_test_serialize_data(M0_NET_TEST_DESERIALIZE, slist->ntsl_str,
-				    sp.sp_len, true, bv, offset + len_total);
+	len = m0_net_test_serialize_data(M0_NET_TEST_DESERIALIZE,
+					 slist->ntsl_str, sp.sp_len, true,
+					 bv, offset + len_total);
 	if (len == 0)
 		goto failed;
+	len_total = net_test_len_accumulate(len_total, len);
 
 	slist->ntsl_list[0] = slist->ntsl_str;
 	/* additional check if received string doesn't contains '\0' */
@@ -221,7 +222,7 @@ static m0_bcount_t slist_decode(struct m0_net_test_slist *slist,
 			goto failed;
 	}
 
-	return len + len_total;
+	return len_total;
 failed:
 	slist_free(slist);
 	return 0;
diff --git a/net/test/st/.gitignore b/net/test/st/.gitignore
new file mode 100644
index 0000000..97aabaf
--- /dev/null
+++ b/net/test/st/.gitignore
@@ -0,0 +1 @@
+st-config.sh
diff --git a/net/test/st/run-1x1.sh b/net/test/st/run-1x1.sh
new file mode 100644
index 0000000..7f07620
--- /dev/null
+++ b/net/test/st/run-1x1.sh
@@ -0,0 +1,89 @@
+#!/bin/sh
+
+# The same values as in client-server UT
+ADDR_CONSOLE4CLIENTS="$LNET_PREFIX:2998"
+ADDR_CONSOLE4SERVERS="$LNET_PREFIX:2999"
+ADDR_CMD_CLIENT="$LNET_PREFIX:3000"
+ADDR_DATA_CLIENT="$LNET_PREFIX:3128"
+ADDR_CMD_SERVER="$LNET_PREFIX:3256"
+ADDR_DATA_SERVER="$LNET_PREFIX:3384"
+
+# Copy-paste from core/utils/ut.sh
+# Small wrapper to run user-space UT, which depends on kmero module
+
+if [ "$(id -u)" -ne 0 ]; then
+    echo "Must be run as root"
+    exit 1
+fi
+
+source "$ST_COMMON"
+
+eval_kill_pid() {
+	eval pid=\${$1-xxx}
+	if [ "$pid" != "xxx" -a -f /proc/$pid/exe ]; then
+		echo killing $pid
+		KILL_PID+="$pid "
+	fi
+}
+
+unload_all() {
+	KILL_PID=
+	eval_kill_pid "PID_SERVER"
+	eval_kill_pid "PID_CLIENT"
+	eval_kill_pid "PID_CONSOLE"
+	for pid in $KILL_PID; do
+		kill $pid > /dev/null 2>&1 || true
+	done
+	modunload
+	modunload_galois
+}
+trap unload_all EXIT
+
+modprobe_lnet
+lctl network up > /dev/null
+modload_galois
+modload || exit $?
+
+# allow only 'fatal' and higher trace messages to be printed on console by
+# default, to prevent cluttering of UT output with "fake" error messages,
+# generated while testing various error paths using fault injection;
+# this can be overridden with '-e' CLI option.
+# export M0_TRACE_LEVEL='fatal+'
+
+export M0_TRACE_IMMEDIATE_MASK=all
+export M0_TRACE_LEVEL=debug+
+
+"$NTN" -a $ADDR_CMD_SERVER -c $ADDR_CONSOLE4SERVERS &
+PID_SERVER=$!
+sleep $NODE_INIT_DELAY
+
+"$NTN" -a $ADDR_CMD_CLIENT -c $ADDR_CONSOLE4CLIENTS &
+PID_CLIENT=$!
+sleep $NODE_INIT_DELAY
+
+BULK_PARAMETERS=
+
+if [ "$TEST_TYPE" == "bulk" ]; then
+	BULK_PARAMETERS="-B $BD_BUF_NR_SERVER \
+			 -b $BD_BUF_NR_CLIENT \
+			 -f $BD_BUF_SIZE \
+			 -g $BD_BUF_NR_MAX"
+fi
+
+"$NTC" -A "$ADDR_CONSOLE4SERVERS" \
+       -a "$ADDR_CONSOLE4CLIENTS" \
+       -C "$ADDR_CMD_SERVER" \
+       -c "$ADDR_CMD_CLIENT" \
+       -D "$ADDR_DATA_SERVER" \
+       -d "$ADDR_DATA_CLIENT" \
+       -t "$TEST_TYPE" \
+       -n "$MSG_NR" \
+       -s "$MSG_SIZE" \
+       -E "$CONCURRENCY_SERVER" \
+       -e "$CONCURRENCY_CLIENT" \
+       $VERBOSE \
+       $PARSABLE \
+       $BULK_PARAMETERS
+
+# The same time for fini
+sleep $NODE_INIT_DELAY
diff --git a/net/test/st/st-bulk.sh b/net/test/st/st-bulk.sh
new file mode 100644
index 0000000..7653a60
--- /dev/null
+++ b/net/test/st/st-bulk.sh
@@ -0,0 +1,16 @@
+#!/bin/sh
+
+CWD=$(cd "$( dirname "$0")" && pwd)
+
+source $CWD/st-config.sh
+TEST_TYPE="bulk"
+MSG_NR=1024
+MSG_SIZE=1m
+CONCURRENCY_CLIENT=8
+CONCURRENCY_SERVER=16
+BD_BUF_NR_CLIENT=16
+BD_BUF_NR_SERVER=32
+BD_BUF_SIZE=4k
+BD_BUF_NR_MAX=8
+
+source $CWD/run-1x1.sh
diff --git a/net/test/st/st-config.sh.in b/net/test/st/st-config.sh.in
new file mode 100644
index 0000000..55a3243
--- /dev/null
+++ b/net/test/st/st-config.sh.in
@@ -0,0 +1,24 @@
+#!/bin/sh
+
+# Path to binaries
+NTN=@SRCDIR@/net/test/user_space/ntn
+NTC=@SRCDIR@/net/test/user_space/ntc
+ST_COMMON=@SRCDIR@/m0t1fs/linux_kernel/st/common.sh
+
+# Time to wait for node loading.
+# Timeout is used here because there is no way to check for node readiness
+NODE_INIT_DELAY=3
+
+# Set to empty string to disable verbose output
+VERBOSE=
+# VERBOSE="-v"
+
+# Set to empty string to disable last line with parsable output
+PARSABLE=
+# PARSABLE="-p"
+
+LNET_IF="0@lo"
+LNET_PID=12345
+LNET_PORTAL=42
+
+LNET_PREFIX="$LNET_IF:$LNET_PID:$LNET_PORTAL"
diff --git a/net/test/st/st-ping.sh b/net/test/st/st-ping.sh
new file mode 100644
index 0000000..635e59a
--- /dev/null
+++ b/net/test/st/st-ping.sh
@@ -0,0 +1,12 @@
+#!/bin/sh
+
+CWD=$(cd "$( dirname "$0")" && pwd)
+
+source $CWD/st-config.sh
+TEST_TYPE="ping"
+MSG_NR=1024
+MSG_SIZE=4k
+CONCURRENCY_CLIENT=8
+CONCURRENCY_SERVER=16
+
+source $CWD/run-1x1.sh
diff --git a/net/test/st/st.sh b/net/test/st/st.sh
new file mode 100644
index 0000000..8fcee3e
--- /dev/null
+++ b/net/test/st/st.sh
@@ -0,0 +1,10 @@
+#!/bin/sh
+
+# Next lines are useful for ST scripts debugging
+# set -eux
+# export PS4='+ ${FUNCNAME[0]:+${FUNCNAME[0]}():}line ${LINENO}: '
+
+CWD=$(cd "$( dirname "$0")" && pwd)
+
+sh $CWD/st-ping.sh
+sh $CWD/st-bulk.sh
diff --git a/net/test/stats.c b/net/test/stats.c
index 47af36b..279ac96 100644
--- a/net/test/stats.c
+++ b/net/test/stats.c
@@ -27,6 +27,8 @@
 #include "lib/misc.h"		/* M0_SET0 */
 #include "lib/arith.h"		/* min_check */
 
+#include "mero/magic.h"	/* M0_NET_TEST_TIMESTAMP_MAGIC */
+
 #include "net/test/stats.h"
 
 /**
@@ -133,7 +135,10 @@ m0_bcount_t m0_net_test_stats_serialize(enum m0_net_test_serialize_op op,
 					struct m0_bufvec *bv,
 					m0_bcount_t bv_offset)
 {
-	struct m0_uint128 *pv128;
+	struct m0_uint128 * const pv128[] = {
+		&stats->nts_sum,
+		&stats->nts_sum_sqr,
+	};
 	m0_bcount_t	   len_total;
 	m0_bcount_t	   len;
 	int		   i;
@@ -141,18 +146,14 @@ m0_bcount_t m0_net_test_stats_serialize(enum m0_net_test_serialize_op op,
 	len = m0_net_test_serialize(op, stats,
 				    USE_TYPE_DESCR(m0_net_test_stats),
 				    bv, bv_offset);
-	len_total = len;
-	for (i = 0; i < 2; ++i) {
-		if (len != 0) {
-			pv128 = stats == NULL ? NULL : i == 0 ?
-				&stats->nts_sum : &stats->nts_sum_sqr;
-			len = m0_net_test_serialize(op, pv128,
-						    USE_TYPE_DESCR(m0_uint128),
-						    bv, bv_offset + len_total);
-			len_total += len;
-		}
+	len_total = net_test_len_accumulate(0, len);
+	for (i = 0; i < ARRAY_SIZE(pv128) && len_total != 0; ++i) {
+		len = m0_net_test_serialize(op, pv128[i],
+					    USE_TYPE_DESCR(m0_uint128),
+					    bv, bv_offset + len_total);
+		len_total = net_test_len_accumulate(len_total, len);
 	}
-	return len == 0 ? 0 : len_total;
+	return len_total;
 }
 
 static m0_time_t unsigned_long2m0_time_t(unsigned long value)
@@ -206,9 +207,9 @@ void m0_net_test_timestamp_init(struct m0_net_test_timestamp *t, uint64_t seq)
 }
 
 TYPE_DESCR(m0_net_test_timestamp) = {
+	FIELD_DESCR(struct m0_net_test_timestamp, ntt_magic),
 	FIELD_DESCR(struct m0_net_test_timestamp, ntt_time),
 	FIELD_DESCR(struct m0_net_test_timestamp, ntt_seq),
-	FIELD_DESCR(struct m0_net_test_timestamp, ntt_magic),
 };
 
 m0_bcount_t m0_net_test_timestamp_serialize(enum m0_net_test_serialize_op op,
@@ -321,7 +322,7 @@ m0_time_t m0_net_test_mps_add(struct m0_net_test_mps *mps,
  */
 
 /**
-   @defgroup NetTestStatsMsgNRInternals Messages Per Second Statistics
+   @defgroup NetTestStatsMsgNRInternals Messages Number
    @ingroup NetTestInternals
 
    @{
diff --git a/net/test/stats.h b/net/test/stats.h
index 1cac0ba..06ac9b1 100644
--- a/net/test/stats.h
+++ b/net/test/stats.h
@@ -76,11 +76,6 @@
    @{
  */
 
-enum {
-	/** NT_TIMES @todo move to lib/magic.h */
-	M0_NET_TEST_TIMESTAMP_MAGIC = 0x53454d49545f544e,
-};
-
 /**
    This structure is used for statistics calculation and collecting.
    Min and max stored directly in this structure, average and
@@ -199,14 +194,16 @@ m0_time_t m0_net_test_stats_time_max(struct m0_net_test_stats *stats);
 
    Used to transmit m0_time_t value in ping/bulk buffers.
    @see m0_net_test_timestamp_init(), m0_net_test_timestamp_serialize().
+
+   @{
  */
 struct m0_net_test_timestamp {
+	/** M0_NET_TEST_TIMESTAMP_MAGIC */
+	uint64_t  ntt_magic;
 	/** Current time. Set in m0_net_test_timestamp_init() */
 	m0_time_t ntt_time;
 	/** Sequence number. */
 	uint64_t  ntt_seq;
-	/** Magic. Checked when deserializing. */
-	uint64_t  ntt_magic;
 };
 
 /**
diff --git a/net/test/str.c b/net/test/str.c
index 1345e4d..7955010 100644
--- a/net/test/str.c
+++ b/net/test/str.c
@@ -26,14 +26,14 @@
 
 #include "lib/memory.h"		/* m0_alloc */
 
+#include "mero/magic.h"	/* M0_NET_TEST_STR_MAGIC */
+
 #include "net/test/str.h"
 
 /**
    @defgroup NetTestStrInternals Serialization of ASCIIZ string
    @ingroup NetTestInternals
 
-   @todo move to net/test/str.h
-
    @see
    @ref net-test
 
@@ -41,13 +41,14 @@
  */
 
 struct net_test_str_len {
-	size_t   ntsl_len;
+	/** M0_NET_TEST_STR_MAGIC */
 	uint64_t ntsl_magic;
+	size_t   ntsl_len;
 };
 
 TYPE_DESCR(net_test_str_len) = {
-	FIELD_DESCR(struct net_test_str_len, ntsl_len),
 	FIELD_DESCR(struct net_test_str_len, ntsl_magic),
+	FIELD_DESCR(struct net_test_str_len, ntsl_len),
 };
 
 m0_bcount_t m0_net_test_str_serialize(enum m0_net_test_serialize_op op,
@@ -56,7 +57,7 @@ m0_bcount_t m0_net_test_str_serialize(enum m0_net_test_serialize_op op,
 				      m0_bcount_t bv_offset)
 {
 	struct net_test_str_len str_len;
-	m0_bcount_t		len = 0;
+	m0_bcount_t		len;
 	m0_bcount_t		len_total;
 
 	M0_PRE(op == M0_NET_TEST_SERIALIZE || op == M0_NET_TEST_DESERIALIZE);
@@ -66,9 +67,10 @@ m0_bcount_t m0_net_test_str_serialize(enum m0_net_test_serialize_op op,
 		str_len.ntsl_len = strlen(*str) + 1;
 		str_len.ntsl_magic = M0_NET_TEST_STR_MAGIC;
 	}
-	len_total = m0_net_test_serialize(op, &str_len,
-					  USE_TYPE_DESCR(net_test_str_len),
-					  bv, bv_offset);
+	len = m0_net_test_serialize(op, &str_len,
+				    USE_TYPE_DESCR(net_test_str_len),
+				    bv, bv_offset);
+	len_total = net_test_len_accumulate(0, len);
 	if (len_total != 0) {
 		if (op == M0_NET_TEST_DESERIALIZE) {
 			if (str_len.ntsl_magic != M0_NET_TEST_STR_MAGIC)
@@ -80,10 +82,10 @@ m0_bcount_t m0_net_test_str_serialize(enum m0_net_test_serialize_op op,
 		len = m0_net_test_serialize_data(op, *str, str_len.ntsl_len,
 						 true,
 						 bv, bv_offset + len_total);
-		len_total += len;
+		len_total = net_test_len_accumulate(len_total, len);
 	};
 
-	return len == 0 ? 0 : len_total;
+	return len_total;
 }
 
 void m0_net_test_str_fini(char **str)
diff --git a/net/test/str.h b/net/test/str.h
index ed97984..6177ac3 100644
--- a/net/test/str.h
+++ b/net/test/str.h
@@ -36,11 +36,6 @@
    @{
  */
 
-enum {
-	/** NTSTRING @todo move to lib/magic.h */
-	M0_NET_TEST_STR_MAGIC = 0x474e49525453544e,
-};
-
 /**
    Serialize or deserialize ASCIIZ string.
    @pre op == M0_NET_TEST_SERIALIZE || op == M0_NET_TEST_DESERIALIZE
diff --git a/net/test/user_space/console_u.c b/net/test/user_space/console_u.c
index 927e4cb..85be0d9 100644
--- a/net/test/user_space/console_u.c
+++ b/net/test/user_space/console_u.c
@@ -32,10 +32,14 @@
 #include "net/test/slist.h"		/* m0_net_test_slist */
 #include "net/test/stats.h"		/* m0_net_test_stats */
 #include "net/test/console.h"		/* m0_net_test_console_ctx */
+#include "net/test/initfini.h"		/* m0_net_test_init */
 
 /**
    @page net-test-fspec-cli-console Test console command line parameters
-   @todo Update obsoleted options.
+   @todo Update obsoleted options. Use
+   @code
+   ntc -?
+   @endcode
 
    Installing/uninstalling test suite (kernel modules, scripts etc.)
    to/from remote host:
@@ -81,7 +85,7 @@
    --remote-path=$HOME/net-test --live=1
    @endcode
    Run bulk test with host1 as test client and host2 as test server. Number of
-   bulk packets is one million, size is 1 MiB. Test statistics should be updated
+   bulk messages is one million, size is 1 MiB. Test statistics should be updated
    every second.
 
    @see @ref net-test
@@ -96,6 +100,41 @@
    @{
  */
 
+#define DESCRIBE(field, name, description) \
+	static const char *msg_##field = description; \
+	static const char opt_##field = name
+
+
+/* Description messages for m0_net_test_console_cfg fields */
+DESCRIBE(addr_console4servers, 'A', "Console command endpoint address "
+				    "for the test servers");
+DESCRIBE(addr_console4clients, 'a', "Console command endpoint address "
+				    "for the test clients");
+DESCRIBE(servers,	       'C', "List of test server command endpoints");
+DESCRIBE(clients,	       'c', "List of test client command endpoints");
+DESCRIBE(data_servers,	       'D', "List of test server data endpoints");
+DESCRIBE(data_clients,	       'd', "List of test client data endpoints");
+DESCRIBE(test_type,	       't', "Test type, 'ping' or 'bulk'");
+DESCRIBE(msg_nr,	       'n', "Number of test messages for the "
+				    "test client (for each server)");
+DESCRIBE(msg_size,	       's', "Test message size");
+DESCRIBE(bd_buf_nr_server,     'B', "Number of message buffers for bulk buffer "
+				    "network descriptors for the test server");
+DESCRIBE(bd_buf_nr_client,     'b', "Number of message buffers for bulk buffer "
+				    "network descriptors for the test client");
+DESCRIBE(bd_buf_size,	       'f', "Size of buffer for bulk buffer "
+				    "network descriptors");
+DESCRIBE(bd_nr_max,	       'g', "Maximum number of bulk buffer "
+				    "network descriptors in msg buffer");
+DESCRIBE(concurrency_server,   'E', "Test server concurrency");
+DESCRIBE(concurrency_client,   'e', "Test client concurrency");
+
+/**
+ * Print string with test results in parsable format
+ * in the end of the console output.
+ */
+static bool produce_parsable_output = true;
+
 /** Console printf */
 static bool addr_check(const char *addr)
 {
@@ -140,6 +179,13 @@ static bool config_check(struct m0_net_test_console_cfg *cfg)
 	      cfg->ntcc_test_type == M0_NET_TEST_TYPE_BULK))
 		return false;
 	if (cfg->ntcc_msg_nr == 0 || cfg->ntcc_msg_size == 0)
+		return false;
+	if (cfg->ntcc_test_type == M0_NET_TEST_TYPE_BULK &&
+	    (cfg->ntcc_bd_buf_nr_server == 0 ||
+	     cfg->ntcc_bd_buf_nr_client == 0 ||
+	     cfg->ntcc_bd_buf_size == 0 ||
+	     cfg->ntcc_bd_nr_max == 0))
+		return false;
 	if (cfg->ntcc_concurrency_server == 0 ||
 	    cfg->ntcc_concurrency_client == 0)
 		return false;
@@ -195,7 +241,36 @@ static int configure(int argc, char *argv[],
 {
 	bool list_if = false;
 	bool success = true;
-	/** @todo single-letter options is very bad */
+
+#define NUMBER_ARG(name)						\
+		M0_NUMBERARG(opt_##name, msg_##name,			\
+		LAMBDA(void, (int64_t nr) {				\
+			if (nr <= 0)					\
+				success = false;			\
+			else						\
+				cfg->ntcc_##name = nr;			\
+		}))
+#define SCALED_ARG(name)						\
+		M0_SCALEDARG(opt_##name, msg_##name,			\
+		LAMBDA(void, (m0_bcount_t size) {			\
+			if (size <= 0)					\
+				success = false;			\
+			else						\
+				cfg->ntcc_##name = size;		\
+		}))
+#define SLIST_ARG(name)							\
+		M0_STRINGARG(opt_##name, msg_##name,			\
+		LAMBDA(void, (const char *str) {			\
+			success &=					\
+			m0_net_test_slist_init(&cfg->ntcc_##name,	\
+					       str, ',') == 0;		\
+		}))
+#define ASCIIZ_ARG(name)						\
+		M0_STRINGARG(opt_##name, msg_##name,			\
+		LAMBDA(void, (const char *str) {			\
+			cfg->ntcc_##name = m0_net_test_u_str_copy(str);	\
+		}))
+
 	M0_GETOPTS("m0netperf", argc, argv,
 		M0_STRINGARG('t', "Test type, {ping|bulk}",
 		LAMBDA(void, (const char *type) {
@@ -206,69 +281,22 @@ static int configure(int argc, char *argv[],
 			else
 				success = false;
 		})),
-		M0_NUMBERARG('n', "Number of test messages "
-			      "for the test client",
-		LAMBDA(void, (int64_t nr) {
-			if (nr <= 0)
-				success = false;
-			else
-				cfg->ntcc_msg_nr = nr;
-		})),
-		M0_SCALEDARG('s', "Test message size",
-		LAMBDA(void, (m0_bcount_t size) {
-			if (size <= 0)
-				success = false;
-			else
-				cfg->ntcc_msg_size = size;
-		})),
-		M0_STRINGARG('a', "Console command endpoint address "
-				  "for the test servers",
-		LAMBDA(void, (const char *str) {
-			cfg->ntcc_addr_console4servers =
-				m0_net_test_u_str_copy(str);
-		})),
-		M0_STRINGARG('b', "Console command endpoint address "
-				  "for the test clients",
-		LAMBDA(void, (const char *str) {
-			cfg->ntcc_addr_console4clients =
-				m0_net_test_u_str_copy(str);
-		})),
-		M0_STRINGARG('c', "List of test server command endpoints",
-		LAMBDA(void, (const char *str) {
-			success &= m0_net_test_slist_init(&cfg->ntcc_servers,
-							  str, ',') == 0;
-		})),
-		M0_STRINGARG('d', "List of test client command endpoints",
-		LAMBDA(void, (const char *str) {
-			success &= m0_net_test_slist_init(&cfg->ntcc_clients,
-							  str, ',') == 0;
-		})),
-		M0_STRINGARG('e', "List of test server data endpoints",
-		LAMBDA(void, (const char *str) {
-			success &=
-			m0_net_test_slist_init(&cfg->ntcc_data_servers,
-					       str, ',') == 0;
-		})),
-		M0_STRINGARG('f', "List of test client data endpoints",
-		LAMBDA(void, (const char *str) {
-			success &=
-			m0_net_test_slist_init(&cfg->ntcc_data_clients,
-					       str, ',') == 0;
-		})),
-		M0_NUMBERARG('g', "Test server concurrency",
-		LAMBDA(void, (int64_t nr) {
-			if (nr <= 0)
-				success = false;
-			else
-				cfg->ntcc_concurrency_server = nr;
-		})),
-		M0_NUMBERARG('h', "Test client concurrency",
-		LAMBDA(void, (int64_t nr) {
-			if (nr <= 0)
-				success = false;
-			else
-				cfg->ntcc_concurrency_client = nr;
-		})),
+		ASCIIZ_ARG(addr_console4servers),
+		ASCIIZ_ARG(addr_console4clients),
+		SLIST_ARG(servers),
+		SLIST_ARG(clients),
+		SLIST_ARG(data_servers),
+		SLIST_ARG(data_clients),
+		M0_STRINGARG(opt_test_type, msg_test_type,
+		NUMBER_ARG(msg_nr),
+		SCALED_ARG(msg_size),
+		NUMBER_ARG(bd_buf_nr_server),
+		NUMBER_ARG(bd_buf_nr_client),
+		SCALED_ARG(bd_buf_size),
+		NUMBER_ARG(bd_nr_max),
+		NUMBER_ARG(concurrency_server),
+		NUMBER_ARG(concurrency_client),
+		M0_FLAGARG('p', "Parsable output", &produce_parsable_output),
 		M0_VERBOSEFLAGARG,
 		M0_IFLISTARG(&list_if),
 		M0_HELPARG('?'),
@@ -277,6 +305,10 @@ static int configure(int argc, char *argv[],
 		config_print(cfg);
 	success &= config_check(cfg);
 	return list_if ? 1 : success ? 0 : -1;
+#undef NUMBER_ARG
+#undef SCALED_ARG
+#undef SLIST_ARG
+#undef ASCIIZ_ARG
 }
 
 static void config_free(struct m0_net_test_console_cfg *cfg)
@@ -321,18 +353,6 @@ static void print_stats(const char *descr,
 			       m0_net_test_stats_stddev(stats));
 }
 
-static void print_status_data_v(struct m0_net_test_cmd_status_data *sd)
-{
-	m0_net_test_u_printf_v("messages total/failed/bad: ");
-	print_msg_nr("sent", &sd->ntcsd_msg_nr_send);
-	print_msg_nr(", received", &sd->ntcsd_msg_nr_recv);
-	m0_net_test_u_printf_v("; count/min/max/avg/stddev: ");
-	print_stats("MPS, sent", &sd->ntcsd_mps_send.ntmps_stats);
-	print_stats(", MPS, received", &sd->ntcsd_mps_recv.ntmps_stats);
-	print_stats(", RTT", &sd->ntcsd_rtt);
-	m0_net_test_u_printf_v(" ns\n");
-}
-
 static void bsize_print(const char *descr,
 			struct m0_net_test_console_ctx *ctx,
 			double msg_nr)
@@ -351,7 +371,9 @@ static double avg_total(m0_time_t diff_t, double msg_nr)
 
 static void print_status_data(struct m0_net_test_console_ctx *ctx)
 {
-	struct m0_net_test_cmd_status_data *sd = ctx->ntcc_clients.ntcrc_sd;
+	struct m0_net_test_cmd_status_data *sd;
+	struct m0_net_test_msg_nr	   *send_nr;
+	struct m0_net_test_msg_nr	   *recv_nr;
 	m0_time_t			    diff_t;
 	m0_time_t			    rtt_t;
 	unsigned long			    rtt;
@@ -359,23 +381,31 @@ static void print_status_data(struct m0_net_test_console_ctx *ctx)
 	double				    avg_i;
 	double				    total_o;
 	double				    total_i;
-
-	total_o = sd->ntcsd_msg_nr_send.ntmn_total;
-	total_i = sd->ntcsd_msg_nr_recv.ntmn_total;
+	bool				    type_ping;
+
+	type_ping = ctx->ntcc_cfg->ntcc_test_type == M0_NET_TEST_TYPE_PING;
+	sd = ctx->ntcc_clients.ntcrc_sd;
+	send_nr = type_ping ? &sd->ntcsd_msg_nr_send : &sd->ntcsd_bulk_nr_send;
+	recv_nr = type_ping ? &sd->ntcsd_msg_nr_recv : &sd->ntcsd_bulk_nr_recv;
+	total_o = send_nr->ntmn_total;
+	total_i = recv_nr->ntmn_total;
 	if (sd->ntcsd_finished) {
 		diff_t = m0_time_sub(sd->ntcsd_time_finish,
 				     sd->ntcsd_time_start);
 		avg_o = avg_total(diff_t, total_o);
 		avg_i = avg_total(diff_t, total_i);
 	} else {
-		avg_o = m0_net_test_stats_avg(&sd->ntcsd_mps_recv.ntmps_stats);
-		avg_i = m0_net_test_stats_avg(&sd->ntcsd_mps_send.ntmps_stats);
+		avg_o = m0_net_test_stats_avg(&sd->ntcsd_mps_send.ntmps_stats);
+		avg_i = m0_net_test_stats_avg(&sd->ntcsd_mps_recv.ntmps_stats);
 	}
 	bsize_print("avg out: ", ctx, avg_o);
 	bsize_print("/s avg in: ", ctx, avg_i);
 	bsize_print("/s total out: ", ctx, total_o);
 	bsize_print(" total in: ", ctx, total_i);
 
+	if (!type_ping)
+		sd = ctx->ntcc_servers.ntcrc_sd;
+
 	rtt_t = m0_net_test_stats_avg(&sd->ntcsd_rtt);
 	rtt = m0_time_seconds(rtt_t) * M0_TIME_ONE_BILLION +
 	      m0_time_nanoseconds(rtt_t);
@@ -384,10 +414,111 @@ static void print_status_data(struct m0_net_test_console_ctx *ctx)
 	m0_net_test_u_printf("\n");
 }
 
+static void print_msg_nr_parsable(const char *prefix,
+				  struct m0_net_test_msg_nr *msg_nr)
+{
+#define CONSOLE_PRINT_MSG_NR(name) \
+	printf("%s_"#name" %lu ", prefix, msg_nr->ntmn_##name)
+	CONSOLE_PRINT_MSG_NR(total);
+	CONSOLE_PRINT_MSG_NR(failed);
+	CONSOLE_PRINT_MSG_NR(bad);
+#undef CONSOLE_PRINT_MSG_NR
+}
+
+static void print_stats_parsable(const char *prefix,
+				 struct m0_net_test_stats *stats)
+{
+#define CONSOLE_PRINT_STATS(name) \
+	printf("%s_"#name" %lu ", prefix, stats->nts_##name);
+	CONSOLE_PRINT_STATS(count);
+	CONSOLE_PRINT_STATS(min);
+	CONSOLE_PRINT_STATS(max);
+#undef CONSOLE_PRINT_STATS
+	printf("%s_avg %.0f ", prefix, m0_net_test_stats_avg(stats));
+	printf("%s_stddev %.0f ", prefix, m0_net_test_stats_stddev(stats));
+}
+
+static void
+print_status_data_implementation(struct m0_net_test_cmd_status_data *sd,
+				 bool parsable)
+{
+	size_t i;
+	struct {
+		const char		  *prefix_p;
+		const char		  *prefix_v;
+		struct m0_net_test_msg_nr *messages;
+	} msg_nr[] = {
+		{ .prefix_p = "sent",
+		  .prefix_v = "sent",
+		  .messages = &sd->ntcsd_msg_nr_send },
+		{ .prefix_p = "received",
+		  .prefix_v = ", received",
+		  .messages = &sd->ntcsd_msg_nr_recv },
+		{ .prefix_p = "bulk_sent",
+		  .prefix_v = ", bulk sent",
+		  .messages = &sd->ntcsd_bulk_nr_send },
+		{ .prefix_p = "bulk_received",
+		  .prefix_v = ", bulk received",
+		  .messages = &sd->ntcsd_bulk_nr_recv },
+		{ .prefix_p = "transfers",
+		  .prefix_v = ", transfers",
+		  .messages = &sd->ntcsd_transfers }
+	};
+	struct {
+		const char		 *prefix_p;
+		const char		 *prefix_v;
+		struct m0_net_test_stats *stats;
+	} stats[] = {
+		{ .prefix_p = "mps_sent",
+		  .prefix_v = "MPS, sent",
+		  .stats    = &sd->ntcsd_mps_send.ntmps_stats },
+		{ .prefix_p = "mps_received",
+		  .prefix_v = ", MPS, received",
+		  .stats    = &sd->ntcsd_mps_recv.ntmps_stats },
+		{ .prefix_p = "mps_rtt",
+		  .prefix_v = ", RTT",
+		  .stats    = &sd->ntcsd_rtt },
+	};
+
+	M0_PRE(sd != NULL);
+
+	if (!parsable)
+		m0_net_test_u_printf_v("messages total/failed/bad: ");
+	for (i = 0; i < ARRAY_SIZE(msg_nr); ++i) {
+		(parsable ? print_msg_nr_parsable : print_msg_nr)
+			(parsable ? msg_nr[i].prefix_p : msg_nr[i].prefix_v,
+			 msg_nr[i].messages);
+	}
+	if (!parsable)
+		m0_net_test_u_printf_v("; count/min/max/avg/stddev: ");
+	for (i = 0; i < ARRAY_SIZE(stats); ++i) {
+		(parsable ? print_stats_parsable : print_stats)
+			(parsable ? stats[i].prefix_p : stats[i].prefix_v,
+			 stats[i].stats);
+	}
+	if (!parsable)
+		m0_net_test_u_printf_v(" ns\n");
+}
+
+static void print_status_data_v(struct m0_net_test_cmd_status_data *sd)
+{
+	print_status_data_implementation(sd, false);
+}
+
+static void print_status_data_parsable(struct m0_net_test_cmd_status_data *sd)
+{
+	print_status_data_implementation(sd, true);
+	printf("time_start = %lu ", sd->ntcsd_time_start);
+	printf("time_finish = %lu\n", sd->ntcsd_time_finish);
+}
+
 static int console_run(struct m0_net_test_console_ctx *ctx)
 {
-	m0_time_t status_interval = M0_MKTIME(1, 0);
-	bool good;
+	enum m0_net_test_role role;
+	enum m0_net_test_role role1;
+	m0_time_t	      status_interval = M0_MKTIME(1, 0);
+	bool		      good;
+	bool		      verbose;
 
 	good = console_step(ctx, M0_NET_TEST_ROLE_SERVER, M0_NET_TEST_CMD_INIT,
 			    "INIT => test servers",
@@ -409,14 +540,23 @@ static int console_run(struct m0_net_test_console_ctx *ctx)
 			    "test clients => START DONE");
 	if (!good)
 		return -ENETUNREACH;
+	role = ctx->ntcc_cfg->ntcc_test_type == M0_NET_TEST_TYPE_PING ?
+	       M0_NET_TEST_ROLE_CLIENT : M0_NET_TEST_ROLE_SERVER;
+	role1 = role == M0_NET_TEST_ROLE_CLIENT ? M0_NET_TEST_ROLE_SERVER :
+						  M0_NET_TEST_ROLE_CLIENT;
 	do {
 		/** @todo can be interrupted */
 		m0_nanosleep(status_interval, NULL);
-		if (!console_step(ctx, M0_NET_TEST_ROLE_CLIENT,
-				  M0_NET_TEST_CMD_STATUS, NULL, NULL)) {
+		good = console_step(ctx, role, M0_NET_TEST_CMD_STATUS,
+				    NULL, NULL);
+		good = good ? console_step(ctx, role1, M0_NET_TEST_CMD_STATUS,
+					   NULL, NULL) : good;
+		if (!good) {
 			m0_net_test_u_printf("STATUS DATA command failed.\n");
 		} else {
-			print_status_data_v(ctx->ntcc_clients.ntcrc_sd);
+			print_status_data_v(role == M0_NET_TEST_ROLE_CLIENT ?
+				            ctx->ntcc_clients.ntcrc_sd :
+				            ctx->ntcc_servers.ntcrc_sd);
 			print_status_data(ctx);
 		}
 	} while (!ctx->ntcc_clients.ntcrc_sd->ntcsd_finished);
@@ -434,10 +574,17 @@ static int console_run(struct m0_net_test_console_ctx *ctx)
 			    "test clients => STOP DONE");
 	if (!good)
 		return -ENETUNREACH;
+	verbose = m0_net_test_u_printf_verbose;
+	m0_net_test_u_printf_verbose = true;
 	m0_net_test_u_printf_v("clients total: ");
 	print_status_data_v(ctx->ntcc_clients.ntcrc_sd);
 	m0_net_test_u_printf_v("servers total: ");
 	print_status_data_v(ctx->ntcc_servers.ntcrc_sd);
+	m0_net_test_u_printf_verbose = verbose;
+	if (produce_parsable_output) {
+		print_status_data_parsable(ctx->ntcc_clients.ntcrc_sd);
+		print_status_data_parsable(ctx->ntcc_servers.ntcrc_sd);
+	}
 	return 0;
 }
 
@@ -449,13 +596,18 @@ int main(int argc, char *argv[])
 		.ntcc_addr_console4servers = NULL,
 		.ntcc_addr_console4clients = NULL,
 		/** @todo add to command line parameters */
-		.ntcc_cmd_send_timeout     = M0_MKTIME(3, 0),
-		.ntcc_cmd_recv_timeout     = M0_MKTIME(3, 0),
+		.ntcc_cmd_send_timeout     = M0_MKTIME(10, 0),
+		.ntcc_cmd_recv_timeout     = M0_MKTIME(10, 0),
 		.ntcc_buf_send_timeout     = M0_MKTIME(3, 0),
 		.ntcc_buf_recv_timeout     = M0_MKTIME(3, 0),
+		.ntcc_buf_bulk_timeout     = M0_MKTIME(3, 0),
 		.ntcc_test_type		   = M0_NET_TEST_TYPE_PING,
 		.ntcc_msg_nr		   = 0,
 		.ntcc_msg_size		   = 0,
+		.ntcc_bd_buf_nr_client	   = 0,
+		.ntcc_bd_buf_nr_server	   = 0,
+		.ntcc_bd_buf_size	   = 0,
+		.ntcc_bd_nr_max		   = 0,
 		.ntcc_concurrency_server   = 0,
 		.ntcc_concurrency_client   = 0,
 	};
@@ -465,6 +617,11 @@ int main(int argc, char *argv[])
 	if (rc != 0)
 		return rc;
 
+	rc = m0_net_test_init();
+	m0_net_test_u_print_error("Net-test initialization failed", rc);
+	if (rc != 0)
+		goto mero_fini;
+
 	rc = configure(argc, argv, &cfg);
 	if (rc != 0) {
 		if (rc == 1) {
@@ -475,7 +632,7 @@ int main(int argc, char *argv[])
 			m0_net_test_u_printf("Error in configuration.\n");
 			config_free(&cfg);
 		}
-		goto mero_fini;
+		goto net_test_fini;
 	}
 
 	rc = m0_net_test_console_init(&console, &cfg);
@@ -489,6 +646,8 @@ int main(int argc, char *argv[])
 	m0_net_test_console_fini(&console);
 cfg_free:
 	config_free(&cfg);
+net_test_fini:
+	m0_net_test_fini();
 mero_fini:
 	m0_fini();
 
diff --git a/net/test/user_space/node_u.c b/net/test/user_space/node_u.c
index 0591a4b..ef57847 100644
--- a/net/test/user_space/node_u.c
+++ b/net/test/user_space/node_u.c
@@ -30,6 +30,7 @@
 
 #include "net/test/user_space/common_u.h" /* m0_net_test_u_str_copy */
 #include "net/test/node.h"
+#include "net/test/initfini.h"		/* m0_net_test_init */
 
 /**
    @page net-test-fspec-cli-node-user Test node command line pamameters
@@ -104,6 +105,11 @@ int main(int argc, char *argv[])
 	if (rc != 0)
 		return rc;
 
+	rc = m0_net_test_init();
+	m0_net_test_u_print_error("Net-test initialization failed", rc);
+	if (rc != 0)
+		goto mero_fini;
+
 	/** @todo add Ctrl+C handler
 	   m0_net_test_fini()+m0_net_test_config_fini() */
 	/** @todo atexit() */
@@ -117,7 +123,7 @@ int main(int argc, char *argv[])
 			m0_net_test_u_printf("Error in configuration.\n");
 			config_free(&cfg);
 		}
-		goto mero_fini;
+		goto net_test_fini;
 	}
 
 	m0_net_test_u_printf_v("m0_net_test_node_init()\n");
@@ -142,6 +148,8 @@ node_fini:
 	m0_net_test_node_fini(&node);
 cfg_free:
 	config_free(&cfg);
+net_test_fini:
+	m0_net_test_fini();
 mero_fini:
 	m0_net_test_u_printf_v("m0_fini()\n");
 	m0_fini();
diff --git a/net/test/ut/client_server.c b/net/test/ut/client_server.c
index e9a03c8..d4a4f65 100644
--- a/net/test/ut/client_server.c
+++ b/net/test/ut/client_server.c
@@ -18,38 +18,34 @@
  * Original creation date: 05/19/2012
  */
 
-/* @todo remove */
-#ifndef __KERNEL__
-#include <stdio.h>		/* printf */
-#endif
-
-/* @todo debug only, remove it */
-#ifndef __KERNEL__
-/*
-#define LOGD(format, ...) printf(format, ##__VA_ARGS__)
-*/
-#define LOGD(format, ...) do {} while (0)
-#else
-#define LOGD(format, ...) do {} while (0)
-#endif
-
-#include "net/test/node.h"		/* m0_net_test_node_ctx */
-#include "net/test/console.h"		/* m0_net_test_console_ctx */
-
 #include "lib/ut.h"			/* M0_UT_ASSERT */
 #include "lib/memory.h"			/* m0_free */
 #include "lib/thread.h"			/* M0_THREAD_INIT */
 #include "lib/semaphore.h"		/* m0_semaphore_down */
 #include "lib/misc.h"			/* M0_SET0 */
+#include "lib/trace.h"			/* M0_LOG */
+
 #include "net/lnet/lnet.h"		/* M0_NET_LNET_PID */
 
+#include "net/test/node.h"		/* m0_net_test_node_ctx */
+#include "net/test/console.h"		/* m0_net_test_console_ctx */
+
 enum {
 	NTCS_PID		  = M0_NET_LNET_PID,
 	NTCS_PORTAL		  = 42,
 	NTCS_NODES_MAX		  = 128,
 	NTCS_NODE_ADDR_MAX	  = 0x100,
-	NTCS_TIMEOUT_SEND_MS	  = 10000,
-	NTCS_TIMEOUT_RECV_MS	  = 10000,
+	/** @todo 10min for debugging in gdb */
+	/*
+	NTCS_TIMEOUT_CMD_MS	  = 600000,
+	NTCS_TIMEOUT_SEND_MS	  = 600000,
+	NTCS_TIMEOUT_RECV_MS	  = 600000,
+	NTCS_TIMEOUT_BULK_MS	  = 600000,
+	*/
+	NTCS_TIMEOUT_CMD_MS	  = 20000,
+	NTCS_TIMEOUT_SEND_MS	  = 20000,
+	NTCS_TIMEOUT_RECV_MS	  = 20000,
+	NTCS_TIMEOUT_BULK_MS	  = 20000,
 	NTCS_TMID_CONSOLE4CLIENTS = 2998,
 	NTCS_TMID_CONSOLE4SERVERS = 2999,
 	NTCS_TMID_NODES		  = 3000,
@@ -69,8 +65,11 @@ static char  clients[(NTCS_NODES_MAX + 1) * NTCS_NODE_ADDR_MAX];
 static char  servers[(NTCS_NODES_MAX + 1) * NTCS_NODE_ADDR_MAX];
 static char  clients_data[(NTCS_NODES_MAX + 1) * NTCS_NODE_ADDR_MAX];
 static char  servers_data[(NTCS_NODES_MAX + 1) * NTCS_NODE_ADDR_MAX];
-m0_time_t    timeout_send;
-m0_time_t    timeout_recv;
+
+static m0_time_t timeout_cmd;
+static m0_time_t timeout_send;
+static m0_time_t timeout_recv;
+static m0_time_t timeout_bulk;
 
 static char *addr_get(const char *nid, int tmid)
 {
@@ -131,7 +130,7 @@ static void node_cfg_fill(struct m0_net_test_node_cfg *ncfg,
 {
 	ncfg->ntnc_addr		= addr_cmd;
 	ncfg->ntnc_addr_console = addr_console;
-	ncfg->ntnc_send_timeout = timeout_send;
+	ncfg->ntnc_send_timeout = timeout_cmd;
 
 	strncat(addr_cmd_list, ncfg->ntnc_addr, NTCS_NODE_ADDR_MAX);
 	strncat(addr_cmd_list, last_node ? "" : ",", 2);
@@ -144,8 +143,8 @@ static void node_cfg_fill(struct m0_net_test_node_cfg *ncfg,
 static void msg_nr_print(const char *prefix,
 			 const struct m0_net_test_msg_nr *msg_nr)
 {
-	LOGD("%s total/failed/bad = %lu/%lu/%lu\n", prefix,
-	     msg_nr->ntmn_total, msg_nr->ntmn_failed, msg_nr->ntmn_bad);
+	M0_LOG(M0_DEBUG, "%-21s total/failed/bad = %lu/%lu/%lu", prefix,
+	       msg_nr->ntmn_total, msg_nr->ntmn_failed, msg_nr->ntmn_bad);
 }
 
 /*
@@ -159,22 +158,31 @@ static void net_test_client_server(const char *nid,
 				   size_t concurrency_client,
 				   size_t concurrency_server,
 				   size_t msg_nr,
-				   m0_bcount_t msg_size)
+				   m0_bcount_t msg_size,
+				   size_t bd_buf_nr_client,
+				   size_t bd_buf_nr_server,
+				   m0_bcount_t bd_buf_size,
+				   size_t bd_nr_max)
 {
-	struct m0_net_test_console_cfg console_cfg;
-	struct m0_net_test_console_ctx console;
-	int			       rc;
-	int			       i;
-	m0_time_t		       _1s = M0_MKTIME(1, 0);
+	struct m0_net_test_cmd_status_data *sd_servers;
+	struct m0_net_test_cmd_status_data *sd_clients;
+	struct m0_net_test_console_cfg	    console_cfg;
+	struct m0_net_test_console_ctx	    console;
+	int				    rc;
+	int				    i;
+	m0_time_t			    _1s = M0_MKTIME(1, 0);
 
 	M0_PRE(clients_nr <= NTCS_NODES_MAX);
 	M0_PRE(servers_nr <= NTCS_NODES_MAX);
 	/* prepare config for test clients and test servers */
+	timeout_cmd  = ms2time(NTCS_TIMEOUT_CMD_MS);
 	timeout_send = ms2time(NTCS_TIMEOUT_SEND_MS);
 	timeout_recv = ms2time(NTCS_TIMEOUT_RECV_MS);
+	timeout_bulk = ms2time(NTCS_TIMEOUT_BULK_MS);
 	addr_console4clients = addr_get(nid, NTCS_TMID_CONSOLE4CLIENTS);
 	addr_console4servers = addr_get(nid, NTCS_TMID_CONSOLE4SERVERS);
 	clients[0] = '\0';
+	clients_data[0] = '\0';
 	for (i = 0; i < clients_nr; ++i) {
 		node_cfg_fill(&node_cfg[i],
 			      addr_get(nid, NTCS_TMID_CMD_CLIENTS + i), clients,
@@ -183,6 +191,7 @@ static void net_test_client_server(const char *nid,
 			      i == clients_nr - 1);
 	}
 	servers[0] = '\0';
+	servers_data[0] = '\0';
 	for (i = 0; i < servers_nr; ++i) {
 		node_cfg_fill(&node_cfg[clients_nr + i],
 			      addr_get(nid, NTCS_TMID_CMD_SERVERS + i), servers,
@@ -206,12 +215,12 @@ static void net_test_client_server(const char *nid,
 	/* prepare console config */
 	console_cfg.ntcc_addr_console4servers = addr_console4servers;
 	console_cfg.ntcc_addr_console4clients = addr_console4clients;
-	LOGD("\naddr_console4servers = %s\n", addr_console4servers);
-	LOGD("addr_console4clients = %s\n", addr_console4clients);
-	LOGD("clients		   = %s\n", clients);
-	LOGD("servers		   = %s\n", servers);
-	LOGD("clients_data	   = %s\n", clients_data);
-	LOGD("servers_data	   = %s\n", servers_data);
+	M0_LOG(M0_DEBUG, "addr_console4servers = %s", addr_console4servers);
+	M0_LOG(M0_DEBUG, "addr_console4clients = %s", addr_console4clients);
+	M0_LOG(M0_DEBUG, "clients      = %s", (char *) clients);
+	M0_LOG(M0_DEBUG, "servers      = %s", (char *) servers);
+	M0_LOG(M0_DEBUG, "clients_data = %s", (char *) clients_data);
+	M0_LOG(M0_DEBUG, "servers_data = %s", (char *) servers_data);
 	rc = m0_net_test_slist_init(&console_cfg.ntcc_clients, clients, ',');
 	M0_UT_ASSERT(rc == 0);
 	rc = m0_net_test_slist_init(&console_cfg.ntcc_servers, servers, ',');
@@ -222,13 +231,18 @@ static void net_test_client_server(const char *nid,
 	rc = m0_net_test_slist_init(&console_cfg.ntcc_data_servers,
 				    servers_data, ',');
 	M0_UT_ASSERT(rc == 0);
-	console_cfg.ntcc_cmd_send_timeout   = timeout_send;
-	console_cfg.ntcc_cmd_recv_timeout   = timeout_recv;
+	console_cfg.ntcc_cmd_send_timeout   = timeout_cmd;
+	console_cfg.ntcc_cmd_recv_timeout   = timeout_cmd;
 	console_cfg.ntcc_buf_send_timeout   = timeout_send;
 	console_cfg.ntcc_buf_recv_timeout   = timeout_recv;
+	console_cfg.ntcc_buf_bulk_timeout   = timeout_bulk;
 	console_cfg.ntcc_test_type	    = type;
 	console_cfg.ntcc_msg_nr		    = msg_nr;
 	console_cfg.ntcc_msg_size	    = msg_size;
+	console_cfg.ntcc_bd_buf_nr_server   = bd_buf_nr_server;
+	console_cfg.ntcc_bd_buf_nr_client   = bd_buf_nr_client;
+	console_cfg.ntcc_bd_buf_size	    = bd_buf_size;
+	console_cfg.ntcc_bd_nr_max	    = bd_nr_max;
 	console_cfg.ntcc_concurrency_server = concurrency_server;
 	console_cfg.ntcc_concurrency_client = concurrency_client;
 	/* initialize console */
@@ -257,21 +271,34 @@ static void net_test_client_server(const char *nid,
 					     M0_NET_TEST_CMD_STATUS);
 		M0_UT_ASSERT(rc == clients_nr);
 	} while (!console.ntcc_clients.ntcrc_sd->ntcsd_finished);
+	/* send STATUS command to the test clients */
+	rc = m0_net_test_console_cmd(&console, M0_NET_TEST_ROLE_CLIENT,
+				     M0_NET_TEST_CMD_STATUS);
+	M0_UT_ASSERT(rc == clients_nr);
 	/* send STATUS command to the test servers */
 	rc = m0_net_test_console_cmd(&console, M0_NET_TEST_ROLE_SERVER,
 				     M0_NET_TEST_CMD_STATUS);
 	M0_UT_ASSERT(rc == servers_nr);
-	msg_nr_print("client sent\t",
+	msg_nr_print("client msg sent",
 		     &console.ntcc_clients.ntcrc_sd->ntcsd_msg_nr_send);
-	msg_nr_print("client received\t",
+	msg_nr_print("client msg received",
 		     &console.ntcc_clients.ntcrc_sd->ntcsd_msg_nr_recv);
-	msg_nr_print("server sent\t",
+	msg_nr_print("client bulk sent",
+		     &console.ntcc_clients.ntcrc_sd->ntcsd_bulk_nr_send);
+	msg_nr_print("client bulk received",
+		     &console.ntcc_clients.ntcrc_sd->ntcsd_bulk_nr_recv);
+	msg_nr_print("client transfers",
+		     &console.ntcc_clients.ntcrc_sd->ntcsd_transfers);
+	msg_nr_print("server msg sent",
 		     &console.ntcc_servers.ntcrc_sd->ntcsd_msg_nr_send);
-	msg_nr_print("server received\t",
+	msg_nr_print("server msg received",
 		     &console.ntcc_servers.ntcrc_sd->ntcsd_msg_nr_recv);
-	M0_UT_ASSERT(
-		console.ntcc_servers.ntcrc_sd->ntcsd_msg_nr_send.ntmn_total ==
-		console.ntcc_servers.ntcrc_sd->ntcsd_msg_nr_recv.ntmn_total);
+	msg_nr_print("server bulk sent",
+		     &console.ntcc_servers.ntcrc_sd->ntcsd_bulk_nr_send);
+	msg_nr_print("server bulk received",
+		     &console.ntcc_servers.ntcrc_sd->ntcsd_bulk_nr_recv);
+	msg_nr_print("server transfers",
+		     &console.ntcc_servers.ntcrc_sd->ntcsd_transfers);
 	/* send STOP command to the test clients */
 	rc = m0_net_test_console_cmd(&console, M0_NET_TEST_ROLE_CLIENT,
 				     M0_NET_TEST_CMD_STOP);
@@ -280,11 +307,30 @@ static void net_test_client_server(const char *nid,
 	rc = m0_net_test_console_cmd(&console, M0_NET_TEST_ROLE_SERVER,
 				     M0_NET_TEST_CMD_STOP);
 	M0_UT_ASSERT(rc == servers_nr);
+	sd_servers = console.ntcc_servers.ntcrc_sd;
+	sd_clients = console.ntcc_clients.ntcrc_sd;
+	/* check stats */
+	if (type == M0_NET_TEST_TYPE_BULK) {
+		/*
+		 * number of transfers are not measured on the test server
+		 * for ping test.
+		 */
+		M0_ASSERT(sd_servers->ntcsd_transfers.ntmn_total ==
+			  sd_clients->ntcsd_transfers.ntmn_total);
+	}
+	M0_ASSERT(sd_servers->ntcsd_msg_nr_send.ntmn_total ==
+		  sd_clients->ntcsd_msg_nr_recv.ntmn_total);
+	M0_ASSERT(sd_servers->ntcsd_msg_nr_recv.ntmn_total ==
+		  sd_clients->ntcsd_msg_nr_send.ntmn_total);
+	M0_ASSERT(sd_servers->ntcsd_bulk_nr_send.ntmn_total ==
+		  sd_clients->ntcsd_bulk_nr_recv.ntmn_total);
+	M0_ASSERT(sd_servers->ntcsd_bulk_nr_recv.ntmn_total ==
+		  sd_clients->ntcsd_bulk_nr_send.ntmn_total);
 	/* finalize console */
-	m0_net_test_slist_fini(&console_cfg.ntcc_data_servers);
-	m0_net_test_slist_fini(&console_cfg.ntcc_data_clients);
 	m0_net_test_slist_fini(&console_cfg.ntcc_servers);
 	m0_net_test_slist_fini(&console_cfg.ntcc_clients);
+	m0_net_test_slist_fini(&console_cfg.ntcc_data_servers);
+	m0_net_test_slist_fini(&console_cfg.ntcc_data_clients);
 	m0_net_test_console_fini(&console);
 	/* finalize test clients and test servers */
 	for (i = 0; i < clients_nr + servers_nr; ++i) {
@@ -300,7 +346,8 @@ static void net_test_client_server(const char *nid,
 void m0_net_test_client_server_ping_ut(void)
 {
 	net_test_client_server("0@lo", M0_NET_TEST_TYPE_PING,
-			       8, 8, 8, 128, 0x1000, 0x1000);
+			       8, 8, 8, 128, 0x1000, 0x1000,
+			       0, 0, 0, 0);
 	/*
 	net_test_client_server("0@lo", M0_NET_TEST_TYPE_PING,
 			       8, 8, 4, 16, 0x100, 0x100);
@@ -309,10 +356,14 @@ void m0_net_test_client_server_ping_ut(void)
 
 void m0_net_test_client_server_bulk_ut(void)
 {
-	/*
+	/**
+	 * @todo investigate strange m0_net_tm_stop() time
+	 * on the bulk test client.
+	 */
 	net_test_client_server("0@lo", M0_NET_TEST_TYPE_BULK,
-			       8, 8, 4, 16, 0x100, 0x10000);
-	*/
+			       1, 1, 1, 2,
+			       0x1000, 0x1000,
+			       1, 2, 0x1000, 0x10000);
 }
 
 /*
diff --git a/net/test/ut/commands.c b/net/test/ut/commands.c
index 33e53a1..f5cde4c 100644
--- a/net/test/ut/commands.c
+++ b/net/test/ut/commands.c
@@ -284,7 +284,8 @@ static void commands_ut_recv_type(struct net_test_cmd_node *node,
 					 M0_NET_TEST_TYPE_BULK);
 		commands_ut_assert(node, cmd_init->ntci_msg_nr	 == 0x10000);
 		commands_ut_assert(node, cmd_init->ntci_msg_size == 0x100000);
-		commands_ut_assert(node, cmd_init->ntci_concurrency == 0x100);
+		commands_ut_assert(node,
+				   cmd_init->ntci_msg_concurrency == 0x100);
 		timeout = cmd_init->ntci_buf_send_timeout;
 		commands_ut_assert(node, m0_time_seconds(timeout) == 2);
 		commands_ut_assert(node, m0_time_nanoseconds(timeout) == 3);
@@ -393,14 +394,14 @@ static void commands_ut_send_all_type(size_t nr,
 	M0_SET0(&cmd);
 	cmd.ntc_type = type;
 	if (type == M0_NET_TEST_CMD_INIT) {
-		cmd_init		   = &cmd.ntc_init;
-		cmd_init->ntci_role	   = M0_NET_TEST_ROLE_SERVER;
-		cmd_init->ntci_type	   = M0_NET_TEST_TYPE_BULK;
-		cmd_init->ntci_msg_nr	   = 0x10000;
-		cmd_init->ntci_msg_size	   = 0x100000;
-		cmd_init->ntci_concurrency = 0x100;
+		cmd_init			= &cmd.ntc_init;
+		cmd_init->ntci_role		= M0_NET_TEST_ROLE_SERVER;
+		cmd_init->ntci_type		= M0_NET_TEST_TYPE_BULK;
+		cmd_init->ntci_msg_nr		= 0x10000;
+		cmd_init->ntci_msg_size		= 0x100000;
+		cmd_init->ntci_msg_concurrency  = 0x100;
 		cmd_init->ntci_buf_send_timeout = M0_MKTIME(2, 3);
-		cmd_init->ntci_tm_ep	   = "0@lo:1:2:3";
+		cmd_init->ntci_tm_ep		= "0@lo:1:2:3";
 		m0_net_test_slist_init(&cmd_init->ntci_ep, "1,2,3", ',');
 	} else if (type != M0_NET_TEST_CMD_START &&
 		   type != M0_NET_TEST_CMD_STOP &&
diff --git a/net/test/ut/main.c b/net/test/ut/main.c
index 745db69..15fc6ba 100644
--- a/net/test/ut/main.c
+++ b/net/test/ut/main.c
@@ -20,7 +20,7 @@
 
 #include "lib/ut.h"		/* m0_test_suite */
 
-#include "net/test/network.h"	/* m0_net_test_network_init */
+#include "net/test/initfini.h"	/* m0_net_test_init */
 
 extern void m0_net_test_ringbuf_ut(void);
 
@@ -30,6 +30,11 @@ extern void m0_net_test_str_ut(void);
 
 extern void m0_net_test_slist_ut(void);
 
+extern void m0_net_test_stats_ut(void);
+extern void m0_net_test_timestamp_ut(void);
+
+extern void m0_net_test_service_ut(void);
+
 extern void m0_net_test_network_ut_buf_desc(void);
 extern void m0_net_test_network_ut_ping(void);
 extern void m0_net_test_network_ut_bulk(void);
@@ -37,47 +42,40 @@ extern void m0_net_test_network_ut_bulk(void);
 extern void m0_net_test_cmd_ut_single(void);
 extern void m0_net_test_cmd_ut_multiple(void);
 
-extern void m0_net_test_stats_ut(void);
-extern void m0_net_test_timestamp_ut(void);
-
-extern void m0_net_test_service_ut(void);
-
 extern void m0_net_test_client_server_ping_ut(void);
 extern void m0_net_test_client_server_bulk_ut(void);
 
-static int net_test_init(void)
-{
-	return m0_net_test_network_init();
-}
-
 static int net_test_fini(void)
 {
-	m0_net_test_network_fini();
+	m0_net_test_fini();
 	return 0;
 }
 
 const struct m0_test_suite m0_net_test_ut = {
 	.ts_name = "net-test",
-	.ts_init = net_test_init,
+	.ts_init = m0_net_test_init,
 	.ts_fini = net_test_fini,
 	.ts_tests = {
 		{ "ringbuf",		m0_net_test_ringbuf_ut		  },
 		{ "serialize",		m0_net_test_serialize_ut	  },
 		{ "str",		m0_net_test_str_ut		  },
 		{ "slist",		m0_net_test_slist_ut		  },
+		{ "stats",		m0_net_test_stats_ut		  },
+		{ "timestamp",		m0_net_test_timestamp_ut	  },
+		{ "service",		m0_net_test_service_ut		  },
 		{ "network-buf-desc",	m0_net_test_network_ut_buf_desc	  },
 		{ "network-ping",	m0_net_test_network_ut_ping	  },
 		{ "network-bulk",	m0_net_test_network_ut_bulk	  },
 		{ "cmd-single",		m0_net_test_cmd_ut_single	  },
+#ifndef __KERNEL__
 		{ "cmd-multiple",	m0_net_test_cmd_ut_multiple	  },
-		{ "stats",		m0_net_test_stats_ut		  },
-		{ "timestamp",		m0_net_test_timestamp_ut	  },
-		{ "service",		m0_net_test_service_ut		  },
 		{ "client-server-ping",	m0_net_test_client_server_ping_ut },
 		{ "client-server-bulk",	m0_net_test_client_server_bulk_ut },
+#endif
 		{ NULL,			NULL				  }
 	}
 };
+M0_EXPORTED(m0_net_test_ut);
 
 /*
  *  Local variables:
diff --git a/net/test/ut/network.c b/net/test/ut/network.c
index bcd37dc..ddb9ef1 100644
--- a/net/test/ut/network.c
+++ b/net/test/ut/network.c
@@ -18,7 +18,7 @@
  * Original creation date: 05/19/2012
  */
 
-/* @todo remove */
+/** @todo remove */
 #ifndef __KERNEL__
 #include <stdio.h>		/* printf */
 #endif
@@ -30,7 +30,7 @@
 
 #include "net/test/network.h"
 
-/* @todo debug only, remove it */
+/** @todo debug only, remove it */
 #ifndef __KERNEL__
 #define LOGD(format, ...) printf(format, ##__VA_ARGS__)
 #else
@@ -56,7 +56,7 @@ static m0_bcount_t bv_copy(struct m0_bufvec *dst,
 	return m0_bufvec_cursor_copy(&bcdst, &bcsrc, len);
 }
 
-/* @todo too expensive, use m0_bufvec_cursor_step() + memcmp() */
+/** @todo too expensive, use m0_bufvec_cursor_step() + memcmp() */
 static bool net_buf_data_eq(enum m0_net_test_network_buf_type buf_type,
 			    struct m0_net_test_network_ctx *ctx1,
 			    uint32_t buf_index1,
@@ -157,14 +157,14 @@ void m0_net_test_network_ut_ping(void)
 					  &ping_tm_cb, &ping_buf_cb,
 					  buf_size, 1,
 					  0, 0,
-					  1, NULL);
+					  1, NULL, false);
 	M0_UT_ASSERT(rc == 0);
 
 	rc = m0_net_test_network_ctx_init(&recv, "0@lo:12345:42:4001",
 					  &ping_tm_cb, &ping_buf_cb,
 					  buf_size, 1,
 					  0, 0,
-					  1, NULL);
+					  1, NULL, false);
 	M0_UT_ASSERT(rc == 0);
 
 	rc = m0_net_test_network_ep_add(&send, "0@lo:12345:42:4001");
@@ -193,7 +193,7 @@ void m0_net_test_network_ut_ping(void)
 		rc = m0_net_test_network_msg_send(&send, 0, 0);
 		M0_UT_ASSERT(rc == 0);
 
-		/* @todo timeddown */
+		/** @todo timeddown */
 		m0_semaphore_down(&recv_sem);
 		m0_semaphore_down(&send_sem);
 
@@ -251,8 +251,10 @@ void m0_net_test_network_ut_bulk(void)
 {
 	static struct m0_net_test_network_ctx client;
 	static struct m0_net_test_network_ctx server;
+	m0_bcount_t			      offset;
+	m0_bcount_t			      bcount;
 	int				      rc;
-	int				      rc_u32;
+	size_t				      rc_size;
 	int				      i;
 	bool				      rc_bool;
 
@@ -260,13 +262,13 @@ void m0_net_test_network_ut_bulk(void)
 					  &bulk_tm_cb, &bulk_buf_cb,
 					  NET_TEST_PING_BUF_SIZE, 1,
 					  NET_TEST_BULK_BUF_SIZE, 2,
-					  1, NULL);
+					  1, NULL, false);
 	M0_UT_ASSERT(rc == 0);
 	rc = m0_net_test_network_ctx_init(&server, "0@lo:12345:42:4001",
 					  &bulk_tm_cb, &bulk_buf_cb,
 					  NET_TEST_PING_BUF_SIZE, 1,
 					  NET_TEST_BULK_BUF_SIZE, 1,
-					  1, NULL);
+					  1, NULL, false);
 	M0_UT_ASSERT(rc == 0);
 
 	rc = m0_net_test_network_ep_add(&client, "0@lo:12345:42:4001");
@@ -301,13 +303,16 @@ void m0_net_test_network_ut_bulk(void)
 			M0_NET_QT_PASSIVE_BULK_RECV);
 	M0_UT_ASSERT(rc == 0);
 	/* client: add buffer descriptors to ping buf */
-	m0_net_test_network_bd_reset(&client, 0);
-	rc = m0_net_test_network_bd_encode(&client, 0, 0);
-	M0_UT_ASSERT(rc == 0);
-	rc = m0_net_test_network_bd_encode(&client, 0, 1);
-	M0_UT_ASSERT(rc == 0);
-	rc_u32 = m0_net_test_network_bd_count(&client, 0);
-	M0_UT_ASSERT(rc_u32 == 2);
+	offset = 0;
+	bcount = m0_net_test_network_bd_serialize(M0_NET_TEST_SERIALIZE,
+						  &client, 0, 0, offset);
+	M0_UT_ASSERT(bcount != 0);
+	offset += bcount;
+	bcount = m0_net_test_network_bd_serialize(M0_NET_TEST_SERIALIZE,
+						  &client, 1, 0, offset);
+	M0_UT_ASSERT(bcount != 0);
+	rc_size = m0_net_test_network_bd_nr(&client, 0);
+	M0_UT_ASSERT(rc_size == 2);
 	/* client: send ping buf */
 	rc = m0_net_test_network_msg_send(&client, 0, 0);
 	M0_UT_ASSERT(rc == 0);
@@ -317,23 +322,26 @@ void m0_net_test_network_ut_bulk(void)
 	rc_bool = net_buf_data_eq(M0_NET_TEST_BUF_PING, &client, 0, &server, 0);
 	M0_ASSERT(rc_bool);
 	/* server: extract buf descriptor for active recv */
-	rc_u32 = m0_net_test_network_bd_count(&server, 0);
-	M0_UT_ASSERT(rc_u32 == 2);
-	m0_net_test_network_bd_reset(&server, 0);
-	rc = m0_net_test_network_bd_decode(&server, 0, 0);
-	M0_UT_ASSERT(rc == 0);
+	rc_size = m0_net_test_network_bd_nr(&server, 0);
+	M0_UT_ASSERT(rc_size == 2);
+	offset = 0;
+	bcount = m0_net_test_network_bd_serialize(M0_NET_TEST_DESERIALIZE,
+						  &server, 0, 0, offset);
+	M0_UT_ASSERT(bcount != 0);
+	offset += bcount;
 	/* server: do active recv */
 	rc = m0_net_test_network_bulk_enqueue(&server, 0, 0,
-			M0_NET_QT_ACTIVE_BULK_RECV);
+					      M0_NET_QT_ACTIVE_BULK_RECV);
 	M0_UT_ASSERT(rc == 0);
 	/* server: wait for active recv callback */
 	m0_semaphore_down(&bulk_cb_sem[M0_NET_QT_ACTIVE_BULK_RECV]);
 	/* server: extract buf descriptor for active send */
-	rc = m0_net_test_network_bd_decode(&server, 0, 0);
-	M0_UT_ASSERT(rc == 0);
+	bcount = m0_net_test_network_bd_serialize(M0_NET_TEST_DESERIALIZE,
+						  &server, 0, 0, offset);
+	M0_UT_ASSERT(bcount != 0);
 	/* server: do active send */
 	rc = m0_net_test_network_bulk_enqueue(&server, 0, 0,
-			M0_NET_QT_ACTIVE_BULK_SEND);
+					      M0_NET_QT_ACTIVE_BULK_SEND);
 	M0_UT_ASSERT(rc == 0);
 	/* server: wait for active send callbacks */
 	m0_semaphore_down(&bulk_cb_sem[M0_NET_QT_ACTIVE_BULK_SEND]);
@@ -413,33 +421,32 @@ static bool buf_desc_eq(struct m0_net_test_network_ctx *ctx1,
 static void multiple_buf_desc_encode_decode(struct m0_net_test_network_ctx *ctx,
 					    int count)
 {
-	int i;
-	bool rc_bool;
-	uint32_t rc_u32;
-	int rc;
-
-	m0_net_test_network_bd_reset(ctx, 0);
-	rc_u32 = m0_net_test_network_bd_count(ctx, 0);
-	M0_UT_ASSERT(rc_u32 == 0);
+	m0_bcount_t bcount;
+	m0_bcount_t offset;
+	size_t	    rc_size;
+	int	    i;
+	bool	    rc_bool;
+
+	offset = 0;
 	for (i = 0; i < count; ++i) {
 		/* encode */
-		rc = m0_net_test_network_bd_encode(ctx, 0, i % 2);
-		M0_UT_ASSERT(rc == 0);
+		bcount = m0_net_test_network_bd_serialize(M0_NET_TEST_SERIALIZE,
+							 ctx, i % 2, 0, offset);
+		M0_UT_ASSERT(bcount != 0);
+		offset += bcount;
 		/* check number of buf descriptors in the ping buffer */
-		rc_u32 = m0_net_test_network_bd_count(ctx, 0);
-		M0_UT_ASSERT(rc_u32 == i + 1);
+		rc_size = m0_net_test_network_bd_nr(ctx, 0);
+		M0_UT_ASSERT(rc_size == i + 1);
 	}
 	/* prepare to decode */
-	m0_net_test_network_bd_reset(ctx, 0);
-	rc_u32 = m0_net_test_network_bd_count(ctx, 0);
-	M0_UT_ASSERT(rc_u32 == 0);
+	offset = 0;
 	for (i = 0; i < count; ++i) {
 		/* decode */
-		rc = m0_net_test_network_bd_decode(ctx, 0, 2 + i % 2);
-		M0_UT_ASSERT(rc == 0);
-		/* check number of buf descriptors in the ping buffer */
-		rc_u32 = m0_net_test_network_bd_count(ctx, 0);
-		M0_UT_ASSERT(rc_u32 == i + 1);
+		bcount = m0_net_test_network_bd_serialize(
+				M0_NET_TEST_DESERIALIZE,
+				ctx, 2 + i % 2, 0, offset);
+		M0_UT_ASSERT(bcount != 0);
+		offset += bcount;
 		/* compare m0_net_buf_desc's */
 		rc_bool = buf_desc_eq(ctx, i % 2, ctx, 2 + i % 2);
 		M0_UT_ASSERT(rc_bool);
@@ -449,15 +456,15 @@ static void multiple_buf_desc_encode_decode(struct m0_net_test_network_ctx *ctx,
 void m0_net_test_network_ut_buf_desc(void)
 {
 	static struct m0_net_test_network_ctx ctx;
-	int i;
-	int rc;
-	static struct m0_clink tmwait;
+	static struct m0_clink		      tmwait;
+	int				      i;
+	int				      rc;
 
 	rc = m0_net_test_network_ctx_init(&ctx, "0@lo:12345:42:*",
 					  &tm_cb_empty, &buf_cb_empty,
 					  NET_TEST_PING_BUF_SIZE, 2,
 					  NET_TEST_BULK_BUF_SIZE, 4,
-					  1, NULL);
+					  1, NULL, false);
 	M0_UT_ASSERT(rc == 0);
 
 	/* add some ep - tranfer machine ep */
diff --git a/net/test/ut/ringbuf.c b/net/test/ut/ringbuf.c
index f739e8b..b8101e5 100644
--- a/net/test/ut/ringbuf.c
+++ b/net/test/ut/ringbuf.c
@@ -31,14 +31,20 @@ static void ringbuf_push_pop(struct m0_net_test_ringbuf *rb, size_t nr)
 {
 	size_t i;
 	size_t value;
+	size_t len;
 
 	M0_PRE(rb != NULL);
 
-	for (i = 0; i < nr; ++i)
+	for (i = 0; i < nr; ++i) {
 		m0_net_test_ringbuf_push(rb, i);
+		len = m0_net_test_ringbuf_nr(rb);
+		M0_UT_ASSERT(len == i + 1);
+	}
 	for (i = 0; i < nr; ++i) {
 		value = m0_net_test_ringbuf_pop(rb);
 		M0_UT_ASSERT(value == i);
+		len = m0_net_test_ringbuf_nr(rb);
+		M0_UT_ASSERT(len == nr - i - 1);
 	}
 }
 
@@ -48,14 +54,21 @@ void m0_net_test_ringbuf_ut(void)
 	int			   rc;
 	int			   i;
 	size_t			   value;
+	size_t			   nr;
 
 	/* init */
 	rc = m0_net_test_ringbuf_init(&rb, NET_TEST_RB_SIZE);
 	M0_UT_ASSERT(rc == 0);
+	nr = m0_net_test_ringbuf_nr(&rb);
+	M0_UT_ASSERT(nr == 0);
 	/* test #1: single value push, single value pop */
 	m0_net_test_ringbuf_push(&rb, 42);
+	nr = m0_net_test_ringbuf_nr(&rb);
+	M0_UT_ASSERT(nr == 1);
 	value = m0_net_test_ringbuf_pop(&rb);
 	M0_UT_ASSERT(value == 42);
+	nr = m0_net_test_ringbuf_nr(&rb);
+	M0_UT_ASSERT(nr == 0);
 	/* test #2: multiple values push, multiple values pop */
 	ringbuf_push_pop(&rb, NET_TEST_RB_SIZE);
 	/*
diff --git a/net/test/ut/stats.c b/net/test/ut/stats.c
index c2a0459..46d28bb 100644
--- a/net/test/ut/stats.c
+++ b/net/test/ut/stats.c
@@ -29,6 +29,8 @@
 #include "lib/misc.h"		/* M0_SET0 */
 #include "lib/ut.h"		/* M0_UT_ASSERT */
 
+#include "mero/magic.h"	/* M0_NET_TEST_TIMESTAMP_MAGIC */
+
 #include "net/test/stats.h"
 
 enum {
diff --git a/utils/linux_kernel/main.c b/utils/linux_kernel/main.c
index e8c5367..717f4c3 100644
--- a/utils/linux_kernel/main.c
+++ b/utils/linux_kernel/main.c
@@ -38,6 +38,7 @@ extern const struct m0_test_suite m0_loop_ut;
 extern const struct m0_test_suite m0_net_bulk_if_ut;
 extern const struct m0_test_suite m0_net_bulk_mem_ut;
 extern const struct m0_test_suite m0_net_lnet_ut;
+extern const struct m0_test_suite m0_net_test_ut;
 extern const struct m0_test_suite m0_net_tm_prov_ut;
 extern const struct m0_test_suite conn_ut;
 extern const struct m0_test_suite file_io_ut;
@@ -69,6 +70,7 @@ static void run_kernel_ut(int ignored)
 	m0_ut_add(&m0_net_bulk_if_ut);
 	m0_ut_add(&m0_net_bulk_mem_ut);
 	m0_ut_add(&m0_net_lnet_ut);
+	m0_ut_add(&m0_net_test_ut);
 	m0_ut_add(&m0_net_tm_prov_ut);
 	m0_ut_add(&conn_ut);
 	m0_ut_add(&frm_ut);
-- 
1.8.3.2

