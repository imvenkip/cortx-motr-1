From a05be784f00d7cf4869cf0b707ccc15c3ba2b2c6 Mon Sep 17 00:00:00 2001
From: Amit Jambure <Amit_Jambure@xyratex.com>
Date: Fri, 6 Apr 2012 15:34:03 +0530
Subject: [PATCH 10/10] * Added code to call readdir rpc.

---
 c2t1fs/linux_kernel/dir.c | 163 +++++++++++++++++++++++++++++++++++++++-------
 mdservice/md_fops.ff      |   3 +-
 2 files changed, 140 insertions(+), 26 deletions(-)

diff --git a/c2t1fs/linux_kernel/dir.c b/c2t1fs/linux_kernel/dir.c
index aa16716..02f92b3 100644
--- a/c2t1fs/linux_kernel/dir.c
+++ b/c2t1fs/linux_kernel/dir.c
@@ -195,8 +195,8 @@ static void inode_to_fop_cob(const struct inode *inode,
 #define OFFSET_WITHIN_PAGE(addr) \
 		(uint32_t)((unsigned long)addr & (PAGE_CACHE_SIZE - 1))
 
-static int to_fop_str(const unsigned char *name,
-		      int                  namelen,
+static int to_fop_str(const unsigned char *str,
+		      int                  len,
 		      struct c2_fop_str   *fop_str)
 {
 	struct page **ppage;
@@ -211,24 +211,23 @@ static int to_fop_str(const unsigned char *name,
 
 	} else {
 
-		*ppage             = virt_to_page(name);
+		*ppage             = virt_to_page(str);
 		fop_str->s_buf     = ppage;
-		fop_str->cfs_pgoff = OFFSET_WITHIN_PAGE(name);
-		fop_str->s_len     = namelen;
+		fop_str->cfs_pgoff = OFFSET_WITHIN_PAGE(str);
+		fop_str->s_len     = len;
 
 		rc = 0;
-
 	}
 
 	C2_LEAVE("rc: %d", rc);
 	return rc;
 }
 
-int fop_create_prepare(struct inode        *dir,
-		       struct inode        *inode,
-		       const unsigned char *name,
-		       int                  namelen,
-		       struct c2_fop      **out)
+static int create_request_prepare(struct inode        *dir,
+				  struct inode        *inode,
+				  const unsigned char *name,
+				  int                  namelen,
+				  struct c2_fop      **out)
 {
 	struct c2t1fs_inode  *dir_ci;
 	struct c2_fop_create *req;
@@ -267,34 +266,51 @@ int fop_create_prepare(struct inode        *dir,
 	return rc;
 }
 
-static int make_create_rpc_call(struct c2_fop         *fop,
-				struct c2_rpc_session *session)
+static int gen_rpc(struct c2_fop          *fop,
+		   struct c2_rpc_session  *session,
+		   struct c2_fop         **reply_fop)
 {
-	int rc;
+	struct c2_rpc_item *reply_item;
+	int                 rc;
+
+	*reply_fop = NULL;
 
 	rc = c2_rpc_client_call(fop, session, &c2_fop_default_item_ops,
 				C2T1FS_RPC_TIMEOUT);
 	if (rc == 0) {
-		struct c2_rpc_item       *reply_item;
-		struct c2_fop            *reply_fop;
-		struct c2_fop_create_rep *create_reply;
 
 		/* XXX @todo Handle generic error reply */
 		reply_item = fop->f_item.ri_reply;
 		C2_ASSERT(reply_item != NULL);
-		C2_ASSERT(reply_item->ri_type ==
-			  &c2_fop_create_rep_fopt.ft_rpc_item_type);
 
-		reply_fop = c2_rpc_item_to_fop(reply_item);
+		*reply_fop = c2_rpc_item_to_fop(reply_item);
+	}
+
+	return rc;
+
+}
+
+static int create_rpc(struct c2_fop         *fop,
+		      struct c2_rpc_session *session)
+{
+	struct c2_fop_create_rep *create_reply;
+	struct c2_fop            *reply_fop;
+	int                       rc;
+
+	C2_ENTRY();
+
+	rc = gen_rpc(fop, session, &reply_fop);
+	if (rc == 0) {
 		create_reply = c2_fop_data(reply_fop);
 		C2_ASSERT(create_reply != NULL);
 
-		rc = create_reply->c_rc;
 		/*
-		 * XXX @todo load attributes returned by create_reply in
-		 * inode
+		 * Do other create specific work if any
+		 * e.g. move fop_cob attributes to inode
 		 */
+		rc = create_reply->c_rc;
 	}
+
 	C2_LEAVE("rc: %d", rc);
 	return rc;
 }
@@ -315,11 +331,11 @@ int c2t1fs_gob_create(struct inode        *dir,
 	} else if (namelen >= C2T1FS_MAX_NAME_LEN) {
 		rc =  -ENAMETOOLONG;
 	} else {
-		rc = fop_create_prepare(dir, inode, name, namelen, &fop);
+		rc = create_request_prepare(dir, inode, name, namelen, &fop);
 		if (rc == 0) {
 			session = c2t1fs_inode_get_tgt_session(dir);
 			C2_ASSERT(session != NULL);
-			rc = make_create_rpc_call(fop, session);
+			rc = create_rpc(fop, session);
 		}
 	}
 
@@ -550,6 +566,103 @@ out:
 	return 0;
 }
 
+int readdir_request_prepare(const struct inode  *dir,
+			    const char          *last,
+			    struct c2_fop      **out)
+{
+	struct c2_fop_readdir *fop_readdir;
+	struct c2_fop         *fop;
+	int                    rc;
+
+	C2_ENTRY();
+
+	*out = NULL;
+
+	fop = c2_fop_alloc(&c2_fop_readdir_fopt, NULL);
+	if (fop == NULL) {
+		C2_LEAVE("rc: %d", ENOMEM);
+		return -ENOMEM;
+	}
+
+	fop_readdir = c2_fop_data(fop);
+	C2_ASSERT(fop_readdir != NULL);
+
+	inode_to_fop_cob(dir, &fop_readdir->r_body);
+
+	fop_readdir->r_path.s_len = 0;
+
+	rc = to_fop_str(last, strlen(last), &fop_readdir->r_pos);
+	if (rc != 0)
+		c2_fop_free(fop);
+	else
+		*out = fop;
+
+	C2_LEAVE("rc: %d", rc);
+	return rc;
+}
+
+void fop_buf_to_c2_buf(const struct c2_fop_buf *fbuf,
+		       struct c2_buf           *buf)
+{
+	char *data;
+
+	C2_PRE(fbuf != NULL && fbuf->b_addr != NULL);
+	/* XXX Temporary: assuming fop_buf is always <= page size */
+	C2_PRE(fbuf->b_count + fbuf->cfb_pgoff < PAGE_CACHE_SIZE);
+
+	data = page_address(*fbuf->b_addr);
+	data += fbuf->cfb_pgoff;
+
+	c2_buf_init(buf, data, fbuf->b_count);
+}
+int readdir_rpc(struct c2_fop         *fop,
+		struct c2_rpc_session *session,
+		struct c2_buf         *buf_out)
+{
+	struct c2_fop_readdir_rep *readdir_reply;
+	struct c2_fop             *reply_fop;
+	int                        rc;
+
+	C2_ENTRY();
+
+	rc = gen_rpc(fop, session, &reply_fop);
+	if (rc == 0) {
+		readdir_reply = c2_fop_data(reply_fop);
+		C2_ASSERT(readdir_reply != NULL);
+
+		rc = readdir_reply->r_rc;
+		if (rc == 0) {
+			fop_buf_to_c2_buf(&readdir_reply->r_buf, buf_out);
+		}
+	}
+
+	C2_LEAVE("rc: %d", rc);
+	return rc;
+
+}
+/*static*/ int do_readdir(struct inode *dir, struct c2_buf *out)
+{
+	struct c2_rpc_session *session;
+	struct c2_fop         *fop;
+	int                    rc;
+
+	C2_ENTRY();
+	C2_PRE(dir != NULL && out != NULL);
+
+	c2_buf_init(out, NULL, 0);
+
+	rc = readdir_request_prepare(dir, ".", &fop);
+	if (rc == 0) {
+		session = c2t1fs_inode_get_tgt_session(dir);
+		C2_ASSERT(session != NULL);
+
+		rc = readdir_rpc(fop, session, out);
+	}
+
+	C2_LEAVE("rc: %d", rc);
+	return rc;
+}
+
 static int c2t1fs_dir_ent_remove(struct inode *dir, struct c2t1fs_dir_ent *de)
 {
 	C2_ENTRY();
diff --git a/mdservice/md_fops.ff b/mdservice/md_fops.ff
index e913aa9..1d7a78b 100644
--- a/mdservice/md_fops.ff
+++ b/mdservice/md_fops.ff
@@ -136,7 +136,8 @@ DEF(c2_fop_buf, SEQUENCE,
 DEF(c2_fop_readdir_rep, RECORD,
     _(r_end,  c2_fop_str),
     _(r_body, c2_fop_cob),
-    _(r_buf,  c2_fop_buf));
+    _(r_buf,  c2_fop_buf),
+    _(r_rc,   U32));
 
 /** @} end of fop group */
 
-- 
1.8.3.2

