From 76d4c5a09d84d71de0def2e55251b2168893db99 Mon Sep 17 00:00:00 2001
From: Mandar Sawant <mandar_sawant@xyratex.com>
Date: Thu, 26 Dec 2013 11:33:44 +0530
Subject: [PATCH 6/7] be.conv.conf, - Add BE specific xcode object dup function
 to xcode/xcode.c - Add cleanup code for confdb in case of failure - Add
 failure test cases to conf/ut/db.c

---
 conf/db.c     | 162 ++++++++++++++++++++++------------------------------------
 conf/ut/db.c  |  52 ++++++++++++-------
 xcode/xcode.c | 108 +++++++++++++++++++++++++++++++++++++--
 xcode/xcode.h |   5 ++
 4 files changed, 203 insertions(+), 124 deletions(-)

diff --git a/conf/db.c b/conf/db.c
index 426d563..b587f89 100644
--- a/conf/db.c
+++ b/conf/db.c
@@ -20,6 +20,7 @@
 
 #define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_CONF
 #include "lib/trace.h"
+#include "lib/finject.h"
 
 #include "conf/db.h"
 #include "conf/onwire.h"     /* m0_confx_obj, m0_confx */
@@ -56,20 +57,16 @@ static enum m0_conf_objtype xobj_type(const struct m0_confx_obj *xobj)
 	return t;
 }
 
-/* Note: m0_xcode_ctx_init() doesn't allow `xobj' to be const. Sigh. */
-static int
-xcode_ctx_init(struct m0_xcode_ctx *ctx, struct m0_confx_obj *xobj, bool decode)
+static int confx_to_xcode_obj(struct m0_confx_obj *xobj,
+			      struct m0_xcode_obj *out, bool decode)
 {
-	M0_ENTRY();
+	M0_PRE(xobj != NULL && out != NULL);
 
 	switch(xobj_type(xobj)) {
-#define _CASE(type, abbrev)                                                    \
-	case type:                                                             \
-		m0_xcode_ctx_init(                                             \
-			ctx,                                                   \
-			&M0_XCODE_OBJ(                                         \
-				m0_confx_ ## abbrev ## _xc,                    \
-				decode ? NULL : &xobj->o_conf.u.u_ ## abbrev));\
+#define _CASE(type, abbrev)                                                        \
+	case type:                                                                 \
+		*out =  M0_XCODE_OBJ(m0_confx_ ## abbrev ## _xc,                    \
+				     decode ? NULL : &xobj->o_conf.u.u_ ## abbrev); \
 		break
 
 	_CASE(M0_CO_PROFILE,    profile);
@@ -85,6 +82,19 @@ xcode_ctx_init(struct m0_xcode_ctx *ctx, struct m0_confx_obj *xobj, bool decode)
 		M0_RETERR(-EINVAL, "Invalid object type: %u", xobj_type(xobj));
 	}
 
+	M0_RETURN(0);
+}
+
+/* Note: m0_xcode_ctx_init() doesn't allow `xobj' to be const. Sigh. */
+static int
+xcode_ctx_init(struct m0_xcode_ctx *ctx, struct m0_confx_obj *xobj, bool decode)
+{
+	struct m0_xcode_obj obj;
+
+	M0_ENTRY();
+
+	confx_to_xcode_obj(xobj, &obj, decode);
+	m0_xcode_ctx_init(ctx, &obj);
 	if (decode)
 		ctx->xcx_alloc = _conf_xcode_alloc;
 
@@ -148,7 +158,7 @@ confdb_key_cmp(const void *key0, const void *key1)
 
 static m0_bcount_t confdb_ksize(const void *key)
 {
-	return sizeof(struct confdb_key);;
+	return sizeof(struct confdb_key);
 }
 
 static m0_bcount_t confdb_vsize(const void *val)
@@ -188,15 +198,13 @@ static void confx_to_dbkey(struct m0_confx_obj *src, struct confdb_key *key)
  *
  * @note  xcode API doesn't let `src' to be const.
  */
-static int confx_to_db(struct m0_confx_obj *src, struct confdb_key *key,
-		       struct confdb_obj *dest)
+static void confx_to_db(struct m0_confx_obj *src, struct confdb_key *key,
+			struct confdb_obj *dest)
 {
 	M0_ENTRY();
 
 	m0_buf_init(&dest->do_key, key, sizeof(struct confdb_key));
 	m0_buf_init(&dest->do_rec, &src->o_conf, sizeof(struct m0_confx_u));
-
-	M0_RETURN(0);
 }
 
 /**
@@ -210,15 +218,16 @@ static int confx_from_db(struct m0_confx_obj *dest, enum m0_conf_objtype type,
 {
 	struct confdb_key *key;
 	struct m0_buf         buf;
-	int                   rc = 0;
+	int                   rc;
 	M0_ENTRY();
 	M0_PRE(M0_CO_DIR < type && type < M0_CO_NR);
 
 	M0_SET0(&dest->o_id); /* to satisfy the precondition of m0_buf_copy() */
 	key = (struct confdb_key *)src->do_key.b_addr;
 	m0_buf_init(&buf, key->cdk_key, key->cdk_len);
-	m0_buf_copy(&dest->o_id, &buf);
-	dest->o_conf = *(struct m0_confx_u *)src->do_rec.b_addr;
+	rc = m0_buf_copy(&dest->o_id, &buf);
+	if (rc == 0)
+		dest->o_conf = *(struct m0_confx_u *)src->do_rec.b_addr;
 
 	M0_RETURN(rc);
 }
@@ -278,97 +287,42 @@ confdb_tables_init(struct m0_be_seg *seg, struct m0_be_btree *btrees[],
 		M0_BE_OP_SYNC(op, m0_be_btree_create(btrees[i], tx, &op));
 		rc = m0_be_seg_dict_insert(seg, tx, table_names[i], btrees[i]);
 		if (rc != 0)
-			return rc;
+			break;
+	}
+
+	if (M0_FI_ENABLED("ut_confdb_create_failure"))
+		rc = -EINVAL;
+	if (rc != 0) {
+		confdb_tables_fini(seg);
+		m0_confdb_destroy(seg, tx);
 	}
 
 	M0_RETURN(rc);
 }
 
-
 /* ------------------------------------------------------------------
  * Database operations
  * ------------------------------------------------------------------ */
-#define CONF_XCODE_BE_ALLOC_PTR(seg, tx, xobj, xit, ptr, size) \
-do {                                                           \
-	ptr = m0_xcode_allocp(xit, &size);                    \
-	if (size != 0 && *ptr == NULL) {                       \
-		M0_ASSERT(xobj->xo_ptr == NULL);               \
-		M0_BE_ALLOC_ARR_SYNC(*ptr, size, seg, tx);     \
-		xobj->xo_ptr = *ptr;                           \
-		if (xobj->xo_ptr == NULL)                      \
-			return -ENOMEM;                        \
-	}                                                      \
-} while (0);
-
 static int confx_obj_dup(struct m0_confx_obj *dest, struct m0_confx_obj *src,
 			 struct m0_be_seg *seg, struct m0_be_tx *tx)
 {
-	struct m0_xcode_ctx     dctx;
-	struct m0_xcode_ctx     sctx;
-	struct m0_xcode_cursor *dit = &dctx.xcx_it;
-	struct m0_xcode_cursor *sit = &sctx.xcx_it;
-	struct m0_xcode_obj    *src_obj;
-	struct m0_xcode_obj    *dest_obj;
-	int                     result;
-	int                     rc;
+	struct m0_xcode_obj    src_obj;
+	struct m0_xcode_obj    dest_obj;
+	int                    rc;
 
 	M0_BE_ALLOC_ARR_SYNC(dest->o_id.b_addr, src->o_id.b_nob, seg, tx);
 	dest->o_id.b_nob = src->o_id.b_nob;
 	memcpy(dest->o_id.b_addr, src->o_id.b_addr, src->o_id.b_nob);
 	dest->o_conf.u_type = src->o_conf.u_type;
-	rc = xcode_ctx_init(&dctx, dest, false) ?: xcode_ctx_init(&sctx, src, false);
-	if (rc != 0)
-		M0_RETURN(rc);
-	while ((result = m0_xcode_next(sit)) > 0) {
-                struct m0_xcode_cursor_frame *sf;
-                struct m0_xcode_cursor_frame *df;
-		struct m0_xcode_obj          *sobj;
-		struct m0_xcode_obj          *dobj;
-		const struct m0_xcode_type   *xt;
-		size_t                        nob = 0;
-		void                        **slot;
-
-		result = m0_xcode_next(dit);
-		M0_ASSERT(result > 0);
-
-		sf = m0_xcode_cursor_top(sit);
-		df = m0_xcode_cursor_top(dit);
-		sobj = &sf->s_obj;
-		dobj = &df->s_obj;
-		xt = sobj->xo_type;
-                if (sf->s_flag == M0_XCODE_CURSOR_PRE &&
-                    xt->xct_aggr == M0_XA_ATOM) {
-                        struct m0_xcode_cursor_frame *prev = df - 1;
-                        struct m0_xcode_obj          *par  = &prev->s_obj;
-                        bool array = m0_xcode_at_array(dit, prev, par) &&
-                                m0_xcode_is_byte_array(par->xo_type);
-			CONF_XCODE_BE_ALLOC_PTR(seg, tx, dobj, dit, slot, nob)
-			if (nob == 0)
-				nob = sobj->xo_type->xct_sizeof;
-			memcpy(dobj->xo_ptr, sobj->xo_ptr, nob);
-			if (array) {
-                                dit->xcu_depth--;
-                                sit->xcu_depth--;
-                                m0_xcode_skip(dit);
-                                m0_xcode_skip(sit);
-			}
-		} else if (sf->s_flag == M0_XCODE_CURSOR_PRE &&
-			   xt->xct_aggr == M0_XA_SEQUENCE &&
-			   dobj->xo_ptr == NULL) {
-				CONF_XCODE_BE_ALLOC_PTR(seg, tx, dobj, dit, slot, nob)
-		}
-	}
-
-	dest_obj = &dctx.xcx_it.xcu_stack[0].s_obj;
-	src_obj = &sctx.xcx_it.xcu_stack[0].s_obj;
-
-	if (result >= 0)
-		result = 0;
-	M0_POST(ergo(result == 0, m0_xcode_cmp(dest_obj, src_obj) == 0));
-
-	return result;
+	rc = confx_to_xcode_obj(dest, &dest_obj, false) ?:
+		confx_to_xcode_obj(src, &src_obj, false);
+	if (M0_FI_ENABLED("ut_confx_obj_dup_failure"))
+		rc = -EINVAL;
+	if (rc == 0)
+		rc = m0_xcode_be_dup(&dest_obj, &src_obj, seg, tx);
+
+	return rc;
 }
-#undef CONF_XCODE_BE_ALLOC_PTR
 
 M0_INTERNAL int m0_confdb_create_credit(struct m0_be_seg *seg,
 					const struct m0_confx *conf,
@@ -475,20 +429,24 @@ M0_INTERNAL int m0_confdb_create(struct m0_be_seg *seg, struct m0_be_tx *tx,
 		M0_ASSERT(IS_IN_ARRAY(xobj_type(&conf->cx_objs[i]),
 				      table_names));
 		rc = confx_obj_dup(&confx_objs[i], &conf->cx_objs[i], seg, tx);
-		M0_SET0(&db_obj);
-		confx_to_dbkey(&confx_objs[i], &db_key);
-		rc = confx_to_db(&confx_objs[i], &db_key, &db_obj);
 		if (rc != 0)
 			break;
+		M0_SET0(&db_obj);
+		confx_to_dbkey(&confx_objs[i], &db_key);
+		confx_to_db(&confx_objs[i], &db_key, &db_obj);
 		btree = btrees[xobj_type(&conf->cx_objs[i])];
 		M0_BE_OP_SYNC(op, m0_be_btree_insert(btree, tx, &op,
 						     &db_obj.do_key,
 						     &db_obj.do_rec));
 	}
-	rc = confdb_objs_count(btrees, &nr_objs);
-	M0_ASSERT(rc == 0);
-	if (rc !=0)
+	if (rc == 0) {
+		rc = confdb_objs_count(btrees, &nr_objs);
+		M0_ASSERT(rc == 0);
+	}
+	if (rc !=0) {
 		confdb_tables_fini(seg);
+		m0_confdb_destroy(seg, tx);
+	}
 	m0_free(confx_objs);
 	M0_RETURN(rc);
 }
@@ -580,9 +538,9 @@ out:
 	if (rc == 0) {
 		M0_POST(i == dest->cx_nr);
 	} else {
-		/*for (; i > 0; --i)
-			m0_xcode_free(&M0_XCODE_OBJ(m0_confx_obj_xc,
-						    &dest->cx_objs[i]));*/
+		for (; i > 0; --i)
+			m0_free(dest->cx_objs[i].o_id.b_addr);
+		confx_free(dest);
 		M0_SET0(dest);
 	}
 	M0_RETURN(rc);
diff --git a/conf/ut/db.c b/conf/ut/db.c
index 67f7771..b6261c9 100644
--- a/conf/ut/db.c
+++ b/conf/ut/db.c
@@ -19,6 +19,7 @@
  */
 
 #include <stdlib.h>        /* system */
+#include "lib/finject.h"
 #include "conf/db.h"       /* m0_confdb_create, m0_confdb_read */
 #include "conf/onwire.h"   /* m0_confx_obj, m0_confx */
 #include "conf/obj.h"      /* m0_conf_objtype */
@@ -188,19 +189,21 @@ static void conf_ut_db_fini()
         m0_be_ut_backend_fini(&ut_be);
 }
 
-#define CONF_UT_BE_TX_CREATE(tx, ut_be, accum, rc) \
-do {                                               \
-        m0_be_ut_tx_init(&(tx), &(ut_be));         \
-        m0_be_tx_prep(&(tx), &(accum));            \
-        rc = m0_be_tx_open_sync(&(tx));            \
-        M0_UT_ASSERT(rc == 0);                     \
-} while (0);
-
-#define CONF_UT_BE_TX_FINI(tx)    \
-do {                              \
-        m0_be_tx_close_sync(&tx); \
-        m0_be_tx_fini(&tx);       \
-} while (0);
+static int conf_ut_be_tx_create(struct m0_be_tx *tx,
+				struct m0_be_ut_backend *ut_be,
+				struct m0_be_tx_credit *accum)
+{
+        m0_be_ut_tx_init(tx, ut_be);
+        m0_be_tx_prep(tx, accum);
+        return m0_be_tx_open_sync(tx);
+}
+
+static void conf_ut_be_tx_fini(struct m0_be_tx *tx)
+{
+        m0_be_tx_close_sync(tx);
+        m0_be_tx_fini(tx);
+}
+
 void test_confdb(void)
 {
 	struct m0_confx        *enc;
@@ -244,10 +247,22 @@ void test_confdb(void)
 
 	rc = m0_confdb_create_credit(seg, enc, &accum);
 	M0_UT_ASSERT(rc == 0);
-	CONF_UT_BE_TX_CREATE(tx, ut_be, accum, rc);
+	rc = conf_ut_be_tx_create(&tx, &ut_be, &accum);
+	M0_UT_ASSERT(rc == 0);
+
+	m0_fi_enable("confdb_tables_init", "ut_confdb_create_failure");
+	rc = m0_confdb_create(seg, &tx, enc);
+	M0_UT_ASSERT(rc < 0);
+	m0_fi_disable("confdb_tables_init", "ut_confdb_create_failure");
+
+	m0_fi_enable("confx_obj_dup", "ut_confx_obj_dup_failure");
+	rc = m0_confdb_create(seg, &tx, enc);
+	M0_UT_ASSERT(rc < 0);
+	m0_fi_disable("confx_obj_dup", "ut_confx_obj_dup_failure");
+
 	rc = m0_confdb_create(seg, &tx, enc);
 	M0_UT_ASSERT(rc == 0);
-	CONF_UT_BE_TX_FINI(tx);
+	conf_ut_be_tx_fini(&tx);
 
 	rc = m0_confdb_read(seg, &dec);
 	M0_UT_ASSERT(rc == 0);
@@ -259,10 +274,11 @@ void test_confdb(void)
 	M0_SET0(&accum);
 	rc = m0_confdb_destroy_credit(seg, &accum);
 	M0_UT_ASSERT(rc == 0);
-	CONF_UT_BE_TX_CREATE(tx, ut_be, accum, rc);
+	rc = conf_ut_be_tx_create(&tx, &ut_be, &accum);
+	M0_UT_ASSERT(rc == 0);
 	rc = m0_confdb_destroy(seg, &tx);
         M0_UT_ASSERT(rc == 0);
-	CONF_UT_BE_TX_FINI(tx);
+	conf_ut_be_tx_fini(&tx);
 	conf_ut_db_fini();
 
 	cleanup();
@@ -270,5 +286,3 @@ void test_confdb(void)
 
 #undef _BUF
 #undef _CONFDB_PATH
-#undef CONF_UT_BE_TX_CREATE
-#undef CONF_UT_BE_TX_FINI
diff --git a/xcode/xcode.c b/xcode/xcode.c
index 9725329..eb96c5d 100644
--- a/xcode/xcode.c
+++ b/xcode/xcode.c
@@ -23,7 +23,8 @@
 #include "lib/errno.h"
 #include "lib/assert.h"
 #include "lib/memory.h"
-
+#include "be/op.h"
+#include "be/alloc.h"
 #include "xcode/xcode.h"
 
 /**
@@ -422,6 +423,108 @@ M0_INTERNAL void m0_xcode_free(struct m0_xcode_obj *obj)
 	}
 }
 
+static int xcode_be_alloc(struct m0_be_seg *seg, struct m0_be_tx *tx,
+			  struct m0_xcode_obj *xobj, struct m0_xcode_cursor *it,
+			  size_t *size)
+{
+	int    rc = 0;
+	void **slot;
+
+	slot = m0_xcode_allocp(it, size);
+	if (*size != 0 && *slot == NULL) {
+		M0_ASSERT(xobj->xo_ptr == NULL);
+		M0_BE_ALLOC_ARR_SYNC(*slot, *size, seg, tx);
+		xobj->xo_ptr = *slot;
+		if (xobj->xo_ptr == NULL)
+			rc = -ENOMEM;
+	}
+
+	return rc;
+}
+
+static bool is_xcode_cursor_at(struct m0_xcode_cursor *it,
+			       enum m0_xcode_cursor_flag flag,
+			       enum m0_xcode_aggr aggr)
+{
+	struct m0_xcode_cursor_frame *f = m0_xcode_cursor_top(it);
+
+	return (f->s_flag == flag &&
+		f->s_obj.xo_type->xct_aggr == aggr);
+}
+
+static void iff_at_array_xcode_cursor_skip(struct m0_xcode_cursor *it)
+{
+	struct m0_xcode_cursor_frame *prev = m0_xcode_cursor_top(it) - 1;
+	struct m0_xcode_obj          *par  = &prev->s_obj;
+	bool array = m0_xcode_at_array(it, prev, par) &&
+		m0_xcode_is_byte_array(par->xo_type);
+
+	if (array) {
+		it->xcu_depth--;
+		m0_xcode_skip(it);
+	}
+}
+
+M0_INTERNAL int m0_xcode_be_dup(struct m0_xcode_obj *dest,
+				struct m0_xcode_obj *src, struct m0_be_seg *seg,
+				struct m0_be_tx *tx)
+{
+	struct m0_xcode_cursor  dit;
+	struct m0_xcode_cursor  sit;
+	struct m0_xcode_obj    *src_obj;
+	struct m0_xcode_obj    *dest_obj;
+	int                     result;
+	int                     rc;
+
+	M0_PRE(dest->xo_type == src->xo_type);
+
+	m0_xcode_cursor_init(&sit, src);
+	m0_xcode_cursor_init(&dit, dest);
+	while ((result = m0_xcode_next(&sit)) > 0) {
+		struct m0_xcode_cursor_frame *sf;
+		struct m0_xcode_cursor_frame *df;
+		struct m0_xcode_obj          *sobj;
+		struct m0_xcode_obj          *dobj;
+		const struct m0_xcode_type   *xt;
+		size_t                        nob = 0;
+
+		result = m0_xcode_next(&dit);
+		M0_ASSERT(result > 0);
+
+		sf = m0_xcode_cursor_top(&sit);
+		df = m0_xcode_cursor_top(&dit);
+		M0_ASSERT(sf->s_flag == df->s_flag);
+		sobj = &sf->s_obj;
+		dobj = &df->s_obj;
+		xt = sobj->xo_type;
+		M0_ASSERT(xt == dobj->xo_type);
+		if (is_xcode_cursor_at(&sit, M0_XCODE_CURSOR_PRE, M0_XA_ATOM)) {
+			rc = xcode_be_alloc(seg, tx, dobj, &dit, &nob);
+			M0_ASSERT(rc == 0);
+			if (nob == 0)
+				nob = sobj->xo_type->xct_sizeof;
+			memcpy(dobj->xo_ptr, sobj->xo_ptr, nob);
+			iff_at_array_xcode_cursor_skip(&sit);
+			iff_at_array_xcode_cursor_skip(&dit);
+		} else if (is_xcode_cursor_at(&sit, M0_XCODE_CURSOR_PRE,
+					      M0_XA_SEQUENCE) &&
+			   dobj->xo_ptr == NULL) {
+			rc = xcode_be_alloc(seg, tx, dobj, &dit, &nob);
+			M0_ASSERT(rc == 0);
+		}
+	}
+
+	dest_obj = &dit.xcu_stack[0].s_obj;
+	src_obj = &sit.xcu_stack[0].s_obj;
+
+	if (result >= 0)
+		result = 0;
+	M0_POST(ergo(result == 0, m0_xcode_cmp(dest_obj, src_obj) == 0));
+
+	return result;
+
+}
+
 M0_INTERNAL int m0_xcode_cmp(const struct m0_xcode_obj *o0,
 			     const struct m0_xcode_obj *o1)
 {
@@ -452,8 +555,7 @@ M0_INTERNAL int m0_xcode_cmp(const struct m0_xcode_obj *o0,
 		xt = s0->xo_type;
 		M0_ASSERT(xt == s1->xo_type);
 
-		if (t0->s_flag == M0_XCODE_CURSOR_PRE &&
-		    xt->xct_aggr == M0_XA_ATOM) {
+		if (is_xcode_cursor_at(&it0, M0_XCODE_CURSOR_PRE, M0_XA_ATOM)) {
 			result = memcmp(s0->xo_ptr, s1->xo_ptr, xt->xct_sizeof);
 			if (result != 0)
 				return result;
diff --git a/xcode/xcode.h b/xcode/xcode.h
index 038e6de..056638c 100644
--- a/xcode/xcode.h
+++ b/xcode/xcode.h
@@ -122,6 +122,8 @@
 
 /* import */
 struct m0_bufvec_cursor;
+struct m0_be_seg;
+struct m0_be_tx;
 
 /* export */
 struct m0_xcode;
@@ -642,6 +644,9 @@ M0_INTERNAL int m0_xcode_read(struct m0_xcode_obj *obj, const char *str);
 M0_INTERNAL void m0_xcode_free(struct m0_xcode_obj *obj);
 M0_INTERNAL int m0_xcode_cmp(const struct m0_xcode_obj *o0,
 			     const struct m0_xcode_obj *o1);
+M0_INTERNAL int m0_xcode_be_dup(struct m0_xcode_obj *dest,
+				struct m0_xcode_obj *src, struct m0_be_seg *seg,
+				struct m0_be_tx *tx);
 
 /**
    Returns the address of a sub-object within an object.
-- 
1.8.3.2

