From 9ee69a31e641ff5b3a91dec19923543f082c3cbe Mon Sep 17 00:00:00 2001
From: Maxim Medved <Max_Medved@xyratex.com>
Date: Thu, 24 Jan 2013 13:59:28 +0200
Subject: [PATCH 02/99] net-test-kernel integration

---
 build_kernel_modules/Makefile.in |   12 +-
 lib/linux_kernel/ktrace.c        |    6 +
 lib/linux_kernel/semaphore.c     |    4 +
 net/test/commands.c              |   80 +--
 net/test/commands.h              |   12 +-
 net/test/console.c               |   88 ++-
 net/test/debug.h                 |   86 +++
 net/test/network.c               |   17 +-
 net/test/node.c                  |  119 ++--
 net/test/node_bulk.c             |  314 ++++++-----
 net/test/node_helper.c           |    3 +-
 net/test/node_ping.c             |   69 +--
 net/test/node_stub.c             |  133 +++++
 net/test/node_stub.h             |   51 ++
 net/test/ringbuf.c               |    6 +-
 net/test/serialize.c             |    4 +-
 net/test/service.c               |   12 -
 net/test/service.h               |    1 -
 net/test/slist.c                 |   32 +-
 net/test/stats.h                 |    5 +-
 net/test/str.c                   |    1 +
 net/test/ut/client_server.c      |  180 +++---
 net/test/ut/commands.c           |  196 ++++++-
 net/test/ut/main.c               |   16 +-
 net/test/ut/network.c            | 1154 +++++++++++++++++++++++++++++++++++++-
 utils/linux_kernel/main.c        |    4 +
 utils/ut.valgrind                |    2 +-
 utils/ut_main.c                  |    8 +-
 28 files changed, 2138 insertions(+), 477 deletions(-)
 create mode 100644 net/test/debug.h
 create mode 100644 net/test/node_stub.c
 create mode 100644 net/test/node_stub.h

diff --git a/build_kernel_modules/Makefile.in b/build_kernel_modules/Makefile.in
index 1b1f989..285b550 100644
--- a/build_kernel_modules/Makefile.in
+++ b/build_kernel_modules/Makefile.in
@@ -154,11 +154,13 @@ net_lnet_ut_SOURCES             := lnet_ut.c
 
 net_test_SOURCES		:= commands.c console.c initfini.c network.c  \
 				   node_bulk.c node_helper.c node_ping.c      \
-				   node.c ringbuf.c serialize.c service.c     \
-				   slist.c stats.c str.c
-net_test_HEADERS		:= commands.h console.h initfini.h network.h  \
-				   node_bulk.h node_helper.h node_ping.h      \
-				   node.h ringbuf.h serialize.h service.h     \
+				   node_stub.c node.c ringbuf.c serialize.c   \
+				   service.c slist.c stats.c str.c
+net_test_HEADERS		:= commands.h console.h debug.h initfini.h    \
+				   network.h node_bulk.h node_helper.h	      \
+				   node_ping.h node_stub.h node.h ringbuf.h   \
+				   serialize.h service.h slist.h stats.h      \
+				   str.h
 
 net_test_ut_SOURCES             := client_server.c commands.c main.c          \
                                    network.c ringbuf.c serialize.c service.c  \
diff --git a/lib/linux_kernel/ktrace.c b/lib/linux_kernel/ktrace.c
index 5903841..1dc344e 100644
--- a/lib/linux_kernel/ktrace.c
+++ b/lib/linux_kernel/ktrace.c
@@ -35,6 +35,11 @@
  * @{
  */
 
+static char *trace_immediate_mask = "all";
+static char *trace_level	  = "debug+";
+static char *trace_print_context  = "full";
+
+/*
 static char *trace_immediate_mask;
 module_param(trace_immediate_mask, charp, 0644);
 MODULE_PARM_DESC(trace_immediate_mask,
@@ -53,6 +58,7 @@ MODULE_PARM_DESC(trace_print_context,
 		 " controls whether to display additional trace point"
 		 " info, like subsystem, file, func, etc.; values:"
 		 " none, func, short, full");
+ */
 
 static int set_trace_immediate_mask(void)
 {
diff --git a/lib/linux_kernel/semaphore.c b/lib/linux_kernel/semaphore.c
index 7ff31d5..0f92b3e 100644
--- a/lib/linux_kernel/semaphore.c
+++ b/lib/linux_kernel/semaphore.c
@@ -80,6 +80,10 @@ M0_INTERNAL bool m0_semaphore_timeddown(struct m0_semaphore *semaphore,
 	ts.tv_sec  = m0_time_seconds(reltime);
 	ts.tv_nsec = m0_time_nanoseconds(reltime);
 	reljiffies = timespec_to_jiffies(&ts);
+	/*
+	if (reljiffies == 0)
+		reljiffies = 1;
+	*/
 
 	return down_timeout(&semaphore->s_sem, reljiffies) == 0;
 }
diff --git a/net/test/commands.c b/net/test/commands.c
index 9ced63b..c9ee713 100644
--- a/net/test/commands.c
+++ b/net/test/commands.c
@@ -18,32 +18,25 @@
  * Original creation date: 05/05/2012
  */
 
-/** @todo remove */
-#ifndef __KERNEL__
-#include <stdio.h>		/* printf */
-#endif
-
-/** @todo debug only, remove it */
-#ifndef __KERNEL__
-/*
-#define LOGD(format, ...) printf(format, ##__VA_ARGS__)
-*/
-#define LOGD(format, ...) do {} while (0)
-#else
-#define LOGD(format, ...) do {} while (0)
-#endif
-
 #include "lib/cdefs.h"		/* container_of */
 #include "lib/types.h"		/* m0_bcount_t */
 #include "lib/misc.h"		/* M0_SET0 */
 #include "lib/memory.h"		/* M0_ALLOC_ARR */
 #include "lib/errno.h"		/* ENOMEM */
+#include "lib/trace.h"		/* M0_LOG */
 
 #include "net/test/serialize.h"	/* m0_net_test_serialize */
 #include "net/test/str.h"	/* m0_net_test_str */
 
 #include "net/test/commands.h"
 
+#ifdef NET_TEST_MODULE_NAME
+#undef NET_TEST_MODULE_NAME
+#endif
+#define NET_TEST_MODULE_NAME commands
+#include "net/test/debug.h"	/* LOGD */
+
+
 /**
    @defgroup NetTestCommandsInternals Commands
    @ingroup NetTestInternals
@@ -215,7 +208,7 @@ static void cmd_free(struct m0_net_test_cmd *cmd)
 	M0_PRE(cmd != NULL);
 
 	if (cmd->ntc_type == M0_NET_TEST_CMD_INIT) {
-		m0_net_test_str_fini  (&cmd->ntc_init.ntci_tm_ep);
+		m0_net_test_str_fini(&cmd->ntc_init.ntci_tm_ep);
 		m0_net_test_slist_fini(&cmd->ntc_init.ntci_ep);
 	}
 }
@@ -241,7 +234,10 @@ static void commands_cb_msg_recv(struct m0_net_test_network_ctx *net_ctx,
 	struct m0_net_test_cmd_ctx *ctx = cmd_ctx_extract(net_ctx);
 
 	M0_PRE(m0_net_test_commands_invariant(ctx));
+	M0_PRE(buf_index >= ctx->ntcc_ep_nr && buf_index < ctx->ntcc_ep_nr * 3);
 	M0_PRE(q == M0_NET_QT_MSG_RECV);
+	LOGD("M0_NET_QT_MSG_RECV commands callback from %s",
+	     ev->nbe_ep == NULL ? "NULL" : ev->nbe_ep->nep_addr);
 
 	/* save endpoint and buffer status */
 	if (ev->nbe_ep != NULL)
@@ -265,6 +261,10 @@ static void commands_cb_msg_send(struct m0_net_test_network_ctx *net_ctx,
 
 	M0_PRE(m0_net_test_commands_invariant(ctx));
 	M0_PRE(q == M0_NET_QT_MSG_SEND);
+	M0_PRE(buf_index < ctx->ntcc_ep_nr);
+	LOGD("M0_NET_QT_MSG_SEND commands callback to %s",
+	     ev->nbe_buffer->nb_ep == NULL ? "NULL" :
+	     ev->nbe_buffer->nb_ep->nep_addr);
 
 	/* invoke 'message sent' callback if it is present */
 	if (ctx->ntcc_send_cb != NULL)
@@ -302,6 +302,8 @@ static int commands_recv_enqueue(struct m0_net_test_cmd_ctx *ctx,
 {
 	int rc;
 
+	M0_PRE(buf_index >= ctx->ntcc_ep_nr && buf_index < ctx->ntcc_ep_nr * 3);
+
 	ctx->ntcc_buf_status[buf_index].ntcbs_in_recv_queue = true;
 	rc = m0_net_test_network_msg_recv(&ctx->ntcc_net, buf_index);
 	if (rc != 0)
@@ -325,9 +327,9 @@ static void commands_recv_ep_put(struct m0_net_test_cmd_ctx *ctx,
 }
 
 static bool is_buf_in_recv_q(struct m0_net_test_cmd_ctx *ctx,
-			  size_t buf_index)
+			     size_t buf_index)
 {
-	M0_PRE(buf_index < ctx->ntcc_ep_nr * 2);
+	M0_PRE(buf_index >= ctx->ntcc_ep_nr && buf_index < ctx->ntcc_ep_nr * 3);
 
 	return ctx->ntcc_buf_status[buf_index].ntcbs_in_recv_queue;
 }
@@ -386,11 +388,11 @@ static int commands_initfini(struct m0_net_test_cmd_ctx *ctx,
 	if (rc != 0)
 		goto free_sem_send;
 
-	rc = m0_net_test_ringbuf_init(&ctx->ntcc_rb, ctx->ntcc_ep_nr * 2);
+	rc = m0_net_test_ringbuf_init(&ctx->ntcc_rb, ctx->ntcc_ep_nr * 3);
 	if (rc != 0)
 		goto free_sem_recv;
 
-	M0_ALLOC_ARR(ctx->ntcc_buf_status, ctx->ntcc_ep_nr * 2);
+	M0_ALLOC_ARR(ctx->ntcc_buf_status, ctx->ntcc_ep_nr * 3);
 	if (ctx->ntcc_buf_status == NULL)
 		goto free_rb;
 
@@ -398,7 +400,7 @@ static int commands_initfini(struct m0_net_test_cmd_ctx *ctx,
 					  &m0_net_test_commands_tm_cb,
 					  &commands_buffer_cb,
 					  M0_NET_TEST_CMD_SIZE_MAX,
-					  2 * ctx->ntcc_ep_nr,
+					  3 * ctx->ntcc_ep_nr,
 					  0, 0,
 					  ep_list->ntsl_nr,
 					  &timeouts, false);
@@ -408,7 +410,7 @@ static int commands_initfini(struct m0_net_test_cmd_ctx *ctx,
 	rc = m0_net_test_network_ep_add_slist(&ctx->ntcc_net, ep_list);
 	if (rc != 0)
 		goto free_net_ctx;
-	for (i = 0; i < ctx->ntcc_ep_nr; ++i) {
+	for (i = 0; i < ctx->ntcc_ep_nr * 2; ++i) {
 		rc = commands_recv_enqueue(ctx, ctx->ntcc_ep_nr + i);
 		if (rc != 0) {
 			commands_recv_dequeue_nr(ctx, i);
@@ -422,7 +424,7 @@ static int commands_initfini(struct m0_net_test_cmd_ctx *ctx,
     fini:
 	M0_PRE(m0_net_test_commands_invariant(ctx));
 	m0_net_test_commands_send_wait_all(ctx);
-	commands_recv_dequeue_nr(ctx, ctx->ntcc_ep_nr);
+	commands_recv_dequeue_nr(ctx, ctx->ntcc_ep_nr * 2);
     free_net_ctx:
 	m0_net_test_network_ctx_fini(&ctx->ntcc_net);
     free_buf_status:
@@ -465,12 +467,10 @@ int m0_net_test_commands_send(struct m0_net_test_cmd_ctx *ctx,
 	M0_PRE(m0_net_test_commands_invariant(ctx));
 	M0_PRE(cmd != NULL);
 
-	LOGD("m0_net_test_commands_send:\n");
-	LOGD("> from:\t\t%s\n", ctx->ntcc_net.ntc_tm->ntm_ep->nep_addr);
-	LOGD("> to %lu:\t\t%s\n", cmd->ntc_ep_index,
-	     ctx->ntcc_net.ntc_ep[cmd->ntc_ep_index]->nep_addr);
-	LOGD("> cmd->ntc_type = %d\n", cmd->ntc_type);
-	LOGD("end.\n");
+	LOGD("m0_net_test_commands_send: from %s to %lu %s cmd->ntc_type = %d",
+	     ctx->ntcc_net.ntc_tm->ntm_ep->nep_addr, cmd->ntc_ep_index,
+	     ctx->ntcc_net.ntc_ep[cmd->ntc_ep_index]->nep_addr,
+	     cmd->ntc_type);
 
 	buf_index = cmd->ntc_ep_index;
 	buf = m0_net_test_network_buf(&ctx->ntcc_net, M0_NET_TEST_BUF_PING,
@@ -495,6 +495,7 @@ void m0_net_test_commands_send_wait_all(struct m0_net_test_cmd_ctx *ctx)
 	int64_t nr;
 	int64_t i;
 
+	LOGD("m0_net_test_commands_send_wait_all enter");
 	M0_PRE(m0_net_test_commands_invariant(ctx));
 
 	m0_mutex_lock(&ctx->ntcc_send_mutex);
@@ -502,8 +503,12 @@ void m0_net_test_commands_send_wait_all(struct m0_net_test_cmd_ctx *ctx)
 	ctx->ntcc_send_nr = 0;
 	m0_mutex_unlock(&ctx->ntcc_send_mutex);
 
-	for (i = 0; i < nr; ++i)
+	LOGD("nr = %ld", (long) nr);
+	for (i = 0; i < nr; ++i) {
+		LOGD("semaphore_down() #%ld", (long) i);
 		m0_semaphore_down(&ctx->ntcc_sem_send);
+	}
+	LOGD("m0_net_test_commands_send_wait_all leave");
 }
 
 int m0_net_test_commands_recv(struct m0_net_test_cmd_ctx *ctx,
@@ -555,13 +560,12 @@ done:
 	/* buffer now not in receive queue */
 	ctx->ntcc_buf_status[buf_index].ntcbs_in_recv_queue = false;
 
-	LOGD("m0_net_test_commands_recv:\n");
-	LOGD("> rc = %d\n", rc);
-	LOGD("> from %lu:\t%s\n", cmd->ntc_ep_index,
-	     ctx->ntcc_net.ntc_ep[cmd->ntc_ep_index]->nep_addr);
-	LOGD("> to:\t\t%s\n", ctx->ntcc_net.ntc_tm->ntm_ep->nep_addr);
-	LOGD("> cmd->ntc_type = %d\n", cmd->ntc_type);
-	LOGD("end.\n");
+	LOGD("m0_net_test_commands_recv: from %lu %s to %s "
+	     "rc = %d cmd->ntc_type = %d",
+	     cmd->ntc_ep_index,
+	     ctx->ntcc_net.ntc_ep[cmd->ntc_ep_index]->nep_addr,
+	     ctx->ntcc_net.ntc_tm->ntm_ep->nep_addr,
+	     rc, cmd->ntc_type);
 
 	return rc;
 }
@@ -588,7 +592,7 @@ bool m0_net_test_commands_invariant(struct m0_net_test_cmd_ctx *ctx)
 		return false;
 	if (ctx->ntcc_ep_nr != ctx->ntcc_net.ntc_ep_nr)
 		return false;
-	if (ctx->ntcc_ep_nr * 2 != ctx->ntcc_net.ntc_buf_ping_nr)
+	if (ctx->ntcc_ep_nr * 3 != ctx->ntcc_net.ntc_buf_ping_nr)
 		return false;
 	if (ctx->ntcc_net.ntc_buf_bulk_nr != 0)
 		return false;
diff --git a/net/test/commands.h b/net/test/commands.h
index 4204f07..f6bef65 100644
--- a/net/test/commands.h
+++ b/net/test/commands.h
@@ -56,10 +56,12 @@ enum m0_net_test_role {
 
 /**
    Test type - can be ping test or bulk test.
+   M0_NET_TEST_TYPE_STUB used in UTs.
  */
 enum m0_net_test_type {
 	M0_NET_TEST_TYPE_PING,
-	M0_NET_TEST_TYPE_BULK
+	M0_NET_TEST_TYPE_BULK,
+	M0_NET_TEST_TYPE_STUB,
 };
 
 /**
@@ -228,7 +230,11 @@ typedef void (*m0_net_test_commands_send_cb_t)(struct m0_net_test_cmd_ctx *ctx,
    Commands context.
  */
 struct m0_net_test_cmd_ctx {
-	/** network context for this command context */
+	/**
+	 * Network context for this command context.
+	 * First ntcc_ep_nr ping buffers are used for commands sending,
+	 * other ntcc_ep_nr * 2 ping buffers are used for commands receiving.
+	 */
 	struct m0_net_test_network_ctx	   ntcc_net;
 	/**
 	   Ring buffer for receive queue.
@@ -278,7 +284,7 @@ struct m0_net_test_cmd_ctx {
    @return -errno (failure)
    @note
    - buffers for message sending/receiving will be allocated here,
-     two buffers per endpoint;
+     three buffers per endpoint: one for sending, two for receiving;
    - all buffers will have M0_NET_TEST_CMD_SIZE_MAX size;
    - all buffers for receiving commands will be added to receive queue here;
    - buffers will not be automatically added to receive queue after
diff --git a/net/test/console.c b/net/test/console.c
index d80bb4b..a1068ae 100644
--- a/net/test/console.c
+++ b/net/test/console.c
@@ -18,21 +18,6 @@
  * Original creation date: 09/03/2012
  */
 
-/** @todo remove */
-#ifndef __KERNEL__
-#include <stdio.h>		/* printf */
-#endif
-
-/** @todo debug only, remove it */
-#ifndef __KERNEL__
-/*
-#define LOGD(format, ...) printf(format, ##__VA_ARGS__)
-*/
-#define LOGD(format, ...) do {} while (0)
-#else
-#define LOGD(format, ...) do {} while (0)
-#endif
-
 #include "lib/arith.h"		/* min_check */
 #include "lib/memory.h"		/* M0_ALLOC_PTR */
 #include "lib/misc.h"		/* M0_SET0 */
@@ -40,6 +25,12 @@
 
 #include "net/test/console.h"
 
+#ifdef NET_TEST_MODULE_NAME
+#undef NET_TEST_MODULE_NAME
+#endif
+#define NET_TEST_MODULE_NAME console
+#include "net/test/debug.h"	/* LOGD */
+
 
 /**
    @defgroup NetTestConsoleInternals Test Console
@@ -52,15 +43,14 @@
  */
 
 static int console_role_init_fini(struct m0_net_test_console_role_ctx *ctx,
-				 struct m0_net_test_console_cfg *cfg,
-				 enum m0_net_test_role role,
-				 bool init)
+				  struct m0_net_test_console_cfg *cfg,
+				  enum m0_net_test_role role)
 {
 	struct m0_net_test_slist *nodes;
 	char			 *addr_console;
 	int			  rc = -ENOMEM;
 
-	if (!init)
+	if (cfg == NULL)
 		goto fini;
 
 	addr_console = role == M0_NET_TEST_ROLE_CLIENT ?
@@ -107,32 +97,30 @@ success:
 }
 
 static int console_init_fini(struct m0_net_test_console_ctx *ctx,
-			     struct m0_net_test_console_cfg *cfg,
-			     bool init)
+			     struct m0_net_test_console_cfg *cfg)
 {
 	int rc;
 
 	M0_PRE(ctx != NULL);
-	M0_PRE(ergo(init, cfg != NULL));
 
 	ctx->ntcc_cfg = cfg;
 	rc = console_role_init_fini(&ctx->ntcc_clients, cfg,
-				    M0_NET_TEST_ROLE_CLIENT, init);
+				    M0_NET_TEST_ROLE_CLIENT);
 	if (rc == 0)
 		rc = console_role_init_fini(&ctx->ntcc_servers, cfg,
-					    M0_NET_TEST_ROLE_SERVER, init);
+					    M0_NET_TEST_ROLE_SERVER);
 	return rc;
 }
 
 int m0_net_test_console_init(struct m0_net_test_console_ctx *ctx,
 			     struct m0_net_test_console_cfg *cfg)
 {
-	return console_init_fini(ctx, cfg, true);
+	return console_init_fini(ctx, cfg);
 }
 
 void m0_net_test_console_fini(struct m0_net_test_console_ctx *ctx)
 {
-	int rc = console_init_fini(ctx, NULL, false);
+	int rc = console_init_fini(ctx, NULL);
 	M0_POST(rc == 0);
 }
 
@@ -245,7 +233,7 @@ size_t m0_net_test_console_cmd(struct m0_net_test_console_ctx *ctx,
 	struct m0_net_test_console_role_ctx *rctx;
 	struct m0_net_test_console_cfg	    *cfg;
 	struct m0_net_test_cmd_ctx	    *cmd_ctx;
-	struct m0_net_test_cmd		     cmd;
+	struct m0_net_test_cmd		    *cmd;
 	struct m0_net_test_cmd_status_data  *sd = NULL;
 	int				     i;
 	int				     j;
@@ -272,22 +260,24 @@ size_t m0_net_test_console_cmd(struct m0_net_test_console_ctx *ctx,
 	       cmd_type == M0_NET_TEST_CMD_STOP ||
 	       cmd_type == M0_NET_TEST_CMD_STATUS);
 
-	M0_SET0(&cmd);
+	M0_ALLOC_PTR(cmd);
+	if (cmd == NULL)
+		goto done;
 	cfg = ctx->ntcc_cfg;
 
 	if (cmd_type == M0_NET_TEST_CMD_INIT)
-		console_cmd_init_fill(cfg, role, &cmd.ntc_init);
+		console_cmd_init_fill(cfg, role, &cmd->ntc_init);
 
-	role_client  = role == M0_NET_TEST_ROLE_CLIENT;
-	cmd.ntc_type = cmd_type;
-	nodes	     = role_client ? &cfg->ntcc_clients : &cfg->ntcc_servers;
-	nodes_data   = role_client ? &cfg->ntcc_data_clients :
-				     &cfg->ntcc_data_servers;
+	role_client   = role == M0_NET_TEST_ROLE_CLIENT;
+	cmd->ntc_type = cmd_type;
+	nodes	      = role_client ? &cfg->ntcc_clients : &cfg->ntcc_servers;
+	nodes_data    = role_client ? &cfg->ntcc_data_clients :
+				      &cfg->ntcc_data_servers;
 	rctx	     = role_client ? &ctx->ntcc_clients : &ctx->ntcc_servers;
 	cmd_ctx	     = rctx->ntcrc_cmd;
 
 	/* clear commands receive queue */
-	while ((rc = m0_net_test_commands_recv(cmd_ctx, &cmd, m0_time_now())) !=
+	while ((rc = m0_net_test_commands_recv(cmd_ctx, cmd, m0_time_now())) !=
 	       -ETIMEDOUT) {
 		/*
 		 * Exit from this loop after nodes->ntsl_nr failures.
@@ -299,16 +289,16 @@ size_t m0_net_test_console_cmd(struct m0_net_test_console_ctx *ctx,
 		if (failures_nr > nodes->ntsl_nr)
 			break;
 		rc = m0_net_test_commands_recv_enqueue(cmd_ctx,
-						       cmd.ntc_buf_index);
+						       cmd->ntc_buf_index);
 		/** @todo rc != 0 is lost here */
-		m0_net_test_commands_received_free(&cmd);
+		m0_net_test_commands_received_free(cmd);
 	}
 	/* send all commands */
 	for (i = 0; i < nodes->ntsl_nr; ++i) {
 		if (cmd_type == M0_NET_TEST_CMD_INIT)
-			cmd.ntc_init.ntci_tm_ep = nodes_data->ntsl_list[i];
-		cmd.ntc_ep_index     = i;
-		rctx->ntcrc_errno[i] = m0_net_test_commands_send(cmd_ctx, &cmd);
+			cmd->ntc_init.ntci_tm_ep = nodes_data->ntsl_list[i];
+		cmd->ntc_ep_index     = i;
+		rctx->ntcrc_errno[i] = m0_net_test_commands_send(cmd_ctx, cmd);
 	}
 	m0_net_test_commands_send_wait_all(cmd_ctx);
 
@@ -319,7 +309,7 @@ size_t m0_net_test_console_cmd(struct m0_net_test_console_ctx *ctx,
 	}
 	deadline = m0_time_add(m0_time_now(), cfg->ntcc_cmd_recv_timeout);
 	while (m0_time_now() <= deadline && rcvd_nr < nodes->ntsl_nr) {
-		rc = m0_net_test_commands_recv(cmd_ctx, &cmd, deadline);
+		rc = m0_net_test_commands_recv(cmd_ctx, cmd, deadline);
 		/* deadline reached */
 		if (rc == -ETIMEDOUT)
 			break;
@@ -328,11 +318,11 @@ size_t m0_net_test_console_cmd(struct m0_net_test_console_ctx *ctx,
 			continue;
 		rcvd_nr++;
 		/* reject unknown sender */
-		j = cmd.ntc_ep_index;
+		j = cmd->ntc_ep_index;
 		if (j < 0)
 			goto reuse_cmd;
 		/* reject unexpected command type */
-		if (cmd.ntc_type != answer[cmd_type])
+		if (cmd->ntc_type != answer[cmd_type])
 			goto reuse_cmd;
 		/*
 		 * reject command from node, which can't have outgoing cmd
@@ -343,27 +333,29 @@ size_t m0_net_test_console_cmd(struct m0_net_test_console_ctx *ctx,
 			goto reuse_cmd;
 		/* handle incoming command */
 		if (answer[cmd_type] == M0_NET_TEST_CMD_STATUS_DATA) {
-			status_data_add(sd, &cmd.ntc_status_data);
+			status_data_add(sd, &cmd->ntc_status_data);
 			success_nr++;
 		} else {
-			rctx->ntcrc_status[j] = cmd.ntc_done.ntcd_errno;
+			rctx->ntcrc_status[j] = cmd->ntc_done.ntcd_errno;
 			if (rctx->ntcrc_status[j] == 0)
 				success_nr++;
 		}
 		/*
 		 * @todo console user can't recover from this error -
-		 * cmd.ntc_buf_index is lost. use ringbuf to save?
+		 * cmd->ntc_buf_index is lost. use ringbuf to save?
 		 */
 reuse_cmd:
 		rc = m0_net_test_commands_recv_enqueue(cmd_ctx,
-						       cmd.ntc_buf_index);
+						       cmd->ntc_buf_index);
 		if (j != -1) {
 			M0_ASSERT(j >= 0 && j < nodes->ntsl_nr);
 			rctx->ntcrc_errno[j] = rc;
 		}
-		m0_net_test_commands_received_free(&cmd);
+		m0_net_test_commands_received_free(cmd);
 	}
 
+done:
+	m0_free(cmd);
 	LOGD("console: rc = %d\n", rc);
 
 	return success_nr;
diff --git a/net/test/debug.h b/net/test/debug.h
new file mode 100644
index 0000000..e1d058a
--- /dev/null
+++ b/net/test/debug.h
@@ -0,0 +1,86 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Maxim Medved <max_medved@xyratex.com>
+ * Original creation date: 01/12/2012
+ */
+
+#pragma once
+
+#ifndef __MERO_NET_TEST_DEBUG_H__
+#define __MERO_NET_TEST_DEBUG_H__
+
+#include "lib/trace.h"	/* M0_LOG */
+
+/**
+   @defgroup NetTestDebugDFS Debugging tools
+   @ingroup NetTestDFS
+
+   Usage recipe
+   0. in .c file
+   1. #ifdef NET_TEST_MODULE_NAME
+      #undef NET_TEST_MODULE_NAME
+      #endif
+   2. #define NET_TEST_MODULE_NAME name_of_net_test_module
+   3. #include "net/test/debug.h"
+   4. Use LOGD() macro for regular debug output.
+   5. Enable/disable debug output from any point using
+      LOGD_VAR_NAME(some_module_name) variable
+      (declared using LOGD_VAR_DECLARE(some_module_name) (disabled by default).
+
+   Macro names used: LOGD, NET_TEST_MODULE_NAME, LOGD_VAR_DECLARE, LOGD_VAR_NAME
+
+   @{
+ */
+
+#ifndef NET_TEST_MODULE_NAME
+M0_BASSERT("NET_TEST_MODULE_NAME should be defined "
+	   "before including debug.h" == NULL);
+#endif
+
+#define LOGD_VAR_NAME(module_name)					\
+	M0_CAT(m0_net_test_logd_, module_name)
+
+bool LOGD_VAR_NAME(NET_TEST_MODULE_NAME) = false;
+
+#define LOGD_VAR_DECLARE(module_name)					\
+	extern bool LOGD_VAR_NAME(module_name);
+
+#ifdef LOGD
+#undef LOGD
+#endif
+#define LOGD(...)							\
+	do {								\
+		if (LOGD_VAR_NAME(NET_TEST_MODULE_NAME))		\
+			M0_LOG(M0_DEBUG, ##__VA_ARGS__);		\
+	} while (0)
+
+
+/**
+   @} end of NetTestDebugDFS group
+ */
+
+#endif /*  __MERO_NET_TEST_DEBUG_H__ */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 79
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/net/test/network.c b/net/test/network.c
index 4c144f5..16f69b1 100644
--- a/net/test/network.c
+++ b/net/test/network.c
@@ -18,13 +18,6 @@
  * Original creation date: 03/22/2012
  */
 
-#ifdef __KERNEL__
-#include <linux/kernel.h>	/* snprintf() */
-#else
-#include <stdio.h>		/* snprintf() */
-#include <inttypes.h>		/* PRIu64 */
-#endif
-
 #include "lib/cdefs.h"		/* ergo */
 #include "lib/errno.h"		/* E2BIG */
 #include "lib/memory.h"		/* M0_ALLOC_ARR */
@@ -33,7 +26,7 @@
 
 #include "mero/magic.h"	/* M0_NET_TEST_NETWORK_BD_MAGIC */
 
-#include "net/net.h"
+#include "net/net.h"		/* m0_net_buffer */
 #include "net/lnet/lnet.h"	/* m0_net_lnet_xprt */
 
 #include "net/test/network.h"
@@ -52,12 +45,6 @@
    @{
  */
 
-#if 0
-#ifndef __KERNEL__
-#define DEBUG_NET_TEST_NETWORK
-#endif
-#endif
-
 int m0_net_test_network_init(void)
 {
 	return m0_net_xprt_init(&m0_net_lnet_xprt);
@@ -114,6 +101,7 @@ static void cb_default(const struct m0_net_buffer_event *ev)
 	enum m0_net_queue_type		q;
 
 	M0_PRE(buf != NULL);
+	M0_PRE((buf->nb_flags & M0_NET_BUF_QUEUED) == 0);
 	q = ev->nbe_buffer->nb_qtype;
 
 	ctx = cb_ctx_extract(ev);
@@ -405,6 +393,7 @@ void m0_net_test_network_ctx_fini(struct m0_net_test_network_ctx *ctx)
 	m0_free(ctx->ntc_buf_ping);
 	net_test_tm_stop(ctx->ntc_tm);
 	m0_net_tm_fini(ctx->ntc_tm);
+	m0_free(ctx->ntc_tm);
 	m0_net_domain_fini(ctx->ntc_dom);
 	m0_free(ctx->ntc_tm);
 	m0_free(ctx->ntc_dom);
diff --git a/net/test/node.c b/net/test/node.c
index 10500c8..7eeb7cf 100644
--- a/net/test/node.c
+++ b/net/test/node.c
@@ -18,26 +18,22 @@
  * Original creation date: 03/22/2012
  */
 
-/** @todo remove */
-#ifndef __KERNEL__
-#include <stdio.h>		/* printf */
-#endif
-
-/** @todo debug only, remove it */
-#ifndef __KERNEL__
-//#define LOGD(format, ...) printf(format, ##__VA_ARGS__)
-#define LOGD(format, ...) do {} while (0)
-#else
-#define LOGD(format, ...) do {} while (0)
-#endif
-
 #include "lib/errno.h"		/* ETIMEDOUT */
 #include "lib/misc.h"		/* M0_SET0 */
+#include "lib/memory.h"		/* M0_ALLOC_PTR */
+#include "lib/trace.h"		/* M0_LOG */
 
 #include "net/test/node.h"	/* m0_net_test_node_ctx */
+#include "net/test/node_stub.h"	/* m0_net_test_node_stub_ops */
 #include "net/test/node_ping.h"	/* m0_net_test_node_ping_ops */
 #include "net/test/node_bulk.h"	/* m0_net_test_node_bulk_ops */
 
+#ifdef NET_TEST_MODULE_NAME
+#undef NET_TEST_MODULE_NAME
+#endif
+#define NET_TEST_MODULE_NAME node
+#include "net/test/debug.h"
+
 /**
    @page net-test Mero Network Benchmark
 
@@ -176,6 +172,7 @@
      node_	-> service;
      node_u	-> node_;
      node_k	-> node_;
+     commands	-> network;
      console	-> commands;
      console_u	-> console;
      stats_u	-> stats;
@@ -694,20 +691,14 @@ enum {
 	NODE_WAIT_CMD_GRANULARITY_MS = 20,
 };
 
-static void node_tm_event_cb(const struct m0_net_tm_event *ev)
-{
-}
-
-static const struct m0_net_tm_callbacks node_tm_cb = {
-	.ntc_event_cb = node_tm_event_cb
-};
-
 static struct m0_net_test_service_ops *
 service_ops_get(struct m0_net_test_cmd *cmd)
 {
 	M0_PRE(cmd->ntc_type == M0_NET_TEST_CMD_INIT);
 
 	switch (cmd->ntc_init.ntci_type) {
+	case M0_NET_TEST_TYPE_STUB:
+		return &m0_net_test_node_stub_ops;
 	case M0_NET_TEST_TYPE_PING:
 		return &m0_net_test_node_ping_ops;
 	case M0_NET_TEST_TYPE_BULK:
@@ -726,14 +717,15 @@ static int node_cmd_get(struct m0_net_test_cmd_ctx *cmd_ctx,
 		rc = m0_net_test_commands_recv_enqueue(cmd_ctx,
 						       cmd->ntc_buf_index);
 	if (rc == 0) {
-		LOGD("node_cmd_get: rc = %d\n", rc);
-		LOGD("node_cmd_get: cmd->ntc_type = %d\n", cmd->ntc_type);
-		LOGD("node_cmd_get: cmd->ntc_init.ntci_msg_nr = %lu\n",
-		     cmd->ntc_init.ntci_msg_nr);
+		LOGD("node_cmd_get: rc = %d", rc);
+		LOGD("node_cmd_get: cmd->ntc_type = %d", cmd->ntc_type);
+		LOGD("node_cmd_get: cmd->ntc_init.ntci_msg_nr = %lu",
+		     (unsigned long) cmd->ntc_init.ntci_msg_nr);
 	}
 	return rc;
 }
 
+/** @todo memory leak for all commands with different type from parameter */
 static int node_cmd_wait(struct m0_net_test_node_ctx *ctx,
 			 struct m0_net_test_cmd *cmd,
 			 enum m0_net_test_cmd_type type)
@@ -758,32 +750,38 @@ static void node_thread(struct m0_net_test_node_ctx *ctx)
 	struct m0_net_test_service	svc;
 	struct m0_net_test_service_ops *svc_ops;
 	enum m0_net_test_service_state	svc_state;
-	struct m0_net_test_cmd		cmd;
-	struct m0_net_test_cmd		reply;
+	struct m0_net_test_cmd	       *cmd;
+	struct m0_net_test_cmd	       *reply;
 	int				rc;
 	bool				skip_cmd_get;
 
 	M0_PRE(ctx != NULL);
 
+	M0_ALLOC_PTR(cmd);
+	M0_ALLOC_PTR(reply);
+	if (cmd == NULL || reply == NULL) {
+		rc = -ENOMEM;
+		goto done;
+	}
+
 	/* wait for INIT command */
-	M0_SET0(&cmd);
-	ctx->ntnc_errno = node_cmd_wait(ctx, &cmd, M0_NET_TEST_CMD_INIT);
+	ctx->ntnc_errno = node_cmd_wait(ctx, cmd, M0_NET_TEST_CMD_INIT);
 	if (ctx->ntnc_exit_flag) {
-		m0_net_test_commands_received_free(&cmd);
-		return;
+		m0_net_test_commands_received_free(cmd);
+		goto done;
 	}
 	if (ctx->ntnc_errno != 0)
-		return;
+		goto done;
 	/* we have configuration; initialize test service */
-	svc_ops = service_ops_get(&cmd);
+	svc_ops = service_ops_get(cmd);
 	if (svc_ops == NULL) {
-		m0_net_test_commands_received_free(&cmd);
-		return;
+		m0_net_test_commands_received_free(cmd);
+		goto done;
 	}
 	rc = m0_net_test_service_init(&svc, svc_ops);
 	if (rc != 0) {
-		m0_net_test_commands_received_free(&cmd);
-		return;
+		m0_net_test_commands_received_free(cmd);
+		goto done;
 	}
 	/* handle INIT command inside main loop */
 	skip_cmd_get = true;
@@ -791,27 +789,29 @@ static void node_thread(struct m0_net_test_node_ctx *ctx)
 	do {
 		/* get command */
 		if (rc == 0 && !skip_cmd_get)
-			rc = node_cmd_get(&ctx->ntnc_cmd, &cmd, m0_time_now());
+			rc = node_cmd_get(&ctx->ntnc_cmd, cmd,
+					  m0_time_from_now(0, 25000000));
+					  // m0_time_now());
 		else
 			skip_cmd_get = false;
 		if (rc == 0)
 			LOGD("node_thread: cmd_get, "
-			     "rc = %d, cmd.ntc_ep_index = %lu\n",
-			     rc, cmd.ntc_ep_index);
-		if (rc == 0 && cmd.ntc_ep_index >= 0) {
-			LOGD("node_thread: have command\n");
+			     "rc = %d, cmd.ntc_ep_index = %lu",
+			     rc, cmd->ntc_ep_index);
+		if (rc == 0 && cmd->ntc_ep_index >= 0) {
+			LOGD("node_thread: have command");
 			/* we have command. handle it */
-			rc = m0_net_test_service_cmd_handle(&svc, &cmd, &reply);
-			LOGD("node_thread: cmd handle: rc = %d\n", rc);
-			reply.ntc_ep_index = cmd.ntc_ep_index;
-			m0_net_test_commands_received_free(&cmd);
+			rc = m0_net_test_service_cmd_handle(&svc, cmd, reply);
+			LOGD("node_thread: cmd handle: rc = %d", rc);
+			reply->ntc_ep_index = cmd->ntc_ep_index;
+			m0_net_test_commands_received_free(cmd);
 			/* send reply */
-			LOGD("node_thread: reply.ntc_ep_index = %lu\n",
-			     reply.ntc_ep_index);
+			LOGD("node_thread: reply.ntc_ep_index = %lu",
+			     reply->ntc_ep_index);
 			m0_net_test_commands_send_wait_all(&ctx->ntnc_cmd);
-			rc = m0_net_test_commands_send(&ctx->ntnc_cmd, &reply);
-			LOGD("node_thread: send reply: rc = %d\n", rc);
-			M0_SET0(&cmd);
+			rc = m0_net_test_commands_send(&ctx->ntnc_cmd, reply);
+			LOGD("node_thread: send reply: rc = %d", rc);
+			M0_SET0(cmd);
 		} else if (rc == -ETIMEDOUT) {
 			/* we haven't command. take a step. */
 			rc = m0_net_test_service_step(&svc);
@@ -824,24 +824,25 @@ static void node_thread(struct m0_net_test_node_ctx *ctx)
 		 !ctx->ntnc_exit_flag &&
 		 rc == 0);
 
-	LOGD("6, rc = %d\n", rc);
-	ctx->ntnc_errno = rc;
 	/* finalize test service */
 	m0_net_test_service_fini(&svc);
 
+done:
+	m0_free(cmd);
+	m0_free(reply);
+	LOGD("rc = %d", rc);
+	ctx->ntnc_errno = rc;
 	m0_semaphore_up(&ctx->ntnc_thread_finished_sem);
 }
 
 static int node_init_fini(struct m0_net_test_node_ctx *ctx,
-			  struct m0_net_test_node_cfg *cfg,
-			  bool init)
+			  struct m0_net_test_node_cfg *cfg)
 {
 	struct m0_net_test_slist ep_list;
 	int			 rc;
 
 	M0_PRE(ctx != NULL);
-	M0_PRE(ergo(init, cfg != NULL));
-	if (!init)
+	if (cfg == NULL)
 		goto fini;
 
 	M0_SET0(ctx);
@@ -874,12 +875,12 @@ failed:
 int m0_net_test_node_init(struct m0_net_test_node_ctx *ctx,
 			  struct m0_net_test_node_cfg *cfg)
 {
-	return node_init_fini(ctx, cfg, true);
+	return node_init_fini(ctx, cfg);
 }
 
 void m0_net_test_node_fini(struct m0_net_test_node_ctx *ctx)
 {
-	int rc = node_init_fini(ctx, NULL, false);
+	int rc = node_init_fini(ctx, NULL);
 	M0_POST(rc == 0);
 }
 
diff --git a/net/test/node_bulk.c b/net/test/node_bulk.c
index 809cb13..810daf1 100644
--- a/net/test/node_bulk.c
+++ b/net/test/node_bulk.c
@@ -22,8 +22,8 @@
 #include "lib/errno.h"			/* EALREADY */
 #include "lib/memory.h"			/* M0_ALLOC_PTR */
 #include "lib/cdefs.h"			/* ergo */
-#include "lib/trace.h"			/* M0_LOG */
 #include "lib/misc.h"			/* M0_IN */
+#include "lib/atomic.h"			/* m0_atomic64 */
 
 #include "mero/magic.h"		/* M0_NET_TEST_BSB_MAGIC */
 
@@ -35,6 +35,12 @@
 
 #include "net/test/node_bulk.h"
 
+#ifdef NET_TEST_MODULE_NAME
+#undef NET_TEST_MODULE_NAME
+#endif
+#define NET_TEST_MODULE_NAME node_bulk
+#include "net/test/debug.h"		/* LOGD */
+
 /**
    @defgroup NetTestBulkNodeInternals Bulk Node
    @ingroup NetTestInternals
@@ -266,7 +272,7 @@ struct node_bulk_ctx {
 	 */
 	struct m0_clink			   nbc_stop_clink;
 	/** Stop flag */
-	bool				   nbc_stop_flag;
+	struct m0_atomic64		   nbc_stop_flag;
 	/**
 	 * At least one callback was executed.
 	 * Set to true in every callback.
@@ -316,6 +322,11 @@ node_bulk_state_change_allowed(enum transfer_state from,
 	return i < allowed_size;
 }
 
+static bool node_bulk_state_is_final(enum transfer_state state)
+{
+	return M0_IN(state, (TS_FAILED, TS_TRANSFERRED, TS_BADMSG));
+}
+
 static void node_bulk_state_change(struct node_bulk_ctx *ctx,
 				   size_t bs_index,
 				   enum transfer_state state)
@@ -358,10 +369,8 @@ static void node_bulk_state_change(struct node_bulk_ctx *ctx,
 	M0_PRE(bs_index < ctx->nbc_bs_nr);
 	M0_PRE(ctx->nbc_bs != NULL);
 
-	/*
-	M0_LOG(M0_DEBUG, "state_change: role = %d, bs_index = %lu, state = %d",
-	       ctx->nbc_nh.ntnh_role, bs_index, state);
-	*/
+	LOGD("state_change: role = %d, bs_index = %lu, state = %d",
+	     ctx->nbc_nh.ntnh_role, bs_index, state);
 
 	role = ctx->nbc_nh.ntnh_role;
 	bs = &ctx->nbc_bs[bs_index];
@@ -376,7 +385,7 @@ static void node_bulk_state_change(struct node_bulk_ctx *ctx,
 	/* add to ringbufs if needed */
 	if (state == TS_UNUSED)
 		m0_net_test_ringbuf_push(&ctx->nbc_rb_bulk_unused, bs_index);
-	if (M0_IN(state, (TS_FAILED, TS_TRANSFERRED, TS_BADMSG)))
+	if (node_bulk_state_is_final(state))
 		m0_net_test_ringbuf_push(&ctx->nbc_rb_bulk_final, bs_index);
 	/* set start & finish timestamp */
 	if (M0_IN(state, (TS_RECEIVING, TS_QUEUED)))
@@ -606,8 +615,8 @@ static void buf_desc_swap(struct node_bulk_ctx *ctx,
 		ctx->nbc_bs[buf_bulk_index].bsb_desc_send);
 }
 
-static void buf_desc_free(struct node_bulk_ctx *ctx,
-			  size_t buf_bulk_index)
+static void buf_desc_server_free(struct node_bulk_ctx *ctx,
+				 size_t buf_bulk_index)
 {
 	M0_PRE(ctx != NULL);
 	M0_PRE(buf_bulk_index < ctx->nbc_buf_bulk_nr);
@@ -616,6 +625,16 @@ static void buf_desc_free(struct node_bulk_ctx *ctx,
 	m0_net_desc_free(&ctx->nbc_bs[buf_bulk_index].bsb_desc_send);
 }
 
+static void buf_desc_client_free(struct node_bulk_ctx *ctx,
+				 size_t bs_index)
+{
+	M0_PRE(ctx != NULL);
+	M0_PRE(bs_index * 2 + 1 < ctx->nbc_buf_bulk_nr);
+
+	m0_net_desc_free(&net_buf_bulk_get(ctx, bs_index * 2)->nb_desc);
+	m0_net_desc_free(&net_buf_bulk_get(ctx, bs_index * 2 + 1)->nb_desc);
+}
+
 static m0_bcount_t buf_desc_deserialize(struct node_bulk_ctx *ctx,
 					size_t buf_bulk_index,
 					size_t buf_ping_index,
@@ -649,7 +668,7 @@ static m0_bcount_t buf_desc_deserialize(struct node_bulk_ctx *ctx,
 					       offset + len_total);
 	if (len == 0) {
 		/* free already allocated network descriptor */
-		buf_desc_free(ctx, buf_bulk_index);
+		buf_desc_server_free(ctx, buf_bulk_index);
 		return 0;
 	}
 	len_total = net_test_len_accumulate(len_total, len);
@@ -673,16 +692,14 @@ static m0_bcount_t node_bulk_server_transfer_start(struct node_bulk_ctx *ctx,
 						   size_t buf_ping_index,
 						   m0_bcount_t offset)
 {
-	struct buf_status_bulk *bs;
-	struct m0_net_buffer   *buf;
-	m0_bcount_t		len;
-	size_t			buf_bulk_index;
-	bool			no_unused_buf;
-	int			rc;
+	m0_bcount_t len;
+	size_t	    buf_bulk_index;
+	bool	    no_unused_buf;
+	int	    rc;
 
 	no_unused_buf = m0_net_test_ringbuf_is_empty(&ctx->nbc_rb_bulk_unused);
 	if (no_unused_buf) {
-		M0_LOG(M0_DEBUG, "--- NO UNUSED BUFS");
+		LOGD("--- NO UNUSED BUFS");
 		sd_update(ctx, MT_TRANSFER, MS_FAILED, MD_BOTH);
 		return 0;
 	}
@@ -694,11 +711,9 @@ static m0_bcount_t node_bulk_server_transfer_start(struct node_bulk_ctx *ctx,
 	/* deserialize network buffer descriptors */
 	len = buf_desc_deserialize(ctx, buf_bulk_index, buf_ping_index, offset);
 	if (len == 0) {
-		M0_LOG(M0_DEBUG, "BADMSG: buf_bulk_index = %lu, "
-				 "buf_ping_index = %lu, "
-				 "offset = %lu",
-				 buf_bulk_index, buf_ping_index,
-				 (unsigned long) offset);
+		LOGD("BADMSG: buf_bulk_index = %lu, "
+		     "buf_ping_index = %lu, offset = %lu",
+		     buf_bulk_index, buf_ping_index, (unsigned long) offset);
 		/* ping buffer contains invalid data */
 		node_bulk_state_change(ctx, buf_bulk_index, TS_BADMSG);
 		return 0;
@@ -707,18 +722,14 @@ static m0_bcount_t node_bulk_server_transfer_start(struct node_bulk_ctx *ctx,
 	/* start active bulk receiving */
 	rc = m0_net_test_network_bulk_enqueue(&ctx->nbc_net, buf_bulk_index, 0,
 					      M0_NET_QT_ACTIVE_BULK_RECV);
-	bs = &ctx->nbc_bs[buf_bulk_index];
-	buf = m0_net_test_network_buf(&ctx->nbc_net, M0_NET_TEST_BUF_BULK,
-				      buf_bulk_index);
-	bs->bsb_recv.bse_func_rc = rc;
+	ctx->nbc_bs[buf_bulk_index].bsb_recv.bse_func_rc = rc;
 	if (rc != 0) {
 		/*
 		 * Addition buffer to network queue failed.
 		 * Free allocated (when deserialized) network descriptors.
 		 */
 		node_bulk_state_change(ctx, buf_bulk_index, TS_FAILED);
-		m0_net_desc_free(&bs->bsb_desc_send);
-		m0_net_desc_free(&buf->nb_desc);
+		buf_desc_server_free(ctx, buf_bulk_index);
 		sd_update(ctx, MT_BULK, MS_FAILED, MD_RECV);
 	}
 	return rc == 0 ? len : 0;
@@ -738,8 +749,8 @@ static void node_bulk_cb_server(struct node_bulk_ctx *ctx,
 	M0_PRE(ctx != NULL);
 	M0_PRE(ctx->nbc_nh.ntnh_role == M0_NET_TEST_ROLE_SERVER);
 	M0_PRE(ergo(q == M0_NET_QT_MSG_RECV, buf_index < ctx->nbc_buf_ping_nr));
-	M0_PRE(ergo(q == M0_NET_QT_ACTIVE_BULK_RECV ||
-		    q == M0_NET_QT_ACTIVE_BULK_SEND,
+	M0_PRE(ergo(M0_IN(q, (M0_NET_QT_ACTIVE_BULK_RECV,
+			      M0_NET_QT_ACTIVE_BULK_SEND)),
 		    buf_index < ctx->nbc_buf_bulk_nr));
 
 	if (q == M0_NET_QT_MSG_RECV) {
@@ -747,7 +758,7 @@ static void node_bulk_cb_server(struct node_bulk_ctx *ctx,
 			return;
 		nr = m0_net_test_network_bd_nr(&ctx->nbc_net, buf_index);
 		if (nr % 2 != 0) {
-			M0_LOG(M0_DEBUG, "MS_BAD: nr = %lu", nr);
+			LOGD("MS_BAD: nr = %lu", nr);
 			sd_update(ctx, MT_MSG, MS_BAD, MD_RECV);
 			return;
 		}
@@ -760,8 +771,8 @@ static void node_bulk_cb_server(struct node_bulk_ctx *ctx,
 		}
 	} else if (q == M0_NET_QT_ACTIVE_BULK_RECV) {
 		if (ev->nbe_status != 0) {
-			M0_LOG(M0_DEBUG, "--- active bulk recv FAILED!");
-			buf_desc_free(ctx, buf_index);
+			LOGD("--- active bulk recv FAILED!");
+			buf_desc_server_free(ctx, buf_index);
 			return;
 		}
 		/*
@@ -774,16 +785,54 @@ static void node_bulk_cb_server(struct node_bulk_ctx *ctx,
 						M0_NET_QT_ACTIVE_BULK_SEND);
 		ctx->nbc_bs[buf_index].bsb_send.bse_func_rc = rc;
 		if (rc != 0) {
-			M0_LOG(M0_DEBUG, "--- active bulk send FAILED!");
-			buf_desc_free(ctx, buf_index);
+			LOGD("--- active bulk send FAILED!");
+			buf_desc_server_free(ctx, buf_index);
 			node_bulk_state_change(ctx, buf_index, TS_FAILED);
 			sd_update(ctx, MT_BULK, MS_FAILED, MD_SEND);
 		}
 	} else if (q == M0_NET_QT_ACTIVE_BULK_SEND) {
-		buf_desc_free(ctx, buf_index);
+		buf_desc_server_free(ctx, buf_index);
+	}
+}
+
+static void node_bulk_cb_client(struct node_bulk_ctx *ctx,
+				size_t buf_index,
+				enum m0_net_queue_type q,
+				const struct m0_net_buffer_event *ev)
+{
+	struct buf_status_bulk *bs;
+
+	M0_PRE(ctx != NULL);
+	M0_PRE(ctx->nbc_nh.ntnh_role == M0_NET_TEST_ROLE_CLIENT);
+	M0_PRE(ergo(q == M0_NET_QT_MSG_SEND, buf_index < ctx->nbc_buf_ping_nr));
+	M0_PRE(ergo(M0_IN(q, (M0_NET_QT_PASSIVE_BULK_RECV,
+			      M0_NET_QT_PASSIVE_BULK_SEND)),
+		    buf_index < ctx->nbc_buf_bulk_nr));
+
+	if (q == M0_NET_QT_MSG_SEND) {
+		/*
+		 * Change state for every bulk buffer, which
+		 * descriptor is stored in current message.
+		 */
+		m0_tl_for(bsb, &ctx->nbc_bsp[buf_index].bsp_buffers, bs) {
+			bs->bsb_msg.bse_cb_rc = ev->nbe_status;
+			node_bulk_state_change_cb(ctx, bs->bsb_index,
+						  ev->nbe_status == 0);
+			bsb_tlist_del(bs);
+		} m0_tl_endfor;
+	} else if (M0_IN(q, (M0_NET_QT_PASSIVE_BULK_RECV,
+			     M0_NET_QT_PASSIVE_BULK_SEND))) {
+		bs = &ctx->nbc_bs[buf_index / 2];
+		if (node_bulk_state_is_final(bs->bsb_ts))
+			buf_desc_client_free(ctx, buf_index / 2);
 	}
 }
 
+static bool node_bulk_is_stopping(struct node_bulk_ctx *ctx)
+{
+	return m0_atomic64_get(&ctx->nbc_stop_flag) == 1;
+}
+
 static void node_bulk_cb(struct m0_net_test_network_ctx *net_ctx,
 			 const uint32_t buf_index,
 			 enum m0_net_queue_type q,
@@ -797,11 +846,9 @@ static void node_bulk_cb(struct m0_net_test_network_ctx *net_ctx,
 	bool			 buf_send;
 	bool			 buf_bulk;
 
-	/*
-	M0_LOG(M0_DEBUG, "node_bulk_cb: tm_addr = %s, buf_index = %u, q = %d"
-			 ", ev-nbe_status = %d",
-	       net_ctx->ntc_tm->ntm_ep->nep_addr, buf_index, q, ev->nbe_status);
-	*/
+	LOGD("node_bulk_cb: tm_addr = %s, buf_index = %u, q = %d"
+	     ", ev-nbe_status = %d",
+	     net_ctx->ntc_tm->ntm_ep->nep_addr, buf_index, q, ev->nbe_status);
 	M0_PRE(net_ctx != NULL);
 	role_client = ctx->nbc_nh.ntnh_role == M0_NET_TEST_ROLE_CLIENT;
 	M0_PRE(ergo(q == M0_NET_QT_MSG_RECV, !role_client));
@@ -814,12 +861,11 @@ static void node_bulk_cb(struct m0_net_test_network_ctx *net_ctx,
 		    buf_index < ctx->nbc_buf_ping_nr));
 
 	if (ev->nbe_status != 0 && ev->nbe_status != -ECANCELED) {
-		M0_LOG(M0_DEBUG, "--CALLBACK ERROR! errno = %d",
-		       ev->nbe_status);
-		M0_LOG(M0_DEBUG, "node_bulk_cb: tm_addr = %s, "
-				 "buf_index = %u, q = %d"
-				 ", ev-nbe_status = %d",
-	       net_ctx->ntc_tm->ntm_ep->nep_addr, buf_index, q, ev->nbe_status);
+		LOGD("--CALLBACK ERROR! errno = %d", ev->nbe_status);
+		LOGD("node_bulk_cb: tm_addr = %s, buf_index = %u, q = %d"
+		     ", ev-nbe_status = %d",
+		     net_ctx->ntc_tm->ntm_ep->nep_addr, buf_index, q,
+		     ev->nbe_status);
 	}
 
 	ctx->nbc_callback_executed = true;
@@ -839,30 +885,14 @@ static void node_bulk_cb(struct m0_net_test_network_ctx *net_ctx,
 		bs_e->bse_cb_rc = ev->nbe_status;
 		node_bulk_state_change_cb(ctx, bs_index, ev->nbe_status == 0);
 	}
-	if (role_client && q == M0_NET_QT_MSG_SEND) {
-		/*
-		 * Change state for every bulk buffer, which
-		 * descriptor is stored in current message.
-		 */
-		m0_tl_for(bsb, &ctx->nbc_bsp[buf_index].bsp_buffers, bs) {
-			bs->bsb_msg.bse_cb_rc = ev->nbe_status;
-			node_bulk_state_change_cb(ctx, bs->bsb_index,
-						  ev->nbe_status == 0);
-			bsb_tlist_del(bs);
-		} m0_tl_endfor;
-	}
-	if (!role_client)
-		node_bulk_cb_server(ctx, buf_index, q, ev);
-	if (q == M0_NET_QT_MSG_SEND || q == M0_NET_QT_MSG_RECV) {
+	(role_client ? node_bulk_cb_client : node_bulk_cb_server)
+		(ctx, buf_index, q, ev);
+	if (M0_IN(q, (M0_NET_QT_MSG_SEND, M0_NET_QT_MSG_RECV))) {
 		/* ping buffer can be reused now */
 		m0_net_test_ringbuf_push(&ctx->nbc_rb_ping_unused, buf_index);
 	}
 	if (!role_client && q == M0_NET_QT_MSG_RECV) {
-		/*
-		 * @todo nbc_stop_flag isn't protected here with lock.
-		 * is it safe?
-		 */
-		if (!ctx->nbc_stop_flag)
+		if (!node_bulk_is_stopping(ctx))
 			server_process_unused_ping(ctx);
 	}
 	/* update stats */
@@ -873,7 +903,6 @@ static void node_bulk_cb(struct m0_net_test_network_ctx *net_ctx,
 		  buf_send ? MD_SEND : MD_RECV);
 	/* state transitions from final states */
 	node_bulk_state_transition_auto_all(ctx);
-	/* reuse ping buffer on the test server */
 }
 
 static struct m0_net_test_network_buffer_callbacks node_bulk_buf_cb = {
@@ -931,7 +960,6 @@ static void client_transfer_start(struct node_bulk_ctx *ctx,
 	rc = client_bulk_enqueue(ctx, bs_index * 2);
 	bs->bsb_send.bse_func_rc = rc;
 	if (rc != 0) {
-		M0_LOG(M0_DEBUG, "123");
 		node_bulk_state_change(ctx, bs_index, TS_FAILED);
 		sd_update(ctx, MT_BULK, MS_FAILED, MD_SEND);
 		return;
@@ -939,7 +967,6 @@ static void client_transfer_start(struct node_bulk_ctx *ctx,
 	rc = client_bulk_enqueue(ctx, bs_index * 2 + 1);
 	bs->bsb_recv.bse_func_rc = rc;
 	if (rc != 0) {
-		M0_LOG(M0_DEBUG, "456");
 		node_bulk_state_change(ctx, bs_index, TS_FAILED1);
 		client_bulk_dequeue(ctx, bs_index * 2);
 		sd_update(ctx, MT_BULK, MS_FAILED, MD_RECV);
@@ -962,7 +989,7 @@ static void client_process_unused_bulk(struct node_bulk_ctx *ctx)
 		/* Check stop conditions */
 		transfer_next = m0_net_test_nh_transfer_next(&ctx->nbc_nh);
 		/*
-		M0_LOG(M0_DEBUG, "client: transfer_next = %s",
+		LOGD("client: transfer_next = %s",
 		       transfer_next ? (char *) "true" : (char *) "false");
 		*/
 		if (!transfer_next)
@@ -970,7 +997,7 @@ static void client_process_unused_bulk(struct node_bulk_ctx *ctx)
 		/* Start next transfer */
 		bs_index = m0_net_test_ringbuf_pop(&ctx->nbc_rb_bulk_unused);
 		/*
-		M0_LOG(M0_DEBUG, "client: next transfer bs_index = %lu",
+		LOGD("client: next transfer bs_index = %lu",
 		       bs_index);
 		*/
 		client_transfer_start(ctx, bs_index);
@@ -1073,7 +1100,7 @@ take_msg:
 		len = client_bds_serialize2(&ctx->nbc_net, bs->bsb_index,
 					    msg_index, msg_offset);
 		/*
-		M0_LOG(M0_DEBUG, "msg_index = %lu, len = %lu, msg_offset = %lu",
+		LOGD("msg_index = %lu, len = %lu, msg_offset = %lu",
 		       (unsigned long ) msg_index, (unsigned long ) len,
 		       (unsigned long ) msg_offset);
 		*/
@@ -1123,7 +1150,7 @@ take_msg:
 						  msg_bs->bsp_index,
 						  ss->ssb_index);
 		if (rc != 0) {
-			M0_LOG(M0_DEBUG, "--- msg send FAILED!");
+			LOGD("--- msg send FAILED!");
 			sd_update(ctx, MT_MSG, MS_FAILED, MD_SEND);
 		}
 		/* Save rc for future analysis */
@@ -1201,11 +1228,41 @@ static void node_bulk_buf_dequeue(struct node_bulk_ctx *ctx)
 	}
 }
 
+static bool node_bulk_bufs_is_in_use(struct node_bulk_ctx *ctx)
+{
+	struct m0_net_test_network_ctx *net_ctx;
+	struct m0_net_buffer	       *buf;
+	uint64_t			flags;
+	size_t				i;
+	size_t				buf_ping_nr;
+
+	M0_PRE(ctx != NULL);
+
+	net_ctx = &ctx->nbc_net;
+	buf_ping_nr = net_ctx->ntc_buf_ping_nr;
+	for (i = 0; i < buf_ping_nr + net_ctx->ntc_buf_bulk_nr; ++i) {
+		buf = i < buf_ping_nr ?
+		      m0_net_test_network_buf(&ctx->nbc_net,
+					      M0_NET_TEST_BUF_PING, i) :
+		      net_buf_bulk_get(ctx, i - buf_ping_nr);
+
+		M0_CASSERT(sizeof(buf->nb_flags) == 8);
+		M0_CASSERT(sizeof(struct m0_atomic64) == 8);
+		flags = m0_atomic64_get((struct m0_atomic64 *) &buf->nb_flags);
+		if (flags & (M0_NET_BUF_QUEUED | M0_NET_BUF_IN_USE |
+			     M0_NET_BUF_CANCELLED |
+			     M0_NET_BUF_TIMED_OUT | M0_NET_BUF_RETAIN))
+			return true;
+	}
+	return false;
+}
+
 static void node_bulk_worker(struct node_bulk_ctx *ctx)
 {
 	struct m0_clink	tm_clink;
 	struct m0_chan	tm_chan;
-	bool		notify;
+	bool		pending;
+	bool		stopping;
 
 	M0_PRE(ctx != NULL);
 
@@ -1220,23 +1277,26 @@ static void node_bulk_worker(struct node_bulk_ctx *ctx)
 	m0_chan_init(&tm_chan);
 	m0_clink_add(&tm_chan, &tm_clink);
 	/* main loop */
-	notify = true;
-	while (1) {
-		if (ctx->nbc_nh.ntnh_role == M0_NET_TEST_ROLE_CLIENT) {
-			client_process_unused_bulk(ctx);
-			client_process_queued_bulk(ctx);
-		} else {
-			server_process_unused_ping(ctx);
+	stopping = false;
+	while (!node_bulk_is_stopping(ctx) || node_bulk_bufs_is_in_use(ctx)) {
+		if (!node_bulk_is_stopping(ctx)) {
+			if (ctx->nbc_nh.ntnh_role == M0_NET_TEST_ROLE_CLIENT) {
+				client_process_unused_bulk(ctx);
+				client_process_queued_bulk(ctx);
+			} else {
+				server_process_unused_ping(ctx);
+			}
 		}
 		/* notification for buffer events */
-		if (notify) {
+		pending = m0_net_buffer_event_pending(ctx->nbc_net.ntc_tm);
+		if (!pending) {
 			m0_net_buffer_event_notify(ctx->nbc_net.ntc_tm,
 						   &tm_chan);
-			notify = false;
 		}
 		ctx->nbc_callback_executed = false;
 		/* execute network buffer callbacks in this thread context */
 		m0_net_buffer_event_deliver_all(ctx->nbc_net.ntc_tm);
+		M0_ASSERT(ergo(pending, ctx->nbc_callback_executed));
 		/* state transitions from final states */
 		node_bulk_state_transition_auto_all(ctx);
 		/* update copy of statistics */
@@ -1244,42 +1304,22 @@ static void node_bulk_worker(struct node_bulk_ctx *ctx)
 		/* wait for STOP command or buffer event */
 		if (!ctx->nbc_callback_executed)
 			m0_chan_wait(&ctx->nbc_stop_clink);
-		/* it was STOP command */
-		if (ctx->nbc_stop_flag)
-			break;
-		if (!ctx->nbc_callback_executed)
-			notify = true;
-	}
-	/* dequeue all queued network buffers */
-	node_bulk_buf_dequeue(ctx);
-	m0_net_buffer_event_deliver_all(ctx->nbc_net.ntc_tm);
-	node_bulk_state_transition_auto_all(ctx);
-	m0_net_test_nh_sd_copy_locked(&ctx->nbc_nh);
-}
-
-static void *node_bulk_init_fini(struct m0_net_test_service *svc,
-				 void *ctx_,
-				 bool init)
-{
-	struct node_bulk_ctx *ctx;
-
-	M0_PRE(ergo(init, ctx_ == NULL));
-	M0_PRE(ergo(init, svc != NULL));
-	if (init) {
-		M0_ALLOC_PTR(ctx);
-		if (ctx != NULL) {
-			ctx->nbc_svc			  = svc;
-			ctx->nbc_nh.ntnh_test_initialized = false;
+		if (node_bulk_is_stopping(ctx) && !stopping) {
+			/* dequeue all queued network buffers */
+			node_bulk_buf_dequeue(ctx);
+			stopping = true;
 		}
-	} else {
-		ctx = NULL;
 	}
-	return ctx;
+	/* transfer machine should't signal to tm_chan */
+	m0_net_buffer_event_notify(ctx->nbc_net.ntc_tm, NULL);
+	m0_clink_del(&tm_clink);
+	m0_clink_fini(&tm_clink);
+	m0_chan_fini(&tm_chan);
+
 }
 
 static int node_bulk_test_init_fini(struct node_bulk_ctx *ctx,
-				    const struct m0_net_test_cmd *cmd,
-				    bool init)
+				    const struct m0_net_test_cmd *cmd)
 {
 	struct m0_net_test_network_timeouts timeouts;
 	const struct m0_net_test_cmd_init  *icmd;
@@ -1293,9 +1333,8 @@ static int node_bulk_test_init_fini(struct node_bulk_ctx *ctx,
 	size_t				    nr;
 
 	M0_PRE(ctx != NULL);
-	M0_PRE(equi(init, cmd != NULL));
 
-	if (!init)
+	if (cmd == NULL)
 		goto fini;
 	icmd	    = &cmd->ntc_init;
 	role_client = icmd->ntci_role == M0_NET_TEST_ROLE_CLIENT;
@@ -1404,7 +1443,8 @@ free_bsp:
 	}
 free_sstatus:
 	if (ctx->nbc_nh.ntnh_role == M0_NET_TEST_ROLE_CLIENT) {
-		nr = init ? icmd->ntci_ep.ntsl_nr : ctx->nbc_net.ntc_ep_nr;
+		nr = cmd != NULL ? icmd->ntci_ep.ntsl_nr :
+				   ctx->nbc_net.ntc_ep_nr;
 		for (i = 0; i < nr; ++i) {
 			ss = &ctx->nbc_sstatus[i];
 			ssb_tlink_fini(ss);
@@ -1421,14 +1461,39 @@ success:
 	return rc;
 }
 
+static void *node_bulk_init_fini(void *ctx_,
+				 struct m0_net_test_service *svc,
+				 bool init)
+{
+	struct node_bulk_ctx *ctx;
+	int		      rc;
+
+	M0_PRE(equi(init, ctx_ == NULL));
+	M0_PRE(equi(init, svc != NULL));
+
+	if (init) {
+		M0_ALLOC_PTR(ctx);
+		if (ctx != NULL) {
+			ctx->nbc_svc			  = svc;
+			ctx->nbc_nh.ntnh_test_initialized = false;
+		}
+	} else {
+		ctx = ctx_;
+		rc = node_bulk_test_init_fini(ctx, NULL);
+		M0_ASSERT(rc == 0);
+		m0_free(ctx);
+	}
+	return init ? ctx : NULL;
+}
+
 static void *node_bulk_init(struct m0_net_test_service *svc)
 {
-	return node_bulk_init_fini(svc, NULL, true);
+	return node_bulk_init_fini(NULL, svc, true);
 }
 
 static void node_bulk_fini(void *ctx_)
 {
-	void *rc = node_bulk_init_fini(NULL, ctx_, false);
+	void *rc = node_bulk_init_fini(ctx_, NULL, false);
 	M0_POST(rc == NULL);
 }
 
@@ -1483,7 +1548,7 @@ static int node_bulk_cmd_init(void *ctx_,
 	    !ergo(role_client, 2 * ctx->nbc_bs_nr == ctx->nbc_buf_bulk_nr))
 		goto reply;
 
-	rc = node_bulk_test_init_fini(ctx, cmd, true);
+	rc = node_bulk_test_init_fini(ctx, cmd);
 reply:
 	/* fill reply */
 	reply->ntc_type = M0_NET_TEST_CMD_INIT_DONE;
@@ -1513,7 +1578,7 @@ static int node_bulk_cmd_start(void *ctx_,
 	/* initialize stats */
 	m0_net_test_mps_init(&sd->ntcsd_mps_send, 0, sd->ntcsd_time_start, _1s);
 	m0_net_test_mps_init(&sd->ntcsd_mps_recv, 0, sd->ntcsd_time_start, _1s);
-	ctx->nbc_stop_flag = false;
+	m0_atomic64_set(&ctx->nbc_stop_flag, 0);
 	rc = M0_THREAD_INIT(&ctx->nbc_thread, struct node_bulk_ctx *, NULL,
 			    &node_bulk_worker, ctx,
 			    "net-test-bulk-worker#%s",
@@ -1546,14 +1611,11 @@ static int node_bulk_cmd_stop(void *ctx_,
 		goto reply;
 	}
 	/* stop worker thread */
-	ctx->nbc_stop_flag = true;
+	m0_atomic64_set(&ctx->nbc_stop_flag, 1);
 	m0_chan_signal(&ctx->nbc_stop_chan);
 	rc = m0_thread_join(&ctx->nbc_thread);
 	M0_ASSERT(rc == 0);
 	m0_thread_fini(&ctx->nbc_thread);
-	/* finalize test structures */
-	rc = node_bulk_test_init_fini(ctx, NULL, false);
-	M0_ASSERT(rc == 0);
 	/* change service state */
 	m0_net_test_service_state_change(ctx->nbc_svc,
 					 M0_NET_TEST_SERVICE_FINISHED);
diff --git a/net/test/node_helper.c b/net/test/node_helper.c
index 4b045e7..b652d7a 100644
--- a/net/test/node_helper.c
+++ b/net/test/node_helper.c
@@ -18,7 +18,6 @@
  * Original creation date: 11/07/2012
  */
 
-#include "lib/trace.h"			/* M0_LOG */
 #include "lib/misc.h"			/* M0_IN */
 
 #include "net/test/node_helper.h"
@@ -69,7 +68,7 @@ void m0_net_test_nh_sd_copy_locked(struct m0_net_test_nh *nh)
 }
 
 void m0_net_test_nh_sd_get_locked(struct m0_net_test_nh *nh,
-				struct m0_net_test_cmd_status_data *sd)
+				  struct m0_net_test_cmd_status_data *sd)
 {
 	M0_PRE(m0_net_test_nh__invariant(nh));
 
diff --git a/net/test/node_ping.c b/net/test/node_ping.c
index 8b0db9e..592843a 100644
--- a/net/test/node_ping.c
+++ b/net/test/node_ping.c
@@ -18,21 +18,6 @@
  * Original creation date: 09/03/2012
  */
 
-/** @todo remove */
-#ifndef __KERNEL__
-#include <stdio.h>		/* printf */
-#endif
-
-/** @todo debug only, remove it */
-#ifndef __KERNEL__
-/*
-#define LOGD(format, ...) printf(format, ##__VA_ARGS__)
-*/
-#define LOGD(format, ...) do {} while (0)
-#else
-#define LOGD(format, ...) do {} while (0)
-#endif
-
 #include "lib/memory.h"			/* M0_ALLOC_PTR */
 #include "lib/misc.h"			/* M0_SET0 */
 #include "lib/time.h"			/* m0_time_t */
@@ -48,6 +33,12 @@
 
 #include "net/test/node_ping.h"
 
+#ifdef NET_TEST_MODULE_NAME
+#undef NET_TEST_MODULE_NAME
+#endif
+#define NET_TEST_MODULE_NAME node_ping
+#include "net/test/debug.h"		/* LOGD */
+
 
 /**
    @defgroup NetTestPingNodeInternals Ping Node
@@ -279,8 +270,7 @@ static bool node_ping_timestamp_get(struct m0_net_test_network_ctx *net_ctx,
 static void node_ping_to_add(struct node_ping_ctx *ctx,
 			     size_t buf_index)
 {
-	LOGD(">> WAIT: >> %s: buf_index = %lu\n",
-	     __FUNCTION__, buf_index);
+	LOGD("buf_index = %lu", buf_index);
 	buf_state_tlist_add_tail(&ctx->npc_client->npcc_to,
 				 &ctx->npc_buf_state[buf_index]);
 }
@@ -288,8 +278,7 @@ static void node_ping_to_add(struct node_ping_ctx *ctx,
 static void node_ping_to_del(struct node_ping_ctx *ctx,
 			     size_t buf_index)
 {
-	LOGD(">> WAIT: >> %s: buf_index = %lu\n",
-	     __FUNCTION__, buf_index);
+	LOGD("buf_index = %lu", buf_index);
 	buf_state_tlist_del(&ctx->npc_buf_state[buf_index]);
 }
 
@@ -341,11 +330,8 @@ static void node_ping_buf_enqueue(struct node_ping_ctx *ctx,
 		bs->bs_errno = -EWOULDBLOCK;
 		return;
 	}
-	LOGD("node_ping_buf_enqueue:");
-	LOGD(", q = %d", q);
-	LOGD(", buf_index = %lu", buf_index);
-	LOGD(", ep_index = %lu", ep_index);
-	LOGD(", %s", ctx->npc_net.ntc_tm->ntm_ep->nep_addr);
+	LOGD("q = %d, buf_index = %lu, ep_index = %lu, %s",
+	     q, buf_index, ep_index, ctx->npc_net.ntc_tm->ntm_ep->nep_addr);
 	if (q == M0_NET_QT_MSG_SEND) {
 		LOGD(" => %s", (ep == NULL ?
 			    m0_net_test_network_ep(&ctx->npc_net, ep_index) :
@@ -353,7 +339,6 @@ static void node_ping_buf_enqueue(struct node_ping_ctx *ctx,
 	} else {
 		LOGD(" <= ");
 	}
-	LOGD("\n");
 	bs->bs_errno = (bs->bs_q = q) == M0_NET_QT_MSG_RECV ?
 		  m0_net_test_network_msg_recv(nctx, buf_index) : ep == NULL ?
 		  m0_net_test_network_msg_send(nctx, buf_index, ep_index) :
@@ -490,14 +475,13 @@ static void node_ping_msg_cb(struct m0_net_test_network_ctx *net_ctx,
 	ctx = node_ping_ctx_from_net_ctx(net_ctx);
 	bs = &ctx->npc_buf_state[buf_index];
 
-	LOGD("%s,      role = %d, buf_index = %u, nbe_status = %d, q = %d",
-	     __FUNCTION__, ctx->npc_nh.ntnh_role, buf_index, ev->nbe_status, q);
-	LOGD(", ev->nbe_length = %lu", ev->nbe_length);
+	LOGD("role = %d, buf_index = %u, nbe_status = %d, q = %d",
+	     ctx->npc_nh.ntnh_role, buf_index, ev->nbe_status, q);
+	LOGD(", ev->nbe_length = %lu", (long unsigned) ev->nbe_length);
 
 	if (q == M0_NET_QT_MSG_RECV && ev->nbe_status == 0)
 		LOGD(", ev->nbe_ep->nep_addr = %s", ev->nbe_ep->nep_addr);
 
-	LOGD("\n");
 
 	if (ev->nbe_status == -ECANCELED) {
 		m0_semaphore_up(&ctx->npc_buf_q_sem);
@@ -628,7 +612,7 @@ static void node_ping_worker(struct node_ping_ctx *ctx)
 			break;
 		buf_index = m0_net_test_ringbuf_pop(&ctx->npc_buf_rb);
 		bs = &ctx->npc_buf_state[buf_index];
-		LOGD("POP from ringbuf: %lu, role = %d\n",
+		LOGD("POP from ringbuf: %lu, role = %d",
 		     buf_index, ctx->npc_nh.ntnh_role);
 		/* update total/failed stats */
 		failed = bs->bs_errno != 0 || bs->bs_ev.nbe_status != 0;
@@ -765,18 +749,22 @@ static void *node_ping_init_fini(void *ctx_,
 				 struct m0_net_test_service *svc,
 				 bool init)
 {
-	struct node_ping_ctx *ctx = ctx_;
+	struct node_ping_ctx *ctx;
+	int		      rc;
 
-	M0_PRE(equi(init, ctx == NULL));
+	M0_PRE(equi(init, ctx_ == NULL));
 	M0_PRE(equi(init, svc != NULL));
 
 	if (init) {
 		M0_ALLOC_PTR(ctx);
 		if (ctx != NULL) {
-			ctx->npc_svc = svc;
+			ctx->npc_svc			  = svc;
+			ctx->npc_nh.ntnh_test_initialized = false;
 		}
 	} else {
-		node_ping_test_init_fini(ctx, NULL);
+		ctx = ctx_;
+		rc = node_ping_test_init_fini(ctx, NULL);
+		M0_ASSERT(rc == 0);
 		m0_free(ctx);
 	}
 	return init ? ctx : NULL;
@@ -811,8 +799,6 @@ static int node_ping_cmd_init(void *ctx_,
 	M0_PRE(cmd != NULL);
 	M0_PRE(reply != NULL);
 
-	LOGD("%s\n", __FUNCTION__);
-
 	icmd	    = &cmd->ntc_init;
 	role_client = icmd->ntci_role == M0_NET_TEST_ROLE_CLIENT;
 
@@ -878,8 +864,6 @@ static int node_ping_cmd_start(void *ctx_,
 	M0_PRE(cmd != NULL);
 	M0_PRE(reply != NULL);
 
-	LOGD("%s\n", __FUNCTION__);
-
 	sd = &ctx->npc_nh.ntnh_sd;
 	M0_SET0(sd);
 
@@ -918,8 +902,6 @@ static int node_ping_cmd_stop(void *ctx_,
 	M0_PRE(cmd != NULL);
 	M0_PRE(reply != NULL);
 
-	LOGD("%s\n", __FUNCTION__);
-
 	/* stop worker thread */
 	ctx->npc_buf_rb_done = true;
 	m0_semaphore_up(&ctx->npc_buf_rb_sem);
@@ -945,13 +927,6 @@ static int node_ping_cmd_status(void *ctx_,
 
 	m0_net_test_nh_cmd_status(&ctx->npc_nh, cmd, reply);
 
-	if (ctx->npc_nh.ntnh_role == M0_NET_TEST_ROLE_CLIENT) {
-		LOGD("ctx->npc_client->npcc_msg_rt = %lu\n",
-		     ctx->npc_client->npcc_msg_rt);
-		LOGD("ctx->npc_client->npcc_msg_sent = %lu\n",
-		     ctx->npc_client->npcc_msg_sent);
-	}
-
 	return 0;
 }
 
diff --git a/net/test/node_stub.c b/net/test/node_stub.c
new file mode 100644
index 0000000..074ece1
--- /dev/null
+++ b/net/test/node_stub.c
@@ -0,0 +1,133 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Maxim Medved <max_medved@xyratex.com>
+ * Original creation date: 01/12/2013
+ */
+
+#include "lib/misc.h"			/* M0_SET0 */
+#include "lib/time.h"			/* m0_time_t */
+
+#include "net/test/node_stub.h"
+
+
+/**
+   @defgroup NetTestStubNodeInternals Node Stub
+   @ingroup NetTestInternals
+
+   Used in UT to test node-console interaction.
+
+   @{
+ */
+
+static void *node_stub_init(struct m0_net_test_service *svc)
+{
+	return svc;
+}
+
+static void node_stub_fini(void *ctx_)
+{
+}
+
+static int node_stub_step(void *ctx_)
+{
+	return 0;
+}
+
+static int node_stub_cmd_init(void *ctx_,
+			      const struct m0_net_test_cmd *cmd,
+			      struct m0_net_test_cmd *reply)
+{
+	reply->ntc_type = M0_NET_TEST_CMD_INIT_DONE;
+	reply->ntc_done.ntcd_errno = 0;
+	return 0;
+}
+
+static int node_stub_cmd_start(void *ctx_,
+			       const struct m0_net_test_cmd *cmd,
+			       struct m0_net_test_cmd *reply)
+{
+	reply->ntc_type = M0_NET_TEST_CMD_START_DONE;
+	reply->ntc_done.ntcd_errno = 0;
+	return 0;
+}
+
+static int node_stub_cmd_stop(void *ctx_,
+			      const struct m0_net_test_cmd *cmd,
+			      struct m0_net_test_cmd *reply)
+{
+	m0_net_test_service_state_change(ctx_, M0_NET_TEST_SERVICE_FINISHED);
+	reply->ntc_type = M0_NET_TEST_CMD_STOP_DONE;
+	reply->ntc_done.ntcd_errno = 0;
+	return 0;
+}
+
+static int node_stub_cmd_status(void *ctx_,
+				const struct m0_net_test_cmd *cmd,
+				struct m0_net_test_cmd *reply)
+{
+	struct m0_net_test_cmd_status_data *sd;
+
+	reply->ntc_type = M0_NET_TEST_CMD_STATUS_DATA;
+	sd = &reply->ntc_status_data;
+	M0_SET0(sd);
+	sd->ntcsd_finished = true;
+	sd->ntcsd_time_start = m0_time_now();
+	sd->ntcsd_time_finish = m0_time_add(sd->ntcsd_time_start,
+					    M0_MKTIME(0, 1));
+	return 0;
+}
+
+static struct m0_net_test_service_cmd_handler node_stub_cmd_handler[] = {
+	{
+		.ntsch_type    = M0_NET_TEST_CMD_INIT,
+		.ntsch_handler = node_stub_cmd_init,
+	},
+	{
+		.ntsch_type    = M0_NET_TEST_CMD_START,
+		.ntsch_handler = node_stub_cmd_start,
+	},
+	{
+		.ntsch_type    = M0_NET_TEST_CMD_STOP,
+		.ntsch_handler = node_stub_cmd_stop,
+	},
+	{
+		.ntsch_type    = M0_NET_TEST_CMD_STATUS,
+		.ntsch_handler = node_stub_cmd_status,
+	},
+};
+
+struct m0_net_test_service_ops m0_net_test_node_stub_ops = {
+	.ntso_init	     = node_stub_init,
+	.ntso_fini	     = node_stub_fini,
+	.ntso_step	     = node_stub_step,
+	.ntso_cmd_handler    = node_stub_cmd_handler,
+	.ntso_cmd_handler_nr = ARRAY_SIZE(node_stub_cmd_handler),
+};
+
+/**
+   @} end of NetTestStubNodeInternals group
+ */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 79
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/net/test/node_stub.h b/net/test/node_stub.h
new file mode 100644
index 0000000..0af2c79
--- /dev/null
+++ b/net/test/node_stub.h
@@ -0,0 +1,51 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Maxim Medved <max_medved@xyratex.com>
+ * Original creation date: 01/12/2012
+ */
+
+#pragma once
+
+#ifndef __MERO_NET_TEST_NODE_STUB_H__
+#define __MERO_NET_TEST_NODE_STUB_H__
+
+#include "net/test/service.h"		/* m0_net_test_service_ops */
+
+/**
+   @defgroup NetTestStubNodeDFS Node Stub
+   @ingroup NetTestDFS
+
+   @{
+ */
+
+extern struct m0_net_test_service_ops m0_net_test_node_stub_ops;
+
+/**
+   @} end of NetTestStubNodeDFS group
+ */
+
+#endif /*  __MERO_NET_TEST_NODE_STUB_H__ */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 79
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/net/test/ringbuf.c b/net/test/ringbuf.c
index dc244b2..cbc58ae 100644
--- a/net/test/ringbuf.c
+++ b/net/test/ringbuf.c
@@ -18,9 +18,9 @@
  * Original creation date: 07/02/2012
  */
 
-#include "lib/errno.h"	/* ENOMEM */
-#include "lib/misc.h"	/* M0_SET0 */
-#include "lib/memory.h"	/* M0_ALLOC_ARR */
+#include "lib/errno.h"		/* ENOMEM */
+#include "lib/misc.h"		/* M0_SET0 */
+#include "lib/memory.h"		/* M0_ALLOC_ARR */
 
 #include "net/test/ringbuf.h"
 
diff --git a/net/test/serialize.c b/net/test/serialize.c
index c770e3c..b0516ca 100644
--- a/net/test/serialize.c
+++ b/net/test/serialize.c
@@ -51,7 +51,7 @@ static void net_test_serialize_cpu_to_le(char *d, char *s, m0_bcount_t len)
 	} else if (len == 8) {
 		* (uint64_t *) d = m0_byteorder_cpu_to_le64(* (uint64_t *) s);
 	} else {
-		M0_IMPOSSIBLE("len isn't power of 2");
+		M0_IMPOSSIBLE("len isn't a power of 2");
 	}
 
 }
@@ -67,7 +67,7 @@ static void net_test_serialize_le_to_cpu(char *d, char *s, m0_bcount_t len)
 	} else if (len == 8) {
 		* (uint64_t *) d = m0_byteorder_le64_to_cpu(* (uint64_t *) s);
 	} else {
-		M0_IMPOSSIBLE("len isn't power of 2");
+		M0_IMPOSSIBLE("len isn't a power of 2");
 	}
 
 }
diff --git a/net/test/service.c b/net/test/service.c
index b49921d..bd2890d 100644
--- a/net/test/service.c
+++ b/net/test/service.c
@@ -18,18 +18,6 @@
  * Original creation date: 09/03/2012
  */
 
-/** @todo remove */
-#ifndef __KERNEL__
-#include <stdio.h>		/* printf */
-#endif
-
-/** @todo debug only, remove it */
-#ifndef __KERNEL__
-#define LOGD(format, ...) printf(format, ##__VA_ARGS__)
-#else
-#define LOGD(format, ...) do {} while (0)
-#endif
-
 #include "lib/memory.h"		/* M0_ALLOC_PTR */
 #include "lib/misc.h"		/* M0_SET0 */
 #include "lib/errno.h"		/* ENOENT */
diff --git a/net/test/service.h b/net/test/service.h
index fd5fec4..2920b84 100644
--- a/net/test/service.h
+++ b/net/test/service.h
@@ -27,7 +27,6 @@
 #include "lib/thread.h"			/* m0_thread */
 
 #include "net/test/commands.h"		/* m0_net_test_cmd_ctx */
-#include "net/test/node.h"		/* m0_net_test_node_ctx */
 
 /**
    @defgroup NetTestServiceDFS Test Service
diff --git a/net/test/slist.c b/net/test/slist.c
index 14a2ede..571faa8 100644
--- a/net/test/slist.c
+++ b/net/test/slist.c
@@ -56,10 +56,11 @@ int m0_net_test_slist_init(struct m0_net_test_slist *slist,
 			   const char *str,
 			   char delim)
 {
-	char  *str1;
-	size_t len = 0;
-	size_t i = 0;
-	bool   allocated;
+	const char *str1;
+	char	   *str2;
+	size_t	    len = 0;
+	size_t	    i = 0;
+	bool	    allocated;
 
 	M0_PRE(slist != NULL);
 	M0_PRE(str   != NULL);
@@ -67,24 +68,25 @@ int m0_net_test_slist_init(struct m0_net_test_slist *slist,
 
 	M0_SET0(slist);
 
-	for (len = 0; str[len] != '\0'; ++len)
-		slist->ntsl_nr += str[len] == delim;
-
+	len = strlen(str);
 	if (len != 0) {
-		slist->ntsl_nr++;
-
+		for (str1 = str; str1 != NULL; str1 = strchr(str1, delim)) {
+			++str1;
+			++slist->ntsl_nr;
+		}
 		allocated = slist_alloc(slist, slist->ntsl_nr, len + 1);
 		if (!allocated)
 			return -ENOMEM;
 
 		strncpy(slist->ntsl_str, str, len + 1);
-		str1 = slist->ntsl_str;
-		slist->ntsl_list[i++] = str1;
-		for (; *str1 != '\0'; ++str1)
-			if (*str1 == delim) {
-				*str1 = '\0';
-				slist->ntsl_list[i++] = str1 + 1;
+		str2 = slist->ntsl_str;
+		for ( ; str2 != NULL; str2 = strchr(str2, delim)) {
+			if (str2 != slist->ntsl_str) {
+				*str2 = '\0';
+				++str2;
 			}
+			slist->ntsl_list[i++] = str2;
+		}
 	}
 	M0_POST(m0_net_test_slist_invariant(slist));
 	return 0;
diff --git a/net/test/stats.h b/net/test/stats.h
index 06ac9b1..8748b92 100644
--- a/net/test/stats.h
+++ b/net/test/stats.h
@@ -110,6 +110,7 @@ struct m0_net_test_stats {
 
 /**
    Reset m0_net_test_stats structure.
+   Set sample size and min/max/sum/sum_sqr to 0.
    @post m0_net_test_stats_invariant(stats)
  */
 void m0_net_test_stats_reset(struct m0_net_test_stats *stats);
@@ -168,8 +169,10 @@ m0_bcount_t m0_net_test_stats_serialize(enum m0_net_test_serialize_op op,
    - m0_net_test_stats_time_sum()
    - m0_net_test_stats_time_avg()
    - m0_net_test_stats_time_stddev()
-   Mixing m0_net_test_stats_add() and m0_net_test_stats_time_add()
+   @note Mixing m0_net_test_stats_add() and m0_net_test_stats_time_add()
    will lead to undefined behavior.
+   @note m0_net_test_stats_time_sum(), m0_net_test_stats_time_avg(),
+   m0_net_test_stats_time_stddev() are available from user space only.
  */
 void m0_net_test_stats_time_add(struct m0_net_test_stats *stats,
 				m0_time_t time);
diff --git a/net/test/str.c b/net/test/str.c
index 7955010..311cf11 100644
--- a/net/test/str.c
+++ b/net/test/str.c
@@ -62,6 +62,7 @@ m0_bcount_t m0_net_test_str_serialize(enum m0_net_test_serialize_op op,
 
 	M0_PRE(op == M0_NET_TEST_SERIALIZE || op == M0_NET_TEST_DESERIALIZE);
 	M0_PRE(str != NULL);
+	M0_PRE(ergo(op == M0_NET_TEST_SERIALIZE, *str != NULL));
 
 	if (op == M0_NET_TEST_SERIALIZE) {
 		str_len.ntsl_len = strlen(*str) + 1;
diff --git a/net/test/ut/client_server.c b/net/test/ut/client_server.c
index d4a4f65..1a639f6 100644
--- a/net/test/ut/client_server.c
+++ b/net/test/ut/client_server.c
@@ -30,22 +30,28 @@
 #include "net/test/node.h"		/* m0_net_test_node_ctx */
 #include "net/test/console.h"		/* m0_net_test_console_ctx */
 
+#ifdef NET_TEST_MODULE_NAME
+#undef NET_TEST_MODULE_NAME
+#endif
+#define NET_TEST_MODULE_NAME ut_client_server
+#include "net/test/debug.h"
+
 enum {
 	NTCS_PID		  = M0_NET_LNET_PID,
 	NTCS_PORTAL		  = 42,
 	NTCS_NODES_MAX		  = 128,
 	NTCS_NODE_ADDR_MAX	  = 0x100,
-	/** @todo 10min for debugging in gdb */
+	/** @todo 20min for debugging in gdb */
+	NTCS_TIMEOUT_CMD_MS	  = 1200000,
+	NTCS_TIMEOUT_SEND_MS	  = 1200000,
+	NTCS_TIMEOUT_RECV_MS	  = 1200000,
+	NTCS_TIMEOUT_BULK_MS	  = 1200000,
 	/*
-	NTCS_TIMEOUT_CMD_MS	  = 600000,
-	NTCS_TIMEOUT_SEND_MS	  = 600000,
-	NTCS_TIMEOUT_RECV_MS	  = 600000,
-	NTCS_TIMEOUT_BULK_MS	  = 600000,
-	*/
 	NTCS_TIMEOUT_CMD_MS	  = 20000,
 	NTCS_TIMEOUT_SEND_MS	  = 20000,
 	NTCS_TIMEOUT_RECV_MS	  = 20000,
 	NTCS_TIMEOUT_BULK_MS	  = 20000,
+	*/
 	NTCS_TMID_CONSOLE4CLIENTS = 2998,
 	NTCS_TMID_CONSOLE4SERVERS = 2999,
 	NTCS_TMID_NODES		  = 3000,
@@ -143,8 +149,8 @@ static void node_cfg_fill(struct m0_net_test_node_cfg *ncfg,
 static void msg_nr_print(const char *prefix,
 			 const struct m0_net_test_msg_nr *msg_nr)
 {
-	M0_LOG(M0_DEBUG, "%-21s total/failed/bad = %lu/%lu/%lu", prefix,
-	       msg_nr->ntmn_total, msg_nr->ntmn_failed, msg_nr->ntmn_bad);
+	LOGD("%-21s total/failed/bad = %lu/%lu/%lu", prefix,
+	     msg_nr->ntmn_total, msg_nr->ntmn_failed, msg_nr->ntmn_bad);
 }
 
 /*
@@ -166,14 +172,19 @@ static void net_test_client_server(const char *nid,
 {
 	struct m0_net_test_cmd_status_data *sd_servers;
 	struct m0_net_test_cmd_status_data *sd_clients;
-	struct m0_net_test_console_cfg	    console_cfg;
-	struct m0_net_test_console_ctx	    console;
+	struct m0_net_test_console_cfg	   *console_cfg;
+	struct m0_net_test_console_ctx	   *console;
 	int				    rc;
 	int				    i;
 	m0_time_t			    _1s = M0_MKTIME(1, 0);
 
 	M0_PRE(clients_nr <= NTCS_NODES_MAX);
 	M0_PRE(servers_nr <= NTCS_NODES_MAX);
+
+	M0_ALLOC_PTR(console_cfg);
+	M0_ALLOC_PTR(console);
+	if (console_cfg == NULL || console == NULL)
+		goto done;
 	/* prepare config for test clients and test servers */
 	timeout_cmd  = ms2time(NTCS_TIMEOUT_CMD_MS);
 	timeout_send = ms2time(NTCS_TIMEOUT_SEND_MS);
@@ -205,7 +216,7 @@ static void net_test_client_server(const char *nid,
 		rc = M0_THREAD_INIT(&node_thread[i],
 				    struct m0_net_test_node_cfg *,
 				    NULL, &net_test_node, &node_cfg[i],
-				    "node_thread#%d", i);
+				    "ut_node_thread#%d", i);
 		M0_UT_ASSERT(rc == 0);
 	}
 	/* wait until test node started */
@@ -213,102 +224,102 @@ static void net_test_client_server(const char *nid,
 		m0_semaphore_down(&node_init_sem);
 	m0_semaphore_fini(&node_init_sem);
 	/* prepare console config */
-	console_cfg.ntcc_addr_console4servers = addr_console4servers;
-	console_cfg.ntcc_addr_console4clients = addr_console4clients;
-	M0_LOG(M0_DEBUG, "addr_console4servers = %s", addr_console4servers);
-	M0_LOG(M0_DEBUG, "addr_console4clients = %s", addr_console4clients);
-	M0_LOG(M0_DEBUG, "clients      = %s", (char *) clients);
-	M0_LOG(M0_DEBUG, "servers      = %s", (char *) servers);
-	M0_LOG(M0_DEBUG, "clients_data = %s", (char *) clients_data);
-	M0_LOG(M0_DEBUG, "servers_data = %s", (char *) servers_data);
-	rc = m0_net_test_slist_init(&console_cfg.ntcc_clients, clients, ',');
+	console_cfg->ntcc_addr_console4servers = addr_console4servers;
+	console_cfg->ntcc_addr_console4clients = addr_console4clients;
+	LOGD("addr_console4servers = %s", addr_console4servers);
+	LOGD("addr_console4clients = %s", addr_console4clients);
+	LOGD("clients      = %s", (char *) clients);
+	LOGD("servers      = %s", (char *) servers);
+	LOGD("clients_data = %s", (char *) clients_data);
+	LOGD("servers_data = %s", (char *) servers_data);
+	rc = m0_net_test_slist_init(&console_cfg->ntcc_clients, clients, ',');
 	M0_UT_ASSERT(rc == 0);
-	rc = m0_net_test_slist_init(&console_cfg.ntcc_servers, servers, ',');
+	rc = m0_net_test_slist_init(&console_cfg->ntcc_servers, servers, ',');
 	M0_UT_ASSERT(rc == 0);
-	rc = m0_net_test_slist_init(&console_cfg.ntcc_data_clients,
+	rc = m0_net_test_slist_init(&console_cfg->ntcc_data_clients,
 				    clients_data, ',');
 	M0_UT_ASSERT(rc == 0);
-	rc = m0_net_test_slist_init(&console_cfg.ntcc_data_servers,
+	rc = m0_net_test_slist_init(&console_cfg->ntcc_data_servers,
 				    servers_data, ',');
 	M0_UT_ASSERT(rc == 0);
-	console_cfg.ntcc_cmd_send_timeout   = timeout_cmd;
-	console_cfg.ntcc_cmd_recv_timeout   = timeout_cmd;
-	console_cfg.ntcc_buf_send_timeout   = timeout_send;
-	console_cfg.ntcc_buf_recv_timeout   = timeout_recv;
-	console_cfg.ntcc_buf_bulk_timeout   = timeout_bulk;
-	console_cfg.ntcc_test_type	    = type;
-	console_cfg.ntcc_msg_nr		    = msg_nr;
-	console_cfg.ntcc_msg_size	    = msg_size;
-	console_cfg.ntcc_bd_buf_nr_server   = bd_buf_nr_server;
-	console_cfg.ntcc_bd_buf_nr_client   = bd_buf_nr_client;
-	console_cfg.ntcc_bd_buf_size	    = bd_buf_size;
-	console_cfg.ntcc_bd_nr_max	    = bd_nr_max;
-	console_cfg.ntcc_concurrency_server = concurrency_server;
-	console_cfg.ntcc_concurrency_client = concurrency_client;
+	console_cfg->ntcc_cmd_send_timeout   = timeout_cmd;
+	console_cfg->ntcc_cmd_recv_timeout   = timeout_cmd;
+	console_cfg->ntcc_buf_send_timeout   = timeout_send;
+	console_cfg->ntcc_buf_recv_timeout   = timeout_recv;
+	console_cfg->ntcc_buf_bulk_timeout   = timeout_bulk;
+	console_cfg->ntcc_test_type	     = type;
+	console_cfg->ntcc_msg_nr	     = msg_nr;
+	console_cfg->ntcc_msg_size	     = msg_size;
+	console_cfg->ntcc_bd_buf_nr_server   = bd_buf_nr_server;
+	console_cfg->ntcc_bd_buf_nr_client   = bd_buf_nr_client;
+	console_cfg->ntcc_bd_buf_size	     = bd_buf_size;
+	console_cfg->ntcc_bd_nr_max	     = bd_nr_max;
+	console_cfg->ntcc_concurrency_server = concurrency_server;
+	console_cfg->ntcc_concurrency_client = concurrency_client;
 	/* initialize console */
-	rc = m0_net_test_console_init(&console, &console_cfg);
+	rc = m0_net_test_console_init(console, console_cfg);
 	M0_UT_ASSERT(rc == 0);
 	/* send INIT to the test servers */
-	rc = m0_net_test_console_cmd(&console, M0_NET_TEST_ROLE_SERVER,
+	rc = m0_net_test_console_cmd(console, M0_NET_TEST_ROLE_SERVER,
 				     M0_NET_TEST_CMD_INIT);
 	M0_UT_ASSERT(rc == servers_nr);
 	/* send INIT to the test clients */
-	rc = m0_net_test_console_cmd(&console, M0_NET_TEST_ROLE_CLIENT,
+	rc = m0_net_test_console_cmd(console, M0_NET_TEST_ROLE_CLIENT,
 				     M0_NET_TEST_CMD_INIT);
 	M0_UT_ASSERT(rc == clients_nr);
 	/* send START command to the test servers */
-	rc = m0_net_test_console_cmd(&console, M0_NET_TEST_ROLE_SERVER,
+	rc = m0_net_test_console_cmd(console, M0_NET_TEST_ROLE_SERVER,
 				     M0_NET_TEST_CMD_START);
 	M0_UT_ASSERT(rc == servers_nr);
 	/* send START command to the test clients */
-	rc = m0_net_test_console_cmd(&console, M0_NET_TEST_ROLE_CLIENT,
+	rc = m0_net_test_console_cmd(console, M0_NET_TEST_ROLE_CLIENT,
 				     M0_NET_TEST_CMD_START);
 	M0_UT_ASSERT(rc == clients_nr);
 	/* send STATUS command to the test clients until it finishes. */
 	do {
 		m0_nanosleep(_1s, NULL);
-		rc = m0_net_test_console_cmd(&console, M0_NET_TEST_ROLE_CLIENT,
+		rc = m0_net_test_console_cmd(console, M0_NET_TEST_ROLE_CLIENT,
 					     M0_NET_TEST_CMD_STATUS);
 		M0_UT_ASSERT(rc == clients_nr);
-	} while (!console.ntcc_clients.ntcrc_sd->ntcsd_finished);
+	} while (!console->ntcc_clients.ntcrc_sd->ntcsd_finished);
 	/* send STATUS command to the test clients */
-	rc = m0_net_test_console_cmd(&console, M0_NET_TEST_ROLE_CLIENT,
+	rc = m0_net_test_console_cmd(console, M0_NET_TEST_ROLE_CLIENT,
 				     M0_NET_TEST_CMD_STATUS);
 	M0_UT_ASSERT(rc == clients_nr);
 	/* send STATUS command to the test servers */
-	rc = m0_net_test_console_cmd(&console, M0_NET_TEST_ROLE_SERVER,
+	rc = m0_net_test_console_cmd(console, M0_NET_TEST_ROLE_SERVER,
 				     M0_NET_TEST_CMD_STATUS);
 	M0_UT_ASSERT(rc == servers_nr);
 	msg_nr_print("client msg sent",
-		     &console.ntcc_clients.ntcrc_sd->ntcsd_msg_nr_send);
+		     &console->ntcc_clients.ntcrc_sd->ntcsd_msg_nr_send);
 	msg_nr_print("client msg received",
-		     &console.ntcc_clients.ntcrc_sd->ntcsd_msg_nr_recv);
+		     &console->ntcc_clients.ntcrc_sd->ntcsd_msg_nr_recv);
 	msg_nr_print("client bulk sent",
-		     &console.ntcc_clients.ntcrc_sd->ntcsd_bulk_nr_send);
+		     &console->ntcc_clients.ntcrc_sd->ntcsd_bulk_nr_send);
 	msg_nr_print("client bulk received",
-		     &console.ntcc_clients.ntcrc_sd->ntcsd_bulk_nr_recv);
+		     &console->ntcc_clients.ntcrc_sd->ntcsd_bulk_nr_recv);
 	msg_nr_print("client transfers",
-		     &console.ntcc_clients.ntcrc_sd->ntcsd_transfers);
+		     &console->ntcc_clients.ntcrc_sd->ntcsd_transfers);
 	msg_nr_print("server msg sent",
-		     &console.ntcc_servers.ntcrc_sd->ntcsd_msg_nr_send);
+		     &console->ntcc_servers.ntcrc_sd->ntcsd_msg_nr_send);
 	msg_nr_print("server msg received",
-		     &console.ntcc_servers.ntcrc_sd->ntcsd_msg_nr_recv);
+		     &console->ntcc_servers.ntcrc_sd->ntcsd_msg_nr_recv);
 	msg_nr_print("server bulk sent",
-		     &console.ntcc_servers.ntcrc_sd->ntcsd_bulk_nr_send);
+		     &console->ntcc_servers.ntcrc_sd->ntcsd_bulk_nr_send);
 	msg_nr_print("server bulk received",
-		     &console.ntcc_servers.ntcrc_sd->ntcsd_bulk_nr_recv);
+		     &console->ntcc_servers.ntcrc_sd->ntcsd_bulk_nr_recv);
 	msg_nr_print("server transfers",
-		     &console.ntcc_servers.ntcrc_sd->ntcsd_transfers);
+		     &console->ntcc_servers.ntcrc_sd->ntcsd_transfers);
 	/* send STOP command to the test clients */
-	rc = m0_net_test_console_cmd(&console, M0_NET_TEST_ROLE_CLIENT,
+	rc = m0_net_test_console_cmd(console, M0_NET_TEST_ROLE_CLIENT,
 				     M0_NET_TEST_CMD_STOP);
 	M0_UT_ASSERT(rc == clients_nr);
 	/* send STOP command to the test servers */
-	rc = m0_net_test_console_cmd(&console, M0_NET_TEST_ROLE_SERVER,
+	rc = m0_net_test_console_cmd(console, M0_NET_TEST_ROLE_SERVER,
 				     M0_NET_TEST_CMD_STOP);
 	M0_UT_ASSERT(rc == servers_nr);
-	sd_servers = console.ntcc_servers.ntcrc_sd;
-	sd_clients = console.ntcc_clients.ntcrc_sd;
+	sd_servers = console->ntcc_servers.ntcrc_sd;
+	sd_clients = console->ntcc_clients.ntcrc_sd;
 	/* check stats */
 	if (type == M0_NET_TEST_TYPE_BULK) {
 		/*
@@ -327,11 +338,11 @@ static void net_test_client_server(const char *nid,
 	M0_ASSERT(sd_servers->ntcsd_bulk_nr_recv.ntmn_total ==
 		  sd_clients->ntcsd_bulk_nr_send.ntmn_total);
 	/* finalize console */
-	m0_net_test_slist_fini(&console_cfg.ntcc_servers);
-	m0_net_test_slist_fini(&console_cfg.ntcc_clients);
-	m0_net_test_slist_fini(&console_cfg.ntcc_data_servers);
-	m0_net_test_slist_fini(&console_cfg.ntcc_data_clients);
-	m0_net_test_console_fini(&console);
+	m0_net_test_slist_fini(&console_cfg->ntcc_servers);
+	m0_net_test_slist_fini(&console_cfg->ntcc_clients);
+	m0_net_test_slist_fini(&console_cfg->ntcc_data_servers);
+	m0_net_test_slist_fini(&console_cfg->ntcc_data_clients);
+	m0_net_test_console_fini(console);
 	/* finalize test clients and test servers */
 	for (i = 0; i < clients_nr + servers_nr; ++i) {
 		rc = m0_thread_join(&node_thread[i]);
@@ -341,17 +352,32 @@ static void net_test_client_server(const char *nid,
 	}
 	addr_free(addr_console4servers);
 	addr_free(addr_console4clients);
+done:
+	m0_free(console);
+	m0_free(console_cfg);
+}
+
+void m0_net_test_client_server_stub_ut(void)
+{
+	/* test console-node interaction with dummy node */
+	net_test_client_server("0@lo", M0_NET_TEST_TYPE_STUB,
+			       1, 1, 1, 1, 1, 1,
+			       0, 0, 0, 0);
 }
 
 void m0_net_test_client_server_ping_ut(void)
 {
+	/*
+	 * - 0@lo interface
+	 * - 8 test clients, 8 test servers
+	 * - 4k test messages x 4KiB per message
+	 * - 8 pairs of concurrent buffers on each test client
+	 * - 128 concurrent buffers on each test server
+	 */
 	net_test_client_server("0@lo", M0_NET_TEST_TYPE_PING,
 			       8, 8, 8, 128, 0x1000, 0x1000,
+			       /* 1, 1, 8, 128, 0x1000, 0x1000, */
 			       0, 0, 0, 0);
-	/*
-	net_test_client_server("0@lo", M0_NET_TEST_TYPE_PING,
-			       8, 8, 4, 16, 0x100, 0x100);
-	*/
 }
 
 void m0_net_test_client_server_bulk_ut(void)
@@ -360,10 +386,20 @@ void m0_net_test_client_server_bulk_ut(void)
 	 * @todo investigate strange m0_net_tm_stop() time
 	 * on the bulk test client.
 	 */
+	/*
+	 * - 0@lo interface
+	 * - 2 test clients, 2 test servers
+	 * - 64 test messages x 1MiB per message
+	 * - 2 pairs of concurrent buffers on each test client
+	 * - 8 concurrent buffers on each test server
+	 * - 8(16) network buffers for network buffer descriptors
+	 *   on the test client(server) with 4KiB per buffer and
+	 *   64k maximum buffer descriptors in buffer
+	 */
 	net_test_client_server("0@lo", M0_NET_TEST_TYPE_BULK,
-			       1, 1, 1, 2,
-			       0x1000, 0x1000,
-			       1, 2, 0x1000, 0x10000);
+			       2, 2, 2, 8,
+			       64, 0x100000,
+			       8, 16, 0x1000, 0x10000);
 }
 
 /*
diff --git a/net/test/ut/commands.c b/net/test/ut/commands.c
index f5cde4c..d6b3d5f 100644
--- a/net/test/ut/commands.c
+++ b/net/test/ut/commands.c
@@ -29,15 +29,17 @@
 
 /* NTC_ == NET_TEST_COMMANDS_ */
 enum {
-	NTC_PORTAL	      = 42,
-	NTC_TMID_CONSOLE      = 3000,
-	NTC_TMID_NODE	      = 3001,
-	NTC_MULTIPLE_COMMANDS = 64,
+	NTC_TMID_START	      = 3000,
+	NTC_TMID_CONSOLE      = NTC_TMID_START,
+	NTC_TMID_NODE	      = NTC_TMID_CONSOLE + 1,
+	NTC_MULTIPLE_NODES    = 64,
+	NTC_MULTIPLE_COMMANDS = 32,
 	NTC_ADDR_LEN_MAX      = 0x100,
 	NTC_TIMEOUT_MS	      = 1000,
+	NTC_CMD_RECV_WAIT_NS  = 25000000,
 };
 
-static const char   NTC_ADDR[]	   = "0@lo:12345:%d:%d";
+static const char   NTC_ADDR[]	   = "0@lo:12345:42:%d";
 static const size_t NTC_ADDR_LEN   = ARRAY_SIZE(NTC_ADDR);
 static const char   NTC_DELIM      = ',';
 
@@ -55,15 +57,18 @@ struct net_test_cmd_node {
 	bool			   ntcn_barriers_disabled;
 	/** used when checking send/recv */
 	bool			   ntcn_flag;
+	/** transfer machine address */
+	char			  *ntcn_addr;
 };
 
 static char addr_console[NTC_ADDR_LEN_MAX];
-static char addr_node[NTC_ADDR_LEN_MAX * NTC_MULTIPLE_COMMANDS];
+static char addr_node[NTC_ADDR_LEN_MAX * NTC_MULTIPLE_NODES];
 
 static struct m0_net_test_slist   slist_node;
 static struct m0_net_test_slist   slist_console;
 static struct net_test_cmd_node	 *node;
 static struct m0_net_test_cmd_ctx console;
+static struct net_test_cmd_node	  nodes[NTC_MULTIPLE_NODES];
 
 static m0_time_t timeout_get(void)
 {
@@ -78,10 +83,9 @@ static m0_time_t timeout_get_abs(void)
 	return m0_time_add(m0_time_now(), timeout_get());
 }
 
-static int make_addr(char *s, size_t s_len, int port, int svc_id,
-		     bool add_comma)
+static int make_addr(char *s, size_t s_len, int svc_id, bool add_comma)
 {
-	int rc = snprintf(s, s_len, NTC_ADDR, port, svc_id);
+	int rc = snprintf(s, s_len, NTC_ADDR, svc_id);
 
 	M0_ASSERT(NTC_ADDR_LEN <= NTC_ADDR_LEN_MAX);
 	M0_ASSERT(rc > 0);
@@ -101,11 +105,10 @@ static void fill_addr(uint32_t nr)
 	int	 diff;
 
 	/* console */
-	make_addr(addr_console, NTC_ADDR_LEN_MAX, NTC_PORTAL,
-		  NTC_TMID_CONSOLE, false);
+	make_addr(addr_console, NTC_ADDR_LEN_MAX, NTC_TMID_CONSOLE, false);
 	/* nodes */
 	for (i = 0; i < nr; ++i) {
-		diff = make_addr(pos, NTC_ADDR_LEN_MAX, NTC_PORTAL,
+		diff = make_addr(pos, NTC_ADDR_LEN_MAX,
 				 NTC_TMID_NODE + i, i != nr - 1);
 		M0_ASSERT(diff < NTC_ADDR_LEN_MAX);
 		pos += diff;
@@ -248,6 +251,8 @@ static void commands_ut_recv(struct net_test_cmd_node *node,
 	M0_SET0(&cmd);
 	rc = m0_net_test_commands_recv(ctx, &cmd, deadline);
 	commands_ut_assert(node, rc == 0);
+	if (rc != 0)
+		return;
 	if (ep_index == NULL) {
 		rc = m0_net_test_commands_recv_enqueue(ctx, cmd.ntc_buf_index);
 		commands_ut_assert(node, rc == 0);
@@ -343,6 +348,7 @@ static void commands_node_thread(struct net_test_cmd_node *node)
 	}
 	commands_ut_send(node, ctx);			/* test #5 */
 	commands_ut_send(node, ctx);
+	commands_ut_send(node, ctx);
 	barrier_with_main(node);	/* barrier #5.0 */
 	/* main thread will start receiving here */
 	barrier_with_main(node);	/* barrier #5.1 */
@@ -514,16 +520,17 @@ static void net_test_command_ut(size_t nr)
 	flags_reset(nr);
 	commands_ut_send_all(nr);
 	barrier_with_nodes();				/* barrier #4.1 */
-	M0_UT_ASSERT(is_flags_set_odd(nr));
 	barrier_with_nodes();				/* barrier #4.2 */
+	M0_UT_ASSERT(is_flags_set_odd(nr));
 	barrier_with_nodes();				/* barrier #4.3 */
 	/*
-	   Test #5: every node sends two commands, and only after that console
+	   Test #5: every node sends three commands, and only after that console
 	   starts to receive.
 	 */
 	/* nodes will send two commands here */
 	barrier_with_nodes();				/* barrier #5.0 */
 	commands_ut_recv_all(nr, M0_TIME_NEVER);
+	commands_ut_recv_all(nr, M0_TIME_NEVER);
 	flags_reset(nr);
 	commands_ut_recv_all(nr, timeout_get_abs());
 	M0_UT_ASSERT(is_flags_set(nr, false));
@@ -574,7 +581,166 @@ void m0_net_test_cmd_ut_single(void)
 
 void m0_net_test_cmd_ut_multiple(void)
 {
-	net_test_command_ut(NTC_MULTIPLE_COMMANDS);
+	net_test_command_ut(NTC_MULTIPLE_NODES);
+}
+
+static void commands_node_loop(struct net_test_cmd_node *node,
+			       struct m0_net_test_cmd *cmd)
+{
+	m0_time_t deadline;
+	int	  cmd_rcvd = 0;
+	int	  rc;
+
+	/*
+	 * Receive command from console and send it back.
+	 * Repeat NTC_MULTIPLE_COMMANDS times.
+	 */
+	while (cmd_rcvd != NTC_MULTIPLE_COMMANDS) {
+		deadline = m0_time_from_now(0, NTC_CMD_RECV_WAIT_NS);
+		rc = m0_net_test_commands_recv(&node->ntcn_ctx, cmd, deadline);
+		if (rc == -ETIMEDOUT)
+			continue;
+		M0_UT_ASSERT(rc == 0);
+		M0_UT_ASSERT(cmd->ntc_ep_index == 0);
+		rc = m0_net_test_commands_recv_enqueue(&node->ntcn_ctx,
+						       cmd->ntc_buf_index);
+		M0_UT_ASSERT(rc == 0);
+		m0_net_test_commands_send_wait_all(&node->ntcn_ctx);
+		rc = m0_net_test_commands_send(&node->ntcn_ctx, cmd);
+		M0_UT_ASSERT(rc == 0);
+		m0_net_test_commands_received_free(cmd);
+		++cmd_rcvd;
+	}
+}
+
+static void commands_console_loop(struct net_test_cmd_node *node,
+				  struct m0_net_test_cmd *cmd)
+{
+	m0_time_t deadline;
+	int	  cmd_sent = 0;
+	int	  cmd_rcvd;
+	int	  i;
+	int	  rc;
+
+	/*
+	 * Send command to every node and receive reply.
+	 * Repeat NTC_MULTIPLE_COMMANDS times.
+	 */
+	while (cmd_sent != NTC_MULTIPLE_COMMANDS) {
+		m0_net_test_commands_send_wait_all(&node->ntcn_ctx);
+		for (i = 1; i < ARRAY_SIZE(nodes); ++i) {
+			cmd->ntc_ep_index = i - 1;
+			cmd->ntc_type = M0_NET_TEST_CMD_INIT_DONE;
+			rc = m0_net_test_commands_send(&node->ntcn_ctx, cmd);
+			M0_UT_ASSERT(rc == 0);
+		}
+		m0_net_test_commands_send_wait_all(&node->ntcn_ctx);
+		cmd_rcvd = 0;
+		deadline = timeout_get_abs();
+		while (cmd_rcvd != ARRAY_SIZE(nodes) - 1
+		       && m0_time_now() <= deadline) {
+			rc = m0_net_test_commands_recv(&node->ntcn_ctx, cmd,
+						       deadline);
+			M0_UT_ASSERT(rc == 0);
+			rc = m0_net_test_commands_recv_enqueue(&node->ntcn_ctx,
+							cmd->ntc_buf_index);
+			M0_UT_ASSERT(rc == 0);
+			++cmd_rcvd;
+			m0_net_test_commands_received_free(cmd);
+		}
+		M0_UT_ASSERT(cmd_rcvd == ARRAY_SIZE(nodes) - 1);
+		++cmd_sent;
+	}
+}
+
+static void commands_node_thread2(struct net_test_cmd_node *node)
+{
+	struct m0_net_test_cmd	 *cmd;
+	struct m0_net_test_slist  endpoints;
+	static char		  buf[NTC_MULTIPLE_NODES * NTC_ADDR_LEN_MAX];
+	int			  rc;
+	bool			  console_thread = node == &nodes[0];
+	int			  i;
+
+	M0_ALLOC_PTR(cmd);
+	M0_UT_ASSERT(cmd != NULL);
+
+	if (console_thread) {
+		buf[0] = '\0';
+		for (i = 1; i < ARRAY_SIZE(nodes); ++i) {
+			strncat(buf, nodes[i].ntcn_addr, ARRAY_SIZE(buf));
+			if (i != ARRAY_SIZE(nodes) - 1)
+				strncat(buf, ",", ARRAY_SIZE(buf));
+		}
+		buf[ARRAY_SIZE(buf) - 1] = '\0';
+		rc = m0_net_test_slist_init(&endpoints, buf, ',');
+		M0_UT_ASSERT(rc == 0);
+	} else {
+		rc = m0_net_test_slist_init(&endpoints,
+					    nodes[0].ntcn_addr, '`');
+		M0_UT_ASSERT(rc == 0);
+	}
+	rc = m0_net_test_commands_init(&node->ntcn_ctx, node->ntcn_addr,
+				       timeout_get(), NULL, &endpoints);
+	M0_UT_ASSERT(rc == 0);
+
+	barrier_with_main(node);
+
+	if (console_thread) {
+		commands_console_loop(node, cmd);
+	} else {
+		commands_node_loop(node, cmd);
+	}
+
+	m0_net_test_commands_fini(&node->ntcn_ctx);
+	m0_net_test_slist_fini(&endpoints);
+	m0_free(cmd);
+}
+
+/* main thread */
+void m0_net_test_cmd_ut_multiple2(void)
+{
+	struct net_test_cmd_node *node;
+	size_t			  i;
+	int			  rc;
+
+	/* console is node #0 */
+	for (i = 0; i < ARRAY_SIZE(nodes); ++i) {
+		node = &nodes[i];
+		barrier_init(node);
+		node->ntcn_addr = m0_alloc(NTC_ADDR_LEN_MAX);
+		M0_UT_ASSERT(node->ntcn_addr != NULL);
+		make_addr(node->ntcn_addr, NTC_ADDR_LEN_MAX,
+			  NTC_TMID_START + i, false);
+	}
+	/* start threads */
+	for (i = 0; i < ARRAY_SIZE(nodes); ++i) {
+		node = &nodes[i];
+		rc = M0_THREAD_INIT(&node->ntcn_thread,
+				    struct net_test_cmd_node *, NULL,
+				    &commands_node_thread2,
+				    node, "#%dcmd_ut__%s", (int) i,
+				    i == 0 ? "console" : "node");
+		M0_UT_ASSERT(rc == 0);
+	}
+	/* barrier with node threads */
+	for (i = 0; i < ARRAY_SIZE(nodes); ++i)
+		m0_semaphore_down(&nodes[i].ntcn_signal);
+	for (i = 0; i < ARRAY_SIZE(nodes); ++i)
+		m0_semaphore_up(&nodes[i].ntcn_wait);
+	/* stop threads */
+	for (i = 0; i < ARRAY_SIZE(nodes); ++i) {
+		node = &nodes[i];
+		rc = m0_thread_join(&node->ntcn_thread);
+		M0_UT_ASSERT(rc == 0);
+		m0_thread_fini(&node->ntcn_thread);
+	}
+	/* fini nodes */
+	for (i = 0; i < ARRAY_SIZE(nodes); ++i) {
+		node = &nodes[i];
+		m0_free(node->ntcn_addr);
+		barrier_fini(node);
+	}
 }
 
 /*
diff --git a/net/test/ut/main.c b/net/test/ut/main.c
index 15fc6ba..45e5fea 100644
--- a/net/test/ut/main.c
+++ b/net/test/ut/main.c
@@ -41,7 +41,13 @@ extern void m0_net_test_network_ut_bulk(void);
 
 extern void m0_net_test_cmd_ut_single(void);
 extern void m0_net_test_cmd_ut_multiple(void);
+extern void m0_net_test_cmd_ut_multiple2(void);
 
+extern void m0_net_test_bug_ut(void);
+extern void m0_net_test_bug2_ut(void);
+extern void m0_net_test_bug3_ut(void);
+extern void m0_net_test_debug_ut(void);
+extern void m0_net_test_client_server_stub_ut(void);
 extern void m0_net_test_client_server_ping_ut(void);
 extern void m0_net_test_client_server_bulk_ut(void);
 
@@ -67,11 +73,17 @@ const struct m0_test_suite m0_net_test_ut = {
 		{ "network-ping",	m0_net_test_network_ut_ping	  },
 		{ "network-bulk",	m0_net_test_network_ut_bulk	  },
 		{ "cmd-single",		m0_net_test_cmd_ut_single	  },
-#ifndef __KERNEL__
 		{ "cmd-multiple",	m0_net_test_cmd_ut_multiple	  },
+		{ "cmd-multiple2",	m0_net_test_cmd_ut_multiple2	  },
+		{ "debug",		m0_net_test_debug_ut		  },
+#if 0
+		{ "bug3",		m0_net_test_bug3_ut		  },
+		{ "bug2",		m0_net_test_bug2_ut		  },
+		{ "bug",		m0_net_test_bug_ut		  },
+#endif
+		{ "client-server-stub",	m0_net_test_client_server_stub_ut },
 		{ "client-server-ping",	m0_net_test_client_server_ping_ut },
 		{ "client-server-bulk",	m0_net_test_client_server_bulk_ut },
-#endif
 		{ NULL,			NULL				  }
 	}
 };
diff --git a/net/test/ut/network.c b/net/test/ut/network.c
index ddb9ef1..72761be 100644
--- a/net/test/ut/network.c
+++ b/net/test/ut/network.c
@@ -18,11 +18,6 @@
  * Original creation date: 05/19/2012
  */
 
-/** @todo remove */
-#ifndef __KERNEL__
-#include <stdio.h>		/* printf */
-#endif
-
 #include "lib/ut.h"		/* M0_UT_ASSERT */
 #include "lib/semaphore.h"	/* m0_semaphore */
 #include "lib/memory.h"		/* m0_alloc */
@@ -30,13 +25,45 @@
 
 #include "net/test/network.h"
 
-/** @todo debug only, remove it */
-#ifndef __KERNEL__
-#define LOGD(format, ...) printf(format, ##__VA_ARGS__)
-#else
-#define LOGD(format, ...) do {} while (0)
+/* START COPY-PASTE FROM client_server.c */
+#ifdef __KERNEL__
+#include <linux/kgdb.h>
+#endif
+
+#include "lib/ut.h"			/* M0_UT_ASSERT */
+#include "lib/memory.h"			/* m0_free */
+#include "lib/thread.h"			/* M0_THREAD_INIT */
+#include "lib/semaphore.h"		/* m0_semaphore_down */
+#include "lib/misc.h"			/* M0_SET0 */
+
+#include "net/lnet/lnet.h"		/* M0_NET_LNET_PID */
+
+#include "net/test/node.h"		/* m0_net_test_node_ctx */
+#include "net/test/console.h"		/* m0_net_test_console_ctx */
+
+#ifdef __KERNEL__
+#include <linux/kgdb.h>
+#include <linux/completion.h>
 #endif
 
+#include "lib/ut.h"			/* M0_UT_ASSERT */
+#include "lib/memory.h"			/* m0_free */
+#include "lib/thread.h"			/* M0_THREAD_INIT */
+#include "lib/semaphore.h"		/* m0_semaphore_down */
+#include "lib/misc.h"			/* M0_SET0 */
+
+#include "net/lnet/lnet.h"		/* M0_NET_LNET_PID */
+
+#include "net/test/commands.h"		/* m0_net_test_commands */
+#include "net/test/node_ping.h"		/* m0_net_test_node_ping_ops */
+/* END COPY-PASTE FROM client_server.c */
+
+#ifdef NET_TEST_MODULE_NAME
+#undef NET_TEST_MODULE_NAME
+#endif
+#define NET_TEST_MODULE_NAME ut_network
+#include "net/test/debug.h"		/* LOGD */
+
 enum {
 	NET_TEST_PING_BUF_SIZE = 4096,
 	NET_TEST_PING_BUF_STEP = 511,	/** @see m0_net_test_network_ut_ping */
@@ -496,6 +523,1113 @@ void m0_net_test_network_ut_buf_desc(void)
 	m0_net_test_network_ctx_fini(&ctx);
 }
 
+/* START COPY-PASTE FROM client_server.c */
+/*
+ ***********************************************************************
+ ***********************************************************************
+ ***********************************************************************
+ ***********************************************************************
+ */
+
+static void kgdb_break(void)
+{
+#ifdef __KERNEL__
+	// kgdb_breakpoint();
+#endif
+}
+
+#if 0
+#ifdef __KERNEL__
+static DECLARE_COMPLETION(client_completion);
+static DECLARE_COMPLETION(server_completion);
+#else
+static struct m0_semaphore client_completion;
+static struct m0_semaphore server_completion;
+#endif
+
+#ifdef __KERNEL__
+static void net_test_wait_for_completion(struct completion *completion)
+#else
+static void net_test_wait_for_completion(struct m0_semaphore *completion)
+#endif
+{
+#ifdef __KERNEL__
+	wait_for_completion(completion);
+#else
+	m0_semaphore_down(completion);
+#endif
+}
+
+#ifdef __KERNEL__
+static void net_test_complete(struct completion *completion)
+#else
+static void net_test_complete(struct m0_semaphore *completion)
+#endif
+{
+#ifdef __KERNEL__
+	complete(completion);
+#else
+	m0_semaphore_up(completion);
+#endif
+}
+#endif
+
+enum {
+	NTCS_PID		  = M0_NET_LNET_PID,
+	NTCS_PORTAL		  = 42,
+	NTCS_NODES_MAX		  = 128,
+	NTCS_NODE_ADDR_MAX	  = 0x100,
+	/** @todo 20min for debugging in gdb */
+	NTCS_TIMEOUT_CMD_MS	  = 1200000,
+	NTCS_TIMEOUT_SEND_MS	  = 1200000,
+	NTCS_TIMEOUT_RECV_MS	  = 1200000,
+	NTCS_TIMEOUT_BULK_MS	  = 1200000,
+	/*
+	NTCS_TIMEOUT_CMD_MS	  = 20000,
+	NTCS_TIMEOUT_SEND_MS	  = 20000,
+	NTCS_TIMEOUT_RECV_MS	  = 20000,
+	NTCS_TIMEOUT_BULK_MS	  = 20000,
+	*/
+	NTCS_TMID_CONSOLE4CLIENTS = 2998,
+	NTCS_TMID_CONSOLE4SERVERS = 2999,
+	NTCS_TMID_NODES		  = 3000,
+	NTCS_TMID_CMD_CLIENTS	  = NTCS_TMID_NODES,
+	NTCS_TMID_DATA_CLIENTS    = NTCS_TMID_NODES + NTCS_NODES_MAX * 1,
+	NTCS_TMID_CMD_SERVERS	  = NTCS_TMID_NODES + NTCS_NODES_MAX * 2,
+	NTCS_TMID_DATA_SERVERS    = NTCS_TMID_NODES + NTCS_NODES_MAX * 3,
+};
+
+static struct m0_net_test_node_cfg node_cfg[NTCS_NODES_MAX * 2];
+static struct m0_thread		   node_thread[NTCS_NODES_MAX * 2];
+static struct m0_semaphore	   node_init_sem;
+
+static char *addr_console4clients;
+static char *addr_console4servers;
+static char  clients[(NTCS_NODES_MAX + 1) * NTCS_NODE_ADDR_MAX];
+static char  servers[(NTCS_NODES_MAX + 1) * NTCS_NODE_ADDR_MAX];
+static char  clients_data[(NTCS_NODES_MAX + 1) * NTCS_NODE_ADDR_MAX];
+static char  servers_data[(NTCS_NODES_MAX + 1) * NTCS_NODE_ADDR_MAX];
+
+static m0_time_t timeout_cmd;
+static m0_time_t timeout_send;
+static m0_time_t timeout_recv;
+static m0_time_t timeout_bulk;
+
+static char *addr_get(const char *nid, int tmid)
+{
+	char  addr[NTCS_NODE_ADDR_MAX];
+	char *result;
+	int   rc;
+
+	rc = snprintf(addr, NTCS_NODE_ADDR_MAX,
+		     "%s:%d:%d:%d", nid, NTCS_PID, NTCS_PORTAL, tmid);
+	M0_UT_ASSERT(rc < NTCS_NODE_ADDR_MAX);
+
+	result = m0_alloc(rc + 1);
+	M0_UT_ASSERT(result != NULL);
+	return strncpy(result, addr, rc + 1);
+}
+
+static void addr_free(char *addr)
+{
+	m0_free(addr);
+}
+
+static m0_time_t ms2time(int ms)
+{
+	m0_time_t time;
+
+	return m0_time_set(&time,NTCS_TIMEOUT_SEND_MS / 1000,
+			   (NTCS_TIMEOUT_SEND_MS % 1000) * 1000000);
+}
+
+static void node_cfg_fill(struct m0_net_test_node_cfg *ncfg,
+			  char *addr_cmd,
+			  char *addr_cmd_list,
+			  char *addr_data,
+			  char *addr_data_list,
+			  char *addr_console,
+			  bool last_node)
+{
+	ncfg->ntnc_addr		= addr_cmd;
+	ncfg->ntnc_addr_console = addr_console;
+	ncfg->ntnc_send_timeout = timeout_cmd;
+
+	strncat(addr_cmd_list, ncfg->ntnc_addr, NTCS_NODE_ADDR_MAX);
+	strncat(addr_cmd_list, last_node ? "" : ",", 2);
+	strncat(addr_data_list, addr_data, NTCS_NODE_ADDR_MAX);
+	strncat(addr_data_list, last_node ? "" : ",", 2);
+
+	addr_free(addr_data);
+}
+
+#if 0
+static void net_test_node2(struct m0_net_test_node_cfg *node_cfg)
+{
+	struct m0_net_test_node_ctx *ctx;
+	int			     rc;
+
+	M0_PRE(node_cfg != NULL);
+
+	M0_ALLOC_PTR(ctx);
+	M0_ASSERT(ctx != NULL);
+	rc = m0_net_test_node_init(ctx, node_cfg);
+	M0_UT_ASSERT(rc == 0);
+	rc = m0_net_test_node_start(ctx);
+	M0_UT_ASSERT(rc == 0);
+	m0_semaphore_up(&node_init_sem);
+	/* wait for the test node thread */
+	m0_semaphore_down(&ctx->ntnc_thread_finished_sem);
+	m0_net_test_node_stop(ctx);
+	m0_net_test_node_fini(ctx);
+	m0_free(ctx);
+}
+#endif
+
+static void net_test_node3(struct m0_net_test_node_cfg *node_cfg)
+{
+	struct m0_net_test_cmd_ctx *cmd_ctx;
+	struct m0_net_test_cmd	   *cmd;
+	struct m0_net_test_slist    console;
+	int			    rc;
+
+	M0_ALLOC_PTR(cmd_ctx);
+	M0_ALLOC_PTR(cmd);
+	if (cmd == NULL || cmd_ctx == NULL)
+		goto done;
+	rc = m0_net_test_slist_init(&console, node_cfg->ntnc_addr_console, '`');
+	M0_UT_ASSERT(rc == 0);
+	rc = m0_net_test_commands_init(cmd_ctx, node_cfg->ntnc_addr,
+				       node_cfg->ntnc_send_timeout,
+				       NULL, &console);
+	M0_UT_ASSERT(rc == 0);
+
+	m0_semaphore_up(&node_init_sem);
+	while (cmd->ntc_type != M0_NET_TEST_CMD_STOP_DONE) {
+		rc = m0_net_test_commands_recv(cmd_ctx, cmd,
+					       m0_time_from_now(0, 25000000));
+		if (rc == -ETIMEDOUT)
+			continue;
+		M0_UT_ASSERT(rc == 0);
+		M0_UT_ASSERT(cmd->ntc_ep_index == 0);
+		rc = m0_net_test_commands_recv_enqueue(cmd_ctx,
+						       cmd->ntc_buf_index);
+		M0_UT_ASSERT(rc == 0);
+		m0_net_test_commands_received_free(cmd);
+
+		if (cmd->ntc_type == M0_NET_TEST_CMD_INIT)
+			cmd->ntc_type = M0_NET_TEST_CMD_INIT_DONE;
+		else if (cmd->ntc_type == M0_NET_TEST_CMD_STOP)
+			 cmd->ntc_type = M0_NET_TEST_CMD_STOP_DONE;
+		else {
+			M0_IMPOSSIBLE("invalid cmd type");
+		}
+		cmd->ntc_done.ntcd_errno = 0;
+		m0_net_test_commands_send_wait_all(cmd_ctx);
+		rc = m0_net_test_commands_send(cmd_ctx, cmd);
+		M0_UT_ASSERT(rc == 0);
+	}
+	m0_net_test_commands_fini(cmd_ctx);
+	m0_net_test_slist_fini(&console);
+done:
+	m0_free(cmd);
+	m0_free(cmd_ctx);
+}
+
+static void console_cmd_init_fill(struct m0_net_test_console_cfg *cfg,
+				  enum m0_net_test_role role,
+				  struct m0_net_test_cmd_init *cinit)
+{
+	cinit->ntci_role	     = role;
+	cinit->ntci_type	     = cfg->ntcc_test_type;
+	cinit->ntci_msg_nr	     = cfg->ntcc_msg_nr;
+	cinit->ntci_msg_size	     = cfg->ntcc_msg_size;
+	cinit->ntci_bd_buf_nr	     = role == M0_NET_TEST_ROLE_CLIENT ?
+				       cfg->ntcc_bd_buf_nr_client :
+				       cfg->ntcc_bd_buf_nr_server;
+	cinit->ntci_bd_buf_size	     = cfg->ntcc_bd_buf_size;
+	cinit->ntci_bd_nr_max	     = cfg->ntcc_bd_nr_max;
+	cinit->ntci_msg_concurrency  = role == M0_NET_TEST_ROLE_CLIENT ?
+				       cfg->ntcc_concurrency_client :
+				       cfg->ntcc_concurrency_server;
+	/** @todo other timeouts */
+	cinit->ntci_buf_send_timeout = cfg->ntcc_buf_send_timeout;
+	cinit->ntci_buf_bulk_timeout = cfg->ntcc_buf_bulk_timeout;
+	cinit->ntci_ep		     = role == M0_NET_TEST_ROLE_CLIENT ?
+				       cfg->ntcc_data_servers :
+				       cfg->ntcc_data_clients;
+}
+
+static void status_data_reset(struct m0_net_test_cmd_status_data *sd)
+{
+	/* Statistics reset order is not important here */
+	struct m0_net_test_msg_nr * const msg_nr[] = {
+		&sd->ntcsd_msg_nr_send,
+		&sd->ntcsd_msg_nr_recv,
+		&sd->ntcsd_bulk_nr_send,
+		&sd->ntcsd_bulk_nr_recv,
+		&sd->ntcsd_transfers,
+	};
+	struct m0_net_test_stats * const stats[] = {
+		&sd->ntcsd_mps_send.ntmps_stats,
+		&sd->ntcsd_mps_recv.ntmps_stats,
+		&sd->ntcsd_rtt,
+	};
+	size_t i;
+
+	M0_SET0(sd);
+	for (i = 0; i < ARRAY_SIZE(msg_nr); ++i)
+		m0_net_test_msg_nr_reset(msg_nr[i]);
+	for (i = 0; i < ARRAY_SIZE(stats); ++i)
+		m0_net_test_stats_reset(stats[i]);
+	sd->ntcsd_finished    = true;
+	sd->ntcsd_time_start  = M0_TIME_NEVER;
+	sd->ntcsd_time_finish = M0_MKTIME(0, 0);
+}
+
+static void status_data_add(struct m0_net_test_cmd_status_data *all_sd,
+			    const struct m0_net_test_cmd_status_data *cmd_sd)
+{
+	/* Parts of statistics are independent here, so order isn't important */
+	const struct {
+		struct m0_net_test_msg_nr	*nr_all;
+		const struct m0_net_test_msg_nr *nr_node;
+	} msg_nr[] = {
+		{	.nr_all  = &all_sd->ntcsd_msg_nr_send,
+			.nr_node = &cmd_sd->ntcsd_msg_nr_send	},
+		{	.nr_all  = &all_sd->ntcsd_msg_nr_recv,
+			.nr_node = &cmd_sd->ntcsd_msg_nr_recv	},
+		{	.nr_all  = &all_sd->ntcsd_bulk_nr_send,
+			.nr_node = &cmd_sd->ntcsd_bulk_nr_send	},
+		{	.nr_all  = &all_sd->ntcsd_bulk_nr_recv,
+			.nr_node = &cmd_sd->ntcsd_bulk_nr_recv	},
+		{	.nr_all  = &all_sd->ntcsd_transfers,
+			.nr_node = &cmd_sd->ntcsd_transfers	},
+	};
+	const struct {
+		struct m0_net_test_stats       *s_all;
+		const struct m0_net_test_stats *s_node;
+	} stats[] = {
+		{	.s_all  = &all_sd->ntcsd_mps_send.ntmps_stats,
+			.s_node = &cmd_sd->ntcsd_mps_send.ntmps_stats	},
+		{	.s_all  = &all_sd->ntcsd_mps_recv.ntmps_stats,
+			.s_node = &cmd_sd->ntcsd_mps_recv.ntmps_stats	},
+		{	.s_all  = &all_sd->ntcsd_rtt,
+			.s_node = &cmd_sd->ntcsd_rtt,			},
+	};
+	size_t i;
+
+	LOGD("new STATUS_DATA:");
+	LOGD("send total = %lu", cmd_sd->ntcsd_msg_nr_send.ntmn_total);
+	LOGD("recv total = %lu", cmd_sd->ntcsd_msg_nr_recv.ntmn_total);
+	LOGD("finished = %d", cmd_sd->ntcsd_finished);
+	LOGD("end of STATUS_DATA");
+	for (i = 0; i < ARRAY_SIZE(msg_nr); ++i)
+		m0_net_test_msg_nr_add(msg_nr[i].nr_all, msg_nr[i].nr_node);
+	for (i = 0; i < ARRAY_SIZE(stats); ++i)
+		m0_net_test_stats_add_stats(stats[i].s_all, stats[i].s_node);
+	all_sd->ntcsd_finished &= cmd_sd->ntcsd_finished;
+	if (cmd_sd->ntcsd_finished) {
+		all_sd->ntcsd_time_start = min_check(all_sd->ntcsd_time_start,
+						     cmd_sd->ntcsd_time_start);
+		all_sd->ntcsd_time_finish =
+			max_check(all_sd->ntcsd_time_finish,
+				  cmd_sd->ntcsd_time_finish);
+	}
+}
+
+static size_t net_test_console_cmd(struct m0_net_test_console_ctx *ctx,
+				   enum m0_net_test_role role,
+				   enum m0_net_test_cmd_type cmd_type)
+{
+	struct m0_net_test_console_role_ctx *rctx;
+	struct m0_net_test_console_cfg	    *cfg;
+	struct m0_net_test_cmd_ctx	    *cmd_ctx;
+	struct m0_net_test_cmd		    *cmd;
+	struct m0_net_test_cmd_status_data  *sd = NULL;
+	int				     i;
+	int				     j;
+	int				     rc;
+	struct m0_net_test_slist	    *nodes;
+	struct m0_net_test_slist	    *nodes_data;
+	bool				     role_client;
+	m0_time_t			     deadline;
+	size_t				     success_nr = 0;
+	size_t				     failures_nr = 0;
+	size_t				     rcvd_nr = 0;
+	enum m0_net_test_cmd_type	     answer[] = {
+		[M0_NET_TEST_CMD_INIT]	 = M0_NET_TEST_CMD_INIT_DONE,
+		[M0_NET_TEST_CMD_START]	 = M0_NET_TEST_CMD_START_DONE,
+		[M0_NET_TEST_CMD_STOP]	 = M0_NET_TEST_CMD_STOP_DONE,
+		[M0_NET_TEST_CMD_STATUS] = M0_NET_TEST_CMD_STATUS_DATA,
+	};
+
+	M0_PRE(ctx != NULL);
+	M0_PRE(role == M0_NET_TEST_ROLE_SERVER ||
+	       role == M0_NET_TEST_ROLE_CLIENT);
+	M0_PRE(cmd_type == M0_NET_TEST_CMD_INIT ||
+	       cmd_type == M0_NET_TEST_CMD_START ||
+	       cmd_type == M0_NET_TEST_CMD_STOP ||
+	       cmd_type == M0_NET_TEST_CMD_STATUS);
+
+	M0_ALLOC_PTR(cmd);
+	if (cmd == NULL)
+		goto done;
+	cfg = ctx->ntcc_cfg;
+
+	if (cmd_type == M0_NET_TEST_CMD_INIT)
+		console_cmd_init_fill(cfg, role, &cmd->ntc_init);
+
+	role_client   = role == M0_NET_TEST_ROLE_CLIENT;
+	cmd->ntc_type = cmd_type;
+	nodes	      = role_client ? &cfg->ntcc_clients : &cfg->ntcc_servers;
+	nodes_data    = role_client ? &cfg->ntcc_data_clients :
+				      &cfg->ntcc_data_servers;
+	rctx	      = role_client ? &ctx->ntcc_clients : &ctx->ntcc_servers;
+	cmd_ctx	      = rctx->ntcrc_cmd;
+
+	/* clear commands receive queue */
+	while ((rc = m0_net_test_commands_recv(cmd_ctx, cmd, m0_time_now())) !=
+	       -ETIMEDOUT) {
+		/*
+		 * Exit from this loop after nodes->ntsl_nr failures.
+		 * It will prevent from infinite loop if after every
+		 * m0_net_test_commands_recv_enqueue() will be
+		 * unsuccessful m0_net_test_commands_recv().
+		 */
+		failures_nr += rc != 0;
+		if (failures_nr > nodes->ntsl_nr)
+			break;
+		rc = m0_net_test_commands_recv_enqueue(cmd_ctx,
+						       cmd->ntc_buf_index);
+		/** @todo rc != 0 is lost here */
+		m0_net_test_commands_received_free(cmd);
+	}
+	LOGD("send all commands");
+	/* send all commands */
+	for (i = 0; i < nodes->ntsl_nr; ++i) {
+		if (cmd_type == M0_NET_TEST_CMD_INIT)
+			cmd->ntc_init.ntci_tm_ep = nodes_data->ntsl_list[i];
+		cmd->ntc_ep_index     = i;
+		rctx->ntcrc_errno[i] = m0_net_test_commands_send(cmd_ctx, cmd);
+	}
+	LOGD("m0_net_test_commands_send_wait_all(cmd_ctx);");
+	m0_net_test_commands_send_wait_all(cmd_ctx);
+	LOGD("done.");
+
+	/* receive answers */
+	if (answer[cmd_type] == M0_NET_TEST_CMD_STATUS_DATA) {
+		sd = rctx->ntcrc_sd;
+		status_data_reset(sd);
+	}
+	deadline = m0_time_add(m0_time_now(), cfg->ntcc_cmd_recv_timeout);
+	while (m0_time_now() <= deadline && rcvd_nr < nodes->ntsl_nr) {
+		LOGD("rc = m0_net_test_commands_recv(cmd_ctx, cmd, "
+		     "deadline = %lu); now = %lu",
+		     (long unsigned int) deadline,
+		     (long unsigned int) m0_time_now());
+		rc = m0_net_test_commands_recv(cmd_ctx, cmd, deadline);
+		LOGD("done. rc = %d", rc);
+		/* deadline reached */
+		if (rc == -ETIMEDOUT)
+			break;
+		/** @todo possible spinlock if all recv fails instantly? */
+		if (rc != 0)
+			continue;
+		rcvd_nr++;
+		LOGD("reject unknown sender");
+		/* reject unknown sender */
+		j = cmd->ntc_ep_index;
+		if (j < 0)
+			goto reuse_cmd;
+		LOGD("reject unexpected command type");
+		/* reject unexpected command type */
+		if (cmd->ntc_type != answer[cmd_type])
+			goto reuse_cmd;
+		/*
+		 * reject command from node, which can't have outgoing cmd
+		 * because m0_net_test_commands_send() to this node failed.
+		 */
+		LOGD("reject 3");
+		M0_ASSERT(j >= 0 && j < nodes->ntsl_nr);
+		if (rctx->ntcrc_errno[j] != 0)
+			goto reuse_cmd;
+		/* handle incoming command */
+		LOGD("handle incoming cmd");
+		if (answer[cmd_type] == M0_NET_TEST_CMD_STATUS_DATA) {
+			status_data_add(sd, &cmd->ntc_status_data);
+			success_nr++;
+		} else {
+			rctx->ntcrc_status[j] = cmd->ntc_done.ntcd_errno;
+			if (rctx->ntcrc_status[j] == 0)
+				success_nr++;
+		}
+		/*
+		 * @todo console user can't recover from this error -
+		 * cmd->ntc_buf_index is lost. use ringbuf to save?
+		 */
+reuse_cmd:
+		LOGD("m0_net_test_commands_recv_enqueue()");
+		rc = m0_net_test_commands_recv_enqueue(cmd_ctx,
+						       cmd->ntc_buf_index);
+		LOGD("m0_net_test_commands_recv_enqueue() done.");
+		if (j != -1) {
+			M0_ASSERT(j >= 0 && j < nodes->ntsl_nr);
+			rctx->ntcrc_errno[j] = rc;
+		}
+		LOGD("m0_net_test_commands_received_free()");
+		m0_net_test_commands_received_free(cmd);
+		LOGD("m0_net_test_commands_received_free() done.");
+	}
+
+done:
+	m0_free(cmd);
+	LOGD("console: rc = %d", rc);
+
+	return success_nr;
+}
+
+void m0_net_test_bug_ut(void)
+{
+	struct m0_net_test_console_cfg *console_cfg;
+	struct m0_net_test_console_ctx *console;
+	int				rc;
+	int				i;
+	const char		       *nid = "0@lo";
+	enum m0_net_test_type		type = M0_NET_TEST_TYPE_STUB;
+	size_t				clients_nr = 1;
+	size_t				servers_nr = 1;
+	size_t				concurrency_client = 1;
+	size_t				concurrency_server = 1;
+	size_t				msg_nr = 1;
+	m0_bcount_t			msg_size = 1;
+	size_t				bd_buf_nr_client = 0;
+	size_t				bd_buf_nr_server = 0;
+	m0_bcount_t			bd_buf_size = 0;
+	size_t				bd_nr_max = 0;
+
+	kgdb_break();
+
+	M0_PRE(clients_nr <= NTCS_NODES_MAX);
+	M0_PRE(servers_nr <= NTCS_NODES_MAX);
+
+	M0_ALLOC_PTR(console_cfg);
+	M0_ALLOC_PTR(console);
+	if (console_cfg == NULL || console == NULL)
+		goto done;
+	/* prepare config for test clients and test servers */
+	timeout_cmd  = ms2time(NTCS_TIMEOUT_CMD_MS);
+	timeout_send = ms2time(NTCS_TIMEOUT_SEND_MS);
+	timeout_recv = ms2time(NTCS_TIMEOUT_RECV_MS);
+	timeout_bulk = ms2time(NTCS_TIMEOUT_BULK_MS);
+	addr_console4clients = addr_get(nid, NTCS_TMID_CONSOLE4CLIENTS);
+	addr_console4servers = addr_get(nid, NTCS_TMID_CONSOLE4SERVERS);
+	clients[0] = '\0';
+	clients_data[0] = '\0';
+	for (i = 0; i < clients_nr; ++i) {
+		node_cfg_fill(&node_cfg[i],
+			      addr_get(nid, NTCS_TMID_CMD_CLIENTS + i), clients,
+			      addr_get(nid, NTCS_TMID_DATA_CLIENTS + i),
+			      clients_data, addr_console4clients,
+			      i == clients_nr - 1);
+	}
+	servers[0] = '\0';
+	servers_data[0] = '\0';
+	for (i = 0; i < servers_nr; ++i) {
+		node_cfg_fill(&node_cfg[clients_nr + i],
+			      addr_get(nid, NTCS_TMID_CMD_SERVERS + i), servers,
+			      addr_get(nid, NTCS_TMID_DATA_SERVERS + i),
+			      servers_data, addr_console4servers,
+			      i == servers_nr - 1);
+	}
+	/* spawn test clients and test servers */
+	m0_semaphore_init(&node_init_sem, 0);
+	for (i = 0; i < clients_nr + servers_nr; ++i) {
+		rc = M0_THREAD_INIT(&node_thread[i],
+				    struct m0_net_test_node_cfg *,
+				    NULL, &net_test_node3, &node_cfg[i],
+				    "ut_node_thread#%d", i);
+		M0_UT_ASSERT(rc == 0);
+	}
+	/* wait until test node started */
+	for (i = 0; i < clients_nr + servers_nr; ++i)
+		m0_semaphore_down(&node_init_sem);
+	m0_semaphore_fini(&node_init_sem);
+	/* prepare console config */
+	console_cfg->ntcc_addr_console4servers = addr_console4servers;
+	console_cfg->ntcc_addr_console4clients = addr_console4clients;
+	rc = m0_net_test_slist_init(&console_cfg->ntcc_clients, clients, ',');
+	M0_UT_ASSERT(rc == 0);
+	rc = m0_net_test_slist_init(&console_cfg->ntcc_servers, servers, ',');
+	M0_UT_ASSERT(rc == 0);
+	rc = m0_net_test_slist_init(&console_cfg->ntcc_data_clients,
+				    clients_data, ',');
+	M0_UT_ASSERT(rc == 0);
+	rc = m0_net_test_slist_init(&console_cfg->ntcc_data_servers,
+				    servers_data, ',');
+	M0_UT_ASSERT(rc == 0);
+	console_cfg->ntcc_cmd_send_timeout   = timeout_cmd;
+	console_cfg->ntcc_cmd_recv_timeout   = timeout_cmd;
+	console_cfg->ntcc_buf_send_timeout   = timeout_send;
+	console_cfg->ntcc_buf_recv_timeout   = timeout_recv;
+	console_cfg->ntcc_buf_bulk_timeout   = timeout_bulk;
+	console_cfg->ntcc_test_type	     = type;
+	console_cfg->ntcc_msg_nr	     = msg_nr;
+	console_cfg->ntcc_msg_size	     = msg_size;
+	console_cfg->ntcc_bd_buf_nr_server   = bd_buf_nr_server;
+	console_cfg->ntcc_bd_buf_nr_client   = bd_buf_nr_client;
+	console_cfg->ntcc_bd_buf_size	     = bd_buf_size;
+	console_cfg->ntcc_bd_nr_max	     = bd_nr_max;
+	console_cfg->ntcc_concurrency_server = concurrency_server;
+	console_cfg->ntcc_concurrency_client = concurrency_client;
+	/* initialize console */
+	LOGD("console init");
+	rc = m0_net_test_console_init(console, console_cfg);
+	M0_UT_ASSERT(rc == 0);
+	/* send INIT to the test servers */
+	LOGD("sending INIT to the test servers");
+	rc = net_test_console_cmd(console, M0_NET_TEST_ROLE_SERVER,
+				     M0_NET_TEST_CMD_INIT);
+	M0_UT_ASSERT(rc == servers_nr);
+	/* send INIT to the test clients */
+	LOGD("sending INIT to the test clients");
+	rc = net_test_console_cmd(console, M0_NET_TEST_ROLE_CLIENT,
+				     M0_NET_TEST_CMD_INIT);
+	M0_UT_ASSERT(rc == clients_nr);
+	/* send STOP command to the test clients */
+	LOGD("sending STOP to the test clients");
+	rc = net_test_console_cmd(console, M0_NET_TEST_ROLE_CLIENT,
+				     M0_NET_TEST_CMD_STOP);
+	M0_UT_ASSERT(rc == clients_nr);
+	/* send STOP command to the test servers */
+	LOGD("sending STOP to the test servers");
+	rc = net_test_console_cmd(console, M0_NET_TEST_ROLE_SERVER,
+				     M0_NET_TEST_CMD_STOP);
+	M0_UT_ASSERT(rc == servers_nr);
+	/* finalize console */
+	m0_net_test_console_fini(console);
+	m0_net_test_slist_fini(&console_cfg->ntcc_servers);
+	m0_net_test_slist_fini(&console_cfg->ntcc_clients);
+	m0_net_test_slist_fini(&console_cfg->ntcc_data_servers);
+	m0_net_test_slist_fini(&console_cfg->ntcc_data_clients);
+	/* finalize test clients and test servers */
+	for (i = 0; i < clients_nr + servers_nr; ++i) {
+		rc = m0_thread_join(&node_thread[i]);
+		M0_UT_ASSERT(rc == 0);
+		m0_thread_fini(&node_thread[i]);
+		addr_free(node_cfg[i].ntnc_addr);
+	}
+	addr_free(addr_console4servers);
+	addr_free(addr_console4clients);
+done:
+	m0_free(console);
+	m0_free(console_cfg);
+}
+
+/* END COPY-PASTE FROM client_server.c */
+
+enum {
+	BUG2_NODES_NR = 3,
+	CMD_NR	      = 3,
+	DEADLINE_S    = 10,
+};
+
+struct bug2_node {
+	struct m0_semaphore	    bn_sem_init;
+	struct m0_semaphore	    bn_sem_init2;
+	char			   *bn_tm_addr;
+	struct m0_thread	    bn_thread;
+	struct m0_net_test_cmd_ctx  bn_cmd;
+};
+
+static struct bug2_node nodes[BUG2_NODES_NR];
+
+#if 0
+static void bug2_node_main(struct bug2_node *node)
+{
+	struct m0_net_test_cmd cmd;
+	int		       cmd_rcvd = 0;
+	int		       rc;
+
+	while (cmd_rcvd != CMD_NR) {
+		rc = m0_net_test_commands_recv(&node->bn_cmd, &cmd,
+					       m0_time_from_now(0, 25000000));
+		if (rc == -ETIMEDOUT)
+			continue;
+		/*
+		LOGD("node: received");
+		*/
+		M0_ASSERT(rc == 0);
+		M0_ASSERT(cmd.ntc_ep_index == 0);
+		rc = m0_net_test_commands_recv_enqueue(&node->bn_cmd,
+						       cmd.ntc_buf_index);
+		M0_ASSERT(rc == 0);
+		m0_net_test_commands_send_wait_all(&node->bn_cmd);
+		rc = m0_net_test_commands_send(&node->bn_cmd, &cmd);
+		/*
+		LOGD("node: sent");
+		*/
+		M0_ASSERT(rc == 0);
+		m0_net_test_commands_received_free(&cmd);
+		++cmd_rcvd;
+	}
+}
+#endif
+
+static void bug2_console_main(struct bug2_node *node)
+{
+	struct m0_net_test_cmd cmd;
+	int		       cmd_sent = 0;
+	int		       cmd_rcvd;
+	int		       i;
+	m0_time_t	       deadline;
+	int		       rc;
+
+	M0_SET0(&cmd);
+	while (cmd_sent != CMD_NR) {
+		m0_net_test_commands_send_wait_all(&node->bn_cmd);
+		for (i = 1; i < ARRAY_SIZE(nodes); ++i) {
+			cmd.ntc_ep_index = i - 1;
+			switch (cmd_sent) {
+			case 0:
+				cmd.ntc_type = M0_NET_TEST_CMD_INIT;
+				cmd.ntc_init.ntci_tm_ep = "tm_ep";
+				cmd.ntc_init.ntci_type = M0_NET_TEST_TYPE_STUB;
+				break;
+			case 1:
+				cmd.ntc_type = M0_NET_TEST_CMD_START;
+				break;
+			case CMD_NR - 1:
+				cmd.ntc_type = M0_NET_TEST_CMD_STOP;
+				break;
+			default:
+				cmd.ntc_type = M0_NET_TEST_CMD_STATUS;
+			}
+			rc = m0_net_test_commands_send(&node->bn_cmd, &cmd);
+			M0_ASSERT(rc == 0);
+		}
+		m0_net_test_commands_send_wait_all(&node->bn_cmd);
+		LOGD("console: sent to all");
+		cmd_rcvd = 0;
+		deadline = m0_time_from_now(DEADLINE_S, 0);
+		while (cmd_rcvd != ARRAY_SIZE(nodes) - 1
+		       && m0_time_now() <= deadline) {
+			rc = m0_net_test_commands_recv(&node->bn_cmd, &cmd,
+						       deadline);
+			M0_ASSERT(rc == 0);
+			LOGD("console: received");
+			rc = m0_net_test_commands_recv_enqueue(&node->bn_cmd,
+							cmd.ntc_buf_index);
+			M0_ASSERT(rc == 0);
+			++cmd_rcvd;
+			m0_net_test_commands_received_free(&cmd);
+		}
+		M0_ASSERT(cmd_rcvd == ARRAY_SIZE(nodes) - 1);
+		++cmd_sent;
+	}
+}
+
+#if 0
+static void bug2_node_thread(struct bug2_node *node)
+{
+	struct m0_net_test_slist endpoints;
+	static char		 buf[BUG2_NODES_NR * NTCS_NODE_ADDR_MAX];
+	int			 rc;
+	bool			 console_thread = node == &nodes[0];
+	int			 i;
+
+	if (console_thread) {
+		buf[0] = '\0';
+		for (i = 1; i < ARRAY_SIZE(nodes); ++i) {
+			strncat(buf, nodes[i].bn_tm_addr, ARRAY_SIZE(buf));
+			if (i != ARRAY_SIZE(nodes) - 1)
+				strncat(buf, ",", ARRAY_SIZE(buf));
+		}
+		buf[ARRAY_SIZE(buf) - 1] = '\0';
+		rc = m0_net_test_slist_init(&endpoints, buf, ',');
+		M0_ASSERT(rc == 0);
+	} else {
+		rc = m0_net_test_slist_init(&endpoints,
+					    nodes[0].bn_tm_addr, '`');
+		M0_ASSERT(rc == 0);
+	}
+	rc = m0_net_test_commands_init(&node->bn_cmd, node->bn_tm_addr,
+				       M0_MKTIME(DEADLINE_S, 0),
+				       NULL, &endpoints);
+	M0_ASSERT(rc == 0);
+	/* barrier with main thread */
+	m0_semaphore_up(&node->bn_sem_init);
+	m0_semaphore_down(&node->bn_sem_init2);
+
+	if (console_thread) {
+		bug2_console_main(node);
+	} else {
+		bug2_node_main(node);
+	}
+
+	m0_net_test_commands_fini(&node->bn_cmd);
+	m0_net_test_slist_fini(&endpoints);
+}
+#endif
+
+#if 0
+static int node_cmd_get(struct m0_net_test_cmd_ctx *cmd_ctx,
+			struct m0_net_test_cmd *cmd,
+			m0_time_t deadline)
+{
+	int rc = m0_net_test_commands_recv(cmd_ctx, cmd, deadline);
+	if (rc == 0)
+		rc = m0_net_test_commands_recv_enqueue(cmd_ctx,
+						       cmd->ntc_buf_index);
+	if (rc == 0) {
+		LOGD("node_cmd_get: rc = %d", rc);
+		LOGD("node_cmd_get: cmd->ntc_type = %d", cmd->ntc_type);
+		LOGD("node_cmd_get: cmd->ntc_init.ntci_msg_nr = %lu",
+		     (unsigned long) cmd->ntc_init.ntci_msg_nr);
+	}
+	return rc;
+}
+#endif
+
+static void node_thread_func(struct m0_net_test_node_ctx *ctx)
+{
+	struct m0_net_test_cmd *cmd;
+	struct m0_net_test_cmd *reply;
+	int			rc;
+
+	M0_PRE(ctx != NULL);
+
+	M0_ALLOC_PTR(cmd);
+	M0_ALLOC_PTR(reply);
+	if (cmd == NULL || reply == NULL) {
+		rc = -ENOMEM;
+		goto done;
+	}
+
+#if 0
+	/* wait for INIT command */
+	do {
+		deadline = m0_time_from_now(0, 20000000);
+		rc = node_cmd_get(&ctx->ntnc_cmd, cmd, deadline);
+		if (rc != 0 && rc != -ETIMEDOUT)
+			break;
+	} while (!(rc == 0 && cmd->ntc_type == M0_NET_TEST_CMD_INIT) &&
+		 !ctx->ntnc_exit_flag);
+	ctx->ntnc_errno = rc;
+	if (ctx->ntnc_exit_flag) {
+		m0_net_test_commands_received_free(cmd);
+		goto done;
+	}
+	if (ctx->ntnc_errno != 0)
+		goto done;
+	/* handle INIT command inside main loop */
+	skip_cmd_get = true;
+	/* start main loop */
+#endif
+	rc = 0;
+	do {
+		/* get command */
+		rc = m0_net_test_commands_recv(&ctx->ntnc_cmd, cmd,
+					       m0_time_from_now(0, 25000000));
+					       // m0_time_now());
+		if (rc == 0)
+			rc = m0_net_test_commands_recv_enqueue(&ctx->ntnc_cmd,
+							cmd->ntc_buf_index);
+		if (rc == 0 && cmd->ntc_ep_index >= 0) {
+			LOGD("node_thread: have command");
+			/* we have command. handle it */
+			if (cmd->ntc_type == M0_NET_TEST_CMD_STOP)
+				ctx->ntnc_exit_flag = true;
+			reply->ntc_type = M0_NET_TEST_CMD_INIT_DONE;
+			reply->ntc_done.ntcd_errno = 0;
+			reply->ntc_ep_index = cmd->ntc_ep_index;
+			m0_net_test_commands_received_free(cmd);
+			/* send reply */
+			m0_net_test_commands_send_wait_all(&ctx->ntnc_cmd);
+			rc = m0_net_test_commands_send(&ctx->ntnc_cmd, reply);
+			M0_SET0(cmd);
+		} else if (rc == -ETIMEDOUT) {
+			rc = 0;
+		} else {
+			break;
+		}
+	} while (!ctx->ntnc_exit_flag && rc == 0);
+done:
+	m0_free(cmd);
+	m0_free(reply);
+	LOGD("rc = %d", rc);
+	ctx->ntnc_errno = rc;
+	m0_semaphore_up(&ctx->ntnc_thread_finished_sem);
+}
+
+static void bug2_node_thread2(struct bug2_node *node)
+{
+	struct m0_net_test_node_ctx *ctx;
+	struct m0_net_test_node_cfg *cfg;
+	struct m0_net_test_slist     ep_list;
+	int			     rc;
+
+	/* init */
+	M0_ALLOC_PTR(ctx);
+	M0_UT_ASSERT(ctx != NULL);
+	M0_ALLOC_PTR(cfg);
+	M0_UT_ASSERT(cfg != NULL);
+	cfg->ntnc_addr	       = node->bn_tm_addr;
+	cfg->ntnc_addr_console = nodes[0].bn_tm_addr;
+	cfg->ntnc_send_timeout = ms2time(NTCS_TIMEOUT_CMD_MS);
+	rc = m0_net_test_slist_init(&ep_list, cfg->ntnc_addr_console, '`');
+	M0_UT_ASSERT(rc == 0);
+	rc = m0_net_test_commands_init(&ctx->ntnc_cmd, cfg->ntnc_addr,
+				       cfg->ntnc_send_timeout, NULL, &ep_list);
+	M0_UT_ASSERT(rc == 0);
+	m0_net_test_slist_fini(&ep_list);
+	rc = m0_semaphore_init(&ctx->ntnc_thread_finished_sem, 0);
+	M0_UT_ASSERT(rc == 0);
+	ctx->ntnc_exit_flag = false;
+	ctx->ntnc_errno = 0;
+	/* start */
+	rc = M0_THREAD_INIT(&ctx->ntnc_thread, struct m0_net_test_node_ctx *,
+			    NULL, &node_thread_func, ctx,
+			    "net_test_node_thread");
+	M0_UT_ASSERT(rc == 0);
+	/* barrier with main thread */
+	m0_semaphore_up(&node->bn_sem_init);
+	m0_semaphore_down(&node->bn_sem_init2);
+	/* stop */
+	m0_semaphore_down(&ctx->ntnc_thread_finished_sem);
+	ctx->ntnc_exit_flag = true;
+	m0_net_test_commands_send_wait_all(&ctx->ntnc_cmd);
+	rc = m0_thread_join(&ctx->ntnc_thread);
+	M0_UT_ASSERT(rc == 0);
+	/* fini */
+	m0_thread_fini(&ctx->ntnc_thread);
+	m0_semaphore_fini(&ctx->ntnc_thread_finished_sem);
+	m0_net_test_commands_fini(&ctx->ntnc_cmd);
+	m0_free(cfg);
+	m0_free(ctx);
+}
+
+static void bug2_console_thread2(struct bug2_node *node)
+{
+	struct m0_net_test_slist endpoints;
+	static char		 buf[BUG2_NODES_NR * NTCS_NODE_ADDR_MAX];
+	int			 rc;
+	int			 i;
+
+	buf[0] = '\0';
+	for (i = 1; i < ARRAY_SIZE(nodes); ++i) {
+		strncat(buf, nodes[i].bn_tm_addr, ARRAY_SIZE(buf));
+		if (i != ARRAY_SIZE(nodes) - 1)
+			strncat(buf, ",", ARRAY_SIZE(buf));
+	}
+	buf[ARRAY_SIZE(buf) - 1] = '\0';
+	rc = m0_net_test_slist_init(&endpoints, buf, ',');
+	M0_ASSERT(rc == 0);
+	rc = m0_net_test_commands_init(&node->bn_cmd, node->bn_tm_addr,
+				       M0_MKTIME(DEADLINE_S, 0),
+				       NULL, &endpoints);
+	M0_ASSERT(rc == 0);
+	/* barrier with main thread */
+	m0_semaphore_up(&node->bn_sem_init);
+	m0_semaphore_down(&node->bn_sem_init2);
+
+	bug2_console_main(node);
+	m0_net_test_commands_fini(&node->bn_cmd);
+	m0_net_test_slist_fini(&endpoints);
+}
+
+/* main thread */
+void m0_net_test_bug2_ut(void)
+{
+	const char	 *nid = "0@lo";
+	const int	  tmid_start = 2000;
+	struct bug2_node *node;
+	size_t		  i;
+	int		  rc;
+
+	/* console is node #0 */
+	for (i = 0; i < ARRAY_SIZE(nodes); ++i) {
+		node = &nodes[i];
+		rc = m0_semaphore_init(&node->bn_sem_init, 0);
+		M0_ASSERT(rc == 0);
+		rc = m0_semaphore_init(&node->bn_sem_init2, 0);
+		M0_ASSERT(rc == 0);
+		node->bn_tm_addr = addr_get(nid, tmid_start + i);
+		M0_ASSERT(node->bn_tm_addr != NULL);
+	}
+	/* start threads */
+	for (i = 0; i < ARRAY_SIZE(nodes); ++i) {
+		node = &nodes[i];
+		rc = M0_THREAD_INIT(&node->bn_thread, struct bug2_node *, NULL,
+				    i == 0 ? &bug2_console_thread2 :
+					     &bug2_node_thread2,
+				    node, "#%dbug2_%s", (int) i,
+				    i == 0 ? "console" : "node");
+		M0_ASSERT(rc == 0);
+	}
+	/* barrier with node threads */
+	for (i = 0; i < ARRAY_SIZE(nodes); ++i)
+		m0_semaphore_down(&nodes[i].bn_sem_init);
+	for (i = 0; i < ARRAY_SIZE(nodes); ++i)
+		m0_semaphore_up(&nodes[i].bn_sem_init2);
+	/* stop threads */
+	for (i = 0; i < ARRAY_SIZE(nodes); ++i) {
+		node = &nodes[i];
+		rc = m0_thread_join(&node->bn_thread);
+		M0_ASSERT(rc == 0);
+		m0_thread_fini(&node->bn_thread);
+	}
+	/* fini nodes */
+	for (i = 0; i < ARRAY_SIZE(nodes); ++i) {
+		node = &nodes[i];
+		m0_semaphore_fini(&node->bn_sem_init2);
+		m0_semaphore_fini(&node->bn_sem_init);
+		m0_free(node->bn_tm_addr);
+	}
+}
+
+enum {
+	THREAD_NR = 2,
+};
+
+struct sem_test {
+	struct m0_thread    st_thread;
+	struct m0_semaphore st_sem;
+};
+
+static struct sem_test sem_tests[THREAD_NR];
+
+static void sem_test_thread(struct sem_test *test)
+{
+	while (!m0_semaphore_timeddown(&test->st_sem, m0_time_now()))
+		;
+}
+
+void m0_net_test_bug3_ut(void)
+{
+	struct sem_test *test;
+	size_t		 i;
+	int		 rc;
+
+	/* start threads */
+	for (i = 0; i < ARRAY_SIZE(sem_tests); ++i) {
+		test = &sem_tests[i];
+		rc = M0_THREAD_INIT(&test->st_thread, struct sem_test *, NULL,
+				    &sem_test_thread,
+				    test, "#%dbug3_thread", (int) i);
+		M0_ASSERT(rc == 0);
+		rc = m0_semaphore_init(&test->st_sem, 0);
+		M0_ASSERT(rc == 0);
+	}
+	/* up() all semaphores after 1s */
+	m0_nanosleep(M0_MKTIME(1, 0), NULL);
+	for (i = 0; i < ARRAY_SIZE(sem_tests); ++i)
+		m0_semaphore_up(&sem_tests[i].st_sem);
+	/* stop threads */
+	for (i = 0; i < ARRAY_SIZE(sem_tests); ++i) {
+		test = &sem_tests[i];
+		rc = m0_thread_join(&test->st_thread);
+		M0_ASSERT(rc == 0);
+		m0_thread_fini(&test->st_thread);
+		m0_semaphore_fini(&test->st_sem);
+	}
+}
+
+#include "net/test/stats.h"		/* m0_net_test_stats */
+#include "lib/trace.h"			/* M0_LOG */
+
+enum {
+	SAMPLE_SIZE = 0x100000,
+	SEM_DOWN_NR = 0x1000,
+};
+
+static m0_time_t debug_get_time(void)
+{
+	struct timespec ts;
+#ifndef __KERNEL__
+	int		rc;
+
+	rc = clock_gettime(CLOCK_REALTIME, &ts);
+	M0_ASSERT(rc == 0);
+#else
+	getnstimeofday(&ts);
+#endif
+
+	return ts.tv_sec * M0_TIME_ONE_BILLION + ts.tv_nsec;
+}
+
+static void debug_log_stats(const char *descr,
+			    struct m0_net_test_stats *stats)
+{
+	M0_LOG(M0_INFO, "%s nr/min/max/~avg sumHI/sumLO/sum_sqrHI/sum_sqrLO = "
+	       "%lu/%ld/%ld/%lu %lu/%lu/%lu/%lu",
+	       descr,
+	       stats->nts_count,
+	       (long) m0_net_test_stats_time_min(stats),
+	       (long) m0_net_test_stats_time_max(stats),
+	       (unsigned long) stats->nts_sum.u_lo / stats->nts_count,
+	       (unsigned long) stats->nts_sum.u_hi,
+	       (unsigned long) stats->nts_sum.u_lo,
+	       (unsigned long) stats->nts_sum_sqr.u_hi,
+	       (unsigned long) stats->nts_sum_sqr.u_lo);
+}
+
+static void time_measure_accuracy(void)
+{
+	struct m0_net_test_stats stats;
+	size_t			 i;
+	m0_time_t		 time_current;
+	m0_time_t		 time_next;
+	m0_time_t		 delta;
+
+	m0_net_test_stats_reset(&stats);
+	time_current = debug_get_time();
+	for (i = 0; i < SAMPLE_SIZE; ++i) {
+		time_next = debug_get_time();
+		delta = time_next - time_current;
+		time_current = time_next;
+		if (delta != 0)
+			m0_net_test_stats_time_add(&stats, delta);
+	}
+	debug_log_stats("m0_time_now() delta ", &stats);
+}
+
+static void semaphore_timeddown_measure_speed(void)
+{
+	struct m0_net_test_stats stats;
+	struct m0_semaphore	 sem;
+	size_t			 i;
+	int			 rc;
+	m0_time_t		 time_start;
+	m0_time_t		 time_finish;
+	const size_t		 LOG_SIZE = 0x10;
+	m0_time_t		 small_log[LOG_SIZE];
+
+	rc = m0_semaphore_init(&sem, 0);
+	M0_ASSERT(rc == 0);
+	m0_net_test_stats_reset(&stats);
+	for (i = 0; i < SEM_DOWN_NR; ++i) {
+		time_start = debug_get_time();
+		m0_semaphore_timeddown(&sem, m0_time_now());
+		// m0_semaphore_timeddown(&sem, time_start);
+		// m0_semaphore_trydown(&sem);
+		time_finish = debug_get_time();
+		m0_net_test_stats_add(&stats, time_finish - time_start);
+		if (i < LOG_SIZE)
+			small_log[i] = time_finish - time_start;
+	}
+	m0_semaphore_fini(&sem);
+	debug_log_stats("m0_semaphore_down(&sem, m0_time_now()) time ", &stats);
+	for (i = 0; i < LOG_SIZE; ++i)
+		M0_LOG(M0_INFO, "%lu", (unsigned long) small_log[i]);
+}
+
+void m0_net_test_debug_ut(void)
+{
+	time_measure_accuracy();
+	semaphore_timeddown_measure_speed();
+}
+
 /*
  *  Local variables:
  *  c-indentation-style: "K&R"
diff --git a/utils/linux_kernel/main.c b/utils/linux_kernel/main.c
index 717f4c3..68c5f33 100644
--- a/utils/linux_kernel/main.c
+++ b/utils/linux_kernel/main.c
@@ -60,6 +60,7 @@ static void run_kernel_ut(int ignored)
         printk(KERN_INFO "Mero Kernel Unit Test\n");
 
 	m0_uts_init();
+#if 0
 	/* sort test suites in alphabetic order */
 	m0_ut_add(&m0_klibm0_ut);  /* test lib first */
 	m0_ut_add(&m0_addb_ut);
@@ -70,7 +71,9 @@ static void run_kernel_ut(int ignored)
 	m0_ut_add(&m0_net_bulk_if_ut);
 	m0_ut_add(&m0_net_bulk_mem_ut);
 	m0_ut_add(&m0_net_lnet_ut);
+#endif
 	m0_ut_add(&m0_net_test_ut);
+#if 0
 	m0_ut_add(&m0_net_tm_prov_ut);
 	m0_ut_add(&conn_ut);
 	m0_ut_add(&frm_ut);
@@ -81,6 +84,7 @@ static void run_kernel_ut(int ignored)
 	m0_ut_add(&session_ut);
 	m0_ut_add(&sm_ut);
 	m0_ut_add(&xcode_ut);
+#endif
 
 	m0_ut_run();
 	m0_uts_fini();
diff --git a/utils/ut.valgrind b/utils/ut.valgrind
index 78d0ff2..c80a295 100755
--- a/utils/ut.valgrind
+++ b/utils/ut.valgrind
@@ -1,6 +1,6 @@
 #!/bin/sh
 
-EXE=${0%/*}/.libs/lt-ut
+EXE=${0%/*}/.libs/ut
 
 valgrind \
     --tool=memcheck \
diff --git a/utils/ut_main.c b/utils/ut_main.c
index 14bac96..ac68124 100644
--- a/utils/ut_main.c
+++ b/utils/ut_main.c
@@ -91,7 +91,8 @@ extern const struct m0_test_suite yaml2db_ut;
 void add_uts(void)
 {
 	/* sort test suites in alphabetic order */
-	m0_ut_add(&libm0_ut); /* test lib first */
+	/* m0_ut_add(&libm0_ut); */ /* test lib first */
+	/*
 	m0_ut_add(&ad_ut);
 	m0_ut_add(&adieu_ut);
 	m0_ut_add(&balloc_ut);
@@ -103,7 +104,9 @@ void add_uts(void)
 	m0_ut_add(&m0_net_bulk_if_ut);
 	m0_ut_add(&m0_net_bulk_mem_ut);
 	m0_ut_add(&m0_net_lnet_ut);
+	*/
 	m0_ut_add(&m0_net_test_ut);
+	/*
 	m0_ut_add(&m0_net_tm_prov_ut);
 	m0_ut_add(&capa_ut);
 	m0_ut_add(&cm_cp_ut);
@@ -142,9 +145,12 @@ void add_uts(void)
 	m0_ut_add(&xcode_bufvec_fop_ut);
 	m0_ut_add(&xcode_ff2c_ut);
 	m0_ut_add(&xcode_ut);
+	*/
 	/* These tests have redirection of messages. */
+	/*
 	m0_ut_add(&console_ut);
 	m0_ut_add(&yaml2db_ut);
+	*/
 }
 
 int main(int argc, char *argv[])
-- 
1.8.3.2

