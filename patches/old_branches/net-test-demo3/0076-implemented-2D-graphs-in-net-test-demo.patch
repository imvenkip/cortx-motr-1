From efeb749d04dae00803d6a71243d7a5707ed6e13c Mon Sep 17 00:00:00 2001
From: Maxim Medved <Max_Medved@xyratex.com>
Date: Thu, 21 Feb 2013 07:34:01 +0200
Subject: [PATCH 76/99] implemented 2D graphs in net-test demo

---
 net/test/demo/.gitignore        |   3 +
 net/test/demo/demo-config.sh.in |   4 +-
 net/test/demo/demo-list-nids.sh |   3 +
 net/test/demo/demo-test-run.sh  |   3 +
 net/test/demo/demo.sh           | 984 +++++++++++++++++++++++++++++++---------
 5 files changed, 791 insertions(+), 206 deletions(-)
 create mode 100755 net/test/demo/demo-list-nids.sh
 create mode 100755 net/test/demo/demo-test-run.sh

diff --git a/net/test/demo/.gitignore b/net/test/demo/.gitignore
index d3d238a..ab311b9 100644
--- a/net/test/demo/.gitignore
+++ b/net/test/demo/.gitignore
@@ -1 +1,4 @@
 demo-config.sh
+data/
+setup/
+result/
diff --git a/net/test/demo/demo-config.sh.in b/net/test/demo/demo-config.sh.in
index ed993f1..aebbc1f 100644
--- a/net/test/demo/demo-config.sh.in
+++ b/net/test/demo/demo-config.sh.in
@@ -3,6 +3,6 @@
 # Kernel module -  test node
 MOD_NODE=@ABS_SRCDIR@/net/test/linux_kernel/m0nettest.ko
 # Userspace program - test node
-CMD_NODE=@ABS_SRCDIR@/net/test/m0nettestd.sh
+CMD_NODE=@ABS_SRCDIR@/net/test/user_space/m0nettestd
 # Userspace program - test console
-CMD_CONSOLE=@ABS_SRCDIR@/net/test/m0nettest.sh
+CMD_CONSOLE=@ABS_SRCDIR@/net/test/user_space/m0nettest
diff --git a/net/test/demo/demo-list-nids.sh b/net/test/demo/demo-list-nids.sh
new file mode 100755
index 0000000..a674ea6
--- /dev/null
+++ b/net/test/demo/demo-list-nids.sh
@@ -0,0 +1,3 @@
+#!/bin/bash
+
+awk '{print $1 " " $1 "@tcp"}'
diff --git a/net/test/demo/demo-test-run.sh b/net/test/demo/demo-test-run.sh
new file mode 100755
index 0000000..f0dd97f
--- /dev/null
+++ b/net/test/demo/demo-test-run.sh
@@ -0,0 +1,3 @@
+#!/bin/bash
+
+cat /tmp/raw$(expr \( $RANDOM % 4 \) + 1)
diff --git a/net/test/demo/demo.sh b/net/test/demo/demo.sh
index d34023d..b4f0533 100755
--- a/net/test/demo/demo.sh
+++ b/net/test/demo/demo.sh
@@ -1,151 +1,179 @@
 #!/bin/bash
-set -eux
+# set -eux
+# export PS4='+ ${FUNCNAME[0]:+${FUNCNAME[0]}():}line ${LINENO}: '
 
 # Parameters
-# Debugging
+# Verbose mode
 VERBOSE=0
 
+# Resume execution after ^C interrupt
+RESUME=0
+
 # Hardcoded in script
 # Transfer machine ID in test will start from this number
 TMID_START=3000
 # Maximum number of test nodes (for demo)
 NODES_NR_MAX=64
-
-# LNET Network Type. First NID from lctl network list_nids are used for testing
+# Time limit for one test, seconds
+TEST_RUN_TIME=10
+# Message number limit for one test
+# Test will be finished if MSG_NR messages sent/received or time limit reached
+MSG_NR=10000000
+
+# Size for msg buffer with bulk network buffer descriptors
+BD_BUF_SIZE=16k
+# Maximum number of descriptors in this buffer
+BD_NR_MAX=16384
+
+# LNET Network Type. First NID from `lctl network list_nids' with
+# $NET_TYPE network type are used for testing.
 # NET_TYPE=o2ib
 NET_TYPE=tcp
+# NET_TYPE=lo
 LNET_PID=12345
 LNET_PORTAL=42
 
-# User-supplied
+# User-supplied list of ssh credentials for test nodes and test console
 declare -a CLIENTS
 declare -a SERVERS
+CONSOLE=
+
+# Configuration for test nodes
 declare -A NODES
 NODES_NR=0
-TEST_TYPE=
-CLIENTS_SPACE=
-SERVERS_SPACE=
 
-# Variable parameters
-MSG_NR=
-MSG_SIZE=
+# These parameters will be calculated from others
+# See console_cmdline_complement()
 CONCURRENCY_CLIENT=
 CONCURRENCY_SERVER=
-BD_BUF_SIZE=
-BD_BUF_NR=
+BD_BUF_NR_CLIENT=
+BD_BUF_NR_SERVER=
 
 # List of parameters to test
 # MSG_SIZE_LIST="64 128 256 512 1024 2048 4096 8192 16384 32768 65536 131072 \
 # 262144 524288 1048576"
 # CONCURRENCY_CLIENT_LIST="1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 18 20 22 24 \
 # 26 28 30 32 40 48 56 64 80 96 112 128 160 192 224 256"
-MSG_SIZE_LIST="65536 524288 1048576"
-CONCURRENCY_CLIENT_LIST="4 6 8 16"
+MSG_SIZE_LIST="65536 1048576"
+CONCURRENCY_CLIENT_LIST="8 16"
+MEASUREMENT_LIST="Bandwidth RTT MPS"
+M_TYPE_LIST="min max avg stddev"
+declare -a MSG_SIZE_ARR=(${MSG_SIZE_LIST// / })
+declare -a CONCURRENCY_CLIENT_ARR=(${CONCURRENCY_CLIENT_LIST// / })
+declare -a MEASUREMENT_ARR=(${MEASUREMENT_LIST// / })
+declare -a M_TYPE_ARR=(${M_TYPE_LIST// / })
+declare -a DIR_NAME_ARR=
+declare -A MSG_SIZE_REVERSE
 
 # Used by script
-SCRIPT_DIR=${0%/*}
-START_TIMEOUT=1
-STOP_TIMEOUT=3
-
-TMID_CONSOLE_CLIENTS=$TMID_START
-TMID_CONSOLE_SERVERS=$(expr $TMID_START + 1)
-TMID_NODES_START=$(expr $TMID_CONSOLE_SERVERS + 1)
-NID_CONSOLE=
+DIR_SCRIPT=${0%/*}
+DIR_SETUP="$DIR_SCRIPT/setup"
+DIR_DATA="$DIR_SCRIPT/data"
+DIR_RESULT="$DIR_SCRIPT/result"
+DIR_PLOT_SCRIPTS="$DIR_RESULT/gnuplot-scripts"
+FILE_CONSOLE_NID="$DIR_SETUP/console-NIDs-raw"
+FILE_CLIENTS_NID="$DIR_SETUP/clients-NIDs-raw"
+FILE_SERVERS_NID="$DIR_SETUP/servers-NIDs-raw"
+FILE_CONSOLE_CMD="$DIR_SETUP/console-user"
+FILE_CLIENTS_CMD="$DIR_SETUP/clients"
+FILE_SERVERS_CMD="$DIR_SETUP/servers"
+FILE_MSG_SIZE="$DIR_SETUP/msg_size"
+FILE_CONCURRENCY="$DIR_SETUP/concurrency"
+
+SCRIPT_CONFIG="$DIR_SCRIPT/demo-config.sh"
+SCRIPT_LIST_NIDS="$DIR_SCRIPT/demo-list-nids.sh"
+SCRIPT_TEST_RUN="$DIR_SCRIPT/demo-test-run.sh"
+
+CONSOLE_TMID_CLIENTS=$TMID_START
+CONSOLE_TMID_SERVERS=$(expr $TMID_START + 1)
+NODES_TMID_START=$(expr $CONSOLE_TMID_SERVERS + 1)
+
+CONSOLE_NID=
+CONSOLE_EP_CLIENTS=
+CONSOLE_EP_SERVERS=
+CONSOLE_CMDLINE=
+
+MKDIR="mkdir -p"
+ECHO="echo -e"
+ECHO_N="echo -n"
+RM="rm -rf"
+# Tested with v4.6.1
+# devvm has v4.2.6 - it will not work
+GNUPLOT="/work/tmp/gnuplot-4.6.1/src/gnuplot"
+# GNUPLOT="gnuplot"
 
 main()
 {
-	. $SCRIPT_DIR/demo-config.sh
+	. "$SCRIPT_CONFIG"
+	script_init
 	cmdline_parse "$@"
-	configuration_parse
-	lnet_prepare_console
-	for_all_nodes lnet_prepare_node
-	for_all_nodes node_configure
-	local msg_size
-	local concurrency_client
-	for msg_size in $MSG_SIZE_LIST; do
-		for concurrency_client in $CONCURRENCY_CLIENT_LIST; do
-			for_all_nodes node_run
-			sleep $START_TIMEOUT
-			data=$(console_run $msg_size $concurrency_client)
-			for_all_nodes node_stop
-			sleep $STOP_TIMEOUT
-			# for_all_nodes node_kill
-			echo $data
-		done
-	done
+	if [ $RESUME -eq 0 ]; then
+		configuration_parse
+		dirs_create
+		configure
+	fi
+	config_load
+	for_each_combination dirs_make
+	for_each_combination test_run
+	for_each_combination tables_set0
+	for_each_combination console_output_parse
+	draw_graphs
 }
 
 cmdline_help()
 {
-	echo -e "-?"
-	echo -e "-h\tPrint help and exit"
-	echo -e "-v\tVerbose output"
-	echo -e "-c\tComma-separated list of clients"
-	echo -e "-s\tComma-separated list of servers"
-	echo -e "-t\tTest type (ping or bulk)"
-	echo -e "-C\tClients type ('kernel' for kernel module,"
-	echo -e "  \t'user' for userspace program)."
-	echo -e "-S\tServers type (same as -C)"
+	$ECHO "-?"
+	$ECHO "-h\tPrint help and exit"
+	$ECHO "-v\tVerbose output"
+	$ECHO "-d\tRemove all produced files and results"
+	$ECHO "-c\tComma-separated list of clients"
+	$ECHO "-s\tComma-separated list of servers"
+	$ECHO "-e\tConsole address"
+	$ECHO "-r\tResume script execution after ^C"
 }
 
 cmdline_parse()
 {
 	OPTIND=1
 	local IFS_SAVE="$IFS"
-	while getopts "?hvc:s:t:C:S:" opt; do
+	while getopts "?hvdc:s:e:r" opt; do
 		case "$opt" in
-		h|\?)
-			cmdline_help
-			exit 0
-			;;
-		v)
-			VERBOSE=1
-			;;
-		c)
-			IFS=","
-			read -a CLIENTS <<< "$OPTARG"
-			;;
-		s)
-			IFS=","
-			read -a SERVERS <<< "$OPTARG"
-			;;
-		t)
-			TEST_TYPE="$OPTARG"
-			;;
-		C)
-			CLIENTS_SPACE="$OPTARG"
-			;;
-		S)
-			SERVERS_SPACE="$OPTARG"
-			;;
+		h|\?)	cmdline_help
+			exit 0 ;;
+		v)	VERBOSE=1 ;;
+		d)	files_clean
+			exit 0 ;;
+		c)	IFS=","
+			read -a CLIENTS <<< "$OPTARG" ;;
+		s)	IFS=","
+			read -a SERVERS <<< "$OPTARG" ;;
+		e)	CONSOLE="$OPTARG" ;;
+		r)	RESUME=1 ;;
 		esac
 	done
 	IFS="$IFS_SAVE"
-	cmdline_param_check $TEST_TYPE \
-		"Test type (-t) should be 'ping' or 'bulk'" "ping" "bulk"
-	cmdline_param_check $CLIENTS_SPACE \
-		"Clients space (-C) should be 'user' or 'kernel'" \
-		"user" "kernel"
-	cmdline_param_check $SERVERS_SPACE \
-		"Servers space (-S) should be 'user' or 'kernel'" \
-		"user" "kernel"
-}
-
-# $1 - parameter value
-# $2 - error string
-# $3... - valid values
-cmdline_param_check()
-{
-	local value=$1
-	local error_string=$2
-	shift 2
-	for param in "$@"; do
-		if [ "$param" == "$value" ]; then
-			return
-		fi
+}
+
+script_init()
+{
+	local msg_size
+	local index=1
+	local test_type
+	local space_c
+	local space_s
+
+	for msg_size in ${MSG_SIZE_ARR[@]}; do
+		((index++)) || true
+		MSG_SIZE_REVERSE["$msg_size"]="$index"
+	done
+	for test_type in "ping" "bulk"; do
+		for space_c in "user" "kernel"; do
+			for space_s in "user" "kernel"; do
+				DIR_NAME_ARR=("${DIR_NAME_ARR[@]}" \
+					      "$test_type-$space_c-$space_s")
+			done
+		done
 	done
-	echo "$error_string"
-	exit 1
 }
 
 # Setter and getter for node associative array
@@ -176,177 +204,725 @@ exit_if_error()
 	fi
 }
 
-# $1 - node index to run
-# $2 .. - command with parameters to run
-# Note: sudo prefix will be added in this command
-node_run_remote()
-{
-	local addr=$(node_get $1 "addr")
-	shift 1
-	ssh $addr sudo "$@"
-}
-
-# see node_run_remote
-# ssh PID will be saved to "ssh_pid" for node
-node_run_remote_nowait()
-{
-	local index=$1
-	local addr=$(node_get $index "addr")
-	shift 1
-	ssh -tt $addr sudo "$@" < /dev/null &
-	node_set $index "ssh_pid" "$!"
-}
-
-# $1 .. - command to run
-# Note: sudo prefix will be added in this command
-console_run_local()
-{
-	sudo "$@"
-}
-
 configuration_parse()
 {
+	local ssh_addr
 	local addr
-	for addr in "${CLIENTS[@]}" "${SERVERS[@]}"; do
+	local index
+
+	for ssh_addr in "${CLIENTS[@]}" "${SERVERS[@]}"; do
 		if [ "$NODES_NR" -eq "$NODES_NR_MAX" ]; then
 			echo "Too many nodes; current limit is $NODES_NR_MAX"
 			exit 1
 		fi
 		index="$NODES_NR"
 		# configure nodes
-		node_set $index "addr" $addr
+		node_set $index "ssh_addr" $ssh_addr
 		node_set $index "tmid_cmd" \
-			$(expr $TMID_NODES_START + $NODES_NR "*" 2)
+			$(expr $NODES_TMID_START + $NODES_NR "*" 2)
 		node_set $index "tmid_data" \
-			$(expr $TMID_NODES_START + $NODES_NR "*" 2 + 1)
+			$(expr $NODES_TMID_START + $NODES_NR "*" 2 + 1)
 		((NODES_NR++)) || true
 	done
-	local index=0
+	index=0
 	for addr in "${CLIENTS[@]}"; do
 		node_set "$index" "role" "client"
-		node_set "$index" "space" "$CLIENTS_SPACE"
 		((index++)) || true
 	done
 	for addr in "${SERVERS[@]}"; do
 		node_set "$index" "role" "server"
-		node_set "$index" "space" "$SERVERS_SPACE"
 		((index++)) || true
 	done
 }
 
 # $1 - function to call.
 #      Node index will be passed to this function as first argument.
-for_all_nodes()
+# $2 .. - this parameters will be passed to function as $3 .. .
+for_each_node()
 {
 	local i
+	local func="$1"
+	shift 1
 	for i in $(seq 0 $(expr $NODES_NR - 1)); do
-		$1 $i
+		$func $i $@
 	done
 }
 
-# modprobe lnet
-# lctl network up
-# lctl list_nids
-# $1 - address (used only for output)
-# $2 .. - how to run command
-lnet_prepare()
+node_configure()
 {
-	local addr=$1
-	shift 1
-	[ "$VERBOSE" -eq 1 ] && echo "Setting up LNET on $addr..."
-	$@ modprobe lnet
-	exit_if_error "Error probing lnet module on $addr" $?
-	$@ lctl network up
-	exit_if_error "'sudo lctl network up' failed" $?
+	local index=$1
+	local nid=$(node_get $index "nid")
+	local tmid=$(node_get $index "tmid_cmd")
+	local endpoint_cmd="$nid:$LNET_PID:$LNET_PORTAL:$tmid"
+	node_set $index "endpoint_cmd" "$endpoint_cmd"
+	local tmid=$(node_get $index "tmid_data")
+	node_set $index "endpoint_data" "$nid:$LNET_PID:$LNET_PORTAL:$tmid"
+	local role=$(node_get $index "role")
+	local endpoint_console
+	if [ "$role" == "client" ]; then
+		endpoint_console="$CONSOLE_EP_CLIENTS"
+	else
+		endpoint_console="$CONSOLE_EP_SERVERS"
+	fi
+	node_set $index "endpoint_console" "$endpoint_console"
+	node_set $index "cmdline_user" \
+		"$CMD_NODE -a $endpoint_console -c $endpoint_cmd"
+	node_set $index "cmdline_kernel" \
+	  "$MOD_NODE console_addr=$endpoint_console node_addr=$endpoint_cmd"
 }
 
-lnet_nid_get()
+console_configure1()
 {
-	$@ lctl list_nids | grep "$NET_TYPE"$ | head -n 1
-	exit_if_error "'sudo lctl list_nids' failed" $?
+	local console_ep_prefix="$CONSOLE_NID:$LNET_PID:$LNET_PORTAL"
+	CONSOLE_EP_CLIENTS="$console_ep_prefix:$CONSOLE_TMID_CLIENTS"
+	CONSOLE_EP_SERVERS="$console_ep_prefix:$CONSOLE_TMID_SERVERS"
 }
 
-lnet_prepare_node()
+add_comma()
 {
-	local index=$1
-	local addr=$(node_get $index "addr")
-	lnet_prepare "$addr" node_run_remote "$index"
-	local nid=$(lnet_nid_get node_run_remote "$index")
-	node_set $index "nid" $nid
-	[ "$VERBOSE" -eq 1 ] && echo "NID $nid will be used on $addr."
+	if [ "$2" == "" ]; then
+		echo "$1"
+	else
+		echo "$2,$1"
+	fi
 }
 
-lnet_prepare_console()
+console_configure2()
 {
-	lnet_prepare "localhost" console_run_local
-	NID_CONSOLE=$(lnet_nid_get console_run_local)
+	local clients_cmd=
+	local clients_data=
+	local servers_cmd=
+	local servers_data=
+	local index
+	local cmd=
+
+	for index in $(seq 0 $(expr $NODES_NR - 1)); do
+		local role=$(node_get $index "role")
+		local ep_cmd=$(node_get $index "endpoint_cmd")
+		local ep_data=$(node_get $index "endpoint_data")
+		if [ "$role" == "client" ]; then
+			clients_cmd=$(add_comma $ep_cmd "$clients_cmd")
+			clients_data=$(add_comma $ep_data "$clients_data")
+		else
+			servers_cmd=$(add_comma $ep_cmd "$servers_cmd")
+			servers_data=$(add_comma $ep_data "$servers_data")
+		fi
+	done
+	cmd="-A $CONSOLE_EP_SERVERS -a $CONSOLE_EP_CLIENTS"
+	cmd="$cmd -C $servers_cmd -c $clients_cmd"
+	cmd="$cmd -D $servers_data -d $clients_data"
+	CONSOLE_CMDLINE="$CMD_CONSOLE $cmd"
 }
 
-node_configure()
+dirs_create()
+{
+	$MKDIR $DIR_SETUP
+	$MKDIR $DIR_DATA
+	$MKDIR $DIR_RESULT
+	$MKDIR $DIR_PLOT_SCRIPTS
+}
+
+files_clean()
+{
+	$RM $DIR_SETUP $DIR_DATA $DIR_RESULT
+}
+
+# $1 - 'client', 'server', 'console'
+# stdout: list of space-separated ssh_addr and LNET NID, one per line
+ssh_list_type()
+{
+	local i
+	local index
+
+	if [ "$1" == "console" ]; then
+		echo $CONSOLE
+		return
+	fi
+	for index in $(seq 0 $(expr $NODES_NR - 1)); do
+		local role=$(node_get $index "role")
+		local ssh_addr=$(node_get $index "ssh_addr")
+		if [ "$role" == "$1" ]; then
+			echo "$ssh_addr"
+		fi
+	done
+}
+
+nids_get()
+{
+	ssh_list_type "console" | $SCRIPT_LIST_NIDS > $FILE_CONSOLE_NID
+	ssh_list_type "client"	| $SCRIPT_LIST_NIDS > $FILE_CLIENTS_NID
+	ssh_list_type "server"	| $SCRIPT_LIST_NIDS > $FILE_SERVERS_NID
+	CONSOLE_NID=$(cat $FILE_CONSOLE_NID | nid_filter)
+}
+
+nid_filter()
+{
+	# awk script: select first NID for each host
+	# @todo make only one call to this script
+	local NID_SELECT="{ if (!(x[\$1]++) && \$2 ~ /$NET_TYPE\$/) print \$0 }"
+	awk "$NID_SELECT" | head -n 1 | awk '{print $2}'
+}
+
+node_nid_select()
 {
 	local index=$1
-	local nid=$(node_get $index "nid")
-	local tmid=$(node_get $index "tmid_cmd")
-	node_set $index "endpoint_cmd" "$nid:$LNET_PID:$LNET_PORTAL:$tmid"
-	local tmid=$(node_get $index "tmid_data")
-	node_set $index "endpoint_data" "$nid:$LNET_PID:$LNET_PORTAL:$tmid"
 	local role=$(node_get $index "role")
-	if [ "$role" == "client" ]; then
-		tmid=$TMID_CONSOLE_CLIENTS
-	else
-		tmid=$TMID_CONSOLE_SERVERS
-	fi
-	node_set $index "endpoint_console" \
-		"$NID_CONSOLE:$LNET_PID:$LNET_PORTAL:$tmid"
+	local file
+	local nid
+
+	case "$role" in
+	client)	file=$FILE_CLIENTS_NID ;;
+	server)	file=$FILE_SERVERS_NID ;;
+	esac
+	nid=$(cat $file | nid_filter)
+	node_set $index "nid" $nid
 }
 
 # $1 - node index
-# $2 - node commands endpoint
-# $3 - console commands endpoint
-node_run_user()
+# $2 - see $1 in nodes_list_cmdline()
+# $3 - see $2 in nodes_list_cmdline()
+node_list_params()
 {
-	node_run_remote_nowait $1 $CMD_NODE -a $2 -c $3
+	local index=$1
+	local space=$3
+	local role=$(node_get $index "role")
+	if [ "$role" == "$2" ]; then
+		local ssh_addr=$(node_get $index "ssh_addr")
+		local cmdline=$(node_get $index "cmdline_$space")
+		echo "$ssh_addr $space $cmdline"
+	fi
 }
 
-# see node_run_user()
-node_run_kernel()
+# $1 - 'client' or 'server'
+# $2 - 'cmdline_user' or 'cmdline_kernel'
+nodes_list_params()
 {
-	node_run_remote $1 modprobe $MOD_NODE "addr=$2" "addr_console=$3"
+	for_each_node node_list_params $@
 }
 
-# $1 - index of node in NODES array
-node_run()
+configure()
 {
-	local index=$1
-	local space=$(node_get $index "space")
-	local cmdline="$index \
-		       $(node_get $index "endpoint_cmd") \
-		       $(node_get $index "endpoint_console")"
-	if [ "$space" == "user" ]; then
-		node_run_user $cmdline
-	elif [ "$space" == "kernel" ]; then
-		node_run_kernel $cmdline
+	local space
+
+	nids_get
+	console_configure1
+	for_each_node node_nid_select
+	for_each_node node_configure
+	console_configure2
+
+	for space in "user" "kernel"; do
+		nodes_list_params "client" "$space" > "$FILE_CLIENTS_CMD-$space"
+		nodes_list_params "server" "$space" > "$FILE_SERVERS_CMD-$space"
+	done
+	CONSOLE_CMDLINE="$CONSOLE user $CONSOLE_CMDLINE"
+	echo $CONSOLE_CMDLINE > "$FILE_CONSOLE_CMD"
+
+	echo "$MSG_SIZE_LIST" > $FILE_MSG_SIZE
+	echo "$CONCURRENCY_CLIENT_LIST" > $FILE_CONCURRENCY
+}
+
+config_load()
+{
+	MSG_SIZE_LIST=$(cat $FILE_MSG_SIZE)
+	CONCURRENCY_CLIENT_LIST=$(cat $FILE_CONCURRENCY)
+	CONSOLE_CMDLINE=$(cat $FILE_CONSOLE_CMD)
+}
+
+# TODO current options are for 1 client/1 server
+console_cmdline_complement()
+{
+	local test_type=$1
+	local concurrency=$2
+	local msg_size=$3
+
+	CONCURRENCY_CLIENT=$concurrency
+	CONCURRENCY_SERVER=$(expr $concurrency "*" 2)
+	$ECHO_N "-t $test_type "
+	$ECHO_N "-n $MSG_NR "
+	$ECHO_N "-T $TEST_RUN_TIME "
+	$ECHO_N "-s $msg_size "
+	$ECHO_N "-E $CONCURRENCY_SERVER "
+	$ECHO_N "-e $CONCURRENCY_CLIENT "
+	if [ "$test_type" == "bulk" ]; then
+		BD_BUF_NR_CLIENT=$(expr $concurrency "*" 4)
+		BD_BUF_NR_SERVER=$(expr $concurrency "*" 4)
+		$ECHO_N "-B $BD_BUF_NR_SERVER "
+		$ECHO_N "-b $BD_BUF_NR_CLIENT "
+		$ECHO_N "-f $BD_BUF_SIZE "
+		$ECHO_N "-g $BD_NR_MAX "
 	fi
 }
 
-node_stop()
+test_params_echo()
 {
-	local index=$1
-	local ssh_pid=$(node_get $index "ssh_pid")
-	kill $ssh_pid || true 2> /dev/null
-	wait $ssh_pid || true 2> /dev/null
+	local space_clients="$1"
+	local space_servers="$2"
+	shift 2
+	echo "$@"
+	cat "$FILE_CLIENTS_CMD-$space_clients"
+	cat "$FILE_SERVERS_CMD-$space_servers"
 }
 
-node_kill()
+test_file_dir()
 {
-	local index=$1
-	kill -s SIGKILL $(node_get $index "ssh_pid") || true \
-		> /dev/null 2> /dev/null
+	local test_type=$1
+	local space_client=$2
+	local space_server=$3
+
+	echo "$DIR_DATA/$test_type-$space_client-$space_server"
+}
+
+result_dir()
+{
+	local test_type=$1
+	local space_client=$2
+	local space_server=$3
+
+	echo "$DIR_RESULT/$test_type-$space_client-$space_server"
+}
+
+test_table_prefix()
+{
+	echo "$(result_dir $@)/table"
+}
+
+test_file_prefix()
+{
+	local test_type=$1
+	local space_client=$2
+	local space_server=$3
+	local concurrency=$4
+	local msg_size=$5
+
+	echo "$(test_file_dir $@)/$concurrency-$msg_size"
+}
+
+dirs_make()
+{
+	$MKDIR "$(test_file_dir $@)"
+	$MKDIR "$(result_dir $@)"
+}
+
+test_run()
+{
+	local test_type=$1
+	local space_client=$2
+	local space_server=$3
+	local concurrency=$4
+	local msg_size=$5
+	local file_raw="$(test_file_prefix $@)-raw"
+	local console_cmdline
+
+	# skip already finished test
+	if [ -f "$file_raw" ]; then
+		return
+	fi
+	console_cmdline="$(console_cmdline_complement $test_type \
+			$concurrency $msg_size)"
+	console_cmdline="$CONSOLE_CMDLINE $console_cmdline"
+
+	test_params_echo "$space_client" "$space_server" "$console_cmdline" | \
+		$SCRIPT_TEST_RUN > $file_raw
+}
+
+table_filename()
+{
+	local measurement="$1"
+	local m_type="$2"
+	local table_prefix="$3"
+
+	echo "$table_prefix-$measurement-$m_type"
+}
+
+table_set0()
+{
+	local measurement="$1"
+	local m_type="$2"
+	shift 2
+	local table_prefix=$(test_table_prefix $@)
+	table_0 > "$(table_filename $measurement $m_type $table_prefix)"
+}
+
+tables_set0()
+{
+	for_each_measurement table_set0 $@
+}
+
+# $1 - function to call
+for_each_combination()
+{
+	local test_type
+	local space_client
+	local space_server
+	local concurrency
+	local msg_size
+	local func="$1"
+	shift 1
+	for test_type in "ping" "bulk"; do
+	    for space_client in "user" "kernel"; do
+		for space_server in "user" "kernel"; do
+		    for concurrency in $CONCURRENCY_CLIENT_LIST; do
+			for msg_size in $MSG_SIZE_LIST; do
+				"$func" $test_type $space_client $space_server \
+					$concurrency $msg_size $@
+			done
+		    done
+		done
+	    done
+	done
+}
+
+table_0()
+{
+	local concurrency
+	local filler0=$(yes 0 | head -n ${#MSG_SIZE_ARR[@]})
+
+	$ECHO_N "header "
+	$ECHO ${MSG_SIZE_ARR[@]}
+	for concurrency in "${CONCURRENCY_CLIENT_ARR[@]}"; do
+		$ECHO_N "$concurrency "
+		$ECHO $filler0
+	done
+}
+
+table_set()
+{
+	local filename="$1"
+	local msg_size="$2"
+	local concurrency="$3"
+	local value="$4"
+	local AWK_SCRIPT="{if (\$1 == $concurrency)
+			   { \$${MSG_SIZE_REVERSE[$msg_size]} = \"$value\" };
+			   print}"
+
+	awk "$AWK_SCRIPT" "$filename" > "$filename.NEW"
+	mv -f "$filename.NEW" "$filename"
+}
+
+# Output: value
+console_value_get()
+{
+	local file_raw="$1"
+	local role="$2"
+	local name="$3"
+
+	tail -n 2 "$file_raw" | grep "^$role" | tr ' ' '\n' | \
+		grep -A 1 "$name" | tail -n 1
+}
+
+for_each_measurement()
+{
+	local measurement
+	local m_type
+	local func=$1
+	shift 1
+	for measurement in ${MEASUREMENT_ARR[@]}; do
+		for m_type in ${M_TYPE_ARR[@]}; do
+			"$func" $measurement $m_type $@
+		done
+	done
+}
+
+console_measurement_parse()
+{
+	local measurement="$1"
+	local m_type="$2"
+	local table_prefix="$3"
+	local file_raw="$4"
+	local test_type="$5"
+	local msg_size="$6"
+	local concurrency="$7"
+	local value
+	local table_file="$(table_filename $measurement $m_type $table_prefix)"
+
+	case "$measurement" in
+	"Bandwidth"|"MPS")
+		# total bandwidth (in + out)
+		# (mps_sent_ + mps_received_) * msg_size
+		if [ "$measurement" == "Bandwidth" ]; then
+			value="$msg_size"
+		else
+			value=1
+		fi
+		local mps_sent=$(console_value_get "$file_raw" server \
+				 mps_sent_$m_type)
+		local mps_received=$(console_value_get "$file_raw" server \
+				     mps_received_$m_type)
+		value="$(expr \( $mps_sent + $mps_received \) \* $value)" ;;
+	"RTT")
+		# TODO save and draw server RTT for bulk tests
+		value="$(console_value_get "$file_raw" client rtt_$m_type)" ;;
+	esac
+
+	table_set "$table_file" "$msg_size" "$concurrency" "$value"
+}
+
+console_output_parse()
+{
+	local test_type=$1
+	local space_client=$2
+	local space_server=$3
+	local concurrency=$4
+	local msg_size=$5
+	local file_raw="$(test_file_prefix $@)-raw"
+	local table_prefix="$(test_table_prefix $@)"
+
+	for_each_measurement console_measurement_parse "$table_prefix" \
+		"$file_raw" "$test_type" "$msg_size" "$concurrency"
+}
+
+sample_get()
+{
+	local msg_size="$1"
+	local concurrency="$2"
+	local dir_name="$3"
+	local measurement="$4"
+	local m_type="$5"
+	local table_prefix="$DIR_RESULT/$dir_name/table"
+	local table_file="$(table_filename $measurement $m_type $table_prefix)"
+	local AWK_SCRIPT="{if (\$1 == $concurrency)
+			   print \$${MSG_SIZE_REVERSE[$msg_size]}}";
+	awk "$AWK_SCRIPT" "$table_file" | head -n 1
+}
+
+iterate_ox_msg_size()
+{
+	local samples_get="$1"
+	shift 1
+	local msg_size
+	[ "$1" == "0X" ] || exit 2
+	$ECHO $($samples_get "HEADER_GET" "$2" "$3" "$4" "$5" "HEADER_GET")
+	for msg_size in ${MSG_SIZE_ARR[@]}; do
+		$ECHO_N "$msg_size "
+		$ECHO $($samples_get "$msg_size" "$2" "$3" "$4" "$5" "EMPTY")
+	done
+}
+
+iterate_ox_concurrency()
+{
+	local samples_get="$1"
+	local concurrency
+	shift 1
+	[ "$2" == "0X" ] || exit 2
+	$ECHO $($samples_get "$1" "$2" "$3" "$4" "$5" "HEADER_GET")
+	for concurrency in ${CONCURRENCY_CLIENT_ARR[@]}; do
+		$ECHO_N "$concurrency "
+		$ECHO $($samples_get "$1" "$concurrency" "$3" "$4" "$5" "EMPTY")
+	done
+}
+
+samples_get_msg_size()
+{
+	local cmd="$6"
+	local msg_size
+
+	if [ "$cmd" == "HEADER_GET" ]; then
+		$ECHO_N "HEADER "
+		$ECHO "${MSG_SIZE_ARR[@]}"
+		return
+	fi
+	[ "$1" == "SAMPLES" ] || exit 2
+	for msg_size in ${MSG_SIZE_ARR[@]}; do
+		$ECHO_N " "
+		$ECHO_N $(sample_get "$msg_size" "$2" "$3" "$4" "$5")
+	done
+}
+
+samples_get_concurrency()
+{
+	local cmd="$6"
+	local concurrency
+
+	if [ "$cmd" == "HEADER_GET" ]; then
+		$ECHO_N "HEADER "
+		$ECHO "${CONCURRENCY_CLIENT_ARR[@]}"
+		return
+	fi
+	[ "$2" == "SAMPLES" ] || exit 2
+	for concurrency in ${CONCURRENCY_CLIENT_ARR[@]}; do
+		$ECHO_N " "
+		$ECHO_N $(sample_get "$1" "$concurrency" "$3" "$4" "$5")
+	done
+}
+
+samples_get_dir_name()
+{
+	local cmd="$6"
+	local dir_name
+
+	if [ "$cmd" == "HEADER_GET" ]; then
+		$ECHO_N "HEADER "
+		for dir_name in ${DIR_NAME_ARR[@]}; do
+			echo "\"$dir_name\" "
+		done
+		return
+	fi
+	[ "$3" == "SAMPLES" ] || exit 2
+	for dir_name in ${DIR_NAME_ARR[@]}; do
+		$ECHO_N " "
+		$ECHO_N $(sample_get "$1" "$2" "$dir_name" "$4" "$5")
+	done
+}
+
+samples_get_m_type()
+{
+	local cmd="$6"
+	local m_type
+
+	if [ "$cmd" == "HEADER_GET" ]; then
+		$ECHO_N "HEADER "
+		$ECHO "${M_TYPE_ARR[@]}"
+		return
+	fi
+	[ "$5" == "SAMPLES" ] || exit 2
+	for m_type in ${M_TYPE_ARR[@]}; do
+		$ECHO_N " "
+		$ECHO_N $(sample_get "$1" "$2" "$3" "$4" "$m_type")
+	done
+}
+
+plot_script_2d()
+{
+	local title="$1"
+	local plot_file="$2"
+	local out_file="$3"
+	local NF=$(head -n 1 "$plot_file" | awk '{print NF}')
+
+	$ECHO "reset"
+	$ECHO "set terminal png"
+	$ECHO "set out \"$out_file\""
+	$ECHO "set grid"
+	$ECHO "set title \"$title\""
+	$ECHO "set datafile missing \"-\""
+	$ECHO "set xtics nomirror rotate by -45 font \",8\""
+	$ECHO "set key noenhanced"
+	$ECHO "set style data linespoints"
+	$ECHO "# set logscale y"
+	$ECHO "plot '$plot_file' using 2:xtic(1) title columnheader(2),	\\"
+	$ECHO "for [i=3:$NF] '' using i title columnheader(i)"
+}
+
+draw_graph_2d_prepare()
+{
+	local func_iterate="$1"
+	local func_sample_get="$2"
+	local title="$3"
+	shift 3
+	local msg_size="$1"
+	local concurrency="$2"
+	local dir_name="$3"
+	local measurement="$4"
+	local m_type="$5"
+	local root="$msg_size-$concurrency-$dir_name-$measurement-$m_type"
+	local script_prefix="$DIR_PLOT_SCRIPTS/$root"
+	local plot_file="$script_prefix.txt"
+	local script_file="$script_prefix.gnu"
+	local out_file="$DIR_RESULT/$root.png"
+
+	$func_iterate $func_sample_get $@ > "$plot_file"
+	plot_script_2d "$title" "$plot_file" "$out_file" > "$script_file"
+}
+
+draw_graph_2d_measurement()
+{
+	local measurement="$1"
+	local title_prefix="$2"
+	local msg_size
+	local concurrency
+	local dir_name
+	local m_type
+	local title
+	local script_prefix
+
+	dir_name="SAMPLES"
+	m_type="avg"
+	msg_size="0X"
+	for concurrency in ${CONCURRENCY_CLIENT_ARR[@]}; do
+		title="$title_prefix. Concurrency = $concurrency"
+		draw_graph_2d_prepare iterate_ox_msg_size samples_get_dir_name \
+			"$title" "$msg_size" "$concurrency" \
+			"$dir_name" "$measurement" "$m_type"
+	done
+	concurrency="0X"
+	for msg_size in ${MSG_SIZE_ARR[@]}; do
+		title="$title_prefix. Test message size = $msg_size bytes"
+		draw_graph_2d_prepare iterate_ox_concurrency \
+			samples_get_dir_name \
+			"$title" "$msg_size" "$concurrency" \
+			"$dir_name" "$measurement" "$m_type"
+	done
+	msg_size="0X"
+	concurrency="SAMPLES"
+	for dir_name in ${DIR_NAME_ARR[@]}; do
+		title="$title_prefix. $dir_name"
+		draw_graph_2d_prepare iterate_ox_msg_size \
+			samples_get_concurrency \
+			"$title" "$msg_size" "$concurrency" \
+			"$dir_name" "$measurement" "$m_type"
+	done
+	msg_size="SAMPLES"
+	concurrency="0X"
+	for dir_name in ${DIR_NAME_ARR[@]}; do
+		title="$title_prefix. $dir_name"
+		draw_graph_2d_prepare iterate_ox_concurrency \
+			samples_get_msg_size \
+			"$title" "$msg_size" "$concurrency" \
+			"$dir_name" "$measurement" "$m_type"
+	done
+	msg_size="0X"
+	m_type="SAMPLES"
+	for concurrency in ${CONCURRENCY_CLIENT_ARR[@]}; do
+		for dir_name in ${DIR_NAME_ARR[@]}; do
+			title="$title_prefix. Concurrency = $concurrency"
+			title="$title, $dir_name"
+			draw_graph_2d_prepare iterate_ox_msg_size \
+				samples_get_m_type \
+				"$title" "$msg_size" "$concurrency" \
+				"$dir_name" "$measurement" "$m_type"
+		done
+	done
+	concurrency="0X"
+	for msg_size in ${MSG_SIZE_ARR[@]}; do
+		for dir_name in ${DIR_NAME_ARR[@]}; do
+			title="$title_prefix. Test message size = $msg_size"
+			title="$title, $dir_name"
+			draw_graph_2d_prepare iterate_ox_concurrency \
+				samples_get_m_type \
+				"$title" "$msg_size" "$concurrency" \
+				"$dir_name" "$measurement" "$m_type"
+		done
+	done
+}
+
+draw_graphs_2d()
+{
+	declare -A title_start
+
+	title_start["Bandwidth"]="Bandwidth, bytes/s"
+	title_start["RTT"]="Round-trip time, ns"
+	title_start["MPS"]="Messages per Second"
+	for measurement in ${MEASUREMENT_ARR[@]}; do
+		draw_graph_2d_measurement "$measurement" \
+			"${title_start[$measurement]}"
+	done
+}
+
+# TODO
+draw_graphs_3d()
+{
+	true
+}
+
+gnuplot_run()
+{
+	find "$DIR_PLOT_SCRIPTS" -name "*.gnu" | xargs -L1 $GNUPLOT
 }
 
-console_run()
+draw_graphs()
 {
-	echo $FUNCNAME
+	draw_graphs_2d
+	draw_graphs_3d
+	gnuplot_run
 }
 
 main "$@"
-- 
1.8.3.2

