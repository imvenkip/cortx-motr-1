From cd64442a10bd3543d2900bd7aba4a213746ae7ba Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Thu, 31 Jan 2013 04:26:02 +0800
Subject: [PATCH 05/11] layout lookup client and mds code.

---
 m0t1fs/linux_kernel/dir.c    | 46 +++++++++++++++++++---
 m0t1fs/linux_kernel/m0t1fs.h |  9 ++++-
 m0t1fs/linux_kernel/super.c  | 56 ++++++++++++++++++++++++++-
 mdservice/md_foms.c          | 90 +++++++++++++++++++++++++-------------------
 4 files changed, 154 insertions(+), 47 deletions(-)

diff --git a/m0t1fs/linux_kernel/dir.c b/m0t1fs/linux_kernel/dir.c
index 51dfaa3..d979642 100644
--- a/m0t1fs/linux_kernel/dir.c
+++ b/m0t1fs/linux_kernel/dir.c
@@ -29,6 +29,8 @@
 #include "rpc/rpc_opcodes.h"
 #include "ioservice/io_device.h"
 #include "mero/magic.h"
+#include "layout/layout.h"
+#include "layout/pdclust.h"
 #include "m0t1fs/linux_kernel/m0t1fs.h"
 
 M0_INTERNAL void m0t1fs_inode_bob_init(struct m0t1fs_inode *bob);
@@ -895,7 +897,9 @@ static int m0t1fs_mds_cob_fop_populate(const struct m0t1fs_mdop *mo,
 		layout->l_lid = mo->mo_layout_id;
 
 		if (layout->l_op == M0_LAYOUT_OP_CREATE ||
-					layout->l_op == M0_LAYOUT_OP_DELETE) {
+		    layout->l_op == M0_LAYOUT_OP_DELETE) {
+			M0_ASSERT(l != NULL);
+
 			layout->l_buf.b_count = m0_layout_max_recsize(
 						&m0t1fs_globals.g_layout_dom);
 			layout->l_buf.b_addr = m0_alloc(layout->l_buf.b_count);
@@ -1069,19 +1073,21 @@ out:
         return rc;
 }
 
+
 int m0t1fs_layout_op(struct m0t1fs_sb *csb, enum m0_layout_opcode op,
-		     uint64_t lid)
+		     uint64_t lid, struct m0_layout **l_out)
 {
 	struct m0t1fs_mdop        mo = { {  { 0 } } };
 	struct m0_fop_layout_rep *rep = NULL;
 	int                       rc;
 	struct m0_layout         *layout = NULL;
+	struct m0_layout_domain  *ldom = &m0t1fs_globals.g_layout_dom;
 
 	M0_ENTRY();
 
 	M0_LOG(M0_DEBUG, "layout op = %u lid = %llu", op, lid);
 	if (op == M0_LAYOUT_OP_CREATE || op == M0_LAYOUT_OP_DELETE) {
-		layout = m0_layout_find(&m0t1fs_globals.g_layout_dom, lid);
+		layout = m0_layout_find(ldom, lid);
 		if (layout == NULL)
 			M0_RETURN(-ENOENT);
 	}
@@ -1095,12 +1101,40 @@ int m0t1fs_layout_op(struct m0t1fs_sb *csb, enum m0_layout_opcode op,
 	if (rc == 0) {
 		M0_LOG(M0_DEBUG, "layout rep rc = %d", rep->lr_rc);
 
-		if (op == M0_LAYOUT_OP_LOOKUP)
-			(void)rep; /* decode layout from rep */
+		if (op == M0_LAYOUT_OP_LOOKUP) {
+			struct m0_bufvec               bv;
+			struct m0_bufvec_cursor        cur;
+			struct m0_layout              *l;
+			struct m0_layout_type         *lt;
+			M0_ASSERT(l_out != NULL);
+
+		        bv = (struct m0_bufvec)
+				M0_BUFVEC_INIT_BUF((void**)&rep->lr_buf.b_addr,
+					   (m0_bcount_t*)&rep->lr_buf.b_count);
+			m0_bufvec_cursor_init(&cur, &bv);
+
+			lt = &m0_pdclust_layout_type;
+			rc = lt->lt_ops->lto_allocate(ldom, lid, &l);
+			if (rc == 0) {
+				rc = m0_layout_decode(l, &cur, M0_LXO_BUFFER_OP,
+							NULL);
+				/* release lock held by ->lto_allocate() */
+				m0_mutex_unlock(&l->l_lock);
+				if (rc == 0) {
+					/* m0_layout_put() should be called
+					 * after use of this l_out */
+					*l_out = l;
+				} else {
+					m0_layout_put(l);
+				}
+			}
+		}
 	}
 	m0t1fs_fs_unlock(csb);
+
 	if (layout != NULL)
-		m0_layout_put(layout);
+		m0_layout_put(layout); /* dual to m0_layout_find() */
+
 	M0_RETURN(rc);
 }
 
diff --git a/m0t1fs/linux_kernel/m0t1fs.h b/m0t1fs/linux_kernel/m0t1fs.h
index c697fb8..a891d16 100644
--- a/m0t1fs/linux_kernel/m0t1fs.h
+++ b/m0t1fs/linux_kernel/m0t1fs.h
@@ -747,9 +747,16 @@ M0_INTERNAL int m0t1fs_mds_cob_readdir(struct m0t1fs_sb           *csb,
                                        const struct m0t1fs_mdop   *mo,
                                        struct m0_fop_readdir_rep **rep);
 
+/** layout operation from client to mds.
+ * @param op in {CREATE/DELETE/LOOKUP}
+ * @param lid layout id
+ * @param l_out if op is LOOKUP, new layout is returned here. If *l_out is
+ *        returned properly, m0_layout_put() should be called after use.
+ */
 M0_INTERNAL int m0t1fs_layout_op(struct m0t1fs_sb *csb,
 			         enum m0_layout_opcode op,
-			         uint64_t lid);
+			         uint64_t lid,
+				 struct m0_layout **l_out);
 
 M0_INTERNAL int m0t1fs_size_update(struct inode *inode,
                                    uint64_t newsize);
diff --git a/m0t1fs/linux_kernel/super.c b/m0t1fs/linux_kernel/super.c
index ef70c56..72cdbcf 100644
--- a/m0t1fs/linux_kernel/super.c
+++ b/m0t1fs/linux_kernel/super.c
@@ -36,6 +36,17 @@
 #include "conf/confc.h"    /* m0_confc */
 #include "rpc/rpclib.h"    /* m0_rcp_client_connect */
 
+static int m0t1fs_layout_build(const uint64_t         layout_id,
+			       const uint32_t         N,
+			       const uint32_t         K,
+			       const uint32_t         pool_width,
+			       const uint64_t         unit_size,
+			       struct m0_layout_enum *le,
+			       struct m0_layout     **layout);
+
+static int m0t1fs_cob_id_enum_build(const uint32_t pool_width,
+				    struct m0_layout_enum **lay_enum);
+
 extern struct io_mem_stats iommstats;
 
 M0_INTERNAL void io_bob_tlists_init(void);
@@ -687,10 +698,53 @@ static int m0t1fs_root_alloc(struct super_block *sb)
 		M0_RETURN(rc);
 
 	/* create the new layout on mds: -EEXIST is OK */
-	rc = m0t1fs_layout_op(csb, M0_LAYOUT_OP_CREATE, csb->csb_layout_id);
+	rc = m0t1fs_layout_op(csb, M0_LAYOUT_OP_CREATE, csb->csb_layout_id,
+				NULL);
 	if (rc != 0 && rc != -EEXIST)
 		M0_RETURN(rc);
 
+	if (0) {/* testing */
+		uint64_t lid1 = 1234;
+		uint64_t lid2 = 5678;
+		struct m0_layout *l1;
+		struct m0_layout *l2;
+		struct m0_layout *tmp = NULL;
+		struct m0_layout_enum *layout_enum;
+
+		m0t1fs_cob_id_enum_build(10, &layout_enum);
+		rc = m0t1fs_layout_build(lid1,
+					 4,
+					 1,
+					 10,
+					 4096, layout_enum,
+					 &l1);
+		M0_ASSERT(rc == 0 && l1 != NULL);
+		rc = m0t1fs_layout_op(csb, M0_LAYOUT_OP_CREATE, lid1, NULL);
+		M0_ASSERT(rc == 0);
+		m0_layout_put(l1);
+
+		m0t1fs_cob_id_enum_build(20, &layout_enum);
+		rc = m0t1fs_layout_build(lid2,
+					 6,
+					 2,
+					 20,
+					 4096 * 16, layout_enum,
+					 &l2);
+		M0_ASSERT(rc == 0 && l2 != NULL);
+		rc = m0t1fs_layout_op(csb, M0_LAYOUT_OP_CREATE, lid2, NULL);
+		M0_ASSERT(rc == 0);
+		m0_layout_put(l2);
+
+		rc = m0t1fs_layout_op(csb, M0_LAYOUT_OP_LOOKUP, lid1, &tmp);
+		M0_ASSERT(rc == 0);
+		m0_layout_put(tmp);
+		rc = m0t1fs_layout_op(csb, M0_LAYOUT_OP_LOOKUP, lid2, &tmp);
+		M0_ASSERT(rc == 0);
+		m0_layout_put(tmp);
+		rc = m0t1fs_layout_op(csb, M0_LAYOUT_OP_LOOKUP, lid2 + lid1, &tmp);
+		M0_ASSERT(rc =! 0);
+	}
+
 	sb->s_magic = rep->f_type;
 	csb->csb_namelen = rep->f_namelen;
 
diff --git a/mdservice/md_foms.c b/mdservice/md_foms.c
index eaecec2..23d6c11 100644
--- a/mdservice/md_foms.c
+++ b/mdservice/md_foms.c
@@ -1055,51 +1055,63 @@ static int m0_md_tick_layout(struct m0_fom *fom)
         serv_obj = container_of(fom->fo_service, struct m0_reqh_md_service,
 				rmds_gen);
 
-        bv = (struct m0_bufvec) M0_BUFVEC_INIT_BUF((void**)&req->l_buf.b_addr,
+        m0_fom_block_enter(fom);
+	switch (req->l_op) {
+	case M0_LAYOUT_OP_CREATE:
+	case M0_LAYOUT_OP_DELETE:
+		bv = (struct m0_bufvec)
+			M0_BUFVEC_INIT_BUF((void**)&req->l_buf.b_addr,
 					   (m0_bcount_t*)&req->l_buf.b_count);
-        m0_bufvec_cursor_init(&cur, &bv);
-
-        lt = &m0_pdclust_layout_type;
+		m0_bufvec_cursor_init(&cur, &bv);
+		lt = &m0_pdclust_layout_type;
 
-        m0_fom_block_enter(fom);
-        rc = lt->lt_ops->lto_allocate(&serv_obj->rmds_layout_dom,
-				      req->l_lid, &l);
-	if (rc == 0) {
-		switch (req->l_op) {
-		case M0_LAYOUT_OP_CREATE:
-			rc = m0_layout_decode(l, &cur, M0_LXO_BUFFER_OP, NULL);
-	                m0_mutex_unlock(&l->l_lock);/* release lock held by ->lto_allocate() */
-			if (rc == 0) {
-				M0_LOG(M0_DEBUG, "Start creating");
-				layout_pair_set(&pair, &req->l_lid,
-						req->l_buf.b_addr,
-						req->l_buf.b_count);
-				rc = m0_layout_add(l, &fom->fo_tx.tx_dbtx, &pair);
-				M0_LOG(M0_DEBUG, "Creation Done");
-			}
+		rc = lt->lt_ops->lto_allocate(&serv_obj->rmds_layout_dom,
+						req->l_lid, &l);
+		if (rc != 0)
 			break;
-		case M0_LAYOUT_OP_DELETE:
-			rc = m0_layout_decode(l, &cur, M0_LXO_BUFFER_OP, NULL);
-	                m0_mutex_unlock(&l->l_lock);/* release lock held by ->lto_allocate() */
-			if (rc == 0) {
-				M0_LOG(M0_DEBUG, "Start deleting");
-				layout_pair_set(&pair, &req->l_lid,
-						req->l_buf.b_addr,
-						req->l_buf.b_count);
-				rc = m0_layout_delete(l, &fom->fo_tx.tx_dbtx, &pair);
-				M0_LOG(M0_DEBUG, "Deletion Done");
-			}
-			break;
-		case M0_LAYOUT_OP_LOOKUP:
-	                m0_mutex_unlock(&l->l_lock);/* release lock held by ->lto_allocate() */
-			// Lookup from db and encode into reply.
-			// m0_layout_lookup()
-			// m0_layout_encode()
-			M0_LOG(M0_DEBUG, "Lookup Done");
+
+		rc = m0_layout_decode(l, &cur, M0_LXO_BUFFER_OP, NULL);
+                m0_mutex_unlock(&l->l_lock);/* lock held by ->lto_allocate() */
+		if (rc == 0) {
+			M0_LOG(M0_DEBUG, "Start");
+			layout_pair_set(&pair, &req->l_lid,
+					req->l_buf.b_addr,
+					req->l_buf.b_count);
+			if (req->l_op == M0_LAYOUT_OP_CREATE)
+				rc = m0_layout_add(l, &fom->fo_tx.tx_dbtx,
+							&pair);
+			else if (req->l_op == M0_LAYOUT_OP_DELETE)
+				rc = m0_layout_delete(l, &fom->fo_tx.tx_dbtx,
+							&pair);
+			M0_LOG(M0_DEBUG, "Done");
+		}
+		m0_layout_put(l); /* ref from ->lto_allocate() */
+		break;
+
+	case M0_LAYOUT_OP_LOOKUP:
+		M0_LOG(M0_DEBUG, "Lookup Start");
+
+		rep->lr_buf.b_count = m0_layout_max_recsize(
+					&serv_obj->rmds_layout_dom);
+		rep->lr_buf.b_addr = m0_alloc(rep->lr_buf.b_count);
+		if (rep->lr_buf.b_addr == NULL) {
+			rc = -ENOMEM;
 			break;
 		}
-                m0_layout_put(l);
+
+		layout_pair_set(&pair, &req->l_lid,
+				rep->lr_buf.b_addr,
+				rep->lr_buf.b_count);
+		/* lookup from db and encode into pair */
+		rc = m0_layout_lookup(&serv_obj->rmds_layout_dom, req->l_lid,
+				      &m0_pdclust_layout_type,
+				      &fom->fo_tx.tx_dbtx, &pair, &l);
+		if (rc == 0)
+			m0_layout_put(l);
+		M0_LOG(M0_DEBUG, "Lookup Done");
+		break;
 	}
+
         m0_fom_block_leave(fom);
 out:
         rep->lr_rc = rc;
-- 
1.8.3.2

