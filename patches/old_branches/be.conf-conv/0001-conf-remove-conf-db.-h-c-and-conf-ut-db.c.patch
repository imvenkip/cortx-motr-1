From a78088d7cb126aec342b0f159e91c13b1dbb88da Mon Sep 17 00:00:00 2001
From: "Valery V. Vorotyntsev" <valery_vorotyntsev@xyratex.com>
Date: Tue, 30 Jul 2013 23:15:10 +0300
Subject: [PATCH 1/2] conf: remove conf/db.{h,c} and conf/ut/db.c

conf.db was never used.

This commit is part of db5-to-BE conversion task.
TODO: conf/ut/rpc_helpers.c still uses db5 API. It should be converted to BE.
---
 conf/Makefile.sub     |   2 -
 conf/confd.c          |   4 -
 conf/db.c             | 576 --------------------------------------------------
 conf/db.h             |  45 ----
 conf/obj.c            |   7 -
 conf/ut/Makefile.sub  |   1 -
 conf/ut/cache.c       |  11 +-
 conf/ut/db.c          | 215 -------------------
 conf/ut/fuzz.c        |  11 -
 conf/ut/rpc_helpers.c |  10 +-
 utils/ut_main.c       |   6 +-
 11 files changed, 14 insertions(+), 874 deletions(-)
 delete mode 100644 conf/db.c
 delete mode 100644 conf/db.h
 delete mode 100644 conf/ut/db.c

diff --git a/conf/Makefile.sub b/conf/Makefile.sub
index 857de32..b25f648 100644
--- a/conf/Makefile.sub
+++ b/conf/Makefile.sub
@@ -5,7 +5,6 @@ nobase_mero_include_HEADERS += \
                                conf/confc.h \
                                conf/confd.h \
                                conf/confd_fom.h \
-                               conf/db.h \
                                conf/fop.h \
                                conf/obj.h \
                                conf/obj_ops.h \
@@ -20,7 +19,6 @@ mero_libmero_la_SOURCES += \
                            conf/confc.c \
                            conf/confd.c \
                            conf/confd_fom.c \
-                           conf/db.c \
                            conf/fop.c \
                            conf/obj.c \
                            conf/obj_ops.c \
diff --git a/conf/confd.c b/conf/confd.c
index 7c17522..0cc7d38 100644
--- a/conf/confd.c
+++ b/conf/confd.c
@@ -54,7 +54,6 @@
  *
  * Confd depends on the following subsystems:
  * - @ref rpc_service <!-- rpc/service.h -->
- * - @ref db  <!-- db/db.h -->
  * - @ref fom <!-- fop/fom.h -->
  * - @ref fop <!-- fop/fop.h -->
  * - @ref reqh <!-- reqh/reqh.h -->
@@ -68,9 +67,6 @@
  * Most important functions, confd depends on, are listed above:
  * - RPC layer:
  *   - m0_rpc_reply_post() used to send FOP-based reply to Confc;
- * - DB layer:
- *   - m0_db_pair_setup() and m0_table_lookup() used to access
- *     configuration values stored in db.
  * - FOP, FOM, REQH:
  *   - m0_fom_block_at();
  *   - m0_fom_block_leave();
diff --git a/conf/db.c b/conf/db.c
deleted file mode 100644
index f5a8783..0000000
--- a/conf/db.c
+++ /dev/null
@@ -1,576 +0,0 @@
-/* -*- c -*- */
-/*
- * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
- * Original creation date: 25-Sep-2012
- */
-
-#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_CONF
-#include "lib/trace.h"
-
-#include "conf/db.h"
-#include "conf/onwire.h"     /* m0_confx_obj, m0_confx */
-#include "conf/onwire_xc.h"
-#include "conf/obj.h"        /* m0_conf_objtype */
-#include "xcode/xcode.h"
-#include "db/db.h"
-#include "lib/memory.h"      /* m0_alloc, m0_free */
-#include "lib/errno.h"       /* EINVAL */
-#include "lib/misc.h"        /* M0_SET0 */
-
-/* ------------------------------------------------------------------
- * xcoding: m0_confx_obj <--> raw buffer
- * ------------------------------------------------------------------ */
-
-static void *
-_conf_xcode_alloc(struct m0_xcode_cursor *ctx M0_UNUSED, size_t nob)
-{
-	return m0_alloc(nob);
-}
-
-static enum m0_conf_objtype xobj_type(const struct m0_confx_obj *xobj)
-{
-	uint32_t t = xobj->o_conf.u_type;
-
-	M0_CASSERT(M0_CO_DIR == 0);
-	M0_POST(t < M0_CO_NR && t != M0_CO_DIR);
-	return t;
-}
-
-/* Note: m0_xcode_ctx_init() doesn't allow `xobj' to be const. Sigh. */
-static int
-xcode_ctx_init(struct m0_xcode_ctx *ctx, struct m0_confx_obj *xobj, bool decode)
-{
-	M0_ENTRY();
-
-	switch(xobj_type(xobj)) {
-#define _CASE(type, abbrev)                                                    \
-	case type:                                                             \
-		m0_xcode_ctx_init(                                             \
-			ctx,                                                   \
-			&M0_XCODE_OBJ(                                         \
-				m0_confx_ ## abbrev ## _xc,                    \
-				decode ? NULL : &xobj->o_conf.u.u_ ## abbrev));\
-		break
-
-	_CASE(M0_CO_PROFILE,    profile);
-	_CASE(M0_CO_FILESYSTEM, filesystem);
-	_CASE(M0_CO_SERVICE,    service);
-	_CASE(M0_CO_NODE,       node);
-	_CASE(M0_CO_NIC,        nic);
-	_CASE(M0_CO_SDEV,       sdev);
-	_CASE(M0_CO_PARTITION,  partition);
-#undef _CASE
-	case M0_CO_DIR:
-	default:
-		M0_RETERR(-EINVAL, "Invalid object type: %u", xobj_type(xobj));
-	}
-
-	if (decode)
-		ctx->xcx_alloc = _conf_xcode_alloc;
-
-	M0_RETURN(0);
-}
-
-static int confx_obj_measure(struct m0_confx_obj *xobj, m0_bcount_t *result)
-{
-	struct m0_xcode_ctx ctx;
-	int                 rc;
-
-	M0_ENTRY();
-
-	rc = xcode_ctx_init(&ctx, xobj, false);
-	if (rc != 0)
-		M0_RETURN(rc);
-
-	rc = m0_xcode_length(&ctx);
-	if (rc < 0)
-		M0_RETURN(rc);
-	M0_ASSERT(rc != 0); /* XXX How can we be so sure? */
-
-	*result = rc;
-	M0_RETURN(0);
-}
-
-/* ------------------------------------------------------------------
- * confdb_obj
- * ------------------------------------------------------------------ */
-
-/**
- * Database representation of a configuration object.
- *
- * confdb_obj can be stored in a database.
- */
-struct confdb_obj {
-	struct m0_buf do_key; /*< Object identifier. */
-	struct m0_buf do_rec; /*< Object fields. */
-};
-
-/**
- * Encodes m0_confx_obj into the corresponding database representation.
- *
- * If the call succeeds, the user is responsible for freeing allocated memory:
- * @code
- *         m0_buf_free(&dest->do_rec);
- * @endcode
- *
- * @note  xcode API doesn't let `src' to be const.
- */
-static int confx_to_db(struct m0_confx_obj *src, struct confdb_obj *dest)
-{
-	struct m0_xcode_ctx ctx;
-	int                 rc;
-	void               *buf;
-	m0_bcount_t         len;
-	struct m0_bufvec    bvec = M0_BUFVEC_INIT_BUF(&buf, &len);
-
-	M0_ENTRY();
-
-	rc = confx_obj_measure(src, &len) ?: xcode_ctx_init(&ctx, src, false);
-	if (rc != 0)
-		M0_RETURN(rc);
-
-	M0_ALLOC_ARR(buf, len);
-	if (buf == NULL)
-		M0_RETURN(-ENOMEM);
-
-	m0_bufvec_cursor_init(&ctx.xcx_buf, &bvec);
-	rc = m0_xcode_encode(&ctx);
-	if (rc != 0) {
-		m0_free(buf);
-		M0_RETURN(rc);
-	}
-
-	dest->do_key = src->o_id;
-	m0_buf_init(&dest->do_rec, buf, len);
-
-	M0_RETURN(0);
-}
-
-/**
- * Decodes m0_confx_obj from its database representation.
- *
- * @note  XXX User is responsible for freeing `dest' array with
- *        m0_confx_free().
- */
-static int confx_from_db(struct m0_confx_obj *dest, enum m0_conf_objtype type,
-			 struct confdb_obj *src)
-{
-	struct m0_xcode_ctx ctx;
-	int                 rc;
-	struct m0_bufvec    bvec = M0_BUFVEC_INIT_BUF(&src->do_rec.b_addr,
-						      &src->do_rec.b_nob);
-	M0_ENTRY();
-	M0_PRE(M0_CO_DIR < type && type < M0_CO_NR);
-
-	dest->o_conf.u_type = type;
-
-	rc = xcode_ctx_init(&ctx, dest, true);
-	if (rc != 0)
-		M0_RETURN(rc);
-
-	m0_bufvec_cursor_init(&ctx.xcx_buf, &bvec);
-	rc = m0_xcode_decode(&ctx);
-	if (rc != 0)
-		M0_RETURN(rc);
-
-	switch(type) {
-#define _CASE(type, abbrev)                                                   \
-	case type:                                                            \
-		dest->o_conf.u.u_ ## abbrev = *(struct m0_confx_ ## abbrev *) \
-			ctx.xcx_it.xcu_stack[0].s_obj.xo_ptr;                 \
-		break
-
-	_CASE(M0_CO_PROFILE,    profile);
-	_CASE(M0_CO_FILESYSTEM, filesystem);
-	_CASE(M0_CO_SERVICE,    service);
-	_CASE(M0_CO_NODE,       node);
-	_CASE(M0_CO_NIC,        nic);
-	_CASE(M0_CO_SDEV,       sdev);
-	_CASE(M0_CO_PARTITION,  partition);
-#undef _CASE
-	case M0_CO_DIR:
-	default:
-		M0_IMPOSSIBLE("filtered out by xcode_ctx_init()");
-		M0_RETURN(-EINVAL);
-	}
-
-	M0_SET0(&dest->o_id); /* to satisfy the precondition of m0_buf_copy() */
-	m0_buf_copy(&dest->o_id, &src->do_key);
-
-	/* Free the memory allocated by m0_xcode_decode(). */
-	m0_free(ctx.xcx_it.xcu_stack[0].s_obj.xo_ptr);
-
-	M0_RETURN(rc);
-}
-
-/* ------------------------------------------------------------------
- * Tables, confdb_key
- * ------------------------------------------------------------------ */
-
-enum {
-	CONFDB_SRV_EP_MAX = 16,
-	CONFDB_FS_MAX     = 16,
-	CONFDB_NICS_MAX   = 16,
-	CONFDB_SDEVS_MAX  = 16,
-	CONFDB_PART_MAX   = 16,
-	CONFDB_UUID_SIZE  = 40,
-	CONFDB_NAME_LEN   = 256,
-
-	/* XXX FIXME: very inaccurate estimations */
-	CONFDB_REC_MAX    = sizeof(struct m0_confx_obj) + CONFDB_NAME_LEN * (
-		CONFDB_SRV_EP_MAX + CONFDB_FS_MAX + CONFDB_NICS_MAX +
-		CONFDB_SDEVS_MAX + CONFDB_PART_MAX)
-};
-
-/** XXX DOCUMENTME */
-struct confdb_key {
-	uint8_t cdk_len;
-	char    cdk_key[CONFDB_UUID_SIZE];
-};
-
-static int
-confdb_key_cmp(struct m0_table *_ M0_UNUSED, const void *key0, const void *key1)
-{
-	const struct confdb_key *k0 = key0;
-	const struct confdb_key *k1 = key1;
-
-	return memcmp(k0->cdk_key, k1->cdk_key,
-		      min_check(k0->cdk_len, k1->cdk_len));
-}
-
-static const struct m0_table_ops table_ops = {
-	.to = {
-		[TO_KEY] = { .max_size = sizeof(struct confdb_key) },
-		[TO_REC] = { .max_size = CONFDB_REC_MAX }
-	},
-	.key_cmp = confdb_key_cmp
-};
-
-static void
-confdb_obj_to_key(const struct confdb_obj *src, struct confdb_key *dest)
-{
-	const struct m0_buf *k = &src->do_key;
-
-	M0_ENTRY();
-	M0_PRE(k->b_nob < sizeof dest->cdk_key);
-
-	dest->cdk_len = k->b_nob;
-	memcpy(dest->cdk_key, k->b_addr, k->b_nob);
-
-	M0_LEAVE();
-}
-
-/* XXX Consider using "The X macro":
- * http://www.drdobbs.com/cpp/the-x-macro/228700289 */
-static const char *table_names[] = {
-	[M0_CO_DIR]        = NULL,
-	[M0_CO_PROFILE]    = "profile",
-	[M0_CO_FILESYSTEM] = "filesystem",
-	[M0_CO_SERVICE]    = "service",
-	[M0_CO_NODE]       = "node",
-	[M0_CO_NIC]        = "nic",
-	[M0_CO_SDEV]       = "sdev",
-	[M0_CO_PARTITION]  = "partition"
-};
-M0_BASSERT(ARRAY_SIZE(table_names) == M0_CO_NR);
-
-static void confdb_tables_fini(struct m0_table *tables, size_t n)
-{
-	M0_ENTRY();
-	while (n > 0) {
-		--n;
-		if (table_names[n] != NULL)
-			m0_table_fini(&tables[n]);
-	}
-	M0_LEAVE();
-}
-
-static int
-confdb_tables_init(struct m0_dbenv *db, struct m0_table *tables, size_t n)
-{
-	int i;
-	int rc = 0;
-
-	M0_ENTRY();
-	M0_PRE(n == ARRAY_SIZE(table_names));
-
-	for (i = 0; i < n; ++i) {
-		if (table_names[i] == NULL)
-			continue;
-
-		rc = m0_table_init(&tables[i], db, table_names[i], 0,
-				   &table_ops);
-		if (rc != 0) {
-			confdb_tables_fini(tables, i);
-			break;
-		}
-	}
-	M0_RETURN(rc);
-}
-
-/* ------------------------------------------------------------------
- * Database operations
- * ------------------------------------------------------------------ */
-
-M0_INTERNAL int
-m0_confdb_create(const char *dbpath, const struct m0_confx *conf)
-{
-	struct m0_dbenv   db;
-	struct m0_table  *tables;
-	struct m0_db_tx   tx;
-	struct m0_db_pair pair;
-	struct confdb_obj db_obj;
-	struct confdb_key key;
-	int               i;
-	int               rc;
-
-	M0_ENTRY();
-	M0_PRE(conf->cx_nr > 0);
-
-	M0_ALLOC_ARR(tables, ARRAY_SIZE(table_names));
-	if (tables == NULL)
-		M0_RETURN(-ENOMEM);
-
-	rc = m0_dbenv_init(&db, dbpath, 0);
-	if (rc != 0)
-		goto tables_free;
-
-	rc = confdb_tables_init(&db, tables, ARRAY_SIZE(table_names));
-	if (rc != 0)
-		goto dbenv_fini;
-
-	rc = m0_db_tx_init(&tx, &db, 0);
-	if (rc != 0)
-		goto tables_fini;
-
-	for (i = 0; i < conf->cx_nr && rc == 0; ++i) {
-		M0_ASSERT(IS_IN_ARRAY(xobj_type(&conf->cx_objs[i]),
-				      table_names));
-		rc = confx_to_db(&conf->cx_objs[i], &db_obj);
-		if (rc != 0)
-			break;
-
-		confdb_obj_to_key(&db_obj, &key);
-		m0_db_pair_setup(&pair, &tables[xobj_type(&conf->cx_objs[i])],
-				 &key, sizeof key, db_obj.do_rec.b_addr,
-				 db_obj.do_rec.b_nob);
-
-		rc = m0_table_update(&tx, &pair);
-
-		m0_db_pair_fini(&pair);
-		m0_buf_free(&db_obj.do_rec);
-	}
-	if (rc == 0)
-		rc = m0_db_tx_commit(&tx);
-	else
-		(void)m0_db_tx_abort(&tx);
-
-tables_fini:
-	confdb_tables_fini(tables, ARRAY_SIZE(table_names));
-dbenv_fini:
-	m0_dbenv_fini(&db);
-tables_free:
-	m0_free(tables);
-	M0_RETURN(rc);
-}
-
-/* XXX FIXME: Other functions receive both `tables' and the number of tables.
- * confdb_objs_count() shouldn't be different. */
-static int
-confdb_objs_count(struct m0_table *tables, struct m0_db_tx *tx, size_t *result)
-{
-	struct m0_db_pair   pair;
-	struct m0_db_cursor cur;
-	struct confdb_key   key;
-	char               *rec;
-	int                 t;
-	int                 rc;
-
-	M0_ENTRY();
-
-	/* Too large to be allocated on stack. */
-	M0_ALLOC_ARR(rec, CONFDB_REC_MAX);
-	if (rec == NULL)
-		M0_RETURN(-ENOMEM);
-
-	*result = 0;
-	for (t = M0_CO_PROFILE; t < M0_CO_NR; ++t) {
-		m0_db_pair_setup(&pair, &tables[t], &key, sizeof key, rec,
-				 CONFDB_REC_MAX);
-		rc = m0_db_cursor_init(&cur, &tables[t], tx, 0);
-		if (rc != 0)
-			break;
-
-		for (rc = m0_db_cursor_first(&cur, &pair); rc == 0;
-		     rc = m0_db_cursor_next(&cur, &pair))
-			++*result;
-
-		m0_db_cursor_fini(&cur);
-
-		/* Make sure we are at the end of the table. */
-		M0_ASSERT(rc == -ENOENT);
-		rc = 0;
-	}
-
-	m0_free(rec);
-	M0_RETURN(rc);
-}
-
-static struct m0_confx *confx_alloc(size_t nr_objs)
-{
-	struct m0_confx *ret;
-
-	M0_PRE(nr_objs > 0);
-
-	M0_ALLOC_PTR(ret);
-	if (ret == NULL)
-		return NULL;
-
-	M0_ALLOC_ARR(ret->cx_objs, nr_objs);
-	if (ret->cx_objs == NULL) {
-		m0_free(ret);
-		return NULL;
-	}
-
-	ret->cx_nr = nr_objs;
-	return ret;
-}
-
-static void confx_free(struct m0_confx *enc)
-{
-	m0_free(enc->cx_objs);
-	m0_free(enc);
-}
-
-static int
-confx_fill(struct m0_confx *dest, struct m0_table *tables, struct m0_db_tx *tx)
-{
-	struct m0_db_cursor cur;
-	struct m0_db_pair   pair;
-	struct confdb_key   key;
-	char               *rec;
-	size_t              ti;    /* index in tables[] */
-	int                 rc;
-	size_t              i = 0; /* index in dest->cx_objs[] */
-
-	M0_ENTRY();
-	M0_PRE(dest->cx_nr > 0);
-
-	/* Too large to be allocated on stack. */
-	M0_ALLOC_ARR(rec, CONFDB_REC_MAX);
-	if (rec == NULL)
-		M0_RETURN(-ENOMEM);
-
-	for (ti = M0_CO_PROFILE; ti <= M0_CO_PARTITION; ++ti) {
-		m0_db_pair_setup(&pair, &tables[ti], &key, sizeof key, rec,
-				 CONFDB_REC_MAX);
-		rc = m0_db_cursor_init(&cur, &tables[ti], tx, 0);
-		if (rc != 0)
-			break;
-
-		for (rc = m0_db_cursor_first(&cur, &pair); rc == 0;
-		     rc = m0_db_cursor_next(&cur, &pair), ++i) {
-			struct confdb_obj x = {
-				.do_key = M0_BUF_INIT(key.cdk_len, key.cdk_key),
-				.do_rec = M0_BUF_INIT(CONFDB_REC_MAX, rec)
-			};
-
-			M0_ASSERT(i < dest->cx_nr);
-			rc = confx_from_db(&dest->cx_objs[i], ti, &x);
-			if (rc != 0) {
-				m0_db_cursor_fini(&cur);
-				goto out;
-			}
-		}
-
-		m0_db_cursor_fini(&cur);
-		M0_ASSERT(rc == -ENOENT); /* end of the table */
-		rc = 0;
-	}
-out:
-	if (rc == 0) {
-		M0_POST(i == dest->cx_nr);
-	} else {
-		for (; i > 0; --i)
-			m0_xcode_free(&M0_XCODE_OBJ(m0_confx_obj_xc,
-						    &dest->cx_objs[i]));
-		M0_SET0(dest);
-	}
-	m0_free(rec);
-	M0_RETURN(rc);
-}
-
-M0_INTERNAL int m0_confdb_read(const char *dbpath, struct m0_confx **out)
-{
-	struct m0_dbenv  db;
-	struct m0_table *tables;
-	struct m0_db_tx  tx;
-	int              rc;
-	size_t           nr_objs = 0;
-
-	M0_ENTRY();
-
-	M0_ALLOC_ARR(tables, ARRAY_SIZE(table_names));
-	if (tables == NULL)
-		M0_RETURN(-ENOMEM);
-
-	rc = m0_dbenv_init(&db, dbpath, 0);
-	if (rc != 0)
-		goto tables_free;
-
-	rc = confdb_tables_init(&db, tables, ARRAY_SIZE(table_names));
-	if (rc != 0)
-		goto dbenv_fini;
-
-	rc = m0_db_tx_init(&tx, &db, 0);
-	if (rc != 0)
-		goto tables_fini;
-
-	rc = confdb_objs_count(tables, &tx, &nr_objs);
-	if (rc != 0)
-		goto db_tx;
-	if (nr_objs == 0) {
-		rc = -ENODATA;
-		goto db_tx;
-	}
-
-	*out = confx_alloc(nr_objs);
-	if (*out == NULL) {
-		rc = -ENOMEM;
-		goto db_tx;
-	}
-
-	rc = confx_fill(*out, tables, &tx);
-	if (rc != 0) {
-		confx_free(*out);
-		*out = NULL;
-	}
-db_tx:
-	if (rc == 0)
-		rc = m0_db_tx_commit(&tx);
-	else
-		(void)m0_db_tx_abort(&tx);
-tables_fini:
-	confdb_tables_fini(tables, ARRAY_SIZE(table_names));
-dbenv_fini:
-	m0_dbenv_fini(&db);
-tables_free:
-	m0_free(tables);
-	M0_RETURN(rc);
-}
-
-#undef M0_TRACE_SUBSYSTEM
diff --git a/conf/db.h b/conf/db.h
deleted file mode 100644
index b5448de..0000000
--- a/conf/db.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
- * Original creation date: 19-Sep-2012
- */
-#pragma once
-#ifndef __MERO_CONF_DB_H__
-#define __MERO_CONF_DB_H__
-
-struct m0_confx;
-struct m0_confx_obj;
-
-/**
- * Creates configuration database, populating it with provided
- * configuration data.
- *
- * @pre  conf->cx_nr > 0
- */
-M0_INTERNAL int m0_confdb_create(const char *dbpath,
-				 const struct m0_confx *conf);
-
-/**
- * Creates m0_confx and populates it with data read from a
- * configuration database.
- *
- * If the call succeeds, the user is responsible for freeing allocated
- * memory with m0_confx_free(*out).
- */
-M0_INTERNAL int m0_confdb_read(const char *dbpath, struct m0_confx **out);
-
-#endif /* __MERO_CONF_DB_H__ */
diff --git a/conf/obj.c b/conf/obj.c
index 89da0c8..dad42a1 100644
--- a/conf/obj.c
+++ b/conf/obj.c
@@ -126,13 +126,6 @@
  *   assumption and load the entire contents of configuration database
  *   into the cache.
  *
- * - Mero database library ("db/db.h") should provide a user-space
- *   interface for creating in-memory databases. This interface will
- *   be used by confd and user-space confc.
- *
- *   See also `Writing In-Memory Berkeley DB Applications'
- *   [http://docs.oracle.com/cd/E17076_02/html/articles/inmemory/C/index.html].
- *
  * - m0_rpc_item_get() and m0_rpc_item_put() should be implemented.
  *
  *   Confc implementation schedules a state transition in
diff --git a/conf/ut/Makefile.sub b/conf/ut/Makefile.sub
index c7e632b..6a63203 100644
--- a/conf/ut/Makefile.sub
+++ b/conf/ut/Makefile.sub
@@ -1,7 +1,6 @@
 ut_libmero_ut_la_SOURCES += \
     conf/ut/cache.c         \
     conf/ut/confc.c         \
-    conf/ut/db.c            \
     conf/ut/file_helpers.c  \
     conf/ut/file_helpers.h  \
     conf/ut/fuzz.c          \
diff --git a/conf/ut/cache.c b/conf/ut/cache.c
index 282624f..069c3a5 100644
--- a/conf/ut/cache.c
+++ b/conf/ut/cache.c
@@ -169,15 +169,18 @@ static int cache_fini(void)
 	return 0;
 }
 
+void test_confstr_fuzz(void);
+
 const struct m0_test_suite conf_ut = {
 	.ts_name  = "conf-ut",
 	.ts_init  = cache_init,
 	.ts_fini  = cache_fini,
 	.ts_tests = {
-		{ "obj-xtors", test_obj_xtors },
-		{ "cache",     test_cache     },
-		{ "obj-find",  test_obj_find  },
-		{ "obj-fill",  test_obj_fill  },
+		{ "obj-xtors", test_obj_xtors    },
+		{ "cache",     test_cache        },
+		{ "obj-find",  test_obj_find     },
+		{ "obj-fill",  test_obj_fill     },
+		{ "str-fuzz",  test_confstr_fuzz },
 		{ NULL, NULL }
 	}
 };
diff --git a/conf/ut/db.c b/conf/ut/db.c
deleted file mode 100644
index f6ddb1a..0000000
--- a/conf/ut/db.c
+++ /dev/null
@@ -1,215 +0,0 @@
-/* -*- c -*- */
-/*
- * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
- * Original creation date: 26-Sep-2012
- */
-
-#include <stdlib.h>        /* system */
-#include "conf/db.h"       /* m0_confdb_create, m0_confdb_read */
-#include "conf/onwire.h"   /* m0_confx_obj, m0_confx */
-#include "conf/obj.h"      /* m0_conf_objtype */
-#include "conf/preload.h"  /* m0_confstr_parse, m0_confx_free */
-#include "conf/ut/file_helpers.h"
-#include "ut/ut.h"
-
-#define _CONFDB_PATH "_conf.db"
-#define _BUF(str) M0_BUF_INITS(str)
-
-/* ----------------------------------------------------------------
- * Source of configuration data: conf/ut/conf_xc.txt
- * ---------------------------------------------------------------- */
-
-static void profile_check(const struct m0_confx_obj *xobj)
-{
-	M0_UT_ASSERT(xobj->o_conf.u_type == M0_CO_PROFILE);
-	M0_UT_ASSERT(m0_buf_eq(&xobj->o_id, &_BUF("test-2")));
-
-	M0_UT_ASSERT(m0_buf_eq(&xobj->o_conf.u.u_profile.xp_filesystem,
-			       &_BUF("m0t1fs")));
-}
-
-static void filesystem_check(const struct m0_confx_obj *xobj)
-{
-	const struct m0_confx_filesystem *x = &xobj->o_conf.u.u_filesystem;
-
-	M0_UT_ASSERT(xobj->o_conf.u_type == M0_CO_FILESYSTEM);
-	M0_UT_ASSERT(m0_buf_eq(&xobj->o_id, &_BUF("m0t1fs")));
-
-	M0_UT_ASSERT(x->xf_rootfid.f_container == 11);
-	M0_UT_ASSERT(x->xf_rootfid.f_key == 22);
-
-	M0_UT_ASSERT(x->xf_params.ab_count == 3);
-	M0_UT_ASSERT(m0_buf_eq(&x->xf_params.ab_elems[0], &_BUF("50")));
-	M0_UT_ASSERT(m0_buf_eq(&x->xf_params.ab_elems[1], &_BUF("60")));
-	M0_UT_ASSERT(m0_buf_eq(&x->xf_params.ab_elems[2], &_BUF("70")));
-
-	M0_UT_ASSERT(x->xf_services.ab_count == 2);
-	M0_UT_ASSERT(m0_buf_eq(&x->xf_services.ab_elems[0], &_BUF("mds")));
-	M0_UT_ASSERT(m0_buf_eq(&x->xf_services.ab_elems[1], &_BUF("io")));
-}
-
-static void md_service_check(const struct m0_confx_obj *xobj)
-{
-	const struct m0_confx_service *x = &xobj->o_conf.u.u_service;
-
-	M0_UT_ASSERT(xobj->o_conf.u_type == M0_CO_SERVICE);
-	M0_UT_ASSERT(m0_buf_eq(&xobj->o_id, &_BUF("mds")));
-
-	M0_UT_ASSERT(x->xs_type == 1);
-	M0_UT_ASSERT(x->xs_endpoints.ab_count == 1);
-	M0_UT_ASSERT(m0_buf_eq(&x->xs_endpoints.ab_elems[0], &_BUF("addr0")));
-	M0_UT_ASSERT(m0_buf_eq(&x->xs_node, &_BUF("N")));
-}
-
-static void io_service_check(const struct m0_confx_obj *xobj)
-{
-	const struct m0_confx_service *x = &xobj->o_conf.u.u_service;
-
-	M0_UT_ASSERT(xobj->o_conf.u_type == M0_CO_SERVICE);
-	M0_UT_ASSERT(m0_buf_eq(&xobj->o_id, &_BUF("io")));
-
-	M0_UT_ASSERT(x->xs_type == 2);
-	M0_UT_ASSERT(x->xs_endpoints.ab_count == 3);
-	M0_UT_ASSERT(m0_buf_eq(&x->xs_endpoints.ab_elems[0], &_BUF("addr1")));
-	M0_UT_ASSERT(m0_buf_eq(&x->xs_endpoints.ab_elems[1], &_BUF("addr2")));
-	M0_UT_ASSERT(m0_buf_eq(&x->xs_endpoints.ab_elems[2], &_BUF("addr3")));
-	M0_UT_ASSERT(m0_buf_eq(&x->xs_node, &_BUF("N")));
-}
-
-static void node_check(const struct m0_confx_obj *xobj)
-{
-	const struct m0_confx_node *x = &xobj->o_conf.u.u_node;
-
-	M0_UT_ASSERT(xobj->o_conf.u_type == M0_CO_NODE);
-	M0_UT_ASSERT(m0_buf_eq(&xobj->o_id, &_BUF("N")));
-
-	M0_UT_ASSERT(x->xn_memsize == 8000);
-	M0_UT_ASSERT(x->xn_nr_cpu == 2);
-	M0_UT_ASSERT(x->xn_last_state == 3);
-	M0_UT_ASSERT(x->xn_flags == 2);
-	M0_UT_ASSERT(x->xn_pool_id == 0);
-
-	M0_UT_ASSERT(x->xn_nics.ab_count == 1);
-	M0_UT_ASSERT(m0_buf_eq(&x->xn_nics.ab_elems[0], &_BUF("nic0")));
-
-	M0_UT_ASSERT(x->xn_sdevs.ab_count == 1);
-	M0_UT_ASSERT(m0_buf_eq(&x->xn_sdevs.ab_elems[0], &_BUF("sdev0")));
-}
-
-static void nic_check(const struct m0_confx_obj *xobj)
-{
-	const struct m0_confx_nic *x = &xobj->o_conf.u.u_nic;
-
-	M0_UT_ASSERT(xobj->o_conf.u_type == M0_CO_NIC);
-	M0_UT_ASSERT(m0_buf_eq(&xobj->o_id, &_BUF("nic0")));
-
-	M0_UT_ASSERT(x->xi_iface == 5);
-	M0_UT_ASSERT(x->xi_mtu == 8192);
-	M0_UT_ASSERT(x->xi_speed == 10000);
-	M0_UT_ASSERT(m0_buf_eq(&x->xi_filename, &_BUF("ib0")));
-	M0_UT_ASSERT(x->xi_last_state == 3);
-}
-
-static void sdev_check(const struct m0_confx_obj *xobj)
-{
-	const struct m0_confx_sdev *x = &xobj->o_conf.u.u_sdev;
-
-	M0_UT_ASSERT(xobj->o_conf.u_type == M0_CO_SDEV);
-	M0_UT_ASSERT(m0_buf_eq(&xobj->o_id, &_BUF("sdev0")));
-
-	M0_UT_ASSERT(x->xd_iface == 4);
-	M0_UT_ASSERT(x->xd_media == 1);
-	M0_UT_ASSERT(x->xd_size == 596000000000);
-	M0_UT_ASSERT(x->xd_last_state == 3);
-	M0_UT_ASSERT(x->xd_flags == 4);
-	M0_UT_ASSERT(m0_buf_eq(&x->xd_filename, &_BUF("/dev/sdev0")));
-	M0_UT_ASSERT(x->xd_partitions.ab_count == 1);
-	M0_UT_ASSERT(m0_buf_eq(&x->xd_partitions.ab_elems[0], &_BUF("part0")));
-}
-
-static void partition_check(const struct m0_confx_obj *xobj)
-{
-	const struct m0_confx_partition *x = &xobj->o_conf.u.u_partition;
-
-	M0_UT_ASSERT(xobj->o_conf.u_type == M0_CO_PARTITION);
-	M0_UT_ASSERT(m0_buf_eq(&xobj->o_id, &_BUF("part0")));
-
-	M0_UT_ASSERT(x->xa_start == 0);
-	M0_UT_ASSERT(x->xa_size == 596000000000);
-	M0_UT_ASSERT(x->xa_index == 0);
-	M0_UT_ASSERT(x->xa_type == 7);
-	M0_UT_ASSERT(m0_buf_eq(&x->xa_file, &_BUF("/dev/sda1")));
-}
-
-static void cleanup(void)
-{
-	int rc = system("rm -rf " _CONFDB_PATH) ?:
-		system("rm -f " _CONFDB_PATH ".errlog") ?:
-		system("rm -f " _CONFDB_PATH ".msglog");
-	M0_UT_ASSERT(rc == 0);
-}
-
-void test_confdb(void)
-{
-	struct m0_confx *enc;
-	int              i;
-	int              rc;
-	char             buf[1024] = {0};
-	struct {
-		enum m0_conf_objtype type;
-		void               (*check)(const struct m0_confx_obj *xobj);
-	} tests[] = {
-		{ M0_CO_PROFILE,    profile_check     },
-		{ M0_CO_FILESYSTEM, filesystem_check  },
-		{ M0_CO_SERVICE,    io_service_check  },
-		{ M0_CO_SERVICE,    md_service_check  },
-		{ M0_CO_NODE,       node_check        },
-		{ M0_CO_NIC,        nic_check         },
-		{ M0_CO_SDEV,       sdev_check        },
-		{ M0_CO_PARTITION,  partition_check   }
-	};
-
-	cleanup();
-
-	rc = m0_ut_file_read(M0_CONF_UT_PATH("conf_xc.txt"), buf, sizeof buf);
-	M0_UT_ASSERT(rc == 0);
-
-	rc = m0_confstr_parse("[0]", &enc);
-	M0_UT_ASSERT(rc == 0);
-	M0_UT_ASSERT(enc->cx_nr == 0);
-	m0_confx_free(enc);
-
-	rc = m0_confstr_parse(buf, &enc);
-	M0_UT_ASSERT(rc == 0);
-	M0_UT_ASSERT(enc->cx_nr == 8);
-
-	rc = m0_confdb_create(_CONFDB_PATH, enc);
-	M0_UT_ASSERT(rc == 0);
-	m0_confx_free(enc);
-
-	rc = m0_confdb_read(_CONFDB_PATH, &enc);
-	M0_UT_ASSERT(rc == 0);
-	M0_UT_ASSERT(enc->cx_nr == ARRAY_SIZE(tests));
-	for (i = 0; i < ARRAY_SIZE(tests); ++i)
-		tests[i].check(&enc->cx_objs[i]);
-	m0_confx_free(enc);
-
-	cleanup();
-}
-
-#undef _BUF
-#undef _CONFDB_PATH
diff --git a/conf/ut/fuzz.c b/conf/ut/fuzz.c
index e2d0c99..25f311f 100644
--- a/conf/ut/fuzz.c
+++ b/conf/ut/fuzz.c
@@ -224,14 +224,3 @@ void test_confstr_fuzz(void)
 
 	M0_ASSERT(100 * acc.nr_successes / acc.nr_total < 1); /* < 1% */
 }
-
-const struct m0_test_suite confstr_ut = {
-	.ts_name  = "confstr-ut",
-	.ts_init  = NULL,
-	.ts_fini  = NULL,
-	.ts_tests = {
-		{ "db",   test_confdb       },
-		{ "fuzz", test_confstr_fuzz },
-		{ NULL, NULL }
-	}
-};
diff --git a/conf/ut/rpc_helpers.c b/conf/ut/rpc_helpers.c
index 3afaef5..e2d0d4b 100644
--- a/conf/ut/rpc_helpers.c
+++ b/conf/ut/rpc_helpers.c
@@ -105,11 +105,11 @@ M0_INTERNAL int m0_ut_rpc_machine_start(struct m0_rpc_machine *mach,
 		goto buf_pool;
 
 	rc = M0_REQH_INIT(&g_reqh,
-			  .rhia_dtm       = (void*)1,
-			  .rhia_db        = &g_dbenv,
-			  .rhia_mdstore   = (void*)1,
-			  .rhia_fol       = &g_fol,
-			  .rhia_svc       = (void*)1);
+			  .rhia_dtm     = (void*)1,
+			  .rhia_db      = &g_dbenv,
+			  .rhia_mdstore = (void*)1,
+			  .rhia_fol     = &g_fol,
+			  .rhia_svc     = (void*)1);
 	if (rc != 0)
 		goto cob;
 	m0_reqh_start(&g_reqh);
diff --git a/utils/ut_main.c b/utils/ut_main.c
index 8f1c009..1b0f852 100644
--- a/utils/ut_main.c
+++ b/utils/ut_main.c
@@ -49,7 +49,6 @@ extern const struct m0_test_suite cob_ut;
 extern const struct m0_test_suite cobfoms_ut;
 extern const struct m0_test_suite conf_ut;
 extern const struct m0_test_suite confc_ut;
-extern const struct m0_test_suite confstr_ut;
 extern const struct m0_test_suite conn_ut;
 extern const struct m0_test_suite console_ut;
 extern const struct m0_test_suite db_cursor_ut;
@@ -112,9 +111,8 @@ void add_uts(void)
 //XXX_BE_DB	m0_ut_add(&cm_cp_ut);
 //XXX_BE_DB	m0_ut_add(&cm_generic_ut);
 //XXX_BE_DB	m0_ut_add(&cob_ut);
-//XXX_BE_DB	m0_ut_add(&conf_ut);
-//XXX_BE_DB	m0_ut_add(&confc_ut);
-//XXX_BE_DB	m0_ut_add(&confstr_ut);
+	m0_ut_add(&conf_ut);
+	m0_ut_add(&confc_ut);
 //XXX_BE_DB	m0_ut_add(&conn_ut);
 //XXX_BE_DB	m0_ut_add(&db_cursor_ut);
 //XXX_BE_DB	m0_ut_add(&db_ut);
-- 
1.8.3.2

