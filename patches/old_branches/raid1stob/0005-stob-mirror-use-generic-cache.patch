From 05f95f42bb7b066b5c36e52f0912f659d33f4427 Mon Sep 17 00:00:00 2001
From: Nikita Danilov <nikita_danilov@xyratex.com>
Date: Sun, 11 Nov 2012 17:44:53 +0400
Subject: [PATCH 05/15] stob/mirror: use generic cache.

---
 stob/mirror.c | 177 +++++++++++++++++++++-------------------------------------
 stob/mirror.h |  33 -----------
 2 files changed, 63 insertions(+), 147 deletions(-)

diff --git a/stob/mirror.c b/stob/mirror.c
index 59de070..d95ea62 100644
--- a/stob/mirror.c
+++ b/stob/mirror.c
@@ -17,13 +17,15 @@
  * Original creation date: 06-Nov-2012
  */
 
+#include "lib/memory.h"
+#include "lib/errno.h"              /* ENOMEM */
 #include "lib/types.h"              /* uint32_t */
 #include "lib/misc.h"               /* C2_IN */
-#include "lib/tlist.h"
 #include "lib/thread.h"
 
 #include "sm/sm.h"
 #include "stob/stob.h"
+#include "stob/cache.h"
 #include "stob/mirror.h"
 
 /**
@@ -53,7 +55,7 @@ struct target {
 
 struct mirror_domain {
 	struct c2_stob_domain mr_base;
-	struct c2_tl          mr_object;
+	struct c2_stob_cache  mr_cache;
 	uint32_t              mr_nr;
 	struct target         mr_target[MAX_NR_TARGET];
 	struct c2_sm_group    mr_group;
@@ -65,20 +67,11 @@ struct mirror_domain {
  * Mirror storage object.
  */
 struct mirror_stob {
-	uint64_t         ms_magix;
-	struct c2_stob   ms_stob;
-	struct c2_tlink  ms_linkage;
-	struct c2_stob  *ms_obj;
+	struct c2_stob_cacheable   ms_stob;
+	struct c2_stob           **ms_obj;
 };
 
-C2_TL_DESCR_DEFINE(mirror, "mirror stobs", static, struct mirror_stob,
-		   ms_linkage, ms_magix,
-		   0x3377,
-		   0x3377);
-
-C2_TL_DEFINE(mirror, static, struct mirror_stob);
-
-static inline struct mirror_stob *stob2mirror(struct c2_stob *stob)
+static inline struct mirror_stob *stob2mirror(const struct c2_stob *stob)
 {
 	return container_of(stob, struct mirror_stob, ms_stob);
 }
@@ -113,18 +106,13 @@ static void mirror_stob_type_fini(struct c2_stob_type *stype)
 static void mirror_domain_fini(struct c2_stob_domain *self)
 {
 	struct mirror_domain *mdom;
-	uint32_t              i;
 
 	mdom = domain2mirror(self);
 	mdom->mr_shutdown = true;
 	c2_thread_join(&mdom->mr_ast_thread);
 	c2_thread_fini(&mdom->mr_ast_thread);
 	c2_sm_group_fini(&mdom->mr_group);
-	for (i = 0; i < mdom->mr_nr; ++i) {
-		if (mdom->mr_target[i].t_dom != NULL)
-			c2_stob_domain_fini(mdom->mr_target[i].t_dom);
-	}
-	mirror_tlist_fini(&mdom->mr_object);
+	c2_stob_cache_fini(&mdom->mr_cache);
 	c2_stob_domain_fini(self);
 	c2_free(mdom);
 }
@@ -160,13 +148,13 @@ static int mirror_stob_type_domain_locate(struct c2_stob_type *type,
 		c2_sm_group_init(&mdom->mr_group);
 		result = C2_THREAD_INIT(&mdom->mr_ast_thread,
 					struct mirror_domain *, NULL,
-					ast_thread, mdom,
+					&ast_thread, mdom,
 					"ast(%s)", domain_name);
 		if (result == 0) {
-			mirror_tlist_init(&mdom->mirror_object);
-			*out = dom = &adom->mirror_base;
+			*out = dom = &mdom->mr_base;
 			dom->sd_ops = &mirror_stob_domain_op;
 			c2_stob_domain_init(dom, type);
+			c2_stob_cache_init(&mdom->mr_cache);
 		} else {
 			c2_sm_group_fini(&mdom->mr_group);
 			c2_free(mdom);
@@ -178,7 +166,7 @@ static int mirror_stob_type_domain_locate(struct c2_stob_type *type,
 }
 
 int c2_mirror_stob_setup(struct c2_stob_domain *dom, uint32_t nr,
-			 struct c2_stob_domain **targets);
+			 struct c2_stob_domain **targets)
 {
 	struct mirror_domain *mdom;
 	uint32_t              i;
@@ -215,109 +203,73 @@ void c2_mirror_repair(struct c2_stob_domain *dom, uint64_t mask)
 }
 
 /**
- * Searches for the object with a given identifier in the domain object list.
- *
- * This function is used by mirror_domain_stob_find() to check whether in-memory
- * representation of an object already exists.
- */
-static struct mirror_stob *mirror_domain_lookup(struct mirror_domain *mdom,
-						const struct c2_stob_id *id)
-{
-	struct mirror_stob *obj;
-
-	C2_PRE(mdom->mr_nr > 0);
-
-	c2_tl_for(mirror, &mdom->mr_object, obj) {
-		if (c2_stob_id_eq(id, &obj->ms_stob.so_id)) {
-			c2_stob_get(&obj->as_stob);
-			break;
-		}
-	} c2_tl_endfor;
-	return obj;
-}
-
-/**
  * Implementation of c2_stob_op::sop_fini().
  */
 static void mirror_stob_fini(struct c2_stob *stob)
 {
-	struct mirror_stob *mstob;
+	struct mirror_stob   *mstob;
+	struct mirror_domain *mdom;
 	uint32_t            i;
 
 	mstob = stob2mirror(stob);
+	mdom  = domain2mirror(stob->so_domain);
 	for (i = 0; i < mdom->mr_nr; ++i) {
 		if (mstob->ms_obj[i] != NULL)
 			c2_stob_put(mstob->ms_obj[i]);
 	}
-	mirror_tlink_del_fini(mstob);
-	c2_stob_fini(&mdom->mr_base);
+	c2_stob_cacheable_fini(&mstob->ms_stob);
 	c2_free(mstob);
 }
 
-static int mirror_stob_init(struct mirror_domain *mdom,
-			    const struct c2_stob_id *id,
-			    struct mirror_stob *mstob)
+static int mirror_incache_init(struct c2_stob_domain *dom,
+			       const struct c2_stob_id *id,
+			       struct c2_stob_cacheable **out)
 {
-	struct c2_stob *stob;
-	uint32_t        i;
-	int             result;
-
-	stob = &mstob->ms_stob;
-	stob->so_op = &mirror_stob_op;
-	c2_stob_init(stob, id, &mdom->mr_base);
-	for (i = 0; i < mdom->mr_nr; ++i) {
-		result = c2_stob_find(mdom->mr_target[i], id, &mstob->ms_obj[i]);
-		if (result != 0) {
-			mirror_stob_fini(stob);
-			break;
+	struct c2_stob           *stob;
+	struct mirror_stob       *mstob;
+	struct mirror_domain     *mdom;
+	struct c2_stob_cacheable *incache;
+	uint32_t                  i;
+	int                       result;
+
+	mdom  = domain2mirror(dom);
+	mstob = c2_alloc(sizeof *mstob +
+			 mdom->mr_nr * sizeof mstob->ms_obj[0]);
+	if (mstob != NULL) {
+		*out = incache = &mstob->ms_stob;
+		stob = &incache->ca_stob;
+		stob->so_op = &mirror_stob_op;
+		c2_stob_cacheable_init(incache, id, dom);
+		for (result = 0, i = 0; i < mdom->mr_nr; ++i) {
+			result = c2_stob_find(mdom->mr_target[i].t_dom,
+					      id, &mstob->ms_obj[i]);
+			if (result != 0) {
+				mirror_stob_fini(stob);
+				break;
+			}
 		}
-	}
+	} else
+		result = -ENOMEM;
 	return result;
 }
 
 /**
- * Implementation of c2_stob_domain_op::sdo_stob_find().
- *
- * Returns an in-memory representation of the object with a given identifier.
+   Implementation of c2_stob_domain_op::sdo_stob_find().
+
+   Returns an in-memory representation of the object with a given identifier.
  */
 static int mirror_domain_stob_find(struct c2_stob_domain *dom,
 				   const struct c2_stob_id *id,
 				   struct c2_stob **out)
 {
-	struct mirror_domain *mdom;
-	struct mirror_stob   *mstob;
-	struct mirror_stob   *ghost;
-	int                   result;
+	struct c2_stob_cacheable *incache;
+	struct mirror_domain     *mdom;
+	int                       result;
 
 	mdom = domain2mirror(dom);
-
-	C2_PRE(mdom->mr_nr > 0);
-
-	result = 0;
-	c2_rwlock_read_lock(&dom->sd_guard);
-	mstob = mirror_domain_lookup(adom, id);
-	c2_rwlock_read_unlock(&dom->sd_guard);
-
-	if (mstob == NULL) {
-		mstob = c2_alloc(sizeof *mstob +
-				 mdom->mr_nr * sizeof mstob->ms_obj[0]);
-		if (mstob == NULL)
-			return -ENOMEM;
-		result = mirror_stob_init(mdom, id, mstob);
-		if (result == 0) {
-			c2_rwlock_write_lock(&dom->sd_guard);
-			ghost = mirror_domain_lookup(mdom, id);
-			if (ghost == NULL) {
-				mirror_tlink_init_at(mstob, &mdom->mr_object);
-			} else {
-				mirror_stob_fini(&mstob->ms_stob);
-				mstob = ghost;
-				c2_stob_get(&mstob->ms_stob);
-			}
-			c2_rwlock_write_unlock(&dom->sd_guard);
-		}
-	}
-	*out = &mstob->ms_stob;
+	result = c2_stob_cache_find(&mdom->mr_cache, dom, id,
+				    mirror_incache_init, &incache);
+	*out = &incache->ca_stob;
 	return result;
 }
 
@@ -328,7 +280,6 @@ static int mirror_domain_tx_make(struct c2_stob_domain *dom, struct c2_dtx *tx)
 {
 	struct mirror_domain  *mdom;
 	struct c2_stob_domain *child;
-	uint32_t               i;
 
 	mdom = domain2mirror(dom);
 	C2_PRE(mdom->mr_nr > 0);
@@ -354,7 +305,7 @@ static int mirror_stob_create(struct c2_stob *obj, struct c2_dtx *tx)
 		return -EIO;
 	mobj = stob2mirror(obj);
 	for (i = 0; i < mdom->mr_nr; ++i) {
-		result = c2_stob_create(mobj->ms_stob[i], tx);
+		result = c2_stob_create(mobj->ms_obj[i], tx);
 		if (result != 0)
 			/** @todo delete sub-objects on failure. */
 			break;
@@ -376,7 +327,7 @@ static int mirror_stob_locate(struct c2_stob *obj, struct c2_dtx *tx)
 	C2_PRE(mdom->mr_nr > 0);
 	mobj = stob2mirror(obj);
 
-	for (i = 0, i < mdom->mr_nr; ++i) {
+	for (i = 0; i < mdom->mr_nr; ++i) {
 		result = c2_stob_locate(mobj->ms_obj[i], tx);
 		if (result != 0)
 			break;
@@ -450,7 +401,7 @@ int mirror_stob_io_init(struct c2_stob *stob, struct c2_stob_io *io)
 			struct io_target *t = &mio->mi_target[i];
 
 			t->t_io = mio;
-			c2_stob_io_init(t->t_req);
+			c2_stob_io_init(&t->t_req);
 			c2_clink_init(&t->t_clink, &mirror_endio);
 			c2_clink_add(&t->t_req.si_wait, &t->t_clink);
 		}
@@ -471,14 +422,14 @@ static void mirror_stob_io_fini(struct c2_stob_io *io)
 	struct mirror_domain  *mdom;
 	uint32_t               i;
 
-	mdom = domain2mirror(stob->so_domain);
+	mdom = domain2mirror(io->si_obj->so_domain);
 	c2_mutex_fini(&mio->mi_lock);
 	for (i = 0; i < mdom->mr_nr; ++i) {
 		struct io_target *t = &mio->mi_target[i];
 
 		c2_clink_del(&t->t_clink);
 		c2_clink_fini(&t->t_clink);
-		c2_stob_io_fini(t->t_req);
+		c2_stob_io_fini(&t->t_req);
 	}
 	c2_free(mio);
 }
@@ -492,6 +443,7 @@ static int subio_build(struct mirror_stob_io *mio,
 	struct mirror_stob    *mobj = stob2mirror(obj);
 	uint32_t               nr   = mdom->mr_nr;
 	uint32_t               i;
+	int                    result;
 
 	C2_PRE(nr > 0);
 	C2_PRE(end <= nr);
@@ -503,7 +455,7 @@ static int subio_build(struct mirror_stob_io *mio,
 	C2_ASSERT(C2_IN(io->si_opcode, (SIO_READ, SIO_WRITE)));
 
 	c2_mutex_lock(&mio->mi_lock);
-	for (i = start % nr; i != end; i = (i + 1) % nr) {
+	for (result = 0, i = start % nr; i != end; i = (i + 1) % nr) {
 		struct c2_stob_io *tio = &mio->mi_target[i].t_req;
 
 		if (mdom->mr_target[i].t_state != ONLINE)
@@ -534,10 +486,7 @@ static int subio_build(struct mirror_stob_io *mio,
 static int mirror_stob_io_launch(struct c2_stob_io *io)
 {
 	struct mirror_domain  *mdom = domain2mirror(io->si_obj->so_domain);
-	struct mirror_stob    *mobj = stob2mirror(io->si_obj);
 	struct mirror_stob_io *mio  = io->si_stob_private;
-	int                    result;
-	uint32_t               i;
 
 	C2_PRE(mdom->mr_nr > 0);
 	C2_PRE(io->si_obj->so_domain->sd_type == &c2_mirror_stob_type);
@@ -578,7 +527,7 @@ static bool mirror_stob_io_is_locked(const struct c2_stob *stob)
  *
  * @todo check in the invariant that block sizes are the same.
  */
-static uint32_t mirror_stob_block_shift(const struct c2_stob *stob)
+static uint32_t mirror_stob_block_shift(const struct c2_stob *obj)
 {
 	struct mirror_domain *mdom;
 	struct mirror_stob   *mobj;
@@ -618,7 +567,7 @@ static void read_try_next(struct c2_sm_group *grp, struct c2_sm_ast *ast)
 {
 	struct mirror_stob_io *mio;
 	struct c2_stob_io     *io;
-	uint32_t               idx = (uint32_t)ast->sa_datum;
+	uint32_t               idx = (uint64_t)ast->sa_datum;
 
 	mio = container_of(ast, struct mirror_stob_io, mi_ast);
 	io  = mio->mi_io;
@@ -639,14 +588,14 @@ static bool mirror_endio(struct c2_clink *link)
 	bool                   read;
 
 	iot   = container_of(link, struct io_target, t_clink);
-	subio = iot->t_req;
+	subio = &iot->t_req;
 	mio   = iot->t_io;
 	io    = mio->mi_io;
 	read  = io->si_opcode == SIO_READ;
 
 	C2_ASSERT(io->si_state == SIS_BUSY);
 	C2_ASSERT(subio->si_state == SIS_IDLE);
-	C2_ASSERT(mio->mi_done > 0);
+	C2_ASSERT(mio->mi_todo > 0);
 
 	c2_mutex_lock(&mio->mi_lock);
 	rc = subio->si_rc;
diff --git a/stob/mirror.h b/stob/mirror.h
index 4eb5668..827b942 100644
--- a/stob/mirror.h
+++ b/stob/mirror.h
@@ -38,37 +38,6 @@
  * corresponding operationson the mirror stob. The implementation assumes that
  * target domains are not accessed except through the mirror stob interface.
  *
- * When a mirror domain is configured, the user supplies additional
- * parameters, determining fault-tolerance characteristics of the domain:
- *
- *     - nr: number of target domains in the mirror domain. nr is called a
- *       "width" of the mirror domain;
- *
- *     - wreq: maximal number of writes to the target stobs made as part of a
- *       mirrored write. If wreq equals the width, every target object is
- *       updated as part of every write operation. If wreq is less than the
- *       width, the implementation would attempt to load-balance IO requests;
- *
- *     - rreq: maximal number of reads to the target stobs made as part of a
- *       mirrorred read. Similar to wreq. Note, that one usually wants rreq +
- *       wreq >= width, but the implementation doesn't enforce this;
- *
- *     - wack: minimal number of the target stob writes that must complete
- *       successfully, for the mirrored write to succeed. If wack is less than
- *       wreq, then (wreq - wack) write failures are tolerated;
- *
- *     - rack: minimal number of the target stob reads that must complete
- *       successfully, for the mirrored read to succeed. Similar to wack.
- *
- * Usual N-way mirroring is achieved by setting
- *
- *    nr = N, wreq = N, rreq = 1, wack = 1, rreq = 1
- *
- *
- *
- *
- *
- *
  *
  * "I will pack my comb and mirror to praxis oval owes and artless awes."
  *
@@ -88,8 +57,6 @@ extern struct c2_stob_type c2_mirror_stob_type;
  */
 int  c2_mirror_stob_setup(struct c2_stob_domain *dom, uint32_t nr,
 			  struct c2_stob_domain **targets);
-			  uint32_t wreq, uint32_t rreq,
-			  uint32_t wack, uint32_t rack);
 
 void c2_mirror_failed(struct c2_stob_domain *dom, uint64_t mask);
 void c2_mirror_repair(struct c2_stob_domain *dom, uint64_t mask);
-- 
1.8.3.2

