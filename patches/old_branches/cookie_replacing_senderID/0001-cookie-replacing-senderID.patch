From d7602d2bbbe859e32c54e5df9f4ddc7b950ab765 Mon Sep 17 00:00:00 2001
From: Nachiket Sahasrabuddhe <nachiket_sahasrabuddhe@xyratex.com>
Date: Tue, 5 Feb 2013 19:41:21 +0530
Subject: [PATCH 1/6] cookie-replacing-senderID

1. Usage of senderID during conn-establishment
   is replaced with cookie.
2. The field sender_id has been removed from slot_ref.
---
 build_kernel_modules/Makefile.in |  5 ++--
 ioservice/Makefile.sub           |  3 ++-
 lib/Makefile.sub                 |  6 +++++
 lib/cookie.c                     | 11 +++++++++
 lib/cookie.h                     | 16 +++++++++---
 rpc/conn.c                       | 53 ++++++++++++++++++++++++----------------
 rpc/conn.h                       |  5 ++--
 rpc/item.c                       |  1 -
 rpc/rpc.c                        | 10 ++++----
 rpc/rpc_onwire.h                 |  4 ++-
 rpc/session_foms.c               | 30 ++++++-----------------
 rpc/session_fops.c               |  3 ++-
 rpc/session_fops.h               | 22 ++++++++---------
 rpc/slot.c                       | 30 +++++++++++------------
 rpc/ut/conn.c                    | 26 ++++++++++----------
 rpc/ut/packet.c                  |  1 -
 16 files changed, 127 insertions(+), 99 deletions(-)

diff --git a/build_kernel_modules/Makefile.in b/build_kernel_modules/Makefile.in
index ee004fd..8165a8d 100644
--- a/build_kernel_modules/Makefile.in
+++ b/build_kernel_modules/Makefile.in
@@ -125,9 +125,10 @@ lib_SOURCES                     := bitstring.c getopts.c vec.c list.c queue.c \
                                    refs.c time.c bitmap.c chan.c misc.c buf.c \
                                    cond.c thread.c tlist.c bob.c trace.c      \
                                    finject.c vec_xc.c vec.c buf_xc.c buf.c    \
-                                   m0lib.c cookie.c ext.c
+                                   m0lib.c cookie.c cookie_xc.c ext.c
 
-lib_HEADERS                     := vec.h vec_xc.h buf.h buf_xc.h
+lib_HEADERS                     := vec.h vec_xc.h buf.h buf_xc.h cookie.h \
+                                   cookie_xc.h
 
 lib_linux_kernel_SOURCES        := memory.c mutex.c rwlock.c ktime.c timer.c \
                                    kthread.c semaphore.c processor.c kvec.c  \
diff --git a/ioservice/Makefile.sub b/ioservice/Makefile.sub
index 72d357b..a33bc25 100644
--- a/ioservice/Makefile.sub
+++ b/ioservice/Makefile.sub
@@ -12,7 +12,8 @@ mero_libmero_la_SOURCES  += ioservice/io_foms.c \
                             ioservice/io_device.c
 
 ioservice/io_fops_xc.h : addb/addb_xc.h \
-                         net/net_otw_types_xc.h
+                         net/net_otw_types_xc.h \
+			 lib/cookie_xc.h
 
 XC_FILES   += ioservice/io_fops_xc.h
 
diff --git a/lib/Makefile.sub b/lib/Makefile.sub
index 2a7bde7..f08e339 100644
--- a/lib/Makefile.sub
+++ b/lib/Makefile.sub
@@ -12,6 +12,7 @@ nobase_mero_include_HEADERS += lib/adt.h \
                                   lib/chan.h \
                                   lib/cond.h \
                                   lib/cookie.h \
+                                  lib/cookie_xc.h \
                                   lib/errno.h \
                                   lib/ext.h \
                                   lib/finject.h \
@@ -58,6 +59,7 @@ mero_libmero_la_SOURCES  += lib/assert.c \
                                   lib/chan.c \
                                   lib/cond.c \
                                   lib/cookie.c \
+                                  lib/cookie_xc.c \
                                   lib/ext.c \
                                   lib/finject.c \
                                   lib/finject_internal.h \
@@ -91,6 +93,7 @@ mero_libmero_la_SOURCES  += lib/assert.c \
                                   lib/user_space/utime.c
 
 XC_FILES   += lib/buf_xc.h \
+              lib/cookie_xc.h \
               lib/vec_xc.h
 
 EXTRA_DIST += lib/linux_kernel/assert.h \
@@ -123,6 +126,9 @@ EXTRA_DIST += lib/linux_kernel/assert.h \
 CLEANFILES += lib/buf_xc.h \
               lib/buf_xc.c \
               lib/buf.gccxml \
+              lib/cookie_xc.h \
+              lib/cookie_xc.c \
+              lib/cookie.gccxml \
               lib/vec_xc.h \
               lib/vec_xc.c \
               lib/vec.gccxml
diff --git a/lib/cookie.c b/lib/cookie.c
index de481ea..731d99a 100644
--- a/lib/cookie.c
+++ b/lib/cookie.c
@@ -54,6 +54,11 @@
 
 static uint64_t cookie_generation;
 
+const struct m0_cookie cookie_invalid = {
+	.co_generation = 0xffff,
+	.co_addr       = 0,
+};
+
 M0_INTERNAL bool m0_arch_addr_is_sane(const void *addr);
 M0_INTERNAL int m0_arch_cookie_global_init(void);
 M0_INTERNAL void m0_arch_cookie_global_fini(void);
@@ -102,6 +107,12 @@ M0_INTERNAL int m0_cookie_dereference(const struct m0_cookie *cookie,
 		return -EPROTO;
 }
 
+M0_INTERNAL bool m0_cookie_is_invalid(struct m0_cookie cookie)
+{
+	return cookie.co_generation == cookie_invalid.co_generation &&
+		cookie.co_addr == cookie_invalid.co_addr;
+}
+
 M0_INTERNAL void m0_cookie_global_fini(void)
 {
 	m0_arch_cookie_global_fini();
diff --git a/lib/cookie.h b/lib/cookie.h
index 4c33ae7..93dfafb 100644
--- a/lib/cookie.h
+++ b/lib/cookie.h
@@ -23,6 +23,9 @@
 #ifndef __MERO_LIB_COOKIE_H__
 #define __MERO_LIB_COOKIE_H__
 
+#include "lib/types.h"
+#include "xcode/xcode.h"
+
 /**
  * @defgroup cookie Cookie
  *
@@ -52,7 +55,7 @@
 struct m0_cookie {
 	uint64_t co_addr;
 	uint64_t co_generation;
-};
+} M0_XCA_RECORD;
 
 /**
  * Initializes the gencount. Gets called during mero initialization.
@@ -90,14 +93,20 @@ M0_INTERNAL int m0_cookie_dereference(const struct m0_cookie *cookie,
  */
 M0_INTERNAL bool m0_addr_is_sane(const uint64_t * addr);
 
+
+/**
+ * Returns 'true' when cookie is invalid.
+ */
+M0_INTERNAL bool m0_cookie_is_invalid(struct m0_cookie cookie);
+
 /**
  * A macro to retrive address of a parent structure, associated with an object
  * embedded in a cookie.
  */
 #define m0_cookie_of(cookie, type, field)		      \
 ({							      \
-	uint64_t	 *__gen;			      \
-	struct m0_cookie *__cookie = (cookie);		      \
+	uint64_t	       *__gen;			      \
+	const struct m0_cookie *__cookie = (cookie);	      \
 	m0_cookie_dereference(__cookie, &__gen) != 0 ? NULL : \
 			container_of(__gen, type, field);     \
 })
@@ -106,6 +115,7 @@ M0_INTERNAL bool m0_addr_is_sane(const uint64_t * addr);
 /*__M0_LIB_COOKIE_H__*/
 #endif
 
+extern const struct m0_cookie cookie_invalid;
 /*
  *  Local variables:
  *  c-indentation-style: "K&R"
diff --git a/rpc/conn.c b/rpc/conn.c
index d23db0d..dff2d8c 100644
--- a/rpc/conn.c
+++ b/rpc/conn.c
@@ -27,6 +27,7 @@
 #include "lib/bitstring.h"
 #include "lib/arith.h"
 #include "lib/finject.h"
+#include "lib/cookie.h"
 #include "cob/cob.h"
 #include "fop/fop.h"
 #include "db/db.h"
@@ -210,26 +211,26 @@ M0_INTERNAL bool m0_rpc_conn_invariant(const struct m0_rpc_conn *conn)
 
 	switch (conn_state(conn)) {
 	case M0_RPC_CONN_INITIALISED:
-		return  conn->c_sender_id == SENDER_ID_INVALID &&
+		return	m0_cookie_is_invalid(conn->c_cookie) &&
 			conn->c_nr_sessions == 1 &&
 			session_state(session0) == M0_RPC_SESSION_IDLE;
 
 	case M0_RPC_CONN_CONNECTING:
-		return  conn->c_sender_id == SENDER_ID_INVALID &&
+		return  m0_cookie_is_invalid(conn->c_cookie) &&
 			conn->c_nr_sessions == 1;
 
 	case M0_RPC_CONN_ACTIVE:
-		return  conn->c_sender_id != SENDER_ID_INVALID &&
+		return  !m0_cookie_is_invalid(conn->c_cookie) &&
 			conn->c_nr_sessions >= 1 &&
 			ergo(recv_end, conn->c_cob != NULL);
 
 	case M0_RPC_CONN_TERMINATING:
 		return  conn->c_nr_sessions == 1 &&
-			conn->c_sender_id != SENDER_ID_INVALID;
+			!m0_cookie_is_invalid(conn->c_cookie);
 
 	case M0_RPC_CONN_TERMINATED:
 		return	conn->c_nr_sessions == 1 &&
-			conn->c_sender_id != SENDER_ID_INVALID &&
+			!m0_cookie_is_invalid(conn->c_cookie)&&
 			conn->c_cob == NULL &&
 			conn->c_sm.sm_rc == 0;
 
@@ -317,6 +318,7 @@ static int __conn_init(struct m0_rpc_conn      *conn,
 	conn->c_cob         = NULL;
 	conn->c_service     = NULL;
 	conn->c_nr_sessions = 0;
+	conn->c_cookie      = cookie_invalid;
 
 	rpc_session_tlist_init(&conn->c_sessions);
 	rpc_conn_tlink_init(conn);
@@ -597,10 +599,11 @@ M0_EXPORTED(m0_rpc_conn_establish_sync);
 
 M0_INTERNAL int m0_rpc_conn_establish(struct m0_rpc_conn *conn)
 {
-	struct m0_fop         *fop;
-	struct m0_rpc_session *session_0;
-	struct m0_rpc_machine *machine;
-	int                    rc;
+	struct m0_fop                    *fop;
+	struct m0_rpc_session            *session_0;
+	struct m0_rpc_machine            *machine;
+	struct m0_rpc_fop_conn_establish *fop_data;
+	int                               rc;
 
 	M0_ENTRY("conn: %p", conn);
 	M0_PRE(conn != NULL && conn->c_rpc_machine != NULL);
@@ -624,10 +627,14 @@ M0_INTERNAL int m0_rpc_conn_establish(struct m0_rpc_conn *conn)
 	M0_ASSERT(conn_state(conn) == M0_RPC_CONN_INITIALISED &&
 	          m0_rpc_conn_is_snd(conn));
 
-	/* m0_rpc_fop_conn_establish FOP doesn't contain any data. */
 
 	session_0 = m0_rpc_conn_session0(conn);
 
+	fop_data = m0_fop_data(fop);
+	m0_cookie_new(&conn->c_sender_id);
+	m0_cookie_init(&fop_data->rce_cookie, &conn->c_sender_id);
+	fop_data->rce_rc = 0;
+
 	rc = m0_rpc__fop_post(fop, session_0, &conn_establish_item_ops);
 	if (rc == 0) {
 		conn_state_set(conn, M0_RPC_CONN_CONNECTING);
@@ -692,17 +699,17 @@ M0_INTERNAL void m0_rpc_conn_establish_reply_received(struct m0_rpc_item *item)
 	if (rc == 0) {
 		reply_fop = m0_rpc_item_to_fop(reply_item);
 		reply     = m0_fop_data(reply_fop);
-
 		rc = reply->rcer_rc;
 		if (rc == 0) {
-			if (reply->rcer_sender_id != SENDER_ID_INVALID) {
-				conn->c_sender_id = reply->rcer_sender_id;
+			if (!m0_cookie_is_invalid(reply->rcer_cookie)) {
+				conn->c_cookie = reply->rcer_cookie;
 				conn_state_set(conn, M0_RPC_CONN_ACTIVE);
-			} else
+			} else {
+
 				rc = -EPROTO;
+			}
 		}
 	}
-
 	if (rc != 0)
 		conn_failed(conn, rc);
 
@@ -780,7 +787,7 @@ M0_INTERNAL int m0_rpc_conn_terminate(struct m0_rpc_conn *conn)
 		M0_RETURN(0);
 	}
 	args = m0_fop_data(fop);
-	args->ct_sender_id = conn->c_sender_id;
+	args->ct_cookie = conn->c_cookie;
 
 	session_0 = m0_rpc_conn_session0(conn);
 	rc = m0_rpc__fop_post(fop, session_0, &conn_terminate_item_ops);
@@ -826,6 +833,7 @@ M0_INTERNAL void m0_rpc_conn_terminate_reply_received(struct m0_rpc_item *item)
 	struct m0_rpc_fop_conn_terminate_rep *reply;
 	struct m0_fop                        *reply_fop;
 	struct m0_rpc_conn                   *conn;
+	struct m0_rpc_conn		     *conn_retrvd;
 	struct m0_rpc_machine                *machine;
 	struct m0_rpc_item                   *reply_item;
 	int32_t                               rc;
@@ -854,7 +862,10 @@ M0_INTERNAL void m0_rpc_conn_terminate_reply_received(struct m0_rpc_item *item)
 
 		rc = reply->ctr_rc;
 		if (rc == 0) {
-			if (conn->c_sender_id == reply->ctr_sender_id)
+			conn_retrvd = m0_cookie_of(&reply->ctr_cookie,
+					           struct m0_rpc_conn,
+						   c_sender_id);
+			if (conn == conn_retrvd)
 				conn_state_set(conn, M0_RPC_CONN_TERMINATED);
 			else
 				/* XXX generate ADDB record here. */
@@ -1001,7 +1012,7 @@ M0_INTERNAL int m0_rpc_rcv_conn_establish(struct m0_rpc_conn *conn)
 {
 	struct m0_rpc_machine *machine;
 	struct m0_db_tx        tx;
-	uint64_t               sender_id;
+	uint64_t               gen_count;
 	int                    rc;
 
 	M0_ENTRY("conn: %p", conn);
@@ -1018,8 +1029,8 @@ M0_INTERNAL int m0_rpc_rcv_conn_establish(struct m0_rpc_conn *conn)
 	conn_state_set(conn, M0_RPC_CONN_CONNECTING);
 	rc = m0_db_tx_init(&tx, machine->rm_dom->cd_dbenv, 0);
 	if (rc == 0) {
-		sender_id = uuid_generate();
-		rc = conn_persistent_state_attach(conn, sender_id, &tx);
+		m0_cookie_new(&gen_count);
+		rc = conn_persistent_state_attach(conn, gen_count, &tx);
 		if (rc == 0)
 			rc = m0_db_tx_commit(&tx);
 		else
@@ -1027,7 +1038,7 @@ M0_INTERNAL int m0_rpc_rcv_conn_establish(struct m0_rpc_conn *conn)
 	}
 
 	if (rc == 0) {
-		conn->c_sender_id = sender_id;
+		conn->c_sender_id = gen_count;
 		conn_state_set(conn, M0_RPC_CONN_ACTIVE);
 	} else
 		conn_failed(conn, rc);
diff --git a/rpc/conn.h b/rpc/conn.h
index 1a900be..d8493ca 100644
--- a/rpc/conn.h
+++ b/rpc/conn.h
@@ -251,9 +251,10 @@ enum m0_rpc_conn_flags {
   all the state transitions of conn internally.
  */
 struct m0_rpc_conn {
-	/** Sender ID unique on receiver */
-	uint64_t                  c_sender_id;
+	/** Cookie holding a reference to conn on receiver end */
+	struct m0_cookie          c_cookie;
 
+	uint64_t                  c_sender_id;
 	/** Globally unique ID of rpc connection */
 	struct m0_rpc_sender_uuid c_uuid;
 
diff --git a/rpc/item.c b/rpc/item.c
index 95ed21b..704c646 100644
--- a/rpc/item.c
+++ b/rpc/item.c
@@ -55,7 +55,6 @@ M0_TL_DEFINE(rit, static, struct m0_rpc_item_type);
 
 static const struct m0_rpc_onwire_slot_ref invalid_slot_ref = {
 	.osr_slot_id    = SLOT_ID_INVALID,
-	.osr_sender_id  = SENDER_ID_INVALID,
 	.osr_session_id = SESSION_ID_INVALID,
 };
 
diff --git a/rpc/rpc.c b/rpc/rpc.c
index ac4852d..b6bb621 100644
--- a/rpc/rpc.c
+++ b/rpc/rpc.c
@@ -147,15 +147,15 @@ int m0_rpc_reply_post(struct m0_rpc_item *request, struct m0_rpc_item *reply)
 	machine = reply->ri_rmachine = request->ri_rmachine;
 	/* BEWARE: structure instance copy ahead */
 	reply->ri_slot_refs[0] = request->ri_slot_refs[0];
+
 	sref = &reply->ri_slot_refs[0];
 	/* don't need values of sr_link and sr_ready_link of request item */
 	slot_item_tlink_init(reply);
 
-	sref->sr_item = reply;
-
-	reply->ri_prio     = request->ri_prio;
-	reply->ri_deadline = 0;
-	reply->ri_error    = 0;
+	sref->sr_item		 = reply;
+	reply->ri_prio		 = request->ri_prio;
+	reply->ri_deadline	 = 0;
+	reply->ri_error		 = 0;
 
 	slot = sref->sr_slot;
 	m0_rpc_machine_lock(machine);
diff --git a/rpc/rpc_onwire.h b/rpc/rpc_onwire.h
index ae4bd67..f62d534 100644
--- a/rpc/rpc_onwire.h
+++ b/rpc/rpc_onwire.h
@@ -24,6 +24,8 @@
 #define __MERO_RPC_ONWIRE_H__
 
 #include "lib/types.h" /* uint64_t */
+#include "lib/cookie.h"
+#include "lib/cookie_xc.h"
 #include "dtm/verno.h" /* m0_verno */
 #include "dtm/verno_xc.h" /* m0_verno_xc */
 #include "xcode/xcode_attr.h" /* M0_XCA_RECORD */
@@ -52,10 +54,10 @@ struct m0_rpc_onwire_slot_ref {
 
 	struct m0_rpc_sender_uuid  osr_uuid;
 
-	uint64_t                   osr_sender_id;
 
 	uint64_t                   osr_session_id;
 
+	struct m0_cookie           osr_cookie;
 	/** Numeric id of slot. Used when encoding and decoding rpc item to
 	    and from wire-format
 	 */
diff --git a/rpc/session_foms.c b/rpc/session_foms.c
index ea8cc6b..669e1d6 100644
--- a/rpc/session_foms.c
+++ b/rpc/session_foms.c
@@ -181,7 +181,7 @@ M0_INTERNAL int m0_rpc_fom_conn_establish_tick(struct m0_fom *fom)
 		  ctx->cec_sender_ep != NULL);
 
 	M0_ALLOC_PTR(conn);
-	if (conn == NULL){
+	if (conn == NULL) {
 		M0_RETURN(-ENOMEM);
 		/* no reply if conn establish failed.
 		   See [4] at end of this function. */
@@ -204,10 +204,8 @@ M0_INTERNAL int m0_rpc_fom_conn_establish_tick(struct m0_fom *fom)
 			item->ri_session = session0;
 			m0_rpc_slot_item_add_internal(slot, item);
 
-			/* See [2] at the end of function */
-			item->ri_slot_refs[0].sr_ow.osr_sender_id =
-				SENDER_ID_INVALID;
-
+			if (request->rce_rc == 0)
+				conn->c_cookie = request->rce_cookie;
 			M0_ASSERT(conn_state(conn) == M0_RPC_CONN_ACTIVE);
 			M0_ASSERT(m0_rpc_conn_invariant(conn));
 		} else {
@@ -218,8 +216,8 @@ M0_INTERNAL int m0_rpc_fom_conn_establish_tick(struct m0_fom *fom)
 	m0_rpc_machine_unlock(machine);
 
 	if (rc == 0) {
-		reply->rcer_sender_id = conn->c_sender_id;
-		reply->rcer_rc        = 0;
+		m0_cookie_init(&reply->rcer_cookie, &conn->c_sender_id);
+		reply->rcer_rc = 0;
 
 		M0_LOG(M0_INFO, "Conn established: conn [%p] id [%lu]\n", conn,
 				(unsigned long)conn->c_sender_id);
@@ -244,25 +242,13 @@ M0_INTERNAL int m0_rpc_fom_conn_establish_tick(struct m0_fom *fom)
  * symmetric to corresponding sender side slot.
  */
 
-/* [2]
- * IMPORTANT
- * @code
- *     item->ri_slot_refs[0].sr_sender_id = SENDER_ID_INVALID;
- * @endcode
- * Request item has SENDER_ID_INVALID.
- * slot_item_add_internal() overwrites it with conn->c_sender_id.
- * But we want reply to have sender_id SENDER_ID_INVALID.
- * m0_rpc_reply_post() simply copies sender id from req item to
- * reply item as it is. So set sender id of request item
- * to SENDER_ID_INVALID
- */
 
-/* [3]
+/* [2]
  * CONN_ESTABLISH item is directly submitted for execution. Update
  * rpc-layer stats on INCOMING path here.
  */
 
-/* [4]
+/* [3]
  * IMPORTANT: No reply is sent if conn establishing is failed.
  *
  * ACTIVE session is required to send reply. In case of, successful
@@ -530,12 +516,12 @@ M0_INTERNAL int m0_rpc_fom_conn_terminate_tick(struct m0_fom *fom)
 	reply = m0_fop_data(fop_rep);
 	M0_ASSERT(reply != NULL);
 
-	reply->ctr_sender_id = request->ct_sender_id;
 
 	item = &fop->f_item;
 	M0_ASSERT(item->ri_session != NULL);
 
 	conn = item->ri_session->s_conn;
+	reply->ctr_cookie = conn->c_cookie;
 	M0_ASSERT(conn != NULL);
 
 	machine = conn->c_rpc_machine;
diff --git a/rpc/session_fops.c b/rpc/session_fops.c
index 98df721..edd3079 100644
--- a/rpc/session_fops.c
+++ b/rpc/session_fops.c
@@ -28,7 +28,7 @@
 #include "fop/fop.h"
 #include "fop/fop_item_type.h"
 #include "dtm/verno_xc.h" /* m0_xc_verno_init */
-
+#include "lib/cookie_xc.h" /* m0_xc_cookie_init */
 #include "rpc/rpc.h"
 #include "rpc/rpc_internal.h"
 
@@ -146,6 +146,7 @@ M0_INTERNAL int m0_rpc_session_fop_init(void)
 	 * @todo This should be done from dtm subsystem init.
 	 */
 	m0_xc_verno_init();
+	m0_xc_cookie_init();
 	m0_xc_rpc_onwire_init();
 	m0_xc_session_fops_init();
 	return  M0_FOP_TYPE_INIT(&m0_rpc_fop_conn_establish_fopt,
diff --git a/rpc/session_fops.h b/rpc/session_fops.h
index bf4c47d..532328c 100644
--- a/rpc/session_fops.h
+++ b/rpc/session_fops.h
@@ -27,6 +27,8 @@
 #include "fop/fop.h"
 #include "rpc/rpc_opcodes.h"
 #include "lib/types.h"
+#include "lib/cookie.h"
+#include "lib/cookie_xc.h"
 #include "xcode/xcode_attr.h"
 
 /**
@@ -76,7 +78,8 @@ struct m0_rpc_fop_conn_establish_ctx {
 };
 
 struct m0_rpc_fop_conn_establish {
-	uint64_t rce_unused;
+	struct m0_cookie rce_cookie;
+	uint32_t         rce_rc;
 } M0_XCA_RECORD;
 
 /**
@@ -84,16 +87,13 @@ struct m0_rpc_fop_conn_establish {
    FOP.
  */
 struct m0_rpc_fop_conn_establish_rep {
-	/**
-	   sender_id assigned by receiver to the established rpc-connection.
-	   Has value SENDER_ID_INVALID if CONN_ESTABLISH operation fails.
-	 */
-	uint64_t rcer_sender_id;
+
+	struct m0_cookie rcer_cookie;
 	/**
 	   Contains 0 if CONN_ESTABLISH operation is successful, error code
 	   otherwise.
 	 */
-	uint32_t rcer_rc;
+	uint32_t          rcer_rc;
 } M0_XCA_RECORD;
 
 /**
@@ -101,9 +101,9 @@ struct m0_rpc_fop_conn_establish_rep {
  */
 struct m0_rpc_fop_conn_terminate {
 	/**
-	   sender_id of rpc-connection being terminated.
+	   cookie of rpc-connection being terminated.
 	 */
-	uint64_t ct_sender_id;
+	struct m0_cookie ct_cookie;
 } M0_XCA_RECORD;
 
 /**
@@ -113,12 +113,12 @@ struct  m0_rpc_fop_conn_terminate_rep {
 	/**
 	   sender_id of rpc-connection being terminated.
 	 */
-	uint64_t ctr_sender_id;
+	struct m0_cookie ctr_cookie;
 	/**
 	   Contains 0 if CONN_TERMINATE operation is successful, error code
 	   otherwise.
 	 */
-	uint32_t ctr_rc;
+	uint32_t         ctr_rc;
 } M0_XCA_RECORD;
 
 
diff --git a/rpc/slot.c b/rpc/slot.c
index d5e9067..f6511fb 100644
--- a/rpc/slot.c
+++ b/rpc/slot.c
@@ -404,7 +404,7 @@ static void __slot_item_add(struct m0_rpc_slot *slot,
 	item->ri_slot_refs[0] = (struct m0_rpc_slot_ref){
 		.sr_ow = {
 			.osr_session_id = session->s_session_id,
-			.osr_sender_id  = session->s_conn->c_sender_id,
+			.osr_cookie     = session->s_conn->c_cookie,
 			.osr_uuid       = session->s_conn->c_uuid,
 			/*
 			 * m0_rpc_slot_item_apply() will provide an item
@@ -766,7 +766,6 @@ find_conn(const struct m0_rpc_machine *machine,
 	const struct m0_tl           *conn_list;
 	const struct m0_rpc_slot_ref *sref;
 	struct m0_rpc_conn           *conn;
-	bool                          use_uuid;
 
 	M0_ENTRY("machine: %p, item: %p", machine, item);
 
@@ -775,21 +774,22 @@ find_conn(const struct m0_rpc_machine *machine,
 			&machine->rm_outgoing_conns;
 
 	sref = &item->ri_slot_refs[0];
-	use_uuid = (sref->sr_ow.osr_sender_id == SENDER_ID_INVALID);
-	m0_tl_for(rpc_conn, conn_list, conn) {
-		if (use_uuid) {
-			if (m0_rpc_sender_uuid_cmp(
-				    &conn->c_uuid,
-				    &sref->sr_ow.osr_uuid) == 0) {
-				break;
-			}
-		} else {
-			if (conn->c_sender_id == sref->sr_ow.osr_sender_id) {
-				M0_LEAVE("conn: %p", conn);
+	conn = m0_cookie_of(&sref->sr_ow.osr_cookie,
+			    struct m0_rpc_conn,
+			    c_sender_id);
+#ifndef __KERNEL__
+	if (conn != NULL)
+		printf("\nConn detected using cookie\n");
+#endif
+	if (conn == NULL) {
+		m0_tl_for(rpc_conn, conn_list, conn) {
+			if (m0_rpc_sender_uuid_cmp(&conn->c_uuid,
+						   &sref->sr_ow.osr_uuid) ==
+			    0) {
 				break;
 			}
-		}
-	} m0_tl_endfor;
+		} m0_tl_endfor;
+	}
 	M0_LEAVE("conn: %p", conn);
 	return conn;
 }
diff --git a/rpc/ut/conn.c b/rpc/ut/conn.c
index d5a4ebc..a711665 100644
--- a/rpc/ut/conn.c
+++ b/rpc/ut/conn.c
@@ -132,10 +132,11 @@ static void conn_init_and_establish(void)
 	fop_set_session(&est_fop);
 	fop_set_session(&est_fop_rep);
 
-	est_fop.f_item.ri_error    = 0;
-	est_reply.rcer_sender_id   = SENDER_ID; /* sender_id_allocate() */
-	est_reply.rcer_rc          = 0;
-	est_fop_rep.f_data.fd_data = &est_reply;
+	est_fop.f_item.ri_error             = 0;
+	est_reply.rcer_rc                   = 0;
+	est_reply.rcer_cookie.co_generation = conn.c_sender_id;
+	est_reply.rcer_cookie.co_addr       = (uint64_t)&conn.c_sender_id;
+	est_fop_rep.f_data.fd_data          = &est_reply;
 
 }
 
@@ -160,7 +161,7 @@ static void conn_terminate(void)
 	fop_set_session(&term_fop_rep);
 
 	term_fop.f_item.ri_error    = 0;
-	term_reply.ctr_sender_id    = est_reply.rcer_sender_id;
+	term_reply.ctr_cookie       = est_reply.rcer_cookie;
 	term_reply.ctr_rc           = 0;
 	term_fop_rep.f_data.fd_data = &term_reply;
 
@@ -232,6 +233,7 @@ static void conn_establish_fail_test(void)
 
 static void conn_establish_reply_fail_test(void)
 {
+
 	/* Checks for Conn M0_RPC_CONN_CONNECTING => M0_RPC_CONN_FAILED */
 	conn_init_and_establish();
 
@@ -244,11 +246,9 @@ static void conn_establish_reply_fail_test(void)
 
 	m0_rpc_conn_fini(&conn);
 	est_fop.f_item.ri_error = 0;
-
-	/* Due to invalid sender id. */
+	/* Due to invalid-cookie */
 	conn_init_and_establish();
-
-	est_reply.rcer_sender_id = SENDER_ID_INVALID;
+	est_reply.rcer_cookie = cookie_invalid;
 	m0_rpc_machine_lock(&machine);
 	m0_rpc_conn_establish_reply_received(&est_fop.f_item);
 	M0_UT_ASSERT(conn.c_sm.sm_rc == -EPROTO);
@@ -256,8 +256,8 @@ static void conn_establish_reply_fail_test(void)
 	M0_UT_ASSERT(conn_state(&conn) == M0_RPC_CONN_FAILED);
 
 	m0_rpc_conn_fini(&conn);
-	est_reply.rcer_sender_id = SENDER_ID; /* restore */
-
+	est_reply.rcer_cookie.co_generation = conn.c_sender_id; /* restore */
+	est_reply.rcer_cookie.co_addr	    = (uint64_t)&conn.c_sender_id;
 }
 
 static void conn_terminate_fail_test(void)
@@ -303,12 +303,12 @@ static void conn_terminate_reply_fail_test(void)
 	m0_rpc_conn_fini(&conn);
 	term_fop.f_item.ri_error = 0;
 
-	/* Due to non-matching sender id. */
+	/* Due to non-matching cookie. */
 	conn_init_and_establish();
 	conn_establish_reply();
 	conn_terminate();
 
-	term_reply.ctr_sender_id = SENDER_ID + 1;
+	term_reply.ctr_cookie.co_generation = SENDER_ID + 1;
 	m0_rpc_machine_lock(&machine);
 	m0_rpc_conn_terminate_reply_received(&term_fop.f_item);
 	m0_rpc_machine_unlock(&machine);
diff --git a/rpc/ut/packet.c b/rpc/ut/packet.c
index 88faebb..ce50947 100644
--- a/rpc/ut/packet.c
+++ b/rpc/ut/packet.c
@@ -199,7 +199,6 @@ static void populate_item(struct m0_rpc_item *item)
 {
 	item->ri_slot_refs[0].sr_ow = (struct m0_rpc_onwire_slot_ref) {
 		.osr_uuid.su_uuid = 9876,
-		.osr_sender_id = 101,
 		.osr_session_id = 523,
 		.osr_slot_id = 23,
 		.osr_verno = {
-- 
1.8.3.2

