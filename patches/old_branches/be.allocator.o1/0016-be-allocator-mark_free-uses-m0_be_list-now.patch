From 31d5cac98bf7525936d4f62aefb31fab238f63aa Mon Sep 17 00:00:00 2001
From: Maxim Medved <max_medved@xyratex.com>
Date: Wed, 20 Nov 2013 01:26:52 +0200
Subject: [PATCH 16/96] be/allocator: mark_free() uses m0_be_list now

---
 be/alloc.c | 79 +++++++++++++++++++++++++++++---------------------------------
 1 file changed, 37 insertions(+), 42 deletions(-)

diff --git a/be/alloc.c b/be/alloc.c
index 7509964..3e7c723 100644
--- a/be/alloc.c
+++ b/be/alloc.c
@@ -206,6 +206,23 @@ static void be_alloc_head_capture(struct m0_be_allocator *a,
 	M0_BE_TX_CAPTURE_PTR(a->ba_seg, tx, a->ba_h);
 }
 
+static void be_alloc_free_flag_capture(struct m0_be_allocator *a,
+				       struct m0_be_tx *tx,
+				       struct be_alloc_chunk *c)
+{
+	M0_BE_TX_CAPTURE_PTR(a->ba_seg, tx, &c->bac_free);
+}
+
+/*
+static void be_alloc_size_capture(struct m0_be_allocator *a,
+				  struct m0_be_tx *tx,
+				  struct be_alloc_chunk *c)
+{
+	if (c != NULL)
+		M0_BE_TX_CAPTURE_PTR(a->ba_seg, tx, &c->bac_size);
+}
+*/
+
 static void chunks_all_tlist_capture_around(struct m0_be_allocator *a,
 					    struct m0_be_tx *tx,
 					    struct be_alloc_chunk *c)
@@ -221,40 +238,6 @@ static void chunks_all_tlist_capture_around(struct m0_be_allocator *a,
 	be_alloc_head_capture(a, tx);
 }
 
-static void chunks_free_tlist_capture_around(struct m0_be_allocator *a,
-					     struct m0_be_tx *tx,
-					     struct be_alloc_chunk *c)
-{
-	struct be_alloc_chunk *fprev;
-	struct be_alloc_chunk *fnext;
-
-	fprev = chunks_free_tlist_prev(&a->ba_h->bah_free.bl_list, c);
-	fnext = chunks_free_tlist_next(&a->ba_h->bah_free.bl_list, c);
-	be_alloc_chunk_capture(a, tx, c);
-	be_alloc_chunk_capture(a, tx, fprev);
-	be_alloc_chunk_capture(a, tx, fnext);
-	be_alloc_head_capture(a, tx);
-}
-
-/** @todo XXX temporary wrappers for a list functions */
-static void chunks_free_tlist_add_tail_c(struct m0_be_allocator *a,
-					 struct m0_be_tx *tx,
-					 struct be_alloc_chunk *c)
-{
-	chunks_free_tlist_add_tail(&a->ba_h->bah_free.bl_list, c);
-	chunks_free_tlist_capture_around(a, tx, c);
-}
-
-static void chunks_free_tlist_add_before_c(struct m0_be_allocator *a,
-					   struct m0_be_tx *tx,
-					   struct be_alloc_chunk *next,
-					   struct be_alloc_chunk *c)
-{
-	chunks_free_tlist_add_before(next, c);
-	chunks_free_tlist_capture_around(a, tx, c);
-	chunks_free_tlist_capture_around(a, tx, next);
-}
-
 static bool be_alloc_is_mem_in_allocator(struct m0_be_allocator *a,
 					 m0_bcount_t size, const void *ptr)
 {
@@ -383,6 +366,7 @@ static void be_alloc_chunk_mark_free(struct m0_be_allocator *a,
 				     struct be_alloc_chunk *c)
 {
 	struct be_alloc_chunk *next;
+	struct m0_be_list     *cfree = be_alloc_list_free(a);
 
 	M0_PRE(be_alloc_chunk_invariant(a, c));
 	M0_PRE(!c->bac_free);
@@ -392,10 +376,13 @@ static void be_alloc_chunk_mark_free(struct m0_be_allocator *a,
 			break;
 	}
 	c->bac_free = true;
-	if (next == NULL)
-		chunks_free_tlist_add_tail_c(a, tx, c);
-	else
-		chunks_free_tlist_add_before_c(a, tx, next, c);
+	be_alloc_free_flag_capture(a, tx, c);
+	if (next == NULL) {
+		M0_BE_OP_SYNC(op, m0_be_list_add_tail(cfree, &op, tx, c));
+	} else {
+		M0_BE_OP_SYNC(op,
+			      m0_be_list_add_before(cfree, &op, tx, next, c));
+	}
 	M0_POST(c->bac_free);
 	M0_POST(be_alloc_chunk_invariant(a, c));
 }
@@ -708,15 +695,21 @@ M0_INTERNAL void m0_be_allocator_credit(struct m0_be_allocator *a,
 	struct m0_be_tx_credit chunk_add_after_credit = {};
 	struct m0_be_tx_credit chunk_del_fini_credit = {};
 	struct m0_be_tx_credit chunk_trymerge_credit = {};
+	struct m0_be_tx_credit cred_mark_free = {};
 	struct m0_be_tx_credit mem_zero_credit = {};
 	struct m0_be_tx_credit chunk_credit;
 	struct m0_be_tx_credit header_credit;
+	struct m0_be_tx_credit cred_free_flag;
+	struct m0_be_tx_credit cred_chunk_size;
 	struct m0_be_tx_credit tmp;
+	struct be_alloc_chunk  chunk;
 	struct m0_be_list      *chunks = be_alloc_list_chunks(a);
 	struct m0_be_list      *free   = be_alloc_list_free(a);
 
-	chunk_credit  = M0_BE_TX_CREDIT_TYPE(struct be_alloc_chunk);
-	header_credit = M0_BE_TX_CREDIT_TYPE(struct m0_be_allocator_header);
+	chunk_credit	= M0_BE_TX_CREDIT_TYPE(struct be_alloc_chunk);
+	header_credit	= M0_BE_TX_CREDIT_TYPE(struct m0_be_allocator_header);
+	cred_free_flag	= M0_BE_TX_CREDIT_PTR(&chunk.bac_free);
+	cred_chunk_size = M0_BE_TX_CREDIT_PTR(&chunk.bac_size);
 
 	shift = max_check(shift, (unsigned) M0_BE_ALLOC_SHIFT_MIN);
 	mem_zero_credit = M0_BE_TX_CREDIT(1, size * 2);
@@ -745,6 +738,9 @@ M0_INTERNAL void m0_be_allocator_credit(struct m0_be_allocator *a,
 	m0_be_tx_credit_add(&chunk_trymerge_credit, &chunk_del_fini_credit);
 	m0_be_tx_credit_add(&chunk_trymerge_credit, &chunk_credit);
 
+	m0_be_list_credit(free, M0_BLO_INSERT, 1, &cred_mark_free);
+	m0_be_tx_credit_add(&cred_mark_free, &cred_free_flag);
+
 	/** @todo TODO XXX add list credits instead of entire header */
 	switch (optype) {
 		case M0_BAO_CREATE:
@@ -767,8 +763,7 @@ M0_INTERNAL void m0_be_allocator_credit(struct m0_be_allocator *a,
 					       M0_BE_ALLOC_SHIFT_MIN, accum);
 			break;
 		case M0_BAO_FREE_ALIGNED:
-			/* be_alloc_chunk_mark_free = tlist_add_before() */
-			m0_be_tx_credit_mac(accum, &capture_around_credit, 2);
+			m0_be_tx_credit_add(accum, &cred_mark_free);
 			m0_be_tx_credit_mac(accum, &chunk_trymerge_credit, 2);
 			break;
 		case M0_BAO_FREE:
-- 
1.8.3.2

