From 9bf2ba0d00911ff7719fb7f43384b396cae094c2 Mon Sep 17 00:00:00 2001
From: Maxim Medved <max_medved@xyratex.com>
Date: Wed, 20 Nov 2013 00:55:00 +0200
Subject: [PATCH 15/96] be/allocator: m0_be_list_add{,_after}() and
 m0_be_tlink_create() used

---
 be/alloc.c | 116 +++++++++++++++++++++++--------------------------------------
 1 file changed, 43 insertions(+), 73 deletions(-)

diff --git a/be/alloc.c b/be/alloc.c
index abdf303..7509964 100644
--- a/be/alloc.c
+++ b/be/alloc.c
@@ -237,22 +237,6 @@ static void chunks_free_tlist_capture_around(struct m0_be_allocator *a,
 }
 
 /** @todo XXX temporary wrappers for a list functions */
-static void chunks_all_tlink_init_c(struct m0_be_allocator *a,
-				    struct m0_be_tx *tx,
-				    struct be_alloc_chunk *c)
-{
-	chunks_all_tlink_init(c);
-	be_alloc_chunk_capture(a, tx, c);
-}
-
-static void chunks_free_tlink_init_c(struct m0_be_allocator *a,
-				     struct m0_be_tx *tx,
-				     struct be_alloc_chunk *c)
-{
-	chunks_free_tlink_init(c);
-	be_alloc_chunk_capture(a, tx, c);
-}
-
 static void chunks_free_tlist_add_tail_c(struct m0_be_allocator *a,
 					 struct m0_be_tx *tx,
 					 struct be_alloc_chunk *c)
@@ -271,42 +255,6 @@ static void chunks_free_tlist_add_before_c(struct m0_be_allocator *a,
 	chunks_free_tlist_capture_around(a, tx, next);
 }
 
-static void chunks_all_tlist_add_after_c(struct m0_be_allocator *a,
-					 struct m0_be_tx *tx,
-					 struct be_alloc_chunk *c,
-					 struct be_alloc_chunk *new)
-{
-	chunks_all_tlist_add_after(c, new);
-	chunks_all_tlist_capture_around(a, tx, c);
-	chunks_all_tlist_capture_around(a, tx, new);
-}
-
-static void chunks_free_tlist_add_after_c(struct m0_be_allocator *a,
-					  struct m0_be_tx *tx,
-					  struct be_alloc_chunk *c,
-					  struct be_alloc_chunk *new)
-{
-	chunks_free_tlist_add_after(c, new);
-	chunks_free_tlist_capture_around(a, tx, c);
-	chunks_free_tlist_capture_around(a, tx, new);
-}
-
-static void chunks_all_tlist_add_c(struct m0_be_allocator *a,
-				   struct m0_be_tx *tx,
-				   struct be_alloc_chunk *new)
-{
-	chunks_all_tlist_add(&a->ba_h->bah_chunks.bl_list, new);
-	chunks_all_tlist_capture_around(a, tx, new);
-}
-
-static void chunks_free_tlist_add_c(struct m0_be_allocator *a,
-				    struct m0_be_tx *tx,
-				    struct be_alloc_chunk *new)
-{
-	chunks_free_tlist_add(&a->ba_h->bah_free.bl_list, new);
-	chunks_free_tlist_capture_around(a, tx, new);
-}
-
 static bool be_alloc_is_mem_in_allocator(struct m0_be_allocator *a,
 					 m0_bcount_t size, const void *ptr)
 {
@@ -378,8 +326,17 @@ static void be_alloc_chunk_init(struct m0_be_allocator *a,
 		.bac_free   = free,
 		.bac_magic1 = M0_BE_ALLOC_MAGIC1,
 	};
-	chunks_all_tlink_init_c(a, tx, c);
-	chunks_free_tlink_init_c(a, tx, c);
+	M0_BE_OP_SYNC(op,
+		      m0_be_tlink_create(c, tx, &op, be_alloc_list_chunks(a)));
+	M0_BE_OP_SYNC(op,
+		      m0_be_tlink_create(c, tx, &op, be_alloc_list_free(a)));
+	/*
+	 * Move this right before m0_be_tlink_create() to optimize capturing
+	 * size. Chunk capturing at the end of the function will help with
+	 * debugging credit calculation errors with current regmap
+	 * implementation.
+	 */
+	be_alloc_chunk_capture(a, tx, c);
 }
 
 static void be_alloc_chunk_del_fini(struct m0_be_allocator *a,
@@ -459,6 +416,8 @@ be_alloc_chunk_add_after(struct m0_be_allocator *a,
 			 uintptr_t offset,
 			 m0_bcount_t size_total, bool free)
 {
+	struct m0_be_list     *chunks = be_alloc_list_chunks(a);
+	struct m0_be_list     *cfree  = be_alloc_list_free(a);
 	struct be_alloc_chunk *new;
 
 	M0_PRE(ergo(c != NULL, be_alloc_chunk_invariant(a, c)));
@@ -471,16 +430,24 @@ be_alloc_chunk_add_after(struct m0_be_allocator *a,
 	be_alloc_chunk_init(a, tx, new, size_total - sizeof(*new), free);
 
 	/** add chunk to m0_be_allocator_header.bac_chunks list */
-	if (c != NULL)
-		chunks_all_tlist_add_after_c(a, tx, c, new);
-	else
-		chunks_all_tlist_add_c(a, tx, new);
+	if (c != NULL) {
+		M0_BE_OP_SYNC(op,
+			      m0_be_list_add_after(chunks, &op, tx, c, new));
+		// chunks_all_tlist_add_after_c(a, tx, c, new);
+	} else {
+		M0_BE_OP_SYNC(op, m0_be_list_add(chunks, &op, tx, new));
+		// chunks_all_tlist_add_c(a, tx, new);
+	}
 	if (free) {
 		/** add chunk to m0_be_allocator_header.bac_free list */
-		if (f != NULL)
-			chunks_free_tlist_add_after_c(a, tx, f, new);
-		else
-			chunks_free_tlist_add_c(a, tx, new);
+		if (f != NULL) {
+			M0_BE_OP_SYNC(op, m0_be_list_add_after(cfree, &op,
+							       tx, f, new));
+			// chunks_free_tlist_add_after_c(a, tx, f, new);
+		} else {
+			M0_BE_OP_SYNC(op, m0_be_list_add(cfree, &op, tx, new));
+			// chunks_free_tlist_add_c(a, tx, new);
+		}
 	}
 	M0_POST(be_alloc_chunk_invariant(a, new));
 	M0_POST(ergo(free && f != NULL, be_alloc_chunk_invariant(a, f)));
@@ -684,17 +651,16 @@ M0_INTERNAL int m0_be_allocator_create(struct m0_be_allocator *a,
 
 	m0_mutex_lock(&a->ba_lock);
 
-	h->bah_size = free_space;
-	h->bah_addr = (void *) ((uintptr_t) a->ba_seg->bs_addr + overhead);
-
+	h->bah_size  = free_space;
+	h->bah_addr  = (void *) ((uintptr_t) a->ba_seg->bs_addr + overhead);
+	h->bah_stats = (struct m0_be_allocator_stats) {
+		.bas_free_space = free_space,
+	};
 	M0_BE_OP_SYNC(op, m0_be_list_create(be_alloc_list_chunks(a), tx, &op,
 					    seg, &chunks_all_tl));
 	M0_BE_OP_SYNC(op, m0_be_list_create(be_alloc_list_free(a), tx, &op,
 					    seg, &chunks_free_tl));
-
-	h->bah_stats = (struct m0_be_allocator_stats) {
-		.bas_free_space = free_space,
-	};
+	be_alloc_head_capture(a, tx);
 
 	/* init main chunk */
 	c = be_alloc_chunk_add_after(a, tx, NULL, NULL, 0, free_space, true);
@@ -761,10 +727,13 @@ M0_INTERNAL void m0_be_allocator_credit(struct m0_be_allocator *a,
 	m0_be_tx_credit_add(&capture_around_credit, &header_credit);
 	m0_be_tx_credit_mac(&capture_around_credit, &chunk_credit, 3);
 
-	/* tlink_init() x2 */
-	m0_be_tx_credit_mac(&chunk_add_after_credit, &chunk_credit, 2);
-	/* tlist_add_after() x2 */
-	m0_be_tx_credit_mac(&chunk_add_after_credit, &capture_around_credit, 4);
+	tmp = M0_BE_TX_CREDIT(0, 0);
+	m0_be_list_credit(free,	  M0_BLO_TLINK_CREATE, 1, &tmp);
+	m0_be_list_credit(chunks, M0_BLO_TLINK_CREATE, 1, &tmp);
+	m0_be_tx_credit_add(&tmp, &chunk_credit);
+	m0_be_list_credit(free,	  M0_BLO_INSERT,       1, &tmp);
+	m0_be_list_credit(chunks, M0_BLO_INSERT,       1, &tmp);
+	chunk_add_after_credit = tmp;
 
 	tmp = M0_BE_TX_CREDIT(0, 0);
 	m0_be_list_credit(free,	  M0_BLO_DELETE,	1, &tmp);
@@ -781,6 +750,7 @@ M0_INTERNAL void m0_be_allocator_credit(struct m0_be_allocator *a,
 		case M0_BAO_CREATE:
 			m0_be_tx_credit_mac(accum, &cred_list_create, 2);
 			m0_be_tx_credit_add(accum, &chunk_add_after_credit);
+			m0_be_tx_credit_add(accum, &header_credit);
 			break;
 		case M0_BAO_DESTROY:
 			m0_be_tx_credit_add(accum, &chunk_del_fini_credit);
-- 
1.8.3.2

