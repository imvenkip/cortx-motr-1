From 9d79dd566d66cf401badaa5ab6c87519c8bb81ea Mon Sep 17 00:00:00 2001
From: Prashant Dhange <prashant_dhange@xyratex.com>
Date: Fri, 21 Dec 2012 03:54:41 -0800
Subject: [PATCH 14/94] Allocate memory to reg in reg_init and free it in
 reg_fini, tx_fini should call reg_fini

---
 be/be.h                 | 13 +++----------
 be/be_impl.h            |  2 +-
 be/be_reg.c             | 33 +++++++++++++++++++++++++--------
 be/be_tx.c              | 10 ++++++----
 be/lib/be_kv_store.c    | 47 ++++++++++++++++++++++-------------------------
 be/lib/be_kv_store.h    |  4 ++--
 be/lib/ut/be_kv_store.c | 28 +++++++++-------------------
 be/lib/ut/be_tlist.c    | 16 ++++++----------
 be/ut/be.c              | 22 +++++++++++-----------
 9 files changed, 85 insertions(+), 90 deletions(-)

diff --git a/be/be.h b/be/be.h
index c23083b..edf143b 100644
--- a/be/be.h
+++ b/be/be.h
@@ -180,6 +180,7 @@ struct m0_be_credit;
 struct m0_be_reg;
 
 /* import */
+#include <malloc.h>
 #include "be/lib/be_tlist.h"
 #include "be/lib/be_buf.h"
 #include "sm/sm.h"
@@ -323,8 +324,8 @@ M0_INTERNAL void m0_be_seg_fail(struct m0_be_seg *seg);
 /**
  * @post reg->br_sm.sm_state == M0_BEREG_INIT
  */
-M0_INTERNAL void m0_be_reg_init(struct m0_be_reg *reg, struct m0_be_tx *tx,
-                                struct m0_be_seg *seg, struct m0_be_buf *buf);
+M0_INTERNAL void m0_be_reg_init(struct m0_be_reg **rout, struct m0_be_tx *tx,
+                                struct m0_be_seg *seg,  struct m0_be_buf *buf);
 
 /**
  * @pre reg->br_sm.sm_state != M0_BEREG_INPROGRESS
@@ -347,7 +348,6 @@ M0_INTERNAL void m0_be_tx_init(struct m0_be_tx *tx,
  *
  * @pre tx->bt_sm.sm_state == M0_BETX_PREPARING
  */
-//M0_INTERNAL void m0_be_tx_prep(struct m0_be_tx *tx, struct m0_be_credit *cred);
 M0_INTERNAL void m0_be_tx_prep(struct m0_be_tx *tx);
 
 /**
@@ -522,13 +522,6 @@ struct m0_be_tx {
 };
 
 /**
- * Resource used by a transaction.
- */
-struct m0_be_credit {
-        /** @todo add more stuff here. */
-};
-
-/**
  * A region in a segment.
  */
 struct m0_be_reg {
diff --git a/be/be_impl.h b/be/be_impl.h
index 51a0b8f..764c290 100644
--- a/be/be_impl.h
+++ b/be/be_impl.h
@@ -61,7 +61,7 @@ struct m0_be_seg_impl {
 struct m0_be_tx_impl {
         rvm_tid_t               *tx_id;
 
-        /* Credit list associated with this transaction */
+        /* Credit list of (m0_be_reg) regions associated with transaction */
         struct m0_tl             bc_tl;
 
         struct m0_sm_group      *sm_group;
diff --git a/be/be_reg.c b/be/be_reg.c
index 7090725..a2a481b 100644
--- a/be/be_reg.c
+++ b/be/be_reg.c
@@ -84,18 +84,27 @@ static const struct m0_sm_conf reg_conf = {
 /**
  * @post reg->br_sm.sm_state == M0_BEREG_INIT
  */
-M0_INTERNAL void m0_be_reg_init(struct m0_be_reg *reg, struct m0_be_tx *tx,
-                                struct m0_be_seg *seg, struct m0_be_buf *buf)
+M0_INTERNAL void m0_be_reg_init(struct m0_be_reg **reg_out, struct m0_be_tx *tx,
+                                struct m0_be_seg *seg,  struct m0_be_buf *buf)
 {
+        struct m0_be_reg *reg;
+                
         /* Asserting on required pointers */
-        M0_ASSERT(reg != NULL);
+        M0_ASSERT(reg_out != NULL);
         M0_ASSERT(seg != NULL);
         M0_ASSERT(buf != NULL);
 
+        reg = (struct m0_be_reg *)malloc(sizeof(struct m0_be_reg)); 
+
+        if (reg == NULL) {
+                /* TODO@ : malloc failed */
+                goto exit_error;
+        }
+
         /* Initialise region structure with required values */
         reg->br_tx  = tx;
         reg->br_seg = seg;
-        reg->br_buf = *buf;
+        reg->br_buf.b_nob = buf->b_nob;
 
         /* todo@ Locking sm_group is required before initializing sm */
         /* todo@ Register the state machine of the region into sm_group */
@@ -107,6 +116,11 @@ M0_INTERNAL void m0_be_reg_init(struct m0_be_reg *reg, struct m0_be_tx *tx,
         reg->br_sm.sm_state = M0_BEREG_INIT;
 
         M0_POST(reg->br_sm.sm_state == M0_BEREG_INIT);
+
+        *reg_out = reg;
+
+exit_error:
+        return;
 }
 
 /**
@@ -246,6 +260,8 @@ M0_INTERNAL void m0_be_reg_capture(struct m0_be_reg *reg)
         M0_ASSERT(reg != NULL);
         M0_ASSERT(reg->br_tx != NULL);
 
+        M0_PRE(reg->br_sm.sm_state == M0_BEREG_INIT);
+
         ret = rvm_set_range(reg->br_tx->bt_impl.tx_id,
                             reg->br_buf.b_addr,
                             reg->br_buf.b_nob);
@@ -271,11 +287,12 @@ M0_INTERNAL void m0_be_reg_capture(struct m0_be_reg *reg)
 M0_INTERNAL void m0_be_reg_fini(struct m0_be_reg *reg)
 {
 
-        /* Asserting on required pointers */
-        M0_ASSERT(reg != NULL);
-
-        /* todo@ M0_PRE(reg->br_sm.sm_state == M0_BEREG_INPROGRESS); */
+        /* release memory allocated in m0_be_reg_init */
+        free(reg);
+        /* todo@ M0_PRE(M0_IN(reg->br_sm.sm_state, (M0_BEREG_DONE, 
+         *                                          M0_BEREG_FAILED)); */
         /* todo@ Finalizing on state machine */
+        
 }
 
 /**
diff --git a/be/be_tx.c b/be/be_tx.c
index e48b7c6..c7593a7 100644
--- a/be/be_tx.c
+++ b/be/be_tx.c
@@ -190,8 +190,7 @@ M0_INTERNAL void m0_be_tx_prep(struct m0_be_tx *tx)
 
                 /* check reg_it->br_sm.sm_state for region state */
 
-                if ( (reg_it->br_sm.sm_state != M0_BEREG_INIT) &&
-                     (reg_it->br_sm.sm_state != M0_BEREG_DONE) ) {
+                if (reg_it->br_sm.sm_state != M0_BEREG_INIT) {
 
                         M0_TX_SM_STATE_SET(tx, M0_BETX_FAILED);
                         /* TODO@ add error log message */
@@ -266,15 +265,18 @@ M0_INTERNAL void m0_be_tx_fini(struct m0_be_tx *tx)
         /* Asserting on required pointers */
         M0_ASSERT(tx != NULL);
 
-        M0_PRE(tx->bt_sm.sm_state == M0_BETX_DONE);
+        M0_PRE(M0_IN(tx->bt_sm.sm_state, (M0_BETX_DONE, M0_BETX_FAILED)));
 
         rvm_free_tid(tx->bt_impl.tx_id);
 
          /* Removing entries from reg list if present */
          /* Iterate credit list of regions */
          m0_tlist_for(&m0_be_reg_tl, &(tx->bt_impl.bc_tl), reg_it) {
-                if (m0_be_reg_tlink_is_in(reg_it))
+                if (m0_be_reg_tlink_is_in(reg_it)) {
                          m0_be_reg_tlink_del_fini(reg_it);
+
+                         m0_be_reg_fini(reg_it);
+                }
          } m0_tlist_endfor;
 
         /* Finalise bt_impl->bc_tl list */
diff --git a/be/lib/be_kv_store.c b/be/lib/be_kv_store.c
index 143f91c..c74d766 100644
--- a/be/lib/be_kv_store.c
+++ b/be/lib/be_kv_store.c
@@ -108,8 +108,8 @@ static void __prep_prev_next_reg(struct m0_kv_store     *handle,
         m0_be_buf_init(prev_buf, NULL, sizeof(struct m0_be_list_link), 0, 0, 0);
         m0_be_buf_init(next_buf, NULL, sizeof(struct m0_be_list_link), 0, 0, 0);
 
-        m0_be_reg_init(prev_reg, NULL, handle->ks_seg, prev_buf);
-        m0_be_reg_init(next_reg, NULL, handle->ks_seg, next_buf);
+        m0_be_reg_init(&prev_reg, NULL, handle->ks_seg, prev_buf);
+        m0_be_reg_init(&next_reg, NULL, handle->ks_seg, next_buf);
 
         prev_reg->br_buf.b_addr = (void *)link_prev;
         next_reg->br_buf.b_addr = (void *)link_next;
@@ -201,7 +201,7 @@ struct m0_be_buf *m0_ks_find(struct m0_kv_store *handle,
 
 struct m0_be_reg *m0_ks_delete(struct m0_kv_store  *handle,
                                struct m0_kv_key    *key,
-                               struct m0_be_credit *cred)
+                               struct m0_be_tx *tx)
 {
         int                    ret_val;
 	struct m0_kv_store_obj *scan;
@@ -237,8 +237,8 @@ struct m0_be_reg *m0_ks_delete(struct m0_kv_store  *handle,
                 __prep_prev_next_reg(handle, prev_buf, next_buf, prev_reg,
                                      next_reg, link_prev, link_next);
 
-                m0_be_credit_add(cred, prev_reg);
-                m0_be_credit_add(cred, next_reg);
+                m0_be_tx_add_cred(tx, prev_reg);
+                m0_be_tx_add_cred(tx, next_reg);
 
                 /* collect return values */
                 ret_reg = target->kvs_val_reg;
@@ -252,7 +252,6 @@ struct m0_be_reg *m0_ks_delete(struct m0_kv_store  *handle,
 static int __ks_alloc_memory_obj(struct m0_kv_store      *handle,
                                  struct m0_kv_store_obj **new_obj,
                                  struct m0_be_buf       **ret_buf,
-                                 struct m0_be_credit     *cred,
                                  struct m0_be_tx         *tx)
 {
         /* Be Domain Transaction */
@@ -267,8 +266,8 @@ static int __ks_alloc_memory_obj(struct m0_kv_store      *handle,
 
         obj_reg->br_sm.sm_state = M0_BEREG_INIT;
         m0_be_buf_init(obj_buf, NULL, sizeof(struct m0_kv_store_obj), 0, 0, 0);
-        m0_be_reg_init(obj_reg, NULL, (handle->ks_seg), obj_buf);
-        m0_be_credit_add(cred, obj_reg);
+        m0_be_reg_init(&obj_reg, NULL, (handle->ks_seg), obj_buf);
+        m0_be_tx_add_cred(tx, obj_reg);
 
         /* Initialise and start transaction */
         m0_be_tx_init(tx, handle->ks_dom, 0);
@@ -279,7 +278,7 @@ static int __ks_alloc_memory_obj(struct m0_kv_store      *handle,
                         M0_TIME_NEVER);
         m0_sm_group_unlock(tx->bt_impl.sm_group);
 
-        m0_be_tx_prep(tx, cred);
+        m0_be_tx_prep(tx);
 
         m0_sm_group_lock(tx->bt_impl.sm_group);
         m0_sm_timedwait(&tx->bt_sm,
@@ -310,7 +309,6 @@ static int __ks_alloc_memory_obj(struct m0_kv_store      *handle,
 }
 
 static int __obj_memory_alloc(struct m0_kv_store      *handle,
-                              struct m0_be_credit     *cred,
                               struct m0_kv_store_obj **new,
                               struct m0_kv_key        *key,
                               struct m0_be_buf        *buf,
@@ -322,7 +320,7 @@ static int __obj_memory_alloc(struct m0_kv_store      *handle,
         uint64_t offset;
 
         /* Allocate memory to the object in which the key will be stored */
-        ret_val = __ks_alloc_memory_obj(handle, new, &buf, cred, tx);
+        ret_val = __ks_alloc_memory_obj(handle, new, &buf, tx);
 	if (new == NULL || buf == NULL || ret_val == BE_KV_FAILURE)
                 return BE_KV_FAILURE;
 
@@ -346,7 +344,6 @@ static int __obj_memory_alloc(struct m0_kv_store      *handle,
 
 static int __add_at_tail_to_tlist(struct m0_kv_store     *handle,
                                   struct m0_kv_store_obj *new,
-                                  struct m0_be_credit    *cred,
                                   struct m0_kv_key       *key,
                                   struct m0_be_buf       *buf,
                                   struct m0_be_tx        *tx)
@@ -378,16 +375,16 @@ static int __add_at_tail_to_tlist(struct m0_kv_store     *handle,
         m0_be_buf_init(prev_buf, NULL, sizeof(struct m0_be_list_link),
                        0, 0, 0);
 
-        m0_be_reg_init(prev_reg, NULL, handle->ks_seg, prev_buf);
+        m0_be_reg_init(&prev_reg, NULL, handle->ks_seg, prev_buf);
         prev_reg->br_buf.b_addr = (void *)link_prev;
 
-        m0_be_credit_add(cred, prev_reg);
+        m0_be_tx_add_cred(tx, prev_reg);
 
         /* Now allocate memory to the object and add at tail */
-        ret_val          = __obj_memory_alloc(handle, cred, &new, key,
+        ret_val          = __obj_memory_alloc(handle, &new, key,
                                               buf, tx);
         temp_reg         = (struct m0_be_reg *)
-                            m0_be_reg_tlist_head(&(cred->bc_tl));
+                            m0_be_reg_tlist_head(&(tx->bt_impl.bc_tl));
         new->kvs_val_reg = temp_reg;
         
         if (ret_val == BE_KV_SUCCESS) {
@@ -399,7 +396,7 @@ static int __add_at_tail_to_tlist(struct m0_kv_store     *handle,
 
 
 int m0_ks_insert(struct m0_kv_store  *handle, struct m0_kv_key *key,
-                 struct m0_be_credit *cred, struct m0_be_tx    *tx)
+                 struct m0_be_tx    *tx)
 {
 	struct m0_be_buf 		*buf       = NULL;
         struct m0_be_buf                *prev_buf  = NULL;
@@ -429,10 +426,10 @@ int m0_ks_insert(struct m0_kv_store  *handle, struct m0_kv_key *key,
 	    (head->ll_prev.virtual_address == (void *)head)) {
 
                 /* Check if list empty, if yes then add as head */
-                ret_val           = __obj_memory_alloc(handle, cred, &new, key,
+                ret_val           = __obj_memory_alloc(handle, &new, key,
                                                        buf, tx);
                 new->kvs_val_reg  = (struct m0_be_reg *)
-                                     m0_be_reg_tlist_head(&(cred->bc_tl));
+                                    m0_be_reg_tlist_head(&(tx->bt_impl.bc_tl));
 
                	if(ret_val == BE_KV_SUCCESS) {
                         m0_be_tlist_add(&handle->ks_list_descr,
@@ -463,18 +460,18 @@ int m0_ks_insert(struct m0_kv_store  *handle, struct m0_kv_key *key,
                                                      prev_reg, next_reg,
                                                      link_prev, link_next);
 
-                                m0_be_credit_add(cred, prev_reg);
-                                m0_be_credit_add(cred, next_reg);
+                                m0_be_tx_add_cred(tx, prev_reg);
+                                m0_be_tx_add_cred(tx, next_reg);
 
                                 /*
                                  * Now allocate memory to the object to be
                                  * stored in the list
                                  */
-                                ret_val = __obj_memory_alloc(handle, cred, &new,
+                                ret_val = __obj_memory_alloc(handle, &new,
                                                              key, buf, tx);
                                 reg_t   = (struct m0_be_reg *)
-                                           m0_be_reg_tlist_head(&(cred->bc_tl)
-                                                               );
+                                       m0_be_reg_tlist_head(&(tx->bt_impl.bc_tl)
+                                                            );
                                 new->kvs_val_reg = reg_t;
 
                	        	if(ret_val == BE_KV_SUCCESS) {
@@ -489,7 +486,7 @@ int m0_ks_insert(struct m0_kv_store  *handle, struct m0_kv_key *key,
 
 		/* If key is largest in the list, add at tail */
                 /* First capture the original tail to add in credit */
-                ret_val = __add_at_tail_to_tlist(handle, new, cred, key, buf,
+                ret_val = __add_at_tail_to_tlist(handle, new, key, buf,
                                                  tx);
 	}
 	return ret_val;
diff --git a/be/lib/be_kv_store.h b/be/lib/be_kv_store.h
index 966f839..1799e0a 100644
--- a/be/lib/be_kv_store.h
+++ b/be/lib/be_kv_store.h
@@ -140,7 +140,7 @@ void m0_ks_update_handle(struct m0_kv_store  *handle,
  * @param ref_value	:	value associated with the key
  */
 int  m0_ks_insert(struct m0_kv_store  *handle, struct m0_kv_key *key,
-		  struct m0_be_credit *cred,   struct m0_be_tx  *tx);
+		  struct m0_be_tx  *tx);
 
 /*
  * Find value with the @key in the tlist contained in @handle.
@@ -165,7 +165,7 @@ struct m0_be_buf  *m0_ks_find(struct m0_kv_store *handle,
  */
 struct m0_be_reg  *m0_ks_delete(struct m0_kv_store *handle,
                                 struct m0_kv_key *key,
-                                struct m0_be_credit *cred);
+                                struct m0_be_tx *tx);
 
 /*
  * Fini and end the transaction.
diff --git a/be/lib/ut/be_kv_store.c b/be/lib/ut/be_kv_store.c
index e1e3627..87e30a2 100644
--- a/be/lib/ut/be_kv_store.c
+++ b/be/lib/ut/be_kv_store.c
@@ -33,14 +33,13 @@ struct m0_stob          stob;
 struct m0_stob          log_stob;
 
 int main() {
-        struct m0_be_credit      cred;
 	struct m0_kv_store       handle;
 	struct m0_kv_key         key1;
         struct m0_kv_key         key2;
         struct m0_kv_key         key3;
-        struct m0_be_reg         obj1_reg;
-        struct m0_be_reg         obj2_reg;
-        struct m0_be_reg         obj3_reg;
+        struct m0_be_reg         *obj1_reg;
+        struct m0_be_reg         *obj2_reg;
+        struct m0_be_reg         *obj3_reg;
         struct m0_be_buf        obj1_buf;
         struct m0_be_buf        obj2_buf;
         struct m0_be_buf        obj3_buf;
@@ -62,55 +61,46 @@ int main() {
         m0_ks_update_handle(&handle, &dom, &seg, &ns_stob, &stob, &log_stob);
 
         /* insert "name" */
-        obj1_reg.br_sm.sm_state = M0_BEREG_INIT;
-        m0_be_credit_init(&cred);
+        obj1_reg->br_sm.sm_state = M0_BEREG_INIT;
         m0_be_buf_init(&obj1_buf, NULL, sizeof(struct m0_kv_store_obj), 0, 0, 0);
         m0_be_reg_init(&obj1_reg, NULL, handle.ks_seg, &obj1_buf);
-        m0_be_credit_add(&cred, &obj1_reg);
 
         tx1 = (struct m0_be_tx *)malloc(sizeof(struct m0_be_tx));
 
 	strcpy(key1.kv_key, obj1_name);
-	status = m0_ks_insert(&handle, &key1, &cred, tx1);
+	status = m0_ks_insert(&handle, &key1, tx1);
 	if (status == BE_KV_SUCCESS)
 		printf("inserted obj1_name\n");
 
         m0_be_ks_obj_fini(tx1);
-        m0_be_credit_fini(&cred);
 
         /* insert midname */
-        obj2_reg.br_sm.sm_state = M0_BEREG_INIT;
-        m0_be_credit_init(&cred);
+        obj2_reg->br_sm.sm_state = M0_BEREG_INIT;
         m0_be_buf_init(&obj2_buf, NULL, sizeof(struct m0_kv_store_obj), 0, 0, 0);
         m0_be_reg_init(&obj2_reg, NULL, handle.ks_seg, &obj2_buf);
-        m0_be_credit_add(&cred, &obj2_reg);
 
         tx2 = (struct m0_be_tx *)malloc(sizeof(struct m0_be_tx));
 
 	strcpy(key2.kv_key, obj2_name);
-	status = m0_ks_insert(&handle, &key2, &cred, tx2);
+	status = m0_ks_insert(&handle, &key2, tx2);
 	if (status == BE_KV_SUCCESS)
 		printf("inserted obj2_name\n");
 
         m0_be_ks_obj_fini(tx2);
-        m0_be_credit_fini(&cred);
 
         /* insert surname */
-        obj3_reg.br_sm.sm_state = M0_BEREG_INIT;
-        m0_be_credit_init(&cred);
+        obj3_reg->br_sm.sm_state = M0_BEREG_INIT;
         m0_be_buf_init(&obj3_buf, NULL, sizeof(struct m0_kv_store_obj), 0, 0, 0);
         m0_be_reg_init(&obj3_reg, NULL, handle.ks_seg, &obj3_buf);
-        m0_be_credit_add(&cred, &obj3_reg);
 
         tx3 = (struct m0_be_tx *)malloc(sizeof(struct m0_be_tx));
 
 	strcpy(key3.kv_key, obj3_name);
-	status = m0_ks_insert(&handle, &key3, &cred, tx3);
+	status = m0_ks_insert(&handle, &key3, tx3);
 	if (status == BE_KV_SUCCESS)
 		printf("inserted obj3_name\n");
 
         m0_be_ks_obj_fini(tx3);
-        m0_be_credit_fini(&cred);
 
         ret1_buf = m0_ks_find(&handle, &key1);
         ret2_buf = m0_ks_find(&handle, &key2);
diff --git a/be/lib/ut/be_tlist.c b/be/lib/ut/be_tlist.c
index a272d78..f1b6299 100644
--- a/be/lib/ut/be_tlist.c
+++ b/be/lib/ut/be_tlist.c
@@ -109,25 +109,21 @@ void test_add_be_tlist(struct foo **new_obj, int incoming_key,
 {
         /** Be Domain Transaction */
         struct m0_be_tx         tx;
-        struct m0_be_reg        reg;
-        struct m0_be_credit     cred;
+        struct m0_be_reg        *reg;
         struct m0_be_buf        buf;
 
-        reg.br_sm.sm_state = M0_BEREG_INIT;
-
-        m0_be_credit_init(&cred);
+        reg->br_sm.sm_state = M0_BEREG_INIT;
 
         /** Initialise and start transaction */
         m0_be_tx_init(&tx, &dom, 0);
         m0_be_buf_init(&buf, NULL, sizeof(struct foo), 0, 0, 0);
         m0_be_reg_init(&reg, &tx, &seg, &buf);
-        m0_be_credit_add(&cred, &reg);
 
-        m0_be_tx_prep(&tx, &cred);
+        m0_be_tx_prep(&tx);
         m0_be_tx_start(&tx);
 
-        /** Allocate the memory to the object from @reg.br_buf */
-        *new_obj = (struct foo *)reg.br_buf.b_addr;
+        /** Allocate the memory to the object from @reg->br_buf */
+        *new_obj = (struct foo *)reg->br_buf.b_addr;
         if (*new_obj == NULL) {
                 printf("Failed to allocate memory!!\n");
                 return;
@@ -138,7 +134,7 @@ void test_add_be_tlist(struct foo **new_obj, int incoming_key,
 
         /** Insert in tlist */
         printf("Adding %d:%d to tlist\n", incoming_key, incoming_value);
-        add_to_tlist(*new_obj, reg.br_buf.logical_address);
+        add_to_tlist(*new_obj, reg->br_buf.logical_address);
 
         m0_be_tx_done(&tx);
         m0_be_tx_fini(&tx);
diff --git a/be/ut/be.c b/be/ut/be.c
index d1a77ac..3e52eae 100644
--- a/be/ut/be.c
+++ b/be/ut/be.c
@@ -42,7 +42,7 @@ int main()
 {
         /** Be Domain Transaction */
         struct m0_be_tx tx;
-        struct m0_be_reg reg;
+        struct m0_be_reg *reg;
         struct m0_be_buf buf;
 
         /* Initializing domain */
@@ -105,11 +105,11 @@ int main()
 
         m0_be_buf_init(&buf, NULL, 1024, 0, 0, 0);
         m0_be_reg_init(&reg, NULL, &seg, &buf);
-        m0_be_alloc(&reg);
+        m0_be_alloc(reg);
 
-        m0_be_tx_add_cred(&tx, &reg);
+        m0_be_tx_add_cred(&tx, reg);
 
-        printf("reg : %p reg_state[%d]\n", &reg, reg.br_sm.sm_state);
+        printf("reg : %p reg_state[%d]\n", reg, reg->br_sm.sm_state);
         m0_be_tx_prep(&tx);
 
         m0_sm_group_lock(tx.bt_impl.sm_group);
@@ -127,18 +127,18 @@ int main()
         m0_sm_group_unlock(tx.bt_impl.sm_group);
         printf("\nTx Opened\n");
 
-        strcpy(reg.br_buf.logical_address.virtual_address, "VIRTUAL WORLD");
+        strcpy(reg->br_buf.logical_address.virtual_address, "VIRTUAL WORLD");
         printf("\ndata : [%s]\n",
-                        (char *)reg.br_buf.logical_address.virtual_address);
+                        (char *)reg->br_buf.logical_address.virtual_address);
 
         printf("\nsegment_id : %ld segment_offset : %ld\n",
-                        reg.br_buf.logical_address.segid_offset.u_hi,
-                        reg.br_buf.logical_address.segid_offset.u_lo);
+                        reg->br_buf.logical_address.segid_offset.u_hi,
+                        reg->br_buf.logical_address.segid_offset.u_lo);
 
         printf("\nvirtual_addr : %p\n",
-                        reg.br_buf.logical_address.virtual_address);
+                        reg->br_buf.logical_address.virtual_address);
 
-        strcpy(reg.br_buf.logical_address.virtual_address, "START --> END");
+        strcpy(reg->br_buf.logical_address.virtual_address, "START --> END");
         m0_be_tx_done(&tx);
         m0_sm_group_lock(tx.bt_impl.sm_group);
         m0_sm_timedwait(&tx.bt_sm,
@@ -147,7 +147,7 @@ int main()
         m0_sm_group_unlock(tx.bt_impl.sm_group);
 
         printf("\ndata : [%s]\n",
-                        (char *)reg.br_buf.logical_address.virtual_address);
+                        (char *)reg->br_buf.logical_address.virtual_address);
 
         rvm_truncate();
 
-- 
1.8.3.2

