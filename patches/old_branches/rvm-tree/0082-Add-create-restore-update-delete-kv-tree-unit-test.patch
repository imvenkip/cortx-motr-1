From 397ad5dc6f2f5f8cde7b3c9845c7541c481d3218 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Wed, 17 Apr 2013 13:42:32 +0300
Subject: [PATCH 82/94] Add create/restore/update/delete kv-tree unit test.

---
 be/pool.c  | 40 +++++++++++++++++++++++++---------------
 be/tree.c  | 15 +++++++++++++++
 be/ut/be.c |  4 ++--
 3 files changed, 42 insertions(+), 17 deletions(-)

diff --git a/be/pool.c b/be/pool.c
index 6423afd..79f4f2b 100644
--- a/be/pool.c
+++ b/be/pool.c
@@ -48,8 +48,8 @@ M0_INTERNAL void *m0_be_tx_pool_alloc(struct m0_be_tx_pool *pool, size_t size)
 	return reg->br_buf.b_addr;
 }
 
-static int tx_pool_update(struct m0_be_tx_pool *pool, void *p, size_t size,
-			  bool and_free)
+static struct m0_be_reg *pool_reg_prepare(struct m0_be_tx_pool *pool,
+					  void *p, size_t size)
 {
 	struct m0_be_seg *seg = pool->tp_seg;
 	struct m0_be_tx  *tx  = pool->tp_tx;
@@ -61,35 +61,45 @@ static int tx_pool_update(struct m0_be_tx_pool *pool, void *p, size_t size,
 	/* @todo: should I free this reg somewhere, or it's freed? */
         M0_ALLOC_PTR(reg);
         if (reg == NULL)
-		return -ENOMEM;
+		return NULL;
 
 	/* @todo: check if .b_nob == 0 is OK for this case */
 	buf.b_addr = p;
 	buf.b_nob  = size;
         m0_be_reg_init(reg, tx, seg, &buf);
 
-	if (and_free) {
-		/* XXX: free looks to be a special case. That's why capturing
-		   and then freeing.. */
-		m0_be_reg_capture(reg);
-		m0_be_free(reg);
-	}
-
-	m0_be_tx_add_cred(tx, reg);
-
-	M0_RETURN(0);
+	M0_LEAVE("reg: %p", reg);
+	return(reg);
 }
 
 M0_INTERNAL int m0_be_tx_pool_free(struct m0_be_tx_pool *pool,
 				   void *p, size_t size)
 {
-	return tx_pool_update(pool, p, size, true);
+	struct m0_be_reg *reg = pool_reg_prepare(pool, p, size);
+
+	if (reg == NULL)
+		M0_RETURN(-ENOMEM);
+
+	/* XXX: free looks to be a special case.
+	 * That's why capturing and then freeing.. */
+	m0_be_reg_capture(reg);
+	m0_be_free(reg);
+	m0_free(reg);
+	M0_RETURN(0);
 }
 
 M0_INTERNAL int m0_be_tx_pool_update(struct m0_be_tx_pool *pool,
 				     void *p, size_t size)
 {
-	return tx_pool_update(pool, p, size, false);
+	struct m0_be_tx  *tx  = pool->tp_tx;
+	struct m0_be_reg *reg = pool_reg_prepare(pool, p, size);
+
+	if (reg == NULL)
+		M0_RETURN(-ENOMEM);
+
+	m0_be_tx_add_cred(tx, reg);
+
+	M0_RETURN(0);
 }
 
 M0_INTERNAL void m0_be_tx_pool_init(struct m0_be_tx_pool *pool,
diff --git a/be/tree.c b/be/tree.c
index b8c6df3..3831fdc 100644
--- a/be/tree.c
+++ b/be/tree.c
@@ -719,6 +719,12 @@ M0_INTERNAL int btree_delete_key(struct btree *btree,
 		node_pos.node = node;
 		node_pos.index = index;
 		delete_key_from_node(btree, tx, &node_pos);
+
+		/* Update affected memory regions in tx: */
+		/* XXX: this update looks to be useless */
+		rc = MEM_UPDATE(tx, btree, sizeof(struct btree));
+		M0_ASSERT(rc == 0);
+
 		return 0;
 	}
 	//If the leaf node is the root permit deletion even if the
@@ -727,6 +733,11 @@ M0_INTERNAL int btree_delete_key(struct btree *btree,
 		node_pos.node = node;
 		node_pos.index = index;
 		delete_key_from_node(btree, tx, &node_pos);
+
+		/* Update affected memory regions in tx: */
+		rc = MEM_UPDATE(tx, btree, sizeof(struct btree));
+		M0_ASSERT(rc == 0);
+
 		return 0;
 	}
 
@@ -819,6 +830,10 @@ M0_INTERNAL int btree_delete_key(struct btree *btree,
 		delete_key_from_node(btree, tx, &node_pos);
 	}
 
+	/* Update affected memory regions in tx: */
+	rc = MEM_UPDATE(tx, btree, sizeof(struct btree));
+	M0_ASSERT(rc == 0);
+
 	return 0;
 }
 
diff --git a/be/ut/be.c b/be/ut/be.c
index e6f955f..19006be 100644
--- a/be/ut/be.c
+++ b/be/ut/be.c
@@ -368,8 +368,8 @@ M0_UNUSED static void test_be_tree_load(void)
 	int		   rc		M0_UNUSED;
 	uint32_t	   i		M0_UNUSED;
 	uint32_t	   j		M0_UNUSED;
-	uint32_t           min;
-	uint32_t           max;
+	uint32_t           min		M0_UNUSED;
+	uint32_t           max		M0_UNUSED;
 	struct btree     **tree;
 	struct m0_be_tx   *tx		M0_UNUSED;
 	struct bt_key_val *kv		M0_UNUSED;
-- 
1.8.3.2

