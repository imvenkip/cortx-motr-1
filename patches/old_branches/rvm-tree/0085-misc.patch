From 00e45f739b1dc5014e1dbf3b55f7c94b1571596e Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Wed, 17 Apr 2013 21:31:01 +0300
Subject: [PATCH 85/94] misc.

---
 be/btree.c | 809 -------------------------------------------------------------
 be/btree.h |  93 -------
 be/ut/be.c |  12 +-
 3 files changed, 6 insertions(+), 908 deletions(-)
 delete mode 100644 be/btree.c
 delete mode 100644 be/btree.h

diff --git a/be/btree.c b/be/btree.c
deleted file mode 100644
index 22d4b4b..0000000
--- a/be/btree.c
+++ /dev/null
@@ -1,809 +0,0 @@
-/*
- * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- */
-
-#include "btree.h"
-
-typedef enum {left = -1, right = 1} position_t;
-
-typedef struct {
-        struct m0_be_btree_node *node;
-        uint32_t                 index;
-} node_pos;
-
-static node_pos get_btree_node(struct m0_be_btree *btree, void *key);
-
-static int delete_key_from_node(struct m0_be_btree *btree,
-                                struct m0_be_tx *tx,
-                                node_pos *node_pos);
-
-static struct m0_be_btree_node *merge_nodes(struct m0_be_btree *btree,
-                                            struct m0_be_tx *tx,
-                                            struct m0_be_btree_node *n1,
-                                            struct m0_be_btree_key_val *kv,
-                                            struct m0_be_btree_node *n2);
-static void move_key(struct m0_be_btree *btree,
-                     struct m0_be_tx *tx,
-                     struct m0_be_btree_node *node,
-                     uint32_t index, position_t pos);
-
-static node_pos get_max_key_pos(struct m0_be_btree *btree,
-                                struct m0_be_btree_node *subtree);
-static node_pos get_min_key_pos(struct m0_be_btree *btree,
-                                struct m0_be_btree_node *subtree);
-
-static struct m0_be_btree_node *merge_siblings(struct m0_be_btree *btree,
-                                               struct m0_be_tx *tx,
-                                               struct m0_be_btree_node *parent,
-                                               uint32_t index, position_t pos);
-
-static void copy_key_val(struct m0_be_btree *btree, struct m0_be_btree_key_val *src,
-                         struct m0_be_btree_key_val *dst);
-
-struct m0_be_btree_alloc {
-        struct m0_be_reg *ba_reg;
-        struct m0_be_buf *ba_buf;
-};
-
-static inline struct m0_be_reg *ptr2reg(void *ptr) {
-        return (struct m0_be_reg *)((long)ptr - offsetof(struct m0_be_reg, br_buf.b_addr));
-}
-
-static inline struct m0_be_btree_alloc *reg2alloc(struct m0_be_reg *reg) {
-        return (struct m0_be_btree_alloc *)((long)reg - offsetof(struct m0_be_btree_alloc, ba_reg));
-}
-
-static inline struct m0_be_btree_alloc *ptr2alloc(void *ptr) {
-        return reg2alloc(ptr2reg(ptr));
-}
-
-static void *mem_alloc(struct m0_be_seg *seg, struct m0_be_tx *tx, int size) {
-        struct m0_be_btree_alloc *data;
-        struct m0_be_reg *reg;
-        struct m0_be_buf *buf;
-
-        M0_ALLOC_PTR(data);
-        M0_ALLOC_PTR(buf);
-        M0_ALLOC_PTR(reg);
-        buf->b_nob = size;
-        m0_be_reg_init(reg, tx, seg, buf);
-        m0_be_alloc(reg);
-        m0_be_reg_capture(reg);
-        data->ba_buf = buf;
-        data->ba_reg = reg;
-        return reg->br_buf.b_addr;
-}
-
-static void mem_free(void *ptr)
-{
-        struct m0_be_btree_alloc *data = ptr2alloc(ptr);
-
-        m0_be_free(data->ba_reg);
-        m0_free(data->ba_reg);
-        m0_free(data->ba_buf);
-        m0_free(data);
-}
-
-static struct m0_be_btree_node *btree_alloc_node(struct m0_be_btree *btree,
-                                                 struct m0_be_tx *tx,
-                                                 uint32_t order)
-{
-        struct m0_be_btree_node *node;
-
-        node = (struct m0_be_btree_node *)mem_alloc(btree->seg, tx, sizeof(*node));
-        node->nr_active = 0;
-        node->key_vals = (struct m0_be_btree_key_val **)mem_alloc(btree->seg, tx,
-                                2*order*sizeof(struct m0_be_btree_key_val*) - 1);
-        node->children = (struct m0_be_btree_node **)mem_alloc(btree->seg, tx,
-                                2*order*sizeof(struct m0_be_btree_node*));
-        node->leaf = true;
-        node->level = 0;
-        node->next = NULL;
-        return node;
-}
-
-/* This find reg by @ptr and adds to @tx */
-static void btree_dirty_node(struct m0_be_btree_node *node, struct m0_be_tx *tx)
-{
-        struct m0_be_reg *node_reg = ptr2reg(node);
-        struct m0_be_reg *keys_reg = ptr2reg(node->key_vals);
-        struct m0_be_reg *chrn_reg = ptr2reg(node->children);
-        m0_be_tx_add_cred(tx, node_reg);
-        m0_be_tx_add_cred(tx, keys_reg);
-        m0_be_tx_add_cred(tx, chrn_reg);
-
-        m0_be_tx_prep(tx);
-}
-
-static void btree_dirty(struct m0_be_btree *btree, struct m0_be_tx *tx)
-{
-        m0_be_tx_add_cred(tx, ptr2reg(btree));
-        m0_be_tx_prep(tx);
-}
-
-static void btree_free_node(struct m0_be_btree_node *node)
-{
-        mem_free(node->children);
-        mem_free(node->key_vals);
-        mem_free(node);
-}
-
-struct m0_be_btree *m0_be_btree_create(struct m0_be_seg *seg,
-                                       struct m0_be_tx *tx,
-                                       uint32_t order)
-{
-        struct m0_be_btree *btree;
-
-        btree = mem_alloc(seg, tx, sizeof(*btree));
-        btree->seg = seg;
-        btree->order = order;
-        btree->root = btree_alloc_node(btree, tx, order);
-        btree->root->leaf = true;
-        btree->root->nr_active = 0;
-        btree->root->next = NULL;
-        btree->root->level = 0;
-        return btree;
-}
-
-static void btree_split_child(struct m0_be_btree *btree,
-                              struct m0_be_tx *tx,
-                              struct m0_be_btree_node *parent,
-                              uint32_t index,
-                              struct m0_be_btree_node *child)
-{
-        uint32_t order = btree->order;
-        int i = 0;
-
-        /* This new node is added to @tx automatically. */
-        struct m0_be_btree_node *new_child = btree_alloc_node(btree, tx, btree->order);
-
-        new_child->leaf = child->leaf;
-        new_child->level = child->level;
-        new_child->nr_active = btree->order - 1;
-
-        /* Copy the higher order keys to the new child */
-        for (i = 0; i < order - 1;i++) {
-                new_child->key_vals[i] = child->key_vals[i + order];
-                if (!child->leaf)
-                        new_child->children[i] = child->children[i + order];
-        }
-
-        /* Copy the last child pointer */
-        if (!child->leaf)
-                new_child->children[i] = child->children[i + order];
-
-        child->nr_active = order - 1;
-
-        for (i = parent->nr_active + 1;i > index + 1;i--)
-                parent->children[i] = parent->children[i - 1];
-        parent->children[index + 1] = new_child;
-
-        for (i = parent->nr_active;i > index;i--)
-                parent->key_vals[i] = parent->key_vals[i - 1];
-
-        parent->key_vals[index] = child->key_vals[order - 1];
-        parent->nr_active++;
-}
-
-static void btree_insert_nonfull(struct m0_be_btree *btree, struct m0_be_tx *tx,
-                                 struct m0_be_btree_node *parent_node,
-                                 struct m0_be_btree_key_val *key_val)
-{
-        uint32_t key = btree->value(key_val->key);
-        int i ;
-        struct m0_be_btree_node *child;
-        struct m0_be_btree_node *node = parent_node;
-
-insert:
-        i = node->nr_active - 1;
-        if (node->leaf) {
-                while(i >= 0 && key < btree->value(node->key_vals[i]->key)) {
-                        node->key_vals[i + 1] = node->key_vals[i];
-                        i--;
-                }
-                node->key_vals[i + 1] = key_val;
-                node->nr_active++;
-        } else {
-                while (i >= 0 && key < btree->value(node->key_vals[i]->key))
-                        i--;
-                i++;
-                child = node->children[i];
-
-                if (child->nr_active == 2*btree->order - 1) {
-                        btree_split_child(btree, tx, node, i, child);
-                        if (btree->value(key_val->key) >
-                                btree->value(node->key_vals[i]->key)) {
-                                i++;
-                        }
-                }
-                node = node->children[i];
-                goto insert;
-        }
-}
-
-int m0_be_btree_insert_key(struct m0_be_btree *btree, struct m0_be_tx *tx,
-                           struct m0_be_btree_key_val *key_val)
-{
-        struct m0_be_btree_node *rnode;
-
-        rnode = btree->root;
-        if (rnode->nr_active == (2*btree->order - 1)) {
-                struct m0_be_btree_node * new_root;
-                new_root = btree_alloc_node(btree, tx, btree->order);
-                new_root->level = btree->root->level + 1;
-                btree->root = new_root;
-                new_root->leaf = false;
-                new_root->nr_active = 0;
-                new_root->children[0]  = rnode;
-                btree_split_child(btree, tx, new_root, 0, rnode);
-                btree_insert_nonfull(btree, tx, new_root, key_val);
-        } else {
-                btree_insert_nonfull(btree, tx, rnode, key_val);
-        }
-        btree_dirty_node(rnode, tx);
-        btree_dirty(btree, tx);
-        return 0;
-}
-
-static node_pos get_max_key_pos(struct m0_be_btree *btree,
-                                struct m0_be_btree_node *subtree)
-{
-        node_pos node_pos;
-        struct m0_be_btree_node *node = subtree;
-
-        while (true) {
-                if (node == NULL)
-                        break;
-
-                if (node->leaf) {
-                        node_pos.node = node;
-                        node_pos.index = node->nr_active - 1;
-                        return node_pos;
-                } else {
-                        node_pos.node = node;
-                        node_pos.index = node->nr_active - 1;
-                        node = node->children[node->nr_active];
-                }
-        }
-        return node_pos;
-}
-
-static node_pos get_min_key_pos(struct m0_be_btree *btree,
-                                struct m0_be_btree_node *subtree)
-{
-        node_pos node_pos;
-        struct m0_be_btree_node *node = subtree; 
-
-        while (true) {
-                if (node == NULL)
-                        break;
-
-                if (node->leaf) {
-                        node_pos.node = node;
-                        node_pos.index = 0;
-                        return node_pos;
-                } else {
-                        node_pos.node = node;
-                        node_pos.index = 0;
-                        node = node->children[0];
-                }
-        }
-        return node_pos;
-}
-
-static struct m0_be_btree_node *merge_siblings(struct m0_be_btree *btree,
-                                               struct m0_be_tx *tx,
-                                               struct m0_be_btree_node *parent,
-                                               uint32_t index, position_t pos)
-{
-        uint32_t i, j;
-        struct m0_be_btree_node *new_node;
-        struct m0_be_btree_node *n1, *n2;
-
-        if (index == (parent->nr_active)) {
-                index--;
-                n1 = parent->children[parent->nr_active - 1];
-                n2 = parent->children[parent->nr_active];
-        } else {
-                n1 = parent->children[index];
-                n2 = parent->children[index + 1];
-        }
-
-        /* Merge the current node with the left node */
-        new_node = btree_alloc_node(btree, tx, btree->order);
-        new_node->level = n1->level;
-        new_node->leaf = n1->leaf;
-
-        for (j = 0;j < btree->order - 1; j++) {
-                new_node->key_vals[j] = n1->key_vals[j];
-                new_node->children[j] = n1->children[j];
-        }
-
-        new_node->key_vals[btree->order - 1] = parent->key_vals[index];
-        new_node->children[btree->order - 1] = n1->children[btree->order - 1];
-
-        for (j = 0;j < btree->order - 1; j++) {
-                new_node->key_vals[j + btree->order] = n2->key_vals[j];
-                new_node->children[j + btree->order] = n2->children[j];
-        }
-        new_node->children[2*btree->order - 1] = n2->children[btree->order - 1];
-
-        parent->children[index] = new_node;
-
-        for (j = index; j < parent->nr_active;j++) {
-                parent->key_vals[j] = parent->key_vals[j + 1];
-                parent->children[j + 1] = parent->children[j + 2];
-        }
-
-        new_node->nr_active = n1->nr_active + n2->nr_active + 1;
-        parent->nr_active--;
-
-        for (i = parent->nr_active;i < 2*btree->order - 1; i++)
-                parent->key_vals[i] = NULL; 
-
-        btree_free_node(n1);
-        btree_free_node(n2);
-
-        if (parent->nr_active == 0 && btree->root == parent) {
-                btree_free_node(parent);
-                btree->root = new_node;
-                if (new_node->level)
-                        new_node->leaf = false;
-                else
-                        new_node->leaf = true; 
-        } else {
-                btree_dirty_node(parent, tx);
-        }
-        btree_dirty(btree, tx);
-
-        return new_node;
-}
-
-static void move_key(struct m0_be_btree *btree,
-                     struct m0_be_tx *tx,
-                     struct m0_be_btree_node *node,
-                     uint32_t index, position_t pos)
-{
-        struct m0_be_btree_node *lchild;
-        struct m0_be_btree_node *rchild;
-        uint32_t i;
-
-        if (pos == right)
-                index--;
-        lchild = node->children[index];
-        rchild = node->children[index + 1];
-
-        if (pos == left) {
-                /* Move the key from the parent to the left child */
-                lchild->key_vals[lchild->nr_active] = node->key_vals[index];
-                lchild->children[lchild->nr_active + 1] = rchild->children[0];
-                rchild->children[0] = NULL;
-                lchild->nr_active++;
-
-                node->key_vals[index] = rchild->key_vals[0];
-                rchild->key_vals[0] = NULL;
-
-                for (i = 0;i < rchild->nr_active - 1;i++) {
-                        rchild->key_vals[i] = rchild->key_vals[i + 1];
-                        rchild->children[i] = rchild->children[i + 1];
-                }
-                rchild->children[rchild->nr_active - 1] = rchild->children[rchild->nr_active];
-                rchild->nr_active--;
-                btree_dirty_node(rchild, tx);
-        } else {
-                /* Move the key from the parent to the right child */
-                for (i = rchild->nr_active; i > 0 ; i--) {
-                        rchild->key_vals[i] = rchild->key_vals[i - 1];
-                        rchild->children[i + 1] = rchild->children[i];
-                }
-                rchild->children[1] = rchild->children[0];
-                rchild->children[0] = NULL;
-
-                rchild->key_vals[0] = node->key_vals[index];
-
-                rchild->children[0] = lchild->children[lchild->nr_active];
-                lchild->children[lchild->nr_active] = NULL;
-
-                node->key_vals[index] = lchild->key_vals[lchild->nr_active - 1];
-                lchild->key_vals[lchild->nr_active - 1] = NULL;
-
-                lchild->nr_active--;
-                rchild->nr_active++;
-        }
-        btree_dirty_node(rchild, tx);
-        btree_dirty_node(lchild, tx);
-        btree_dirty_node(node, tx);
-        btree_dirty(btree, tx);
-}
-
-static struct m0_be_btree_node *merge_nodes(struct m0_be_btree *btree,
-                                            struct m0_be_tx *tx,
-                                            struct m0_be_btree_node *n1,
-                                            struct m0_be_btree_key_val *kv,
-                                            struct m0_be_btree_node *n2)
-{
-        struct m0_be_btree_node *new_node;
-        uint32_t i;
-
-        new_node = btree_alloc_node(btree, tx, btree->order);
-        new_node->leaf = true;
-
-        for (i = 0;i < n1->nr_active;i++) {
-                new_node->key_vals[i]   = n1->key_vals[i];
-                new_node->children[i]   = n1->children[i];
-        }
-        new_node->children[n1->nr_active] = n1->children[n1->nr_active];
-        new_node->key_vals[n1->nr_active] = kv;
-
-        for (i = 0;i < n2->nr_active;i++) {
-                new_node->key_vals[i + n1->nr_active + 1] = n2->key_vals[i];
-                new_node->children[i + n1->nr_active + 1] = n2->children[i];
-        }
-        new_node->children[2*btree->order - 1] = n2->children[n2->nr_active];
-
-        new_node->nr_active = n1->nr_active + n2->nr_active + 1;
-        new_node->leaf = n1->leaf;
-        new_node->level = n1->level;
-
-        btree_free_node(n1);
-        btree_free_node(n2);
-
-        return new_node;
-}
-
-static int delete_key_from_node(struct m0_be_btree *btree,
-                                struct m0_be_tx *tx,
-                                node_pos *node_pos)
-{
-        uint32_t keys_max = 2*btree->order - 1;
-        uint32_t i;
-        struct m0_be_btree_key_val * key_val;
-        struct m0_be_btree_node *node = node_pos->node;
-
-        if (node->leaf == false)
-                return -1;
-        key_val = node->key_vals[node_pos->index];
-
-        for (i = node_pos->index; i < keys_max - 1;i++)
-                node->key_vals[i] = node->key_vals[i + 1];
-
-        if (key_val->key) {
-                mem_free(key_val->key);
-                key_val->key = NULL;
-        }
-
-        if (key_val->val) {
-                mem_free(key_val->val);
-                key_val->val = NULL;
-        }
-
-        node->nr_active--;
-
-        if (node->nr_active == 0)
-                btree_free_node(node);
-        else
-                btree_dirty_node(node, tx);
-        return 0;
-}
-
-int m0_be_btree_delete_key(struct m0_be_btree *btree,
-                           struct m0_be_tx *tx,
-                           struct m0_be_btree_node *subtree,
-                           void *key)
-{
-        uint32_t i, index;
-        struct m0_be_btree_node *node = NULL, *rsibling, *lsibling;
-        struct m0_be_btree_node *comb_node, *parent;
-        node_pos sub_node_pos;
-        node_pos node_pos;
-        struct m0_be_btree_key_val *key_val, *new_key_val;
-        uint32_t kv = btree->value(key);
-
-        node = subtree;
-        parent = NULL;
-
-del_loop:
-        for (i = 0;;i = 0) {
-                // If there are no keys simply return
-                if (!node->nr_active)
-                        return -1;
-
-                // Fix the index of the key greater than or equal
-                // to the key that we would like to search
-                while (i < node->nr_active && kv > btree->value(node->key_vals[i]->key))
-                        i++;
-                index = i;
-
-                // If we find such key break
-                if (i < node->nr_active && kv == btree->value(node->key_vals[i]->key))
-                        break;
-                if (node->leaf)
-                        return -1;
-                //Store the parent node
-                parent = node;
-
-                // To get a child node 
-                node = node->children[i];
-
-                // If NULL not found
-                if (node == NULL)
-                        return -1;
-
-                if (index == (parent->nr_active)) {
-                        lsibling =  parent->children[parent->nr_active - 1];
-                        rsibling = NULL; 
-                } else if (index == 0) {
-                        lsibling = NULL;
-                        rsibling = parent->children[1];
-                } else {
-                        lsibling = parent->children[i - 1];
-                        rsibling = parent->children[i + 1];
-                }
-
-                if (node->nr_active == btree->order - 1 && parent) {
-                        // The current node has (t - 1) keys but the right sibling has > (t - 1) keys
-                        if (rsibling && (rsibling->nr_active > btree->order - 1)) {
-                                move_key(btree, tx, parent, i, left);
-                        } else
-                        // The current node has (t - 1) keys but the left sibling has (t - 1) keys
-                        if (lsibling && (lsibling->nr_active > btree->order - 1)) {
-                                move_key(btree, tx, parent, i, right);
-                        } else
-                        // Left sibling has (t - 1) keys
-                        if (lsibling && (lsibling->nr_active == btree->order - 1)) {
-                                node = merge_siblings(btree, tx, parent, i, left);
-                        } else
-                        // Right sibling has (t - 1) keys
-                        if (rsibling && (rsibling->nr_active == btree->order - 1)) {
-                                node = merge_siblings(btree, tx, parent, i, right);
-                        }
-                }
-        }
-
-        // Case 1 : The node containing the key is found and is the leaf node.
-        // Also the leaf node has keys greater than the minimum required.
-        // Simply remove the key
-        if (node->leaf && (node->nr_active > btree->order - 1)) {
-                node_pos.node = node;
-                node_pos.index = index;
-                delete_key_from_node(btree, tx, &node_pos);
-                return 0;
-        }
-
-        // If the leaf node is the root permit deletion even if the number of keys is
-        // less than (t - 1)
-        if (node->leaf && (node == btree->root)) {
-                node_pos.node = node;
-                node_pos.index = index;
-                delete_key_from_node(btree, tx, &node_pos);
-                return 0;
-        }
-
-        // Case 2: The node containing the key is found and is an internal node
-        if (node->leaf == false) {
-                if (node->children[index]->nr_active > btree->order - 1 ) {
-                        sub_node_pos = get_max_key_pos(btree,node->children[index]);
-                        key_val = sub_node_pos.node->key_vals[sub_node_pos.index];
-
-                        new_key_val = (struct m0_be_btree_key_val *)mem_alloc(btree->seg,
-                                tx, sizeof(struct m0_be_btree_key_val));
-                        copy_key_val(btree, key_val, new_key_val);
-                        node->key_vals[index] = new_key_val;
-
-                        m0_be_btree_delete_key(btree, tx, node->children[index], key_val->key);
-                        /*if (sub_node_pos.node->leaf == false)
-                                M0_LOG(M0_DEBUG, "Not leaf");*/
-                } else if ((node->children[index + 1]->nr_active > btree->order - 1) ) {
-                        sub_node_pos = get_min_key_pos(btree,node->children[index + 1]);
-                        key_val = sub_node_pos.node->key_vals[sub_node_pos.index];
-
-                        new_key_val = (struct m0_be_btree_key_val *)mem_alloc(btree->seg,
-                                tx, sizeof(struct m0_be_btree_key_val));
-                        copy_key_val(btree, key_val, new_key_val);
-                        node->key_vals[index] = new_key_val;
-
-                        m0_be_btree_delete_key(btree, tx, node->children[index + 1], key_val->key);
-                        /*if (sub_node_pos.node->leaf == false)
-                                M0_LOG(M0_DEBUG, "Not leaf");*/
-                } else if (node->children[index]->nr_active == btree->order - 1 &&
-                           node->children[index + 1]->nr_active == btree->order - 1) {
-                        comb_node = merge_nodes(btree, tx, node->children[index],
-                                                node->key_vals[index],
-                                                node->children[index + 1]);
-                        node->children[index] = comb_node;
-
-                        for (i = index + 1; i < node->nr_active;i++) {
-                                node->children[i] = node->children[i + 1];
-                                node->key_vals[i - 1] = node->key_vals[i];
-                        }
-                        node->nr_active--;
-                        if (node->nr_active == 0 && btree->root == node) {
-                                btree_free_node(node);
-                                btree->root = comb_node;
-                        } 
-                        node = comb_node;
-                        goto del_loop;
-                }
-          }
-
-        // Case 3:
-        // In this case start from the top of the tree and continue
-        // moving to the leaf node making sure that each node that
-        // we encounter on the way has atleast 't' (order of the tree)
-        // keys 
-        if (node->leaf && (node->nr_active > btree->order - 1)) {
-                node_pos.node = node;
-                node_pos.index = index;
-                delete_key_from_node(btree, tx, &node_pos);
-        }
-
-        return 0;
-}
-
-node_pos get_btree_node(struct m0_be_btree *btree, void *key) {
-        node_pos kp;
-        uint32_t key_val = btree->value(key);
-        struct m0_be_btree_node *node;
-        uint32_t i = 0;
-
-        node = btree->root;
-
-        for (;;i = 0) {
-                // Fix the index of the key greater than or equal
-                // to the key that we would like to search
-                while (i < node->nr_active && key_val > btree->value(node->key_vals[i]->key))
-                        i++;
-
-                // If we find such key return the key-value pair
-                if (i < node->nr_active && key_val == btree->value(node->key_vals[i]->key)) {
-                        kp.node = node;
-                        kp.index = i;
-                        return kp;
-                }
-
-                // If the node is leaf and if we did not find the key 
-                // return NULL
-                if (node->leaf)
-                        return kp;
-
-                // To got a child node 
-                node = node->children[i];
-        }
-        return kp;
-}
-
-void m0_be_btree_destroy(struct m0_be_btree *btree, struct m0_be_tx *tx) {
-        uint32_t current_level;
-        int i = 0;
-
-        struct m0_be_btree_node *head, *tail, *node;
-        struct m0_be_btree_node *child, *del_node;
-
-        node = btree->root;
-        current_level = node->level;
-        head = node;
-        tail = node;
-
-        while (true) {
-                if (head == NULL)
-                        break;
-                if (head->level < current_level)
-                        current_level = head->level;
-
-                if (head->leaf == false) {
-                        for (i = 0 ; i < head->nr_active + 1; i++) {
-                                child = head->children[i];
-                                tail->next = child;
-                                tail = child;
-                                child->next = NULL;
-                        }
-                }
-                del_node = head;
-                head = head->next;
-                btree_free_node(del_node);
-        }
-}
-
-struct m0_be_btree_key_val *m0_be_btree_search(struct m0_be_btree *btree, void *key)
-{
-        struct m0_be_btree_key_val *key_val = NULL;
-        node_pos kp = get_btree_node(btree, key);
-
-        if (kp.node)
-                key_val = kp.node->key_vals[kp.index];
-        return key_val;
-}
-
-static void copy_key_val(struct m0_be_btree *btree,
-                         struct m0_be_btree_key_val *src,
-                         struct m0_be_btree_key_val *dst)
-{
-        uint32_t keysize;
-        uint32_t datasize;
-
-        keysize = btree->key_size(src->key);
-        dst->key = (void *)m0_alloc(keysize);
-        bcopy(src->key, dst->key, keysize);
-
-        if (src->val) {
-                datasize = btree->data_size(src->val);
-                dst->val = (void *)m0_alloc(datasize);
-                bcopy(src->val, dst->val, datasize);
-        }
-}
-
-void *btree_get_max_key(struct m0_be_btree *btree) {
-        node_pos node_pos;
-        node_pos = get_max_key_pos(btree, btree->root);
-        return node_pos.node->key_vals[node_pos.index]->key;
-}
-
-void *btree_get_min_key(struct m0_be_btree *btree) {
-        node_pos node_pos;
-        node_pos = get_min_key_pos(btree,btree->root);
-        return node_pos.node->key_vals[node_pos.index]->key;
-}
-
-#ifdef DEBUG
-static void print_node(struct m0_be_btree *btree,
-                       struct m0_be_btree_node *node)
-{
-        int i = 0;
-
-        print(" { ");
-        while(i < node->nr_active) {
-                print("0x%x(%d) ", btree->value(node->key_vals[i]->key),
-                      node->level);
-                i++;
-        }
-        print("} (0x%x,%d) ", node, node->leaf);
-}
-
-void m0_be_btree_print(struct m0_be_btree *btree, struct m0_be_btree_node *node)
-{
-        int i = 0;
-        uint32_t current_level;
-
-        struct m0_be_btree_node *head, *tail;
-        struct m0_be_btree_node *child;
-
-        current_level = node->level;
-        head = node;
-        tail = node;
-
-        while (true) {
-                if (head == NULL)
-                        break;
-                if (head->level < current_level) {
-                        current_level = head->level;
-                        print("\n");
-                }
-                print_node(btree,head);
-
-                if (head->leaf == false) {
-                        for (i = 0 ; i < head->nr_active + 1; i++) {
-                                child = head->children[i];
-                                tail->next = child;
-                                tail = child;
-                                child->next = NULL;
-                        }
-                }
-                head = head->next;
-        }
-        print("\n");
-}
-
-#endif
diff --git a/be/btree.h b/be/btree.h
deleted file mode 100644
index b7a71bb..0000000
--- a/be/btree.h
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- */
-
-#pragma once
-
-#ifndef __MERO_BE_BTREE_H__
-#define __MERO_BE_BTREE_H__
-
-#include "lib/trace.h"        /* M0_LOG and M0_ENTRY */
-
-#include "lib/assert.h"
-#include "lib/cdefs.h"
-#include "lib/errno.h"
-#include "lib/memory.h"
-#include "lib/misc.h" /* SET0() */
-#include "lib/types.h"
-
-#include "be/be.h"
-#include "be/tx.h"
-
-/**
-  @defgroup be_btree
-  @{
-*/
-
-struct m0_be_btree_key_val {
-        void                            *key;
-        void                            *val;
-};
-
-struct m0_be_btree_node {
-        struct m0_be_btree_node         *next;          /**< Pointer used for linked list */
-        bool                             leaf;          /**< Used to indicate whether leaf or not */
-        uint32_t                         nr_active;     /**< Number of active keys */
-        uint32_t                         level;         /**< Level in the B-Tree */
-        struct m0_be_btree_key_val     **key_vals;      /**< Array of keys and values */
-        struct m0_be_btree_node        **children;      /**< Array of pointers to child nodes */
-};
-
-struct m0_be_btree {
-        uint32_t                         order;         /**< B-Tree order */
-        struct m0_be_btree_node         *root;          /**< Root of the B-Tree */
-        struct m0_be_seg                *seg;           /**< Tree segment */
-        uint32_t (*value)(void *key);                   /**< Generate uint value for the key */
-        uint32_t (*key_size)(void *key);                /**< Return the key size */
-        uint32_t (*data_size)(void *data);              /**< Return the data size */
-        void     (*print_key)(void *key);               /**< Print the key */
-};
-
-struct m0_be_btree *m0_be_btree_create(struct m0_be_seg *seg,
-                                       struct m0_be_tx *tx,
-                                       uint32_t order);
-int m0_be_btree_insert_key(struct m0_be_btree *btree, struct m0_be_tx *tx,
-                           struct m0_be_btree_key_val *key_val);
-int m0_be_btree_delete_key(struct m0_be_btree *btree, struct m0_be_tx *tx,
-                           struct m0_be_btree_node *subtree, void *key);
-struct m0_be_btree_key_val *btree_search(struct m0_be_btree *btree, void *key);
-void m0_be_btree_destroy(struct m0_be_btree *btree, struct m0_be_tx *tx);
-void *m0_be_btree_get_max_key(struct m0_be_btree *btree);
-void *m0_be_btree_get_min_key(struct m0_be_btree *btree);
-
-#ifdef DEBUG
-void m0_be_btree_print(struct m0_be_btree *btree, struct m0_be_btree_node *node);
-#endif
-
-/** @} end of be_btree group */
-
-/* __MERO_BE_BTREE_H__ */
-#endif
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/be/ut/be.c b/be/ut/be.c
index 1776b18..f2c73ab 100644
--- a/be/ut/be.c
+++ b/be/ut/be.c
@@ -395,13 +395,13 @@ M0_UNUSED static void btree_log(struct btree **tree)
 M0_UNUSED static void test_be_tree_load(void)
 {
 #if RVM_LOADED_UPDATE
-	int		   rc;		/* M0_UNUSED; */
-	uint32_t	   i;		/* M0_UNUSED; */
-	uint32_t	   j;		/* M0_UNUSED; */
-	struct m0_be_tx   *tx;		/* M0_UNUSED; */
-	struct bt_key_val *kv;		/* M0_UNUSED; */
+	int		   rc;
+	uint32_t	   i;
+	uint32_t	   j;
+	struct m0_be_tx   *tx;
+	struct bt_key_val *kv;
 #endif
-	struct btree     **tree;	/* M0_UNUSED; */
+	struct btree     **tree;
 
 	tree = (struct btree**) m0_be_static_reg_get_handle_addr(seg, 0);
 	M0_UT_ASSERT(tree != NULL);
-- 
1.8.3.2

