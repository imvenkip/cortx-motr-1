From 114a19a1b15f3d0a66ff4027077503c654d4f69c Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Thu, 25 Apr 2013 12:49:57 +0300
Subject: [PATCH 90/94] Added btree based kv-strore and UT.

---
 be/Makefile.sub    |   1 +
 be/kvs.c           |  97 +++++++++++++-----
 be/kvs.h           |  19 ++--
 be/kvs_internal.h  |  32 ++++++
 be/ut/Makefile.sub |   1 +
 be/ut/be.c         |  50 ++--------
 be/ut/kvs.c        | 282 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 utils/ut_main.c    |   2 +
 8 files changed, 410 insertions(+), 74 deletions(-)
 create mode 100644 be/kvs_internal.h
 create mode 100644 be/ut/kvs.c

diff --git a/be/Makefile.sub b/be/Makefile.sub
index 3922af9..ddc5c32 100644
--- a/be/Makefile.sub
+++ b/be/Makefile.sub
@@ -5,6 +5,7 @@ nobase_mero_include_HEADERS +=  be/be.h
 				be/handle_store.h	\
 				be/kv_store.h           \
 				be/kvs.h		\
+				be/kvs_internal.h	\
 				be/tree.h		\
 				be/pool.h
 
diff --git a/be/kvs.c b/be/kvs.c
index 9fb293a..461d6e3 100644
--- a/be/kvs.c
+++ b/be/kvs.c
@@ -28,6 +28,7 @@
 #include "be/seg.h"
 #include "be/reg.h"
 #include "be/kvs.h"
+#include "be/kvs_internal.h"
 #include "be/be.h"
 #include "be/tx.h"
 
@@ -72,7 +73,7 @@ static const struct btree_tx_ops tx_ops = {
 /* -------------------------------------------------------------------------
  * Tx-Helpers
  * ----------------------------------------------------------------------- */
-static int be_tx_commit(struct m0_be_tx *tx, bool prepare)
+M0_INTERNAL int __be_tx_commit(struct m0_be_tx *tx, bool prepare)
 {
 	struct m0_sm_group *sm_group;
 
@@ -89,7 +90,7 @@ static int be_tx_commit(struct m0_be_tx *tx, bool prepare)
 	return m0_be_tx_state(tx) == M0_BETX_DONE ? 0 : -1;
 }
 
-static struct m0_be_tx *be_tx_init(struct m0_be_domain *dom)
+M0_INTERNAL struct m0_be_tx *__be_tx_init(struct m0_be_domain *dom)
 {
 	struct m0_be_tx *tx;
 
@@ -106,7 +107,7 @@ static struct m0_be_tx *be_tx_init(struct m0_be_domain *dom)
 	return tx;
 }
 
-static void be_tx_fini(struct m0_be_tx *tx)
+M0_INTERNAL void __be_tx_fini(struct m0_be_tx *tx)
 {
 	m0_be_tx_fini(tx);
         m0_free(tx);
@@ -186,13 +187,43 @@ struct btree *handle_restore(struct m0_be_seg *seg, uint64_t index,
 	return *tree;
 }
 
-struct btree *handle_create(struct m0_be_kvs *ks, const struct btree_ops *ops)
+static int static_handle_store(struct m0_be_kvs *ks, struct btree *tree,
+			       uint64_t offset)
+{
+	struct m0_be_reg *static_reg;
+	struct m0_be_tx  *tx;
+	struct btree    **ptree;
+	int               rc;
+
+	M0_ALLOC_PTR(static_reg);
+	if (static_reg == NULL)
+		return -ENOMEM;
+
+	tx = __be_tx_init(ks->bk_dom);
+	if (tx == NULL) {
+		m0_free(static_reg);
+		return -ENOMEM;
+	}
+
+	m0_be_static_reg_capture_buf(offset, ks->bk_seg, static_reg, tx);
+	ptree = (struct btree **)m0_be_static_reg_get_handle_addr(ks->bk_seg,
+								  offset);
+	*ptree = tree;
+
+	rc = __be_tx_commit(tx, false);
+	__be_tx_fini(tx);
+
+	return rc;
+}
+
+struct btree *handle_create(struct m0_be_kvs *ks, uint64_t index,
+			    const struct btree_ops *ops)
 {
 	struct m0_be_tx *tx;
 	struct btree    *tree;
 	int rc;
 
-	tx = be_tx_init(ks->bk_dom);
+	tx = __be_tx_init(ks->bk_dom);
 	if (tx == NULL)
 		return NULL;
 
@@ -201,8 +232,10 @@ struct btree *handle_create(struct m0_be_kvs *ks, const struct btree_ops *ops)
 	if (tree == NULL)
 		return NULL;
 
-	rc = be_tx_commit(tx, true);
-	be_tx_fini(tx);
+	rc = __be_tx_commit(tx, true);
+	__be_tx_fini(tx);
+
+	static_handle_store(ks, tree, index);
 
 	return rc == 0 ? tree : NULL;
 }
@@ -218,6 +251,8 @@ M0_INTERNAL int m0_be_kvs_init(struct m0_be_kvs		*ks,
 {
 	int rc;
 
+	M0_ENTRY();
+
 	*ks = (struct m0_be_kvs) {
 		.bk_dom  = dom,
 		.bk_mode = mode
@@ -230,56 +265,68 @@ M0_INTERNAL int m0_be_kvs_init(struct m0_be_kvs		*ks,
 	if (rc != 0)
 		goto err;
 
+	pool.tp_seg = ks->bk_seg;
+
 	ks->bk_tree = mode == M0_BE_KVS_RESTORE
 		? handle_restore(ks->bk_seg, index, ops)
-		: handle_create(ks, ops);
+		: handle_create(ks, index, ops);
 
 	if (ks->bk_tree == NULL) {
 		rc = -ENOMEM;
 		goto err;
 	}
 
-	pool.tp_seg = ks->bk_seg;
-
 	return 0;
 err:
 	m0_be_kvs_fini(ks);
-	return rc;
+	M0_RETURN(rc);
 }
 
 M0_INTERNAL void m0_be_kvs_fini(struct m0_be_kvs *ks)
 {
+	M0_ENTRY();
+
 	if (ks->bk_mode == M0_BE_KVS_CREATE)
 		rvm_truncate();
 
         m0_be_seg_done(ks->bk_seg);
+
+	M0_LEAVE();
 }
 
-M0_INTERNAL int m0_be_kvs_update(struct m0_be_kvs        *ks,
-				 struct m0_be_tx         *tx,
-				 const struct bt_key_val *kv)
+M0_INTERNAL int m0_be_kvs_update(struct m0_be_kvs  *ks,
+				 struct m0_be_tx   *tx,
+				 struct bt_key_val *kv)
 {
-	return -1;
+
+	/* very naiive implementation */
+	int rc;
+
+	rc = m0_be_kvs_delete(ks, tx, kv->key);
+	if (rc != 0)
+		return rc;
+
+	return m0_be_kvs_insert(ks, tx, kv);
 }
 
 M0_INTERNAL int m0_be_kvs_delete(struct m0_be_kvs *ks,
 				 struct m0_be_tx  *tx,
-				 const void       *key)
+				 void             *key)
 {
-	return -1;
+	return btree_delete_key(ks->bk_tree, tx, ks->bk_tree->root, key);
 }
 
-M0_INTERNAL int m0_be_kvs_insert(struct m0_be_kvs        *ks,
-				 struct m0_be_tx         *tx,
-				 const struct bt_key_val *kv)
+M0_INTERNAL int m0_be_kvs_insert(struct m0_be_kvs  *ks,
+				 struct m0_be_tx   *tx,
+				 struct bt_key_val *kv)
 {
-	return -1;
+	return btree_insert_key(ks->bk_tree, tx, kv);
 }
 
-M0_INTERNAL void *m0_be_kvs_lookup(struct m0_be_kvs *ks,
-				   const void       *key)
+M0_INTERNAL struct bt_key_val *m0_be_kvs_lookup(struct m0_be_kvs *ks,
+						void             *key)
 {
-	return NULL;
+	return btree_search(ks->bk_tree, key);
 }
 
 M0_INTERNAL struct bt_key_val *m0_be_kvs_pair_setup(const struct m0_be_kvs *ks,
@@ -287,5 +334,5 @@ M0_INTERNAL struct bt_key_val *m0_be_kvs_pair_setup(const struct m0_be_kvs *ks,
 						    void *key, size_t key_size,
 						    void *val, size_t val_size)
 {
-	return NULL;
+	return btree_pair_setup(ks->bk_tree, tx, key, key_size, val, val_size);
 }
diff --git a/be/kvs.h b/be/kvs.h
index 7efc57f..5525a56 100644
--- a/be/kvs.h
+++ b/be/kvs.h
@@ -57,23 +57,24 @@ M0_INTERNAL int m0_be_kvs_init(struct m0_be_kvs		*ks,
 M0_INTERNAL void m0_be_kvs_fini(struct m0_be_kvs *ks);
 
 /*  */
-M0_INTERNAL int m0_be_kvs_update(struct m0_be_kvs        *ks,
-				 struct m0_be_tx         *tx,
-				 const struct bt_key_val *kv);
+M0_INTERNAL int m0_be_kvs_update(struct m0_be_kvs  *ks,
+				 struct m0_be_tx   *tx,
+				 struct bt_key_val *kv);
 
 /*  */
 M0_INTERNAL int m0_be_kvs_delete(struct m0_be_kvs *ks,
 				 struct m0_be_tx  *tx,
-				 const void       *key);
+				 void		  *key);
 
 /*  */
-M0_INTERNAL int m0_be_kvs_insert(struct m0_be_kvs        *ks,
-				 struct m0_be_tx         *tx,
-				 const struct bt_key_val *kv);
+M0_INTERNAL int m0_be_kvs_insert(struct m0_be_kvs  *ks,
+				 struct m0_be_tx   *tx,
+				 struct bt_key_val *kv);
 
 /*  */
-M0_INTERNAL void *m0_be_kvs_lookup(struct m0_be_kvs *ks,
-				   const void       *key);
+M0_INTERNAL struct bt_key_val *m0_be_kvs_lookup(struct m0_be_kvs *ks,
+						void		 *key);
+
 
 
 /*  */
diff --git a/be/kvs_internal.h b/be/kvs_internal.h
new file mode 100644
index 0000000..77ed596
--- /dev/null
+++ b/be/kvs_internal.h
@@ -0,0 +1,32 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original creation date: 17/04/2013
+ */
+#pragma once
+#ifndef __MERO_BE_KVS_INTERNAL_H__
+#define __MERO_BE_KVS_INTERNAL_H__
+
+struct m0_be_domain;
+struct m0_be_tx;
+
+
+M0_INTERNAL int __be_tx_commit(struct m0_be_tx *tx, bool prepare);
+M0_INTERNAL struct m0_be_tx *__be_tx_init(struct m0_be_domain *dom);
+M0_INTERNAL void __be_tx_fini(struct m0_be_tx *tx);
+
+#endif	/* __MERO_BE_KVS_INTERNAL_H__ */
diff --git a/be/ut/Makefile.sub b/be/ut/Makefile.sub
index 2726512..9250af5 100644
--- a/be/ut/Makefile.sub
+++ b/be/ut/Makefile.sub
@@ -1,5 +1,6 @@
 #be/ut/handle_store.c
 ut_libmero_ut_la_SOURCES += be/ut/be.c			\
 			    be/ut/kv_store.c		\
+			    be/ut/kvs.c			\
 			    be/ut/handle_store.c	\
 			    be/ut/kv_store_ub.c
diff --git a/be/ut/be.c b/be/ut/be.c
index a692075..cd8d0fd 100644
--- a/be/ut/be.c
+++ b/be/ut/be.c
@@ -219,6 +219,7 @@ static void test_be_transaction()
 
 #include "be/tree.h"
 #include "be/pool.h"
+#include "be/kvs_internal.h"
 
 enum {
 	TREE_FAN_OUT = 5,
@@ -279,37 +280,6 @@ static const struct btree_ops tops = {
 	.data_size = tree_data_size
 };
 
-static void be_tx_commit(struct m0_be_tx *tx, bool prepare)
-{
-	if (prepare)
-		m0_be_tx_prep(tx);
-
-        m0_be_tx_start(tx);
-        m0_be_tx_done(tx);
-
-        m0_sm_group_lock(sm_group);
-        m0_sm_timedwait(&tx->bt_sm, (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED),
-                        M0_TIME_NEVER);
-        m0_sm_group_unlock(sm_group);
-}
-
-static struct m0_be_tx *be_tx_init(void)
-{
-	struct m0_be_tx *tx;
-
-        M0_ALLOC_PTR(tx);
-        M0_UT_ASSERT(tx != NULL);
-        m0_be_tx_init(tx, dom, 0);
-
-	return tx;
-}
-
-static void be_tx_fini(struct m0_be_tx *tx)
-{
-	m0_be_tx_fini(tx);
-        m0_free(tx);
-}
-
 M0_UNUSED static void test_be_tree_create(void)
 {
 	struct bt_key_val *bkv;
@@ -324,7 +294,7 @@ M0_UNUSED static void test_be_tree_create(void)
 	/*
 	 * Start using transaction...
 	 */
-	tx = be_tx_init();
+	tx = __be_tx_init(dom);
 
 	/*
 	 * Start manupulating tree here...
@@ -346,13 +316,13 @@ M0_UNUSED static void test_be_tree_create(void)
 	/*
 	 * Finish with transactions...
 	 */
-	be_tx_commit(tx, true);
-	be_tx_fini(tx);
+	__be_tx_commit(tx, true);
+	__be_tx_fini(tx);
 
 	/*
 	 * Save handle in static part of the segment
 	 */
-	tx = be_tx_init();
+	tx = __be_tx_init(dom);
 	M0_ALLOC_PTR(static_reg);
 	M0_ASSERT(static_reg != NULL);
 
@@ -360,8 +330,8 @@ M0_UNUSED static void test_be_tree_create(void)
 	ptree = (struct btree **)m0_be_static_reg_get_handle_addr(seg, 0);
 	*ptree = tree;
 
-	be_tx_commit(tx, false);
-	be_tx_fini(tx);
+	__be_tx_commit(tx, false);
+	__be_tx_fini(tx);
 	m0_free(static_reg);
 }
 
@@ -424,7 +394,7 @@ M0_UNUSED static void test_be_tree_load(void)
 	/*
 	 * Start using transaction...
 	 */
-	tx = be_tx_init();
+	tx = __be_tx_init(dom);
 
 	/*
 	 * Delete, insert...
@@ -467,8 +437,8 @@ M0_UNUSED static void test_be_tree_load(void)
 	/*
 	 * Finish with transactions...
 	 */
-	be_tx_commit(tx, true);
-	be_tx_fini(tx);
+	__be_tx_commit(tx, true);
+	__be_tx_fini(tx);
 #endif
 }
 
diff --git a/be/ut/kvs.c b/be/ut/kvs.c
new file mode 100644
index 0000000..c62bf5d
--- /dev/null
+++ b/be/ut/kvs.c
@@ -0,0 +1,282 @@
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author           : Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original creation date    : 19/04/2013
+ */
+
+
+#undef M0_TRACE_SUBSYSTEM
+#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_BE
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "mero/magic.h"
+#include "lib/memory.h"
+#include "lib/trace.h"
+#include "lib/cdefs.h"
+#include "lib/ut.h"
+#include "sm/sm.h"
+
+#include "be/kvs_internal.h"
+#include "be/domain.h"
+#include "be/tree.h"
+#include "be/reg.h"
+#include "be/seg.h"
+#include "be/kvs.h"
+#include "be/be.h"
+#include "be/tx.h"
+
+#define RVM_CREATE 1
+
+static struct m0_be_kvs	    kvstore;
+static struct m0_sm_group  *sm_group;
+static struct m0_be_domain *dom;
+
+static int tree_cmp(void *key0, void *key1)
+{
+	return strcmp(key0, key1);
+}
+
+static uint32_t tree_key_size(void *key)
+{
+	return strlen(key) + 1;
+}
+
+static uint32_t tree_data_size(void *data)
+{
+	return strlen(data) + 1;
+}
+
+static const struct btree_ops kv_ops = {
+	.compare   = tree_cmp,
+	.key_size  = tree_key_size,
+	.data_size = tree_data_size
+};
+
+extern const char      *log_file;
+
+static int ts_be_init(void)   /* ts_ for "test suite" */
+{
+        int rc = 0;
+#if RVM_CREATE
+	static const char      *stob_dir  = "/tmp/__be/o";
+	static const char      *stob_file = "0000000000000000.0000000000000001";
+	static char be_cmd[1024];
+
+        M0_LOG(M0_DEBUG, "Test Initialization");
+        sprintf(be_cmd, "rm -rf %s", log_file);
+        rc = system(be_cmd);
+        M0_ASSERT(rc == 0);
+
+        sprintf(be_cmd, "mkdir -p %s", stob_dir);
+        rc = system(be_cmd);
+        M0_ASSERT(rc == 0);
+
+        sprintf(be_cmd, "dd if=/dev/zero of=%s/%s bs=1024 count=102408"
+		" 2>/dev/null", stob_dir, stob_file);
+        rc = system(be_cmd);
+        M0_ASSERT(rc == 0);
+
+        M0_ALLOC_PTR(dom);
+        M0_ASSERT(dom != NULL);
+
+        M0_LOG(M0_DEBUG, "Domain create");
+        m0_be_domain_create(dom, NULL, NULL, M0_BE_DOMAIN_MAGIC);
+        m0_be_domain_init(dom);
+        sm_group = m0_be_domain_sm_group(dom);
+        M0_ASSERT(sm_group != NULL);
+
+	m0_be_seg_state_change(&dom->bd_data, M0_BESEG_ACTIVE);
+
+	/*
+	 * kv-store init
+	 */
+	rc = m0_be_kvs_init(&kvstore, dom, &kv_ops, M0_BE_KVS_CREATE, 0);
+	M0_ASSERT(rc == 0);
+
+#else
+        M0_LOG(M0_DEBUG, "Test Re-initialization");
+
+        M0_ALLOC_PTR(dom);
+        M0_ASSERT(dom != NULL);
+
+        M0_LOG(M0_DEBUG, "Domain recreate");
+        m0_be_domain_create(dom, NULL, NULL, M0_BE_DOMAIN_MAGIC);
+        m0_be_domain_init(dom);
+        sm_group = m0_be_domain_sm_group(dom);
+        M0_ASSERT(sm_group != NULL);
+
+        m0_be_seg_state_change(&dom->bd_data, M0_BESEG_ACTIVE);
+
+	/*
+	 * kv-store init
+	 */
+	rc = m0_be_kvs_init(&kvstore, dom, &kv_ops, M0_BE_KVS_RESTORE, 0);
+	M0_ASSERT(rc == 0);
+#endif
+
+        return rc;
+}
+
+static int ts_be_fini(void)
+{
+	/*
+	 * kv-store init
+	 */
+	m0_be_kvs_fini(&kvstore);
+
+        m0_sm_group_lock(sm_group);
+        m0_sm_state_set(&dom->bd_data.bs_sm, M0_BESEG_CLOSED);
+        m0_sm_group_unlock(sm_group);
+        m0_be_domain_fini(dom);
+
+        m0_free(dom);
+
+        return 0;
+}
+
+void test_be_kvs_create(void)
+{
+	struct bt_key_val *k;
+	struct m0_be_tx   *tx;
+	char		   kv[16];
+	char		   nv[16];
+	int		   rc;
+
+	/*
+	 * Start using transaction...
+	 */
+	tx = __be_tx_init(dom);
+
+	/*
+	 * Insert
+	 */
+	sprintf(kv, "%d", 101);
+	k = m0_be_kvs_pair_setup(&kvstore, tx, kv, strlen(kv) + 1,
+					       kv, strlen(kv) + 1);
+	M0_UT_ASSERT(k != NULL);
+
+	rc = m0_be_kvs_insert(&kvstore, tx, k);
+	M0_UT_ASSERT(rc == 0);
+
+	sprintf(kv, "%d", 202);
+	k = m0_be_kvs_pair_setup(&kvstore, tx, kv, strlen(kv) + 1,
+					       kv, strlen(kv) + 1);
+	M0_UT_ASSERT(k != NULL);
+
+	rc = m0_be_kvs_insert(&kvstore, tx, k);
+	M0_UT_ASSERT(rc == 0);
+
+	sprintf(kv, "%d", 303);
+	k = m0_be_kvs_pair_setup(&kvstore, tx, kv, strlen(kv) + 1,
+					       kv, strlen(kv) + 1);
+	M0_UT_ASSERT(k != NULL);
+
+	rc = m0_be_kvs_insert(&kvstore, tx, k);
+	M0_UT_ASSERT(rc == 0);
+
+	/*
+	 * Lookup
+	 */
+	sprintf(kv, "%d", 404);
+	k = m0_be_kvs_lookup(&kvstore, kv);
+	M0_UT_ASSERT(k == NULL);
+
+	sprintf(kv, "%d", 303);
+	k = m0_be_kvs_lookup(&kvstore, kv);
+	M0_UT_ASSERT(k != NULL);
+
+	/*
+	 * Delete
+	 */
+	rc = m0_be_kvs_delete(&kvstore, tx, kv);
+	M0_UT_ASSERT(rc == 0);
+
+	/*
+	 * Update
+	 */
+	sprintf(kv, "%d", 202);
+	sprintf(nv, "%d", 5555);
+	k = m0_be_kvs_pair_setup(&kvstore, tx, kv, strlen(kv) + 1,
+					       nv, strlen(nv) + 1);
+	M0_UT_ASSERT(k != NULL);
+
+	rc = m0_be_kvs_update(&kvstore, tx, k);
+	M0_UT_ASSERT(rc == 0);
+
+	/*
+	 * Finish with transactions...
+	 */
+	__be_tx_commit(tx, true);
+	__be_tx_fini(tx);
+
+	btree_dbg_print(kvstore.bk_tree, kvstore.bk_tree->root);
+}
+
+void test_be_kvs_load(void)
+{
+	struct bt_key_val *k;
+	char		   kv[16];
+
+	btree_dbg_print(kvstore.bk_tree, kvstore.bk_tree->root);
+
+	sprintf(kv, "%d", 101);
+	k = m0_be_kvs_lookup(&kvstore, kv);
+	M0_UT_ASSERT(k != NULL);
+
+	M0_UT_ASSERT(kv_ops.compare(kv, k->key) == 0);
+	M0_UT_ASSERT(kv_ops.compare(kv, k->val) == 0);
+
+
+	sprintf(kv, "%d", 202);
+	k = m0_be_kvs_lookup(&kvstore, kv);
+	M0_UT_ASSERT(k != NULL);
+
+	M0_UT_ASSERT(kv_ops.compare(kv, k->key) == 0);
+	sprintf(kv, "%d", 5555);
+	M0_UT_ASSERT(kv_ops.compare(kv, k->val) == 0);
+}
+
+static void test_be_kvs(void)
+{
+#if RVM_CREATE
+	test_be_kvs_create();
+#else
+	test_be_kvs_load();
+#endif
+}
+
+const struct m0_test_suite be_kvs_ut = {
+        .ts_name = "be-kvs-ut",
+        .ts_init = ts_be_init,
+        .ts_fini = ts_be_fini,
+        .ts_tests = {
+		{ "be-kvs", test_be_kvs },
+                { NULL, NULL },
+        }
+};
+
+#undef M0_TRACE_SUBSYSTEM
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/utils/ut_main.c b/utils/ut_main.c
index 933b493..3b61431 100644
--- a/utils/ut_main.c
+++ b/utils/ut_main.c
@@ -36,6 +36,7 @@ extern const struct m0_test_suite ad_ut;
 extern const struct m0_test_suite addb_ut;
 extern const struct m0_test_suite adieu_ut;
 extern const struct m0_test_suite be_hs_ut;
+extern const struct m0_test_suite be_kvs_ut;
 extern const struct m0_test_suite be_kv_store_ut;
 extern const struct m0_test_suite be_ut;
 extern const struct m0_test_suite balloc_ut;
@@ -98,6 +99,7 @@ void add_uts(void)
         m0_ut_add(&adieu_ut);
         m0_ut_add(&rvm_ut);
         m0_ut_add(&be_hs_ut);
+        m0_ut_add(&be_kvs_ut);
         m0_ut_add(&be_kv_store_ut);
         m0_ut_add(&be_ut);
 	m0_ut_add(&balloc_ut);
-- 
1.8.3.2

