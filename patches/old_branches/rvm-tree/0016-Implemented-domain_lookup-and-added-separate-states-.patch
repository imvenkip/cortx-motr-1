From 0af3132a4b311271ed9944b936c9868cb8353c8c Mon Sep 17 00:00:00 2001
From: Prashant Dhange <prashant_dhange@xyratex.com>
Date: Mon, 24 Dec 2012 08:14:53 -0800
Subject: [PATCH 16/94] Implemented domain_lookup and added separate states for
 seg initialization and final

---
 be/be.h              |  3 +-
 be/be_domain.c       | 28 ++++++++----------
 be/be_seg.c          | 83 ++++++++++++++++++++++++++++------------------------
 be/lib/be_kv_store.c |  2 +-
 be/lib/ut/be_tlist.c |  2 +-
 be/ut/be.c           | 46 ++++++++++++++---------------
 6 files changed, 84 insertions(+), 80 deletions(-)

diff --git a/be/be.h b/be/be.h
index 32c0dca..8b7c4dc 100644
--- a/be/be.h
+++ b/be/be.h
@@ -541,8 +541,9 @@ struct m0_be_reg {
 };
 
 enum m0_be_seg_state {
+        M0_BESEG_INIT,
         M0_BESEG_CREATING,
-        M0_BESEG_CREATED,
+/*      M0_BESEG_CREATED, */
         M0_BESEG_OPENING,
         M0_BESEG_ACTIVE,
         M0_BESEG_CLOSING,
diff --git a/be/be_domain.c b/be/be_domain.c
index 4f92615..6e1f737 100644
--- a/be/be_domain.c
+++ b/be/be_domain.c
@@ -73,6 +73,8 @@ M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom,
         dom->bd_data.bs_stob    = stob;
         dom->bd_impl.log_stob   = log_stob;
 
+        m0_be_seg_init(&(dom->bd_data), dom, &(dom->bd_impl.sm_group), 0);
+
         /**
          * @todo - Need to decide if m0_be_seg_init should be called
          * instead of M0_BESEG_CLOSED state assignment
@@ -117,8 +119,6 @@ M0_INTERNAL void m0_be_domain_lookup(struct m0_be_domain *dom,
                                      struct m0_be_seg **out)
 {
         struct m0_be_seg *seg_it;
-        struct m0_stob *stob;
-
 
         /* Asserting on required conditions */
         M0_ASSERT(dom != NULL);
@@ -145,10 +145,9 @@ M0_INTERNAL void m0_be_domain_lookup(struct m0_be_domain *dom,
         if (*out == NULL) {
                 /* @todo - Check into named segment list whether segment is
                  * created or not
+                 * out = NULL;
+                 * m0_be_seg_tlist_add(&(dom->bd_seg), *out);
                  */
-                *out = NULL;
-                /* Add segment into domain segment list */
-                m0_be_seg_tlist_add(&(dom->bd_seg), *out);
         }
 
         if ( (*out != NULL)                              &&
@@ -165,24 +164,22 @@ M0_INTERNAL void m0_be_domain_lookup(struct m0_be_domain *dom,
 
                 /* todo@ error handling for object allocation */
                 M0_ALLOC_PTR(*out);
-                M0_ALLOC_PTR(stob);
+
+                (*out)->bs_impl.segment_id = segment_id;
+
+                m0_be_seg_tlink_init(*out);
 
                 /* Last 2 arguments - sm_grp and flags */
                 m0_be_seg_init(*out, dom, &(dom->bd_impl.sm_group), 0);
 
-                m0_be_seg_create(*out, NULL, stob);
+                m0_be_seg_create(*out, NULL, NULL);
                 /* Last 3 arguments - transaction_ptr,
                  *                    auto_increment_segment_id, stob
                  */
-        }
 
+                m0_be_seg_tlist_add(&(dom->bd_seg), *out);
+        }
 
-        /* M0_POST(M0_IN((*out)->bs_sm.sm_state, (M0_BESEG_OPENING,
- *                                                M0_BESEG_ACTIVE,
-                                                  M0_BESEG_FAILED) )); */
-        M0_POST( ((*out)->bs_sm.sm_state == M0_BESEG_OPENING) ||
-                 ((*out)->bs_sm.sm_state == M0_BESEG_ACTIVE)  ||
-                 ((*out)->bs_sm.sm_state == M0_BESEG_FAILED)  );
 }
 
 /**
@@ -215,7 +212,6 @@ M0_INTERNAL void m0_be_domain_fini(struct m0_be_domain *dom)
                  * Deallocated segment and stob as it is allocated in
                  * m0_be_domain_lookup
                  */
-                m0_free(seg_it->bs_stob);
                 m0_free(seg_it);
         } m0_tlist_endfor;
 
@@ -232,7 +228,7 @@ M0_INTERNAL void m0_be_domain_fini(struct m0_be_domain *dom)
         m0_stob_fini(dom->bd_impl.log_stob);
 
         /* Free allocated memory */
-        m0_free(dom);
+        /* m0_free(dom); */
 }
 
 /** @} end group be_domain */
diff --git a/be/be_seg.c b/be/be_seg.c
index a3cf3c1..1f277d5 100644
--- a/be/be_seg.c
+++ b/be/be_seg.c
@@ -34,27 +34,31 @@
   @{
   */
 
-/**
- * Static var used as to generate segment_id for newly created segments.
- * New segment_id is generated auto_increment this veriable.
- */
-static int max_seg_id = 0;
-
 /* State machine states for backend segment */
 
 static const struct m0_sm_state_descr m0_be_seg_states[] = {
+        [M0_BESEG_INIT] = {
+                .sd_flags     = M0_SDF_INITIAL,
+                .sd_name      = "BE SEG INIT",
+                .sd_in        = NULL,
+                .sd_ex        = NULL,
+                .sd_invariant = NULL,
+                .sd_allowed   = (1 << M0_BESEG_CREATING) |
+                                (1 << M0_BESEG_OPENING)  |
+                                (1 << M0_BESEG_FAILED)
+        },
+
         [M0_BESEG_CREATING] = {
                 .sd_flags     = 0,
                 .sd_name      = "BE SEG CREATING",
                 .sd_in        = NULL,
                 .sd_ex        = NULL,
                 .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BESEG_CREATED)  |
-                                (1 << M0_BESEG_ACTIVE)   |
+                .sd_allowed   = (1 << M0_BESEG_ACTIVE)  |
                                 (1 << M0_BESEG_FAILED)
         },
-
-        [M0_BESEG_CREATED] = {
+        /**
+         * [M0_BESEG_CREATED] = {
                 .sd_flags     = 0,
                 .sd_name      = "BE SEG CREATED",
                 .sd_in        = NULL,
@@ -63,7 +67,8 @@ static const struct m0_sm_state_descr m0_be_seg_states[] = {
                 .sd_allowed   = (1 << M0_BESEG_OPENING)  |
                                 (1 << M0_BESEG_ACTIVE)   |
                                 (1 << M0_BESEG_FAILED)
-        },
+         * },
+         */
 
         [M0_BESEG_OPENING] = {
                 .sd_flags     = 0,
@@ -71,8 +76,7 @@ static const struct m0_sm_state_descr m0_be_seg_states[] = {
                 .sd_in        = NULL,
                 .sd_ex        = NULL,
                 .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BESEG_OPENING)  |
-                                (1 << M0_BESEG_ACTIVE)   |
+                .sd_allowed   = (1 << M0_BESEG_ACTIVE)   |
                                 (1 << M0_BESEG_FAILED)
         },
 
@@ -98,15 +102,14 @@ static const struct m0_sm_state_descr m0_be_seg_states[] = {
         },
 
         [M0_BESEG_CLOSED] = {
-                .sd_flags     = M0_SDF_INITIAL,
+                .sd_flags     = M0_SDF_FINAL,
                 .sd_name      = "BE SEG CLOSED",
                 .sd_in        = NULL,
                 .sd_ex        = NULL,
                 .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BESEG_CREATING) |
-                                (1 << M0_BESEG_OPENING)  |
+                .sd_allowed   = (1 << M0_BESEG_OPENING)  |
                                 (1 << M0_BESEG_ACTIVE)   |
-                                (1 << M0_BESEG_FAILED)   
+                                (1 << M0_BESEG_FAILED)
         },
 
         [M0_BESEG_CHECKING] = {
@@ -132,7 +135,7 @@ static const struct m0_sm_state_descr m0_be_seg_states[] = {
         },
 
         [M0_BESEG_FAILED] = {
-                .sd_flags     = M0_SDF_FINAL,
+                .sd_flags     = M0_SDF_FAILURE,
                 .sd_name      = "BE SEG FAILED",
                 .sd_in        = NULL,
                 .sd_ex        = NULL,
@@ -153,13 +156,13 @@ static const struct m0_sm_conf seg_conf = {
  * @pre seg->bs_dom->bd_data.bs_sm.sm_state == M0_BESEG_ACTIVE
  * @pre seg->bs_sm.sm_state == M0_BESEG_CLOSED
  * @post M0_IN(seg->bs_sm.sm_state, (M0_BESEG_CREATING,
- *                                   M0_BESEG_CREATED, M0_BESEG_FAILED))
+ *                                   M0_BESEG_ACTIVE, M0_BESEG_FAILED))
  */
 M0_INTERNAL void m0_be_seg_create(struct m0_be_seg *seg,
                                   struct m0_be_tx *tx,
                                   struct m0_stob *stob)
 {
-        M0_PRE(seg->bs_sm.sm_state == M0_BESEG_CLOSED);
+        M0_PRE(seg->bs_sm.sm_state == M0_BESEG_INIT);
 
         /* Locking sm group before setting sm_state */
         m0_sm_group_lock(seg->bs_impl.sm_group);
@@ -175,13 +178,6 @@ M0_INTERNAL void m0_be_seg_create(struct m0_be_seg *seg,
         seg->bs_sm_ast.sa_datum = (void *)seg;
 
         m0_seg_req_post(&(seg->bs_dom->bd_impl.sm_group), &(seg->bs_sm_ast));
-
-        /* M0_POST(M0_IN(seg->bs_sm.sm_state, (M0_BESEG_CREATING,
-                                    M0_BESEG_CREATED, M0_BESEG_FAILED))); */
-
-        M0_POST( (seg->bs_sm.sm_state == M0_BESEG_CREATING) ||
-                 (seg->bs_sm.sm_state == M0_BESEG_CREATED)  ||
-                 (seg->bs_sm.sm_state == M0_BESEG_FAILED)   );
 }
 
 /**
@@ -213,13 +209,13 @@ M0_INTERNAL void m0_be_seg_init(struct m0_be_seg *seg,
         m0_sm_group_lock(seg->bs_impl.sm_group);
 
         /* Register the state machine of the segment into sm_group */
-        m0_sm_init(&seg->bs_sm, &seg_conf, M0_BESEG_CLOSED, sm_group,
+        m0_sm_init(&seg->bs_sm, &seg_conf, M0_BESEG_INIT, sm_group,
                         &seg->bs_addb);
 
         /* unlock locked sm group */
         m0_sm_group_unlock(seg->bs_impl.sm_group);
 
-        M0_POST(seg->bs_sm.sm_state == M0_BESEG_CLOSED);
+        M0_POST(seg->bs_sm.sm_state == M0_BESEG_INIT);
 }
 
 /**
@@ -235,8 +231,8 @@ M0_INTERNAL void m0_be_seg_open(struct m0_be_seg *seg)
         /* Asserting on required pointers */
         M0_ASSERT(seg != NULL);
 
-        M0_PRE( (seg->bs_sm.sm_state == M0_BESEG_CREATED) ||
-                (seg->bs_sm.sm_state == M0_BESEG_CLOSED)  );
+        M0_PRE( (seg->bs_sm.sm_state == M0_BESEG_INIT)    ||
+                (seg->bs_sm.sm_state == M0_BESEG_CLOSED) );
 
         M0_PRE(seg->bs_dom->bd_data.bs_sm.sm_state == M0_BESEG_ACTIVE);
 
@@ -283,7 +279,7 @@ M0_INTERNAL void m0_be_seg_done(struct m0_be_seg *seg)
         /* Locking sm group before setting sm_state */
         m0_sm_group_lock(seg->bs_impl.sm_group);
 
-        m0_sm_state_set(&(seg->bs_sm), M0_BESEG_CLOSING);
+        m0_sm_state_set(&(seg->bs_sm), M0_BESEG_CLOSED);
 
         /* unlock locked sm group */
         m0_sm_group_unlock(seg->bs_impl.sm_group);
@@ -506,11 +502,6 @@ M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
         seg->bs_impl.segment_id = named_seg_hdr->max_segment_index + 1;
         */
 
-        /** @todo - this is temporary fix for segment_id.
-         * We need to generate this by reading named segment as done above
-         */
-        seg->bs_impl.segment_id = ++max_seg_id;
-
         /* Create linux stob */
         /* @todo - Please revisit this when have better understanding
          * of linux stob
@@ -526,6 +517,7 @@ M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
         unsigned long             dev_length        = SEGMENT_SIZE;
         unsigned long             heap_length       = HEAP_SIZE;
         char                     *start_Addr        = (char *)0xbebd000;
+        char                     *static_addr       = NULL;
         long                      rds_static_len    = 0;
         long                      nlist             = 16;
         long                      chunk_size        = 64;
@@ -590,8 +582,23 @@ M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
         /* @todo - begin transaction */
         /* update the named segment transactionally */
         /* @todo - end transaction */
+        /* Assuption : create implicitely opens the segment */
+
+        printf("\ndata_file_path : %s\n", seg->bs_impl.path_name);
+
+        result = rds_load_heap(seg->bs_impl.path_name,
+                               RVM_LENGTH_TO_OFFSET(dev_length),
+                               &static_addr,
+                               &err);
+
+        if (result < 0)
+                goto error;
+
+        printf("\nstatic_addr : %p\n", static_addr);
 
-        m0_sm_state_set((&seg->bs_sm), M0_BESEG_CREATED);
+        seg->bs_addr = (void *)(static_addr);
+
+        m0_sm_state_set((&seg->bs_sm), M0_BESEG_ACTIVE);
 
         return;
 
diff --git a/be/lib/be_kv_store.c b/be/lib/be_kv_store.c
index c74d766..f059473 100644
--- a/be/lib/be_kv_store.c
+++ b/be/lib/be_kv_store.c
@@ -41,7 +41,7 @@ int m0_ks_init_domain_and_segment(struct m0_be_domain  *dom,
         m0_be_seg_create(seg, NULL, stob);
         m0_sm_group_lock(seg->bs_impl.sm_group);
         m0_sm_timedwait(&(seg->bs_sm),
-                        (1 << M0_BESEG_CREATED)|(1 << M0_BESEG_FAILED),
+                        (1 << M0_BESEG_ACTIVE)|(1 << M0_BESEG_FAILED),
                         M0_TIME_NEVER);
         m0_sm_group_unlock(seg->bs_impl.sm_group);
 
diff --git a/be/lib/ut/be_tlist.c b/be/lib/ut/be_tlist.c
index f1b6299..2fb8ca5 100644
--- a/be/lib/ut/be_tlist.c
+++ b/be/lib/ut/be_tlist.c
@@ -85,7 +85,7 @@ void init_tlist_domain_and_segment()
         m0_be_seg_create(&seg, NULL, &stob);
         m0_sm_group_lock(seg.bs_impl.sm_group);
         m0_sm_timedwait(&seg.bs_sm,
-                        (1 << M0_BESEG_CREATED)|(1 << M0_BESEG_FAILED),
+                        (1 << M0_BESEG_ACTIVE)|(1 << M0_BESEG_FAILED),
                         M0_TIME_NEVER);
         m0_sm_group_unlock(seg.bs_impl.sm_group);
 
diff --git a/be/ut/be.c b/be/ut/be.c
index 3e52eae..0a2a63c 100644
--- a/be/ut/be.c
+++ b/be/ut/be.c
@@ -33,7 +33,8 @@
 #include <unistd.h>
 #include "be/be.h"
 
-struct m0_be_seg seg;
+struct m0_be_seg *seg;
+struct m0_be_seg *lseg;
 struct m0_be_domain dom;
 struct m0_stob ns_stob, stob;
 struct m0_stob log_stob;
@@ -50,44 +51,41 @@ int main()
         m0_be_domain_init(&dom, &ns_stob, &log_stob);
         printf("\nDomain is initialized\n");
 
-        m0_be_seg_init(&seg, &dom, &(dom.bd_impl.sm_group), 0);
-        printf("\nSegment is initialized\n");
-
         /**
          * This is just done to work other part of the code.
          * We are not dealing with named segment for this moment.
          */
         dom.bd_data.bs_sm.sm_state = M0_BESEG_ACTIVE;
 
-        m0_be_seg_create(&seg, NULL, &stob);
-
-        printf("\nSegment is creating\n");
-
-        printf("\nWaiting for segment to be created\n");
+        m0_be_domain_lookup(&dom, 1, &seg);
 
-        m0_sm_group_lock(seg.bs_impl.sm_group);
-        m0_sm_timedwait(&seg.bs_sm,
-                        (1 << M0_BESEG_CREATED) | (1 << M0_BESEG_FAILED),
+        m0_sm_group_lock(seg->bs_impl.sm_group);
+        m0_sm_timedwait(&(seg->bs_sm),
+                        (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED),
                         M0_TIME_NEVER);
-        m0_sm_group_unlock(seg.bs_impl.sm_group);
+        m0_sm_group_unlock(seg->bs_impl.sm_group);
 
 
-        /* If segment creation failed, then return with error */
-        if (M0_BESEG_FAILED == seg.bs_sm.sm_state) {
+        if (M0_BESEG_FAILED == seg->bs_sm.sm_state) {
                 printf("\nFailed to create segment \n");
                 return -1;
         }
-
         printf("\nSegment is created\n");
-        m0_be_seg_open(&seg);
-        printf("\nSegment is opening\n");
+
+        /**
+         * TODO :Implement UT to test segment open 
+         */
+
         printf("\nWaiting for segment to be active\n");
+        m0_be_domain_lookup(&dom, 1, &lseg);
 
-        m0_sm_group_lock(seg.bs_impl.sm_group);
-        m0_sm_timedwait(&seg.bs_sm,
+        m0_sm_group_lock(seg->bs_impl.sm_group);
+        m0_sm_timedwait(&(seg->bs_sm),
                         (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED),
                         M0_TIME_NEVER);
-        m0_sm_group_unlock(seg.bs_impl.sm_group);
+        m0_sm_group_unlock(seg->bs_impl.sm_group);
+
+        seg = lseg;
 
         printf("\nSegment is opened\n");
 
@@ -104,7 +102,7 @@ int main()
 
 
         m0_be_buf_init(&buf, NULL, 1024, 0, 0, 0);
-        m0_be_reg_init(&reg, NULL, &seg, &buf);
+        m0_be_reg_init(&reg, NULL, seg, &buf);
         m0_be_alloc(reg);
 
         m0_be_tx_add_cred(&tx, reg);
@@ -153,7 +151,9 @@ int main()
 
         m0_be_tx_fini(&tx);
 
-        /* m0_be_seg_fini(&seg); */
+        m0_be_seg_done(seg);
+        dom.bd_data.bs_sm.sm_state = M0_BESEG_CLOSED;
+        m0_be_domain_fini(&dom);
 
         printf("\nExiting from Backend UT\n");
 
-- 
1.8.3.2

