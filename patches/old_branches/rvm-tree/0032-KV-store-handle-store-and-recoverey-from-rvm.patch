From 866d09c8c8534aec2c3b8ac3d454ab04d3fabd6c Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Tue, 8 Jan 2013 04:44:27 -0800
Subject: [PATCH 32/94] KV store handle store and recoverey from rvm

---
 be/lib/be_helper.c      |   3 +-
 be/lib/be_kv_store.c    | 259 ++++++++++++++++++++++++++++++------------------
 be/lib/be_kv_store.h    |  33 ++++--
 be/lib/be_list.c        |  37 ++++++-
 be/lib/be_tlist.c       |   4 +-
 be/lib/be_types.h       |   5 -
 be/lib/ut/be_kv_store.c | 139 ++++++++++++++------------
 be/lib/ut/be_tlist.c    |  72 ++++++++++++--
 8 files changed, 366 insertions(+), 186 deletions(-)

diff --git a/be/lib/be_helper.c b/be/lib/be_helper.c
index 3395f90..9061518 100644
--- a/be/lib/be_helper.c
+++ b/be/lib/be_helper.c
@@ -34,7 +34,7 @@ M0_INTERNAL void m0_ks_init_domain(struct m0_be_domain  **out_dom)
         M0_ASSERT(dom != NULL);
 
         /* Initializing domain */
-        m0_be_domain_init(dom);
+        m0_be_domain_init(dom, BE_DOMAIN_MAGIC);
         dom->bd_data.bs_sm.sm_state = M0_BESEG_ACTIVE;
 
         *out_dom = dom;
@@ -87,6 +87,7 @@ M0_INTERNAL void m0_ks_fini(struct m0_be_domain *dom, struct m0_be_seg *seg)
 {
         m0_be_seg_done(seg);
         dom->bd_data.bs_sm.sm_state = M0_BESEG_CLOSED;
+        rvm_truncate();
         m0_be_domain_fini(dom);
 }
 M0_EXPORTED(m0_ks_fini);
diff --git a/be/lib/be_kv_store.c b/be/lib/be_kv_store.c
index 5e87de3..cf1c33b 100644
--- a/be/lib/be_kv_store.c
+++ b/be/lib/be_kv_store.c
@@ -18,8 +18,7 @@
  * Original creation date: 12/24/2012
  */
 #include "be/lib/be_kv_store.h"
-#include <string.h>
-#include <stdlib.h>
+#include "be/lib/be_handle_store.h"
 
 /**
    @addtogroup be_kv_store
@@ -51,13 +50,14 @@ static void __get_current(struct m0_be_tl_descr   *d,
                           struct m0_be_list_link **link_cuurent);
 
 /*
- * Adds or captures the regions of the next & previous pointers of
+ * Adds or captures the regions of the current, next & previous pointers of
  * @current object, depending upon @in_tx_state.
  */
 static void __m0_ks_add_prev_next_to_cred(struct m0_kv_store     *handle,
                                           struct m0_be_tx        *tx,
                                           void                   *current,
-                                          int                     in_tx_state);
+                                          int                     in_tx_state,
+                                          int                     operation);
 
 M0_INTERNAL void m0_ks_create_handle(struct m0_be_domain     *dom,
                                      struct m0_be_tl_descr   *descr,
@@ -82,6 +82,8 @@ M0_INTERNAL void m0_ks_create_handle(struct m0_be_domain     *dom,
         m0_ks_domain_lookup(dom, &rvm_handle_seg, 1);
         M0_ASSERT(rvm_handle_seg != NULL);
 
+        m0_be_hs_init(rvm_handle_seg);
+
         m0_be_tx_init(tx, dom, 0);
         M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
                    (1 << M0_BETX_INIT) | (1 << M0_BETX_FAILED));
@@ -97,6 +99,8 @@ M0_INTERNAL void m0_ks_create_handle(struct m0_be_domain     *dom,
         M0_ASSERT(rvm_handle != NULL);
         M0_ASSERT(rvm_handle_ref != NULL);
 
+        m0_be_hs_update(0, &rvm_handle_ref->segid_offset);
+
         /* be_tlist init */
         m0_be_tlist_init(descr, &rvm_handle->ks_tlist);
 
@@ -111,6 +115,9 @@ M0_INTERNAL void m0_ks_create_handle(struct m0_be_domain     *dom,
         temp_tail_offset->u_hi = rvm_handle_ref->segid_offset.u_hi;
         temp_tail_offset->u_lo = rvm_handle_ref->segid_offset.u_lo;
 
+        head->l_head.logical_address.magic = dom->bd_magic;
+        head->l_tail.logical_address.magic = dom->bd_magic;
+
         (*rvm_handle_out) = rvm_handle;
         M0_ASSERT((*rvm_handle_out) != NULL);
 
@@ -127,24 +134,27 @@ M0_INTERNAL void m0_ks_init(struct m0_kv_store    **handle,
                             struct m0_be_tl_descr  *descr,
                             struct m0_be_domain    *dom,
                             kv_key_cmp              cmp_fp,
-                            kv_key_match            match_fp)
+                            kv_key_match            match_fp,
+                            int                     control)
 {
         struct m0_kv_store_rvm  *rvm_handle = NULL;
+        struct m0_be_seg        *rvm_handle_seg = NULL;
 
         if((*handle) == NULL) {
-                M0_ALLOC_PTR((*handle));
-                M0_ASSERT(handle != NULL);
+                        M0_ALLOC_PTR((*handle));
+                        M0_ASSERT(handle != NULL);
         }
 
-        /* if (recover_possible)
-         *      recover;
-         * else {
-         */
-        m0_ks_create_handle(dom, descr, &rvm_handle);
-        /* } */
-        M0_ASSERT(rvm_handle != NULL);
-
-        (*handle)->handle_rvm = rvm_handle;
+        if(control == CREATE) {
+                m0_ks_create_handle(dom, descr, &rvm_handle);
+                M0_ASSERT(rvm_handle != NULL);
+                (*handle)->handle_rvm = rvm_handle;
+        } else {
+                /* For now segid is always == 1*/
+                m0_ks_domain_lookup(dom, &rvm_handle_seg, 1);
+                M0_ASSERT(rvm_handle_seg != NULL);
+                m0_be_hs_init(rvm_handle_seg);
+        }
 
         /* Set the non_rvm part of the handle with user values */
         (*handle)->handle_heap.kv_key_cmp    = cmp_fp;
@@ -188,7 +198,7 @@ M0_INTERNAL void *m0_ks_find(struct m0_kv_store *handle,
 {
         void                   *scan;
         void                   *target = NULL;
-        struct m0_be_tl         *ks_tlist  = NULL;      
+        struct m0_be_tl         *ks_tlist  = NULL;
         struct m0_be_tl_descr   *ks_list_descr  = NULL;
 
         ks_tlist = &handle->handle_rvm->ks_tlist;
@@ -210,18 +220,22 @@ M0_INTERNAL int m0_ks_delete(struct m0_kv_store  *handle,
                              struct m0_be_tx     *del_tx)
 {
         void                   *scan;
-        void                   *target    = NULL;
-        struct m0_be_reg       *curr_reg  = NULL;
-        struct m0_be_list_link *link_curr = NULL;
-        struct m0_be_tx         *tx = del_tx;
-        int                     del_tx_state = IN_TX_NOT_NULL;
-        struct m0_be_tl         *ks_tlist  = NULL;      
-        struct m0_be_tl_descr   *ks_list_descr  = NULL;
+        void                   *target         = NULL;
+        struct m0_be_reg       *t_head_reg     = NULL;
+        struct m0_be_list_link *temp_link      = NULL;
+        struct m0_be_list_link *t_head_link    = NULL;
+        struct m0_be_list_link *head           = NULL;
+        struct m0_be_tx         *tx            = del_tx;
+        int                     del_tx_state   = IN_TX_NOT_NULL;
+        struct m0_be_tl         *ks_tlist      = NULL;
+        struct m0_be_tl_descr   *ks_list_descr = NULL;
 
         ks_list_descr = handle->handle_heap.ks_list_descr;
 
         ks_tlist = &handle->handle_rvm->ks_tlist;
 
+        head = (void *)&ks_tlist->t_head;
+
         if (del_tx == NULL) {
                 del_tx_state = IN_TX_NULL;
 
@@ -240,30 +254,33 @@ M0_INTERNAL int m0_ks_delete(struct m0_kv_store  *handle,
         }m0_be_tlist_endfor;
 
         if (target != NULL) {
-                /* Add linkage of current object to transaction */
-                link_curr = &((struct m0_be_tlink *)
-                              (target + ks_list_descr->td_link_offset))->t_link;
-                
-                /* Init a region for this link */
-                m0_ks_prep_link_reg(handle->handle_heap.ks_dom, link_curr, tx,
-                                    &curr_reg);
-                M0_ASSERT(curr_reg != NULL);
+
+                /* Capture t_head */
+                temp_link   = head->ll_next.virtual_address;
+                t_head_link = temp_link->ll_prev.virtual_address;
+                M0_ASSERT(t_head_link != NULL);
+
+                m0_ks_prep_link_reg(handle->handle_heap.ks_dom, t_head_link, tx,
+                                    &t_head_reg);
+                M0_ASSERT(t_head_reg != NULL);
 
                 if (del_tx == NULL) {
-                        m0_be_tx_add_cred(tx, curr_reg);
+                        m0_be_tx_add_cred(tx, t_head_reg);
                 } else {
-                        m0_be_reg_capture(curr_reg);
-                        M0_BE_WAIT(curr_reg->br_impl.sm_group, &curr_reg->br_sm,
+                        m0_be_reg_capture(t_head_reg);
+                        M0_BE_WAIT(t_head_reg->br_impl.sm_group,
+                                   &t_head_reg->br_sm,
                                    (1 << M0_BEREG_CAPTURED) |
                                    (1 << M0_BEREG_FAILED));
                 }
 
                 /*
-                 * Add the previous and next pointers about to
+                 * Add the current, previous and next pointers about to
                  * be modified to the credit or captures them depending
                  * upon the transaction received.
                  */
-                __m0_ks_add_prev_next_to_cred(handle, tx, target, del_tx_state);
+                __m0_ks_add_prev_next_to_cred(handle, tx, target, del_tx_state,
+                                              KS_DELETE);
 
                 if (del_tx == NULL) {
                         m0_ks_tx_prep(tx);
@@ -297,20 +314,16 @@ M0_INTERNAL int __add_at_tail_to_tlist(struct m0_kv_store     *handle,
                                        struct m0_be_tx        *tx,
                                        int                     in_tx_state)
 {
-        struct m0_be_reg        *tail_reg  = NULL;
-        struct m0_be_list_link  *tail_link = NULL;
         struct m0_be_reg        *tail_obj_reg  = NULL;
         struct m0_be_list_link  *tail_obj_link = NULL;
-        void                    *tail_obj  = NULL;
-        struct m0_be_list       *list_head;
-        struct m0_be_tl         *ks_tlist  = NULL;      
-        struct m0_be_tl_descr   *ks_list_descr  = NULL;
+        void                    *tail_obj      = NULL;
+        struct m0_be_tl         *ks_tlist      = NULL;
+        struct m0_be_tl_descr   *ks_list_descr = NULL;
 
         ks_list_descr = handle->handle_heap.ks_list_descr;
+        ks_tlist      = &handle->handle_rvm->ks_tlist;
 
-        ks_tlist = &handle->handle_rvm->ks_tlist;
-
-        /* Add current tail object to credit */
+        /* Add current tail to credit */
         tail_obj  = m0_be_tlist_tail(ks_list_descr, ks_tlist);
 
         tail_obj_link = &((struct m0_be_tlink *)
@@ -321,29 +334,14 @@ M0_INTERNAL int __add_at_tail_to_tlist(struct m0_kv_store     *handle,
                             &tail_obj_reg);
         M0_ASSERT(tail_obj_reg != NULL);
 
-        /* Add the current tail itself to credit */
-        list_head = &ks_tlist->t_head;
-        tail_link = list_head->l_tail.virtual_address;
-        M0_ASSERT(tail_link != NULL);
- 
-        /* Init a region for this link */
-        m0_ks_prep_link_reg(handle->handle_heap.ks_dom, tail_link, tx,
-                            &tail_reg);
-        M0_ASSERT(tail_reg != NULL);
-
         if (in_tx_state == IN_TX_NULL) {
                 m0_be_tx_add_cred(tx, tail_obj_reg);
-                m0_be_tx_add_cred(tx, tail_reg);
                 m0_ks_tx_prep(tx);
                 m0_ks_tx_start(tx);
         } else {
                 m0_be_reg_capture(tail_obj_reg);
                 M0_BE_WAIT(tail_obj_reg->br_impl.sm_group, &tail_obj_reg->br_sm,
                            (1 << M0_BEREG_CAPTURED) | (1 << M0_BEREG_FAILED));
-
-                m0_be_reg_capture(tail_reg);
-                M0_BE_WAIT(tail_reg->br_impl.sm_group, &tail_reg->br_sm,
-                           (1 << M0_BEREG_CAPTURED) | (1 << M0_BEREG_FAILED));
         }
 
         /* Finally, add at tail in tlist */
@@ -356,29 +354,23 @@ M0_INTERNAL int m0_ks_insert(struct m0_kv_store  *handle,
                              struct m0_be_tx     *ins_tx)
 {
         struct m0_be_reg        *obj_link_reg  = NULL;
-        struct m0_be_reg        *head_reg      = NULL;
+        struct m0_be_reg        *t_head_reg    = NULL;
         struct m0_be_list_link  *link          = NULL;
-        struct m0_be_list_link  *link_head;
-        struct m0_be_list_link  *head;
-        struct m0_be_list       *list_head     = NULL;
+        struct m0_be_tl         *ks_tlist      = NULL;
+        struct m0_be_tl_descr   *ks_list_descr = NULL;
+        struct m0_be_list_link  *head          = NULL;
         struct m0_be_tx         *tx            = ins_tx;
         void                    *new           = NULL;
         void                    *scan;
         int                      ret_val       = BE_KV_INVALID_REQ;
         int                      in_tx_state   = IN_TX_NOT_NULL;
-        struct m0_be_tl         *ks_tlist  = NULL;      
-        struct m0_be_tl_descr   *ks_list_descr  = NULL;
 
         ks_list_descr = handle->handle_heap.ks_list_descr;
 
         ks_tlist = &handle->handle_rvm->ks_tlist;
 
-        /*
-         * TODO: Check magic with magic that would be defined in handle->ks_dom.
-         *       Coz this magic will be domain specific, will be defined in
-         *       be_alloc itself.
-         */
-        if (obj_ref->magic != BE_ALLOC_REF_MAGIC)
+        /* Ensure object is allocated on same domain as that of handle */
+        if (obj_ref->magic != handle->handle_heap.ks_dom->bd_magic)
                 goto exit_failure;
 
         /* Collect the object to be inserted */
@@ -428,26 +420,21 @@ M0_INTERNAL int m0_ks_insert(struct m0_kv_store  *handle,
         if ((head->ll_next.virtual_address == (void *)head) &&
             (head->ll_prev.virtual_address == (void *)head)) {
 
-                /* Check if list empty, if yes then add as head */
-                /* Capture actual head pointer */
-                list_head = &(ks_tlist->t_head);
-                link_head = list_head->l_head.virtual_address;
-                M0_ASSERT(link_head != NULL);
-                
-                /* Init a region for head */
-                m0_ks_prep_link_reg(handle->handle_heap.ks_dom, link_head, tx,
-                                    &head_reg);
-                M0_ASSERT(head_reg != NULL);
+                /* Capture t_head */
+                m0_ks_prep_link_reg(handle->handle_heap.ks_dom, head, tx,
+                                    &t_head_reg);
+                M0_ASSERT(t_head_reg != NULL);
 
                 /* Capture this region */
                 if (ins_tx == NULL) {
-                        m0_be_tx_add_cred(tx, head_reg);
+                        /*m0_be_tx_add_cred(tx, head_reg);*/
+                        m0_be_tx_add_cred(tx, t_head_reg);
                         m0_ks_tx_prep(tx);
                         m0_ks_tx_start(tx);
                 } else {
-                        m0_be_reg_capture(head_reg);
-                        M0_BE_WAIT(head_reg->br_impl.sm_group,
-                                   &head_reg->br_sm,
+                        m0_be_reg_capture(t_head_reg);
+                        M0_BE_WAIT(t_head_reg->br_impl.sm_group,
+                                   &t_head_reg->br_sm,
                                    (1 << M0_BEREG_CAPTURED) |
                                    (1 << M0_BEREG_FAILED));
                 }
@@ -461,15 +448,30 @@ M0_INTERNAL int m0_ks_insert(struct m0_kv_store  *handle,
                 m0_be_tlist_for(ks_list_descr, ks_tlist, scan)
                 {
                         if (handle->handle_heap.kv_key_cmp(new, scan) < 0) {
+
+                                /* Capture t_head */
+                                m0_ks_prep_link_reg(handle->handle_heap.ks_dom,
+                                                    head, tx,
+                                                    &t_head_reg);
+                                M0_ASSERT(t_head_reg != NULL);
+
                                 /*
-                                 * Add the previous and next pointers about to
-                                 * be modified to the credit.
+                                 * Add the current, previous and next pointers
+                                 * about to be modified to the credit.
                                  */
                                 __m0_ks_add_prev_next_to_cred(handle, tx, scan,
-                                                              in_tx_state);
+                                                              in_tx_state,
+                                                              KS_INSERT);
                                 if (ins_tx == NULL) {
+                                        m0_be_tx_add_cred(tx, t_head_reg);
                                         m0_ks_tx_prep(tx);
                                         m0_ks_tx_start(tx);
+                                } else {
+                                        m0_be_reg_capture(t_head_reg);
+                                        M0_BE_WAIT(t_head_reg->br_impl.sm_group,
+                                                   &t_head_reg->br_sm,
+                                                   (1 << M0_BEREG_CAPTURED) |
+                                                   (1 << M0_BEREG_FAILED));
                                 }
 
                                 /*
@@ -485,6 +487,22 @@ M0_INTERNAL int m0_ks_insert(struct m0_kv_store  *handle,
 
                 /* If key is largest in the list, add at tail */
                 if (ret_val == BE_KV_INVALID_REQ) {
+
+                        /* Capture t_head */
+                        m0_ks_prep_link_reg(handle->handle_heap.ks_dom,
+                                            head, tx, &t_head_reg);
+                        M0_ASSERT(t_head_reg != NULL);
+
+                        if (ins_tx == NULL) {
+                                m0_be_tx_add_cred(tx, t_head_reg);
+                        } else {
+                                m0_be_reg_capture(t_head_reg);
+                                M0_BE_WAIT(t_head_reg->br_impl.sm_group,
+                                           &t_head_reg->br_sm,
+                                           (1 << M0_BEREG_CAPTURED) |
+                                           (1 << M0_BEREG_FAILED));
+                        }
+
                         ret_val = __add_at_tail_to_tlist(handle, new, tx,
                                                          in_tx_state);
                 }
@@ -552,41 +570,84 @@ static void __get_current(struct m0_be_tl_descr  *d,
 static void __m0_ks_add_prev_next_to_cred(struct m0_kv_store *handle,
                                           struct m0_be_tx    *tx,
                                           void               *current,
-                                          int                 in_tx_state)
+                                          int                 in_tx_state,
+                                          int                 operation)
 {
         struct m0_be_reg         *prev_reg      = NULL;
         struct m0_be_reg         *next_reg      = NULL;
+        struct m0_be_reg         *curr_reg      = NULL;
         struct m0_be_list_link   *link_prev     = NULL;
+        struct m0_be_list_link   *link_curr     = NULL;
         struct m0_be_list_link   *link_next     = NULL;
         struct m0_be_tl_descr    *ks_list_descr = NULL;
 
         ks_list_descr = handle->handle_heap.ks_list_descr;
 
         __get_prev(ks_list_descr, current, &link_prev);
-        __get_next(ks_list_descr, current, &link_next);
+        __get_current(ks_list_descr, current, &link_curr);
+
+        if (operation == KS_DELETE)
+                __get_next(ks_list_descr, current, &link_next);
+
+        m0_ks_prep_link_reg(handle->handle_heap.ks_dom, link_curr, tx,
+                            &curr_reg);
+        M0_ASSERT(curr_reg != NULL);
 
         m0_ks_prep_link_reg(handle->handle_heap.ks_dom, link_prev, tx,
                             &prev_reg);
         M0_ASSERT(prev_reg != NULL);
 
-        m0_ks_prep_link_reg(handle->handle_heap.ks_dom, link_next, tx,
-                            &next_reg);
-        M0_ASSERT(next_reg != NULL);
+        if (link_next != NULL) {
+                m0_ks_prep_link_reg(handle->handle_heap.ks_dom, link_next, tx,
+                                    &next_reg);
+                M0_ASSERT(next_reg != NULL);
+        }
+
 
         if (in_tx_state == IN_TX_NULL) {
                 m0_be_tx_add_cred(tx, prev_reg);
-                m0_be_tx_add_cred(tx, next_reg);
+                m0_be_tx_add_cred(tx, curr_reg);
+                if (operation == KS_DELETE)
+                        m0_be_tx_add_cred(tx, next_reg);
         } else {
                 m0_be_reg_capture(prev_reg);
                 M0_BE_WAIT(prev_reg->br_impl.sm_group, &prev_reg->br_sm,
                            (1 << M0_BEREG_CAPTURED) | (1 << M0_BEREG_FAILED));
 
-                m0_be_reg_capture(next_reg);
-                M0_BE_WAIT(next_reg->br_impl.sm_group, &next_reg->br_sm,
+                if (operation == KS_DELETE) {
+                        m0_be_reg_capture(next_reg);
+                        M0_BE_WAIT(next_reg->br_impl.sm_group, &next_reg->br_sm,
+                                   (1 << M0_BEREG_CAPTURED) |
+                                   (1 << M0_BEREG_FAILED));
+                }
+
+                m0_be_reg_capture(curr_reg);
+                M0_BE_WAIT(curr_reg->br_impl.sm_group, &curr_reg->br_sm,
                            (1 << M0_BEREG_CAPTURED) | (1 << M0_BEREG_FAILED));
-        }
+       }
 }
 
+M0_INTERNAL void m0_ks_deref_handle(struct m0_kv_store *handle,
+                                    struct m0_be_seg   *seg)
+{
+        struct m0_kv_store_rvm *handle_rvm  = NULL;
+        struct m0_uint128      *kv_store    = NULL;
+        long int                lo;
+
+        kv_store = m0_be_hs_get(0);
+        M0_ASSERT(kv_store != NULL);
+
+        lo = (long int)(seg->bs_heap_addr + (kv_store->u_lo));
+
+        handle_rvm = (struct m0_kv_store_rvm *)lo;
+        M0_ASSERT(handle_rvm != NULL);
+
+        handle->handle_rvm = handle_rvm;
+}
+M0_EXPORTED(m0_ks_deref_handle);
+
+
+
 /* @} end of be_kv_store group */
 
 /*
diff --git a/be/lib/be_kv_store.h b/be/lib/be_kv_store.h
index 44e62f0..92f7a31 100644
--- a/be/lib/be_kv_store.h
+++ b/be/lib/be_kv_store.h
@@ -27,12 +27,17 @@
 #include "be/lib/be_helper.h"
 #include "be/be.h"
 
-#define BE_KV_FAILURE     -1
-#define BE_KV_SUCCESS      0
-#define BE_KV_INVALID_REQ  1
-#define IN_TX_NULL         2
-#define IN_TX_NOT_NULL     3
-
+enum {
+        BE_KV_SUCCESS,
+        BE_KV_FAILURE,
+        BE_KV_INVALID_REQ,
+        IN_TX_NULL,
+        IN_TX_NOT_NULL,
+        CREATE,
+        RECOVER,
+        KS_INSERT,
+        KS_DELETE
+};
 /**
    @defgroup be_kv_store Key Value Store
  */
@@ -102,7 +107,8 @@ M0_INTERNAL void m0_ks_init(struct m0_kv_store    **handle,
                             struct m0_be_tl_descr  *descr,
                             struct m0_be_domain    *dom,
                             kv_key_cmp              cmp_fp,
-                            kv_key_match            match_fp);
+                            kv_key_match            match_fp,
+                            int                     control);
 
 /*
  * Insert a key value pair in the tlist contained in @handle.
@@ -149,6 +155,19 @@ M0_INTERNAL int m0_ks_delete(struct m0_kv_store *handle,
 M0_INTERNAL struct m0_reference *m0_ks_get_next_val(struct m0_kv_store *handle,
                                                     void               *obj);
 
+/*
+ * Recovres the persistent part of the kv_store handle from rvm and puts it back
+ * in the @handle.
+ *
+ * @param handle        :       the kv_store handle
+ * @param seg           :       segment pointer containing heap address
+ * @param kv_store      :       pointer containing segment id and offset of the
+ *                              persistent kv_store handle
+ */
+M0_INTERNAL void m0_ks_deref_handle(struct m0_kv_store *handle,
+                                    struct m0_be_seg   *seg);
+
+
 /** @} end of be_kv_store group */
 
 #endif /* __MERO_BE_LIB_BE_KV_STORE_H__ */
diff --git a/be/lib/be_list.c b/be/lib/be_list.c
index 7332585..c4b0a9a 100644
--- a/be/lib/be_list.c
+++ b/be/lib/be_list.c
@@ -105,10 +105,30 @@ static inline void __m0_be_list_add(struct m0_be_list_link *next,
                                     struct m0_be_list_link *prev,
                                     struct m0_be_list_link *new)
 {
+        uint64_t prev_magic;
+        uint64_t next_magic;
+        uint64_t new_magic;
+
         M0_ASSERT(prev->ll_next.virtual_address == (void *)next &&
                   next->ll_prev.virtual_address == (void *)prev);
         M0_ASSERT(m0_be_list_link_invariant(next));
 
+        /* Make sure all belong in same domain */
+        prev_magic = prev->ll_next.logical_address.magic;
+        next_magic = next->ll_next.logical_address.magic;
+        new_magic  = new->ll_next.logical_address.magic;
+
+        M0_ASSERT(new_magic == prev_magic);
+        M0_ASSERT(new_magic == next_magic);
+
+        prev_magic = prev->ll_prev.logical_address.magic;
+        next_magic = next->ll_prev.logical_address.magic;
+        new_magic  = new->ll_prev.logical_address.magic;
+
+        M0_ASSERT(new_magic == prev_magic);
+        M0_ASSERT(new_magic == next_magic);
+
+        /* Now add to the tlist finally */
         new->ll_next.virtual_address  = next;
         new->ll_prev.virtual_address  = prev;
 
@@ -151,10 +171,22 @@ static void __m0_be_list_del(struct m0_be_list_link *old)
         M0_ASSERT(m0_be_list_link_invariant(old));
         struct m0_be_list_link *prev_temp;
         struct m0_be_list_link *next_temp;
+        uint64_t                prev_magic;
+        uint64_t                next_magic;
 
         prev_temp = old->ll_prev.virtual_address;
         next_temp = old->ll_next.virtual_address;
 
+        /* Magic check to confirm prev and next are from same domain */
+        prev_magic = prev_temp->ll_prev.logical_address.magic;
+        next_magic = next_temp->ll_prev.logical_address.magic;
+        M0_ASSERT(prev_magic == next_magic);
+
+        prev_magic = prev_temp->ll_next.logical_address.magic;
+        next_magic = next_temp->ll_next.logical_address.magic;
+        M0_ASSERT(prev_magic == next_magic);
+
+        /* Now delete */
         prev_temp->ll_next.virtual_address = next_temp;
         next_temp->ll_prev.virtual_address = prev_temp;
 }
@@ -205,7 +237,10 @@ M0_INTERNAL void m0_be_list_link_init(struct m0_be_list_link *link,
 
                 prev_temp->u_hi = seg_id;
                 prev_temp->u_lo = offset;
-                /* TODO: update magic in logical address with the one in reference */
+
+                /* update magic in logical address with the one in reference */
+                link->ll_prev.logical_address.magic = ref->magic;
+                link->ll_next.logical_address.magic = ref->magic;
         }
 }
 M0_EXPORTED(m0_be_list_link_init);
diff --git a/be/lib/be_tlist.c b/be/lib/be_tlist.c
index 06ea997..4f8ee99 100644
--- a/be/lib/be_tlist.c
+++ b/be/lib/be_tlist.c
@@ -57,10 +57,8 @@ M0_INTERNAL void m0_be_tlist_fini(const struct m0_be_tl_descr *d,
 }
 
 M0_INTERNAL void m0_be_tlink_init(const struct m0_be_tl_descr *d,
-                                  struct m0_reference *ref)
+                                  struct m0_reference         *ref)
 {
-        //M0_ASSERT(ref.magic == d->td_link_magic);
-
         void *obj = ref->virtual_address;
         m0_be_list_link_init(be_link(d,obj), ref);
         if (d->td_link_magic != 0)
diff --git a/be/lib/be_types.h b/be/lib/be_types.h
index 0c87f3d..30ae145 100644
--- a/be/lib/be_types.h
+++ b/be/lib/be_types.h
@@ -42,11 +42,6 @@ struct m0_reference {
         uint64_t magic_offset;
 };
 
-enum m0_be_magic {
-        /* be_domain::be_ref_magic (cca11a5ca11ed) */
-        BE_ALLOC_REF_MAGIC = 0x33ca11a5ca11ed77
-};
-
 #endif /* __MERO_BE_LIB_BE_TYPES_H_ */
 
 /*
diff --git a/be/lib/ut/be_kv_store.c b/be/lib/ut/be_kv_store.c
index 188026d..41f5173 100644
--- a/be/lib/ut/be_kv_store.c
+++ b/be/lib/ut/be_kv_store.c
@@ -19,6 +19,7 @@
  */
 
 #include "be/lib/be_kv_store.h"
+#include "be/lib/be_handle_store.h"
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -42,6 +43,7 @@ struct m0_be_tl_descr list_descr = M0_BE_TL_DESCR("kv_store_obj",
 struct m0_be_domain     *dom;
 struct m0_be_seg        *seg;
 struct m0_kv_store      *handle = NULL;
+struct m0_kv_store_rvm  *handle_rvm = NULL;
 
 int function_comp(void *key1, void *key2)
 {
@@ -60,7 +62,7 @@ int function_match(void *in_obj, void *key)
         return strcmp(obj->key, (char *)key);
 }
 
-static void init()
+static void init(int control)
 {
         kv_key_cmp     cmp_routine;
         kv_key_match   match_routine;
@@ -71,9 +73,9 @@ static void init()
         m0_ks_init_domain(&dom);
         M0_ASSERT(dom != NULL);
 
-        m0_ks_init(&handle, &list_descr, dom, cmp_routine, match_routine);
+        m0_ks_init(&handle, &list_descr, dom, cmp_routine, match_routine,
+                   control);
         M0_ASSERT(handle != NULL);
-        M0_ASSERT(handle->handle_rvm != NULL);
 }
 
 static void fini()
@@ -114,7 +116,6 @@ static int insert(struct m0_kv_store_obj **obj,
 
         M0_ASSERT(obj_ref != NULL);
 
-
         strcpy((*obj)->key, key_name);
         (*obj)->val = val;
 
@@ -184,7 +185,7 @@ static int delete(struct m0_kv_store_obj *target)
         return ret_val;
 }
 
-int main() {
+int main(int argc, char *argv[]) {
         struct m0_kv_store_obj  *obj1 = NULL;
         struct m0_kv_store_obj  *obj2 = NULL;
         struct m0_kv_store_obj  *obj3 = NULL;
@@ -193,73 +194,87 @@ int main() {
         struct m0_kv_store_obj  *ret_obj2 = NULL;
         struct m0_kv_store_obj  *ret_obj3 = NULL;
         struct m0_kv_store_obj  *ret_obj4 = NULL;
-
         int                      status = -2;
         char                     obj1_name[] = "abc";
-        char                     obj2_name[] = "def";
+        char                     obj2_name[] = "jkl";
         char                     obj3_name[] = "ghi";
-        char                     obj4_name[] = "jkl";
+        char                     obj4_name[] = "def";
+        char                     mode[8];
 
-        init();
+        if (argc != 2) {
+                printf("Usage:./be_kv_store_ut CREATE ./be_kv_store RECOVER\n");
+                return 0;
+        }
+                
+        strcpy(mode, argv[1]);
+
+        if(strncmp(mode, "CREATE", 6) == 0)
+                init(CREATE);
+        else
+                init(RECOVER);
 
         m0_be_domain_lookup(dom, 1, &seg);
         M0_BE_WAIT(seg->bs_impl.sm_group, &(seg->bs_sm),
-                   (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED));
+                        (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED));
 
         M0_ASSERT(seg != NULL);
 
-        /* insert obj1 */
-        status = insert(&obj1, obj1_name, 1);
-        M0_ASSERT(status == BE_KV_SUCCESS);
-        printf("\nInserted obj1...\n");
-
-        /* insert obj2 */
-        status = insert(&obj2, obj2_name, 2);
-        M0_ASSERT(status == BE_KV_SUCCESS);
-        printf("Inserted obj2...\n");
-
-        /* insert obj3 */
-        status = insert(&obj3, obj3_name, 3);
-        M0_ASSERT(status == BE_KV_SUCCESS);
-        printf("Inserted obj3...\n");
-
-        /* insert obj4 */
-        status = insert(&obj4, obj4_name, 4);
-        M0_ASSERT(status == BE_KV_SUCCESS);
-        printf("Inserted obj4...\n");
-
-        ret_obj1  = (struct m0_kv_store_obj *)find(obj1_name);
-        M0_ASSERT(ret_obj1 != NULL);
-        printf("\nFound obj1 with val = %d\n", ret_obj1->val);
-
-        ret_obj2  = (struct m0_kv_store_obj *)find(obj2_name);
-        M0_ASSERT(ret_obj2 != NULL);
-        printf("Found obj2 with val = %d\n", ret_obj2->val);
-
-        ret_obj3  = (struct m0_kv_store_obj *)find(obj3_name);
-        M0_ASSERT(ret_obj3 != NULL);
-        printf("Found obj3 with val = %d\n", ret_obj3->val);
-
-        ret_obj4  = (struct m0_kv_store_obj *)find(obj4_name);
-        M0_ASSERT(ret_obj4 != NULL);
-        printf("Found obj4 with val = %d\n", ret_obj4->val);
-
-        status = delete(ret_obj1);
-        M0_ASSERT(status == BE_KV_SUCCESS);
-        printf("\nDeleted obj1\n");
-
-        status = delete(ret_obj2);
-        M0_ASSERT(status == BE_KV_SUCCESS);
-        printf("Deleted obj2\n");
-
-        status = delete(ret_obj3);
-        M0_ASSERT(status == BE_KV_SUCCESS);
-        printf("Deleted obj3\n");
-
-        status = delete(ret_obj4);
-        M0_ASSERT(status == BE_KV_SUCCESS);
-        printf("Deleted obj4\n");
-
+        if(strncmp(mode, "CREATE", 6) == 0) {
+                /* insert obj1 */
+                status = insert(&obj1, obj1_name, 1);
+                M0_ASSERT(status == BE_KV_SUCCESS);
+                printf("\nInserted obj1...\n");
+
+                /*insert obj2 */
+                status = insert(&obj2, obj2_name, 2);
+                M0_ASSERT(status == BE_KV_SUCCESS);
+                printf("Inserted obj2...\n");
+
+                /* insert obj3 */
+                status = insert(&obj3, obj3_name, 3);
+                M0_ASSERT(status == BE_KV_SUCCESS);
+                printf("Inserted obj3...\n");
+
+                /* insert obj4 */
+                status = insert(&obj4, obj4_name, 4);
+                M0_ASSERT(status == BE_KV_SUCCESS);
+                printf("Inserted obj4...\n");
+       } else {
+               /* Recover the handle from rvm */
+                m0_ks_deref_handle(handle, seg);
+
+                ret_obj1  = (struct m0_kv_store_obj *)find(obj1_name);
+                M0_ASSERT(ret_obj1 != NULL);
+                printf("\nFound obj1 with val = %d\n", ret_obj1->val);
+
+                ret_obj2  = (struct m0_kv_store_obj *)find(obj2_name);
+                M0_ASSERT(ret_obj2 != NULL);
+                printf("Found obj2 with val = %d\n", ret_obj2->val);
+
+                ret_obj3  = (struct m0_kv_store_obj *)find(obj3_name);
+                M0_ASSERT(ret_obj3 != NULL);
+                printf("Found obj3 with val = %d\n", ret_obj3->val);
+
+                ret_obj4  = (struct m0_kv_store_obj *)find(obj4_name);
+                M0_ASSERT(ret_obj4 != NULL);
+                printf("Found obj4 with val = %d\n", ret_obj4->val);
+
+                status = delete(ret_obj1);
+                M0_ASSERT(status == BE_KV_SUCCESS);
+                printf("\nDeleted obj1\n");
+
+                status = delete(ret_obj2);
+                M0_ASSERT(status == BE_KV_SUCCESS);
+                printf("Deleted obj2\n");
+
+                status = delete(ret_obj3);
+                M0_ASSERT(status == BE_KV_SUCCESS);
+                printf("Deleted obj3\n");
+
+                status = delete(ret_obj4);
+                M0_ASSERT(status == BE_KV_SUCCESS);
+                printf("Deleted obj4\n");
+        }
         fini();
         m0_free(handle);
         return 0;
diff --git a/be/lib/ut/be_tlist.c b/be/lib/ut/be_tlist.c
index 84ce312..420dc76 100644
--- a/be/lib/ut/be_tlist.c
+++ b/be/lib/ut/be_tlist.c
@@ -30,6 +30,7 @@
 #include <unistd.h>
 #include "be/be.h"
 #include "be/lib/be_tlist.h"
+#include "be/lib/be_helper.h"
 
 typedef struct foo {
         int                key;
@@ -45,16 +46,52 @@ struct m0_be_tl_descr list_descr = M0_BE_TL_DESCR("foo",
                                                   0xab5ce55edba1b0a0,
                                                   0xba1dba11adba0bab);
 
-struct m0_be_tl         tlist;
+struct m0_be_tl         *tlist = NULL;
 struct m0_be_seg        *seg;
 struct m0_be_domain      dom;
+uint64_t                 tlist_segid;
+uint64_t                 tlist_offset;
 
+void alloc_memory_tlist_rvm()
+{
+        struct m0_be_tx         *tx = NULL;
+        struct m0_be_reg        *reg = NULL;
+        struct m0_reference     *ref = NULL;
+        struct m0_be_buf         buf;
+
+        M0_ALLOC_PTR(tx);
+        M0_ASSERT(tx != NULL);
+       
+        m0_be_tx_init(tx, &dom, 0);
+        M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
+                   (1 << M0_BETX_INIT) | (1 << M0_BETX_FAILED));
+
+        /* Prepare a region for the rvm_handle */
+        buf.b_nob = sizeof(struct m0_be_tl);
+        m0_be_reg_init(&reg, tx, seg, &buf);
+
+        m0_ks_tx_start(tx);
+
+        tlist = (struct m0_be_tl *)m0_ks_obj_malloc(reg, &ref);
+        M0_ASSERT(tlist != NULL);
+        M0_ASSERT(ref != NULL);
+
+        tlist_segid = ref->segid_offset.u_hi;
+        tlist_offset = ref->segid_offset.u_lo;
+
+        m0_be_tx_done(tx);
+        M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
+                   (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED));
+
+        m0_be_tx_fini(tx);
+        m0_free(tx);
+}
 
 /** Displays the @tlist */
 void print_list()
 {
        struct foo *scan;
-       m0_be_tlist_for(&list_descr, &tlist, scan) {
+       m0_be_tlist_for(&list_descr, tlist, scan) {
                printf("key = %d value = %d\n", scan->key, scan->value);
        }m0_be_tlist_endfor;
 }
@@ -63,15 +100,19 @@ void print_list()
 void add_to_tlist(struct foo *obj, struct m0_reference *ref)
 {
        m0_be_tlink_init(&list_descr, ref);
-       m0_be_tlist_add(&list_descr, &tlist, obj);
+       m0_be_tlist_add(&list_descr, tlist, obj);
        M0_ASSERT(m0_be_tlink_is_in(&list_descr, obj));
 }
 
 /** Initialise the tlist, domain and the segment */
 void init_tlist_domain_and_segment()
 {
+        struct m0_be_list *head = NULL;
+        struct m0_uint128 *temp_head_offset = NULL;
+        struct m0_uint128 *temp_tail_offset = NULL;
+
         /* Initializing domain and segment */
-        m0_be_domain_init(&dom);
+        m0_be_domain_init(&dom, BE_DOMAIN_MAGIC);
         dom.bd_data.bs_sm.sm_state = M0_BESEG_ACTIVE;
 
         /*Create and Open Segment */
@@ -83,7 +124,22 @@ void init_tlist_domain_and_segment()
                         M0_TIME_NEVER);
         m0_sm_group_unlock(seg->bs_impl.sm_group);
 
-        m0_be_tlist_init(&list_descr, &tlist);
+        alloc_memory_tlist_rvm();
+        m0_be_tlist_init(&list_descr, tlist);
+
+        /* Update segment id & offset in head & tail */
+        head = &(tlist->t_head);
+
+        temp_head_offset       = &(head->l_head.logical_address.segid_offset);
+        temp_head_offset->u_hi = tlist_segid;
+        temp_head_offset->u_lo = tlist_offset;
+
+        temp_tail_offset       = &(head->l_tail.logical_address.segid_offset);
+        temp_tail_offset->u_hi = tlist_segid;
+        temp_tail_offset->u_lo = tlist_offset;
+
+        head->l_head.logical_address.magic = dom.bd_magic;
+        head->l_tail.logical_address.magic = dom.bd_magic;
 }
 
 /** Allocates memory to an object and adds it to the tlist */
@@ -170,7 +226,7 @@ int main()
         test_add_be_tlist(&test4, 40, 10);
 
         /* Check the length of the list */
-        printf("List length= %ld\n\n", m0_be_tlist_length(&list_descr, &tlist));
+        printf("List length= %ld\n\n", m0_be_tlist_length(&list_descr, tlist));
         printf("List contents:\n");
         print_list();
 
@@ -182,12 +238,12 @@ int main()
         print_list();
 
         /* Move @test3 to head */
-        m0_be_tlist_move(&list_descr, &tlist, test3);
+        m0_be_tlist_move(&list_descr, tlist, test3);
         printf("\nMoved 30:40 to head Now list:- .\n");
         print_list();
 
         /* Move @test4 to tail */
-        m0_be_tlist_move_tail(&list_descr, &tlist, test4);
+        m0_be_tlist_move_tail(&list_descr, tlist, test4);
         printf("\nMoved 40:10 to tail. Now list:- \n");
         print_list();
 
-- 
1.8.3.2

