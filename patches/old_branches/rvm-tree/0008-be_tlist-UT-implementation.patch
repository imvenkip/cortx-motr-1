From 9b55fa3612d7b2bfd70f232538cc34e0bb14ae89 Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Thu, 13 Dec 2012 02:27:29 -0800
Subject: [PATCH 08/94] be_tlist UT implementation

---
 Makefile.am            |   1 +
 be/lib/ut/Makefile     |   8 ++
 be/lib/ut/Makefile.sub |   1 +
 be/lib/ut/be_tlist.c   | 199 +++++++++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 209 insertions(+)
 create mode 100644 be/lib/ut/Makefile
 create mode 100644 be/lib/ut/Makefile.sub
 create mode 100644 be/lib/ut/be_tlist.c

diff --git a/Makefile.am b/Makefile.am
index d594458..75b7387 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -201,6 +201,7 @@ ut_libmero_ut_la_SOURCES  =
 
 include $(top_srcdir)/addb/ut/Makefile.sub
 include $(top_srcdir)/be/ut/Makefile.sub
+include $(top_srcdir)/be/lib/ut/Makefile.sub
 include $(top_srcdir)/balloc/ut/Makefile.sub
 include $(top_srcdir)/capa/ut/Makefile.sub
 include $(top_srcdir)/cm/ut/Makefile.sub
diff --git a/be/lib/ut/Makefile b/be/lib/ut/Makefile
new file mode 100644
index 0000000..42bcd1c
--- /dev/null
+++ b/be/lib/ut/Makefile
@@ -0,0 +1,8 @@
+.PHONY:all
+
+all:
+	gcc .libs/ut_libmero_ut_la-be_tlist.o  ../../../mero/.libs/libmero.a  -o ./be_tlist_ut  -lpthread  -ldb  -lrt -laio -lrvm -lrds -lseg -L../../../../rvm/rvm/.libs -L../../../../rvm/rds/.libs -L../../../../rvm/seg/.libs
+	rm -rf /tmp/log_file
+clean:
+	rm -rf ./be_tlist_ut
+	rm -f  /tmp/log_file
diff --git a/be/lib/ut/Makefile.sub b/be/lib/ut/Makefile.sub
new file mode 100644
index 0000000..ed8358f
--- /dev/null
+++ b/be/lib/ut/Makefile.sub
@@ -0,0 +1 @@
+ut_libmero_ut_la_SOURCES += be/lib/ut/be_tlist.c
diff --git a/be/lib/ut/be_tlist.c b/be/lib/ut/be_tlist.c
new file mode 100644
index 0000000..a272d78
--- /dev/null
+++ b/be/lib/ut/be_tlist.c
@@ -0,0 +1,199 @@
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author              : Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original creation date       : 12/12/2012
+ */
+
+/**
+ *             BE Tlist UT
+ */
+
+/**
+  @addtogroup be_lib_ut
+  @{
+  */
+
+#include <stdio.h>
+#include <unistd.h>
+#include "be/be.h"
+#include "be/lib/be_tlist.h"
+
+typedef struct foo {
+	int                key;
+	int                value;
+	struct m0_be_tlink linkage;
+	unsigned long int  ref_magic;
+}foo;
+
+struct m0_be_tl_descr list_descr = M0_BE_TL_DESCR("foo",
+					  	  struct foo,
+						  linkage,
+						  ref_magic,
+						  0xab5ce55edba1b0a0,
+						  0xba1dba11adba0bab);
+
+struct m0_be_tl         tlist;
+struct m0_be_seg        seg;
+struct m0_be_domain     dom;
+struct m0_stob          ns_stob;
+struct m0_stob          stob;
+struct m0_stob          log_stob;
+
+
+/** Displays the @tlist */
+void print_list()
+{
+       struct foo *scan;
+
+       m0_be_tlist_for(&list_descr, &tlist, scan) {
+               printf("key = %d value = %d\n", scan->key, scan->value);
+       }m0_be_tlist_endfor;
+}
+
+/** Adds a new @obj to the tlist */
+void add_to_tlist(struct foo *obj, struct m0_reference ref)
+{
+       m0_be_tlink_init(&list_descr, ref);
+       m0_be_tlist_add(&list_descr, &tlist, obj);
+       M0_ASSERT(m0_be_tlink_is_in(&list_descr, obj));
+}
+
+/** Initialise the tlist, domain and the segment */
+void init_tlist_domain_and_segment()
+{
+        /* initialise tlist as well */
+        m0_be_tlist_init(&list_descr, &tlist);
+
+        /* Initializing domain and segment */
+        m0_be_domain_init(&dom, &ns_stob, &log_stob);
+        m0_be_seg_init(&seg, &dom, &(dom.bd_impl.sm_group), 0);
+        dom.bd_data.bs_sm.sm_state = M0_BESEG_ACTIVE;
+
+        m0_be_seg_create(&seg, NULL, &stob);
+        m0_sm_group_lock(seg.bs_impl.sm_group);
+        m0_sm_timedwait(&seg.bs_sm,
+                        (1 << M0_BESEG_CREATED)|(1 << M0_BESEG_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(seg.bs_impl.sm_group);
+
+        /* If segment creation failed, then return */
+        if (seg.bs_sm.sm_state == M0_BESEG_FAILED ) {
+                printf("\nFailed to create segment \n");
+                return;
+        }
+
+        m0_be_seg_open(&seg);
+        m0_sm_group_lock(seg.bs_impl.sm_group);
+        m0_sm_timedwait(&seg.bs_sm,
+                        (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(seg.bs_impl.sm_group);
+}
+
+/** Allocates memory to an object and adds it to the tlist */
+void test_add_be_tlist(struct foo **new_obj, int incoming_key,
+                       int incoming_value)
+{
+        /** Be Domain Transaction */
+        struct m0_be_tx         tx;
+        struct m0_be_reg        reg;
+        struct m0_be_credit     cred;
+        struct m0_be_buf        buf;
+
+        reg.br_sm.sm_state = M0_BEREG_INIT;
+
+        m0_be_credit_init(&cred);
+
+        /** Initialise and start transaction */
+        m0_be_tx_init(&tx, &dom, 0);
+        m0_be_buf_init(&buf, NULL, sizeof(struct foo), 0, 0, 0);
+        m0_be_reg_init(&reg, &tx, &seg, &buf);
+        m0_be_credit_add(&cred, &reg);
+
+        m0_be_tx_prep(&tx, &cred);
+        m0_be_tx_start(&tx);
+
+        /** Allocate the memory to the object from @reg.br_buf */
+        *new_obj = (struct foo *)reg.br_buf.b_addr;
+        if (*new_obj == NULL) {
+                printf("Failed to allocate memory!!\n");
+                return;
+        }
+
+        (*new_obj)->key   = incoming_key;
+        (*new_obj)->value = incoming_value;
+
+        /** Insert in tlist */
+        printf("Adding %d:%d to tlist\n", incoming_key, incoming_value);
+        add_to_tlist(*new_obj, reg.br_buf.logical_address);
+
+        m0_be_tx_done(&tx);
+        m0_be_tx_fini(&tx);
+        rvm_truncate();
+}
+
+int main()
+{
+        struct foo *test1 = NULL;
+        struct foo *test2 = NULL;
+        struct foo *test3 = NULL;
+        struct foo *test4 = NULL;
+
+        /* Initialisse the tlsit, domain and the segment */
+        init_tlist_domain_and_segment();
+
+        /* Add @test1, @test2, @test3 & @test4 to tlist, added to head */
+        printf("\n");
+        test_add_be_tlist(&test1, 10, 20);
+        test_add_be_tlist(&test2, 20, 30);
+        test_add_be_tlist(&test3, 30, 40);
+        test_add_be_tlist(&test4, 40, 10);
+
+        /* Check the length of the list */
+        printf("List length= %ld\n\n", m0_be_tlist_length(&list_descr, &tlist));
+        printf("List contents:\n");
+        print_list();
+
+        /* Try and delete some node. Here @test1 */
+        if (m0_be_tlink_is_in(&list_descr, test1)) {
+                m0_be_tlink_del_fini(&list_descr, test1);
+                printf("\nDeleted  10:20. Now list contents:\n");
+        }
+        print_list();
+
+        /* Move @test3 to head */
+        m0_be_tlist_move(&list_descr, &tlist, test3);
+        printf("\nMoved 30:40 to head Now list:- .\n");
+        print_list();
+
+        /* Move @test4 to tail */
+        m0_be_tlist_move_tail(&list_descr, &tlist, test4);
+        printf("\nMoved 40:10 to tail. Now list:- \n");
+        print_list();
+        return 0;
+}
+
+/** @} end group be_lib_ut */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
-- 
1.8.3.2

