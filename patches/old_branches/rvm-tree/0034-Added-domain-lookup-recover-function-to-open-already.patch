From 0193d769cd3a1f88f95554cb0dfc190b65092192 Mon Sep 17 00:00:00 2001
From: Sachin Patil <sachin_patil@xyratex.com>
Date: Wed, 16 Jan 2013 06:41:39 -0800
Subject: [PATCH 34/94] Added domain lookup recover function to open already
 created function

---
 be/be.h        | 16 +++++++++++++++
 be/be_domain.c | 61 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 be/be_seg.c    | 10 ++++++----
 3 files changed, 82 insertions(+), 5 deletions(-)

diff --git a/be/be.h b/be/be.h
index 30ad6ee..fe114c3 100644
--- a/be/be.h
+++ b/be/be.h
@@ -255,6 +255,22 @@ M0_INTERNAL void m0_be_domain_lookup(struct m0_be_domain *dom,
 
 
 /**
+ * 
+ * Searches a domain for the existing segment with a given name.
+ * Note - This function does not create new segment, if segment not found.
+ *        This will return BE_SEG_FAILED for non existing segment lookups.
+ *
+ * @pre dom->bd_data.bs_sm.sm_state == M0_BESEG_ACTIVE
+ * @pre seg->bs_dom == dom
+ * @post M0_IN(seg->bs_sm.sm_state, (M0_BESEG_OPENING, M0_BESEG_ACTIVE,
+ *                                   M0_BESEG_FAILED))
+ */
+
+M0_INTERNAL void m0_be_domain_lookup_recover(struct m0_be_domain *dom,
+                                             const uint64_t segment_id,
+                                             struct m0_be_seg **out);
+
+/**
  * Initialises the segment structure in memory.
  *
  * @post seg->bs_sm.sm_state == M0_BESEG_CLOSED
diff --git a/be/be_domain.c b/be/be_domain.c
index 12c6b8c..5a9b44f 100644
--- a/be/be_domain.c
+++ b/be/be_domain.c
@@ -106,6 +106,7 @@ M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom, uint64_t dom_magic)
 
 /**
  * Searches a domain for the existing segment with a given name.
+ * If not found, then create new segment.
  *
  * @pre dom->bd_data.bs_sm.sm_state == M0_BESEG_ACTIVE
  * @pre seg->bs_sm.sm_state == M0_BESEG_CLOSED
@@ -178,7 +179,6 @@ M0_INTERNAL void m0_be_domain_lookup(struct m0_be_domain *dom,
 
                 m0_be_seg_tlist_add(&(dom->bd_seg), *out);
         }
-
 }
 
 /**
@@ -230,6 +230,65 @@ M0_INTERNAL void m0_be_domain_fini(struct m0_be_domain *dom)
         /* m0_free(dom); */
 }
 
+/**
+ * 
+ * Searches a domain for the existing segment with a given name.
+ * Note - This function does not create new segment, if segment not found.
+ *        This will return BE_SEG_FAILED for non existing segment lookups.
+ *
+ * @pre dom->bd_data.bs_sm.sm_state == M0_BESEG_ACTIVE
+ * @pre seg->bs_dom == dom
+ * @post M0_IN(seg->bs_sm.sm_state, (M0_BESEG_OPENING, M0_BESEG_ACTIVE,
+ *                                   M0_BESEG_FAILED))
+ */
+
+M0_INTERNAL void m0_be_domain_lookup_recover(struct m0_be_domain *dom,
+                                             const uint64_t segment_id,
+                                             struct m0_be_seg **out)
+{
+        struct m0_be_seg *seg_it;
+
+        /* Asserting on required conditions */
+        M0_ASSERT(dom != NULL);
+        M0_ASSERT(segment_id > 0);
+
+        M0_PRE(dom->bd_data.bs_sm.sm_state == M0_BESEG_ACTIVE);
+
+        /**
+         * Iterate through segment tlist and check for requested segment_id
+         * This assumes all the list is in memory.
+         */
+        m0_tlist_for(&m0_be_seg_tl, &(dom->bd_seg), seg_it) {
+                if (segment_id == seg_it->bs_impl.segment_id) {
+                        *out = seg_it;
+                        break;
+                }
+        } m0_tlist_endfor;
+
+        if ( (*out != NULL)                              &&
+             (M0_BESEG_CLOSED == (*out)->bs_sm.sm_state) ) {
+                m0_be_seg_open(*out);
+        }
+
+        if (*out == NULL) {
+                /* Now allocate, init and open the segment */
+
+                /* todo@ error handling for object allocation */
+                M0_ALLOC_PTR(*out);
+
+                (*out)->bs_impl.segment_id = segment_id;
+
+                m0_be_seg_tlink_init(*out);
+
+                /* Last 2 arguments - sm_grp and flags */
+                m0_be_seg_init(*out, dom, &(dom->bd_impl.sm_group), 0);
+
+                m0_be_seg_open(*out);
+
+                m0_be_seg_tlist_add(&(dom->bd_seg), *out);
+        }
+}
+
 /** @} end group be_domain */
 
 /*
diff --git a/be/be_seg.c b/be/be_seg.c
index a6367e9..4ef75c5 100644
--- a/be/be_seg.c
+++ b/be/be_seg.c
@@ -312,6 +312,12 @@ M0_INTERNAL void m0_be_seg_fini(struct m0_be_seg *seg)
         /* Finalizing respective stob */
         m0_stob_fini(seg->bs_stob);
 
+        /* Removing entry from in memory in segment list if present */
+        if (m0_be_seg_tlink_is_in(seg))
+                m0_be_seg_tlink_del_fini(seg);
+
+        /* free segment object memory */
+        m0_free(seg);
 }
 
 /**
@@ -352,10 +358,6 @@ M0_INTERNAL void m0_be_seg_delete(struct m0_be_seg *seg, struct m0_be_tx *tx)
         segment_id = seg->bs_impl.segment_id;
         dom        = seg->bs_dom;
 
-        /* deallocate stob and segment */
-        m0_free(seg->bs_stob);
-        m0_free(seg);
-
         /* @todo - remove entry from named segment transactionally */
 
         /* M0_POST(M0_IN(seg->bs_sm.sm_state,
-- 
1.8.3.2

