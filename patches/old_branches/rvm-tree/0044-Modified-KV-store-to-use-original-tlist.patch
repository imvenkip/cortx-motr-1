From 207594d96b69b30eda226a5ead4475f0ef62f62b Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Tue, 5 Feb 2013 02:34:26 -0800
Subject: [PATCH 44/94] Modified KV store to use original tlist

---
 be/helper.c      |   6 +-
 be/helper.h      |   6 +-
 be/kv_store.c    | 180 +++++++++++++++++++++++++------------------------------
 be/kv_store.h    |  38 ++++++------
 be/ut/be_tlist.c |   2 +
 be/ut/kv_store.c |  21 ++++---
 utils/ut_main.c  |   4 +-
 7 files changed, 119 insertions(+), 138 deletions(-)

diff --git a/be/helper.c b/be/helper.c
index e020284..ce239ef 100644
--- a/be/helper.c
+++ b/be/helper.c
@@ -73,7 +73,7 @@ M0_INTERNAL int m0_be_ks_domain_restore(struct m0_be_domain *dom,
                                         char                *name)
 {
         struct m0_sm_group *sm_group;
-        
+
         sm_group = m0_be_domain_sm_group(dom);
 
         m0_be_domain_restore(dom, name, seg);
@@ -161,7 +161,7 @@ M0_INTERNAL void m0_be_ks_tx_start(struct m0_be_tx *tx)
 M0_EXPORTED(m0_be_ks_tx_prep_start);
 
 M0_INTERNAL void m0_be_ks_prep_link_reg(struct m0_be_domain    *dom,
-                                        struct m0_be_list_link *link,
+                                        struct m0_list_link    *link,
                                         struct m0_be_tx        *tx,
                                         struct m0_be_reg      **reg)
 {
@@ -179,7 +179,7 @@ M0_INTERNAL void m0_be_ks_prep_link_reg(struct m0_be_domain    *dom,
 
         M0_ALLOC_PTR((*reg));
         M0_ASSERT(*reg != NULL);
-        buf.b_nob = sizeof(struct m0_be_list_link);
+        buf.b_nob = sizeof(struct m0_list_link);
         buf.b_addr = (void *)link;
         m0_be_reg_init(*reg, tx, seg, &buf);
 }
diff --git a/be/helper.h b/be/helper.h
index 2afce2d..5318013 100644
--- a/be/helper.h
+++ b/be/helper.h
@@ -24,7 +24,7 @@
 #include "be/be.h"
 #include "be/domain.h"
 #include "lib/memory.h"
-#include "be/be_list.h"
+#include "lib/list.h"
 #include "mero/magic.h"
 
 /**
@@ -88,7 +88,7 @@ M0_INTERNAL int m0_be_ks_domain_restore(struct m0_be_domain *dom,
 
 /**
   Allocates memory to an object.
-  
+
   @param obj_reg        :       initialised region for the object.
   @param obj_ref        :       reference to be filled up.
   @return allocated chunk of memory.
@@ -106,7 +106,7 @@ M0_INTERNAL void m0_be_ks_tx_start(struct m0_be_tx *tx);
   Prepares and carries out reg_init for @reg for the linkage @link.
  */
 M0_INTERNAL void m0_be_ks_prep_link_reg(struct m0_be_domain    *dom,
-                                        struct m0_be_list_link *link,
+                                        struct m0_list_link    *link,
                                         struct m0_be_tx        *tx,
                                         struct m0_be_reg      **reg);
 
diff --git a/be/kv_store.c b/be/kv_store.c
index da8be04..8401713 100644
--- a/be/kv_store.c
+++ b/be/kv_store.c
@@ -31,25 +31,25 @@
   Gives the linkage of the previous object for current. The previous pointer is
   updated in @link_prev.
  */
-static void __ks_get_prev(struct m0_be_tl_descr   *d,
-                          void                    *current,
-                          struct m0_be_list_link **link_prev);
+static void __ks_get_prev(struct m0_tl_descr   *d,
+                          void                 *current,
+                          struct m0_list_link **link_prev);
 
 /**
   Gives the linkage of the next object for current. The next pointer is
   updated in @link_next.
  */
-static void __ks_get_next(struct m0_be_tl_descr   *d,
-                          void                    *current,
-                          struct m0_be_list_link **link_next);
+static void __ks_get_next(struct m0_tl_descr   *d,
+                          void                 *current,
+                          struct m0_list_link **link_next);
 
 /**
   Gives the linkage of the current object. The pointer is updated in
   @link_current.
  */
-static void __ks_get_current(struct m0_be_tl_descr   *d,
-                             void                    *current,
-                             struct m0_be_list_link **link_cuurent);
+static void __ks_get_current(struct m0_tl_descr   *d,
+                             void                 *current,
+                             struct m0_list_link **link_cuurent);
 
 /**
   Adds or captures the regions of the current, next & previous pointers of
@@ -62,17 +62,13 @@ static void __ks_prev_next_add_cred(struct m0_be_kv_store     *handle,
                                     int                        operation);
 
 M0_INTERNAL void m0_be_ks_create_handle(struct m0_be_domain        *dom,
-                                        struct m0_be_tl_descr      *descr,
+                                        struct m0_tl_descr         *descr,
                                         struct m0_be_kv_store_rvm **rvm_han_out)
 {
         struct m0_be_tx             *tx;
         struct m0_be_reg            *rvm_handle_reg;
-        struct m0_be_reference_ll   *head;
-        struct m0_be_reference_ll   *tail;
         struct m0_be_reference      *rvm_handle_ref;
         struct m0_be_kv_store_rvm   *rvm_handle;
-        struct m0_uint128           *temp_head_offset;
-        struct m0_uint128           *temp_tail_offset;
         struct m0_sm_group          *sm_group;
         struct m0_be_seg            *rvm_handle_seg = NULL;
         struct m0_be_buf             rvm_handle_buf;
@@ -114,22 +110,7 @@ M0_INTERNAL void m0_be_ks_create_handle(struct m0_be_domain        *dom,
          */
         m0_be_hs_update(rvm_handle_seg, 0, &rvm_handle_ref->be_segid_offset);
 
-        m0_be_tlist_init(descr, &rvm_handle->ks_tlist);
-
-        /* Update segment id & offset in head & tail */
-        head = &rvm_handle->ks_tlist.t_head.l_head;
-        tail = &rvm_handle->ks_tlist.t_head.l_tail;
-
-        temp_head_offset       = &head->n_logical_address.be_segid_offset;
-        temp_head_offset->u_hi = rvm_handle_ref->be_segid_offset.u_hi;
-        temp_head_offset->u_lo = rvm_handle_ref->be_segid_offset.u_lo;
-
-        temp_tail_offset       = &tail->n_logical_address.be_segid_offset;
-        temp_tail_offset->u_hi = rvm_handle_ref->be_segid_offset.u_hi;
-        temp_tail_offset->u_lo = rvm_handle_ref->be_segid_offset.u_lo;
-
-        head->n_logical_address.be_magic = dom->bd_magic;
-        tail->n_logical_address.be_magic = dom->bd_magic;
+        m0_tlist_init(descr, &rvm_handle->ks_tlist);
 
         *rvm_han_out = rvm_handle;
         M0_ASSERT(*rvm_han_out != NULL);
@@ -143,12 +124,12 @@ M0_INTERNAL void m0_be_ks_create_handle(struct m0_be_domain        *dom,
 }
 M0_EXPORTED(m0_be_ks_create_handle);
 
-M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store    **out_handle,
-                               struct m0_be_tl_descr     *descr,
-                               struct m0_be_domain       *dom,
-                               kv_key_cmp                 cmp_fp,
-                               kv_key_match               match_fp,
-                               char                      *mode)
+M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store **out_handle,
+                               struct m0_tl_descr     *descr,
+                               struct m0_be_domain    *dom,
+                               kv_key_cmp              cmp_fp,
+                               kv_key_match            match_fp,
+                               char                   *mode)
 {
         struct m0_be_kv_store      *handle = NULL;
         struct m0_be_kv_store_rvm  *rvm_handle;
@@ -175,7 +156,7 @@ M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store    **out_handle,
                 /* Lookup for the kv_store segment. If not found, create one */
                 ret_val = m0_be_ks_domain_lookup(dom, &rvm_handle_seg,
                                                  BE_KV_SEG_NAME);
-                if (ret_val !=0) {
+                if (ret_val != 0) {
                         M0_ALLOC_PTR(rvm_handle_seg);
                         M0_ASSERT(rvm_handle_seg != NULL);
 
@@ -211,31 +192,30 @@ M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store    **out_handle,
 }
 M0_EXPORTED(m0_be_ks_init);
 
-M0_INTERNAL struct m0_be_reference
+M0_INTERNAL struct m0_list_link
 *m0_be_ks_get_next_val(struct m0_be_kv_store *handle, void *obj)
 {
-        struct m0_be_list_link  *link_next;
-        struct m0_be_reference  *ret_ref;
+        struct m0_list_link     *link_next;
         void                    *temp_tail;
-        struct m0_be_tl         *ks_tlist;
-        struct m0_be_tl_descr   *ks_list_descr;
+        struct m0_tl            *ks_tlist;
+        struct m0_tl_descr      *ks_list_descr;
 
         ks_tlist      = &handle->handle_rvm->ks_tlist;
         ks_list_descr = handle->handle_heap.ks_list_descr;
 
-        temp_tail = m0_be_tlist_tail(ks_list_descr, ks_tlist);
+        temp_tail = m0_tlist_tail(ks_list_descr, ks_tlist);
 
         /* If object is last in linked list, then its next will be itself */
         if (temp_tail == obj) {
                 __ks_get_current(ks_list_descr, obj, &link_next);
+                link_next = NULL;
                 goto get_ref;
         }
 
         __ks_get_next(ks_list_descr, obj, &link_next);
 
 get_ref:
-        ret_ref  = &link_next->ll_next.n_logical_address;
-        return ret_ref;
+        return link_next;
 }
 M0_EXPORTED(m0_be_ks_get_next_value);
 
@@ -248,18 +228,18 @@ M0_INTERNAL void *m0_be_ks_find(struct m0_be_kv_store *handle,
          */
         void                    *scan;
         void                    *target = NULL;
-        struct m0_be_tl         *ks_tlist;
-        struct m0_be_tl_descr   *ks_list_descr;
+        struct m0_tl            *ks_tlist;
+        struct m0_tl_descr      *ks_list_descr;
 
         ks_tlist = &handle->handle_rvm->ks_tlist;
         ks_list_descr = handle->handle_heap.ks_list_descr;
 
-        m0_be_tlist_for(ks_list_descr, ks_tlist, scan) {
+        m0_tlist_for(ks_list_descr, ks_tlist, scan) {
                 if (handle->handle_heap.ks_key_match(scan, key) == 0) {
                         target = scan;
                         break;
                 }
-        } m0_be_tlist_endfor;
+        } m0_tlist_endfor;
 
         return target;
 }
@@ -272,11 +252,11 @@ M0_INTERNAL int m0_be_ks_delete(struct m0_be_kv_store  *handle,
         void                    *scan;
         void                    *target = NULL;
         struct m0_be_reg        *t_head_reg;
-        struct m0_be_list_link  *temp_link;
-        struct m0_be_list_link  *t_head_link;
-        struct m0_be_list_link  *head;
-        struct m0_be_tl         *ks_tlist;
-        struct m0_be_tl_descr   *ks_list_descr;
+        struct m0_list_link     *temp_link;
+        struct m0_list_link     *t_head_link;
+        struct m0_list_link     *head;
+        struct m0_tl            *ks_tlist;
+        struct m0_tl_descr      *ks_list_descr;
         struct m0_be_domain     *ks_dom;
         struct m0_sm_group      *sm_group;
         struct m0_be_tx         *tx             = del_tx;
@@ -302,18 +282,18 @@ M0_INTERNAL int m0_be_ks_delete(struct m0_be_kv_store  *handle,
         }
 
         /* Find the target node to be deleted */
-        m0_be_tlist_for(ks_list_descr, ks_tlist, scan) {
+        m0_tlist_for(ks_list_descr, ks_tlist, scan) {
                 if (handle->handle_heap.ks_key_cmp(scan, obj) == 0) {
                         target = scan;
                         target_found = BE_KV_SUCCESS;
                         break;
                 }
-        } m0_be_tlist_endfor;
+        } m0_tlist_endfor;
 
         if (target_found == BE_KV_SUCCESS) {
                 /* Capture t_head */
-                temp_link   = head->ll_next.n_virtual_address;
-                t_head_link = temp_link->ll_prev.n_virtual_address;
+                temp_link   = head->ll_next;
+                t_head_link = temp_link->ll_prev;
                 M0_ASSERT(t_head_link != NULL);
 
                 m0_be_ks_prep_link_reg(ks_dom, t_head_link, tx, &t_head_reg);
@@ -342,7 +322,7 @@ M0_INTERNAL int m0_be_ks_delete(struct m0_be_kv_store  *handle,
                 }
 
                 /* Now delete */
-                m0_be_tlink_del_fini(ks_list_descr, target);
+                m0_tlink_del_fini(ks_list_descr, target);
 
                 if (del_tx == NULL) {
                         m0_be_tx_done(tx);
@@ -370,9 +350,9 @@ M0_INTERNAL int __ks_tlist_add_at_tail(struct m0_be_kv_store     *handle,
                                        int                        in_tx_state)
 {
         struct m0_be_reg        *tail_obj_reg;
-        struct m0_be_list_link  *tail_obj_link;
-        struct m0_be_tl         *ks_tlist;
-        struct m0_be_tl_descr   *ks_list_descr;
+        struct m0_list_link     *tail_obj_link;
+        struct m0_tl            *ks_tlist;
+        struct m0_tl_descr      *ks_list_descr;
         struct m0_be_domain     *ks_dom;
         struct m0_sm_group      *sm_group;
         void                    *tail_obj;
@@ -383,7 +363,7 @@ M0_INTERNAL int __ks_tlist_add_at_tail(struct m0_be_kv_store     *handle,
         sm_group      = m0_be_domain_sm_group(ks_dom);
 
         /* Add current tail to credit */
-        tail_obj  = m0_be_tlist_tail(ks_list_descr, ks_tlist);
+        tail_obj  = m0_tlist_tail(ks_list_descr, ks_tlist);
 
         __ks_get_current(ks_list_descr, tail_obj, &tail_obj_link);
         M0_ASSERT(tail_obj_link != NULL);
@@ -404,7 +384,7 @@ M0_INTERNAL int __ks_tlist_add_at_tail(struct m0_be_kv_store     *handle,
         }
 
         /* Finally, add at tail in tlist */
-        m0_be_tlist_add_tail(ks_list_descr, ks_tlist, new);
+        m0_tlist_add_tail(ks_list_descr, ks_tlist, new);
         return BE_KV_SUCCESS;
 }
 
@@ -415,10 +395,10 @@ M0_INTERNAL int m0_be_ks_insert(struct m0_be_kv_store      *handle,
         struct m0_be_reg        *obj_link_reg;
         struct m0_be_domain     *dom;
         struct m0_be_reg        *t_head_reg;
-        struct m0_be_list_link  *link;
-        struct m0_be_tl         *ks_tlist;
-        struct m0_be_tl_descr   *ks_list_descr;
-        struct m0_be_list_link  *head;
+        struct m0_list_link     *link;
+        struct m0_tl            *ks_tlist;
+        struct m0_tl_descr      *ks_list_descr;
+        struct m0_list_link     *head;
         struct m0_be_tx         *tx = ins_tx;
         struct m0_sm_group      *sm_group;
         void                    *new;
@@ -442,12 +422,12 @@ M0_INTERNAL int m0_be_ks_insert(struct m0_be_kv_store      *handle,
         new = obj_ref->be_virtual_address;
 
         /* Check for duplicate insertion */
-        m0_be_tlist_for(ks_list_descr, ks_tlist, scan) {
+        m0_tlist_for(ks_list_descr, ks_tlist, scan) {
                 if (handle->handle_heap.ks_key_cmp(new, scan) == 0) {
                         ret_val = BE_KV_DUPLICATE;
                         goto exit_insert;
                 }
-        } m0_be_tlist_endfor;
+        } m0_tlist_endfor;
 
         /* If tx is not provided, create and start a new one */
         if (ins_tx == NULL) {
@@ -462,7 +442,7 @@ M0_INTERNAL int m0_be_ks_insert(struct m0_be_kv_store      *handle,
         }
 
         /* Tlink init for this object */
-        m0_be_tlink_init(ks_list_descr, obj_ref);
+        m0_tlink_init(ks_list_descr, new);
 
         __ks_get_current(ks_list_descr, new, &link);
         M0_ASSERT(link != NULL);
@@ -491,8 +471,8 @@ M0_INTERNAL int m0_be_ks_insert(struct m0_be_kv_store      *handle,
         M0_ASSERT(t_head_reg != NULL);
 
         /* Check if tlist is empty */
-        if ((head->ll_next.n_virtual_address == (void *)head) &&
-            (head->ll_prev.n_virtual_address == (void *)head)) {
+        if ((head->ll_next == (void *)head) &&
+            (head->ll_prev == (void *)head)) {
 
                 /* Capture t_head region */
                 if (ins_tx == NULL) {
@@ -507,13 +487,13 @@ M0_INTERNAL int m0_be_ks_insert(struct m0_be_kv_store      *handle,
                 }
 
                 /* Add to tlist now */
-                m0_be_tlist_add(ks_list_descr, ks_tlist, new);
+                m0_tlist_add(ks_list_descr, ks_tlist, new);
                 ret_val = BE_KV_SUCCESS;
         } else {
                 /*
                  * Else, find the appropriate position for the obj and insert
                  */
-                m0_be_tlist_for(ks_list_descr, ks_tlist, scan)
+                m0_tlist_for(ks_list_descr, ks_tlist, scan)
                 {
                         if (handle->handle_heap.ks_key_cmp(new, scan) < 0) {
                                 /*
@@ -535,13 +515,13 @@ M0_INTERNAL int m0_be_ks_insert(struct m0_be_kv_store      *handle,
                                 }
 
                                 /* Now add the object to the tlist */
-                                m0_be_tlist_add_before(ks_list_descr, scan,
+                                m0_tlist_add_before(ks_list_descr, scan,
                                                        new);
 
                                 ret_val = BE_KV_SUCCESS;
                                 break;
                         }
-                } m0_be_tlist_endfor;
+                } m0_tlist_endfor;
 
                 /* If key is largest in the list, add at tail */
                 if (ret_val == BE_KV_INVALID_REQ) {
@@ -607,44 +587,44 @@ exit_deref:
 }
 M0_EXPORTED(m0_be_ks_deref_handle);
 
-static void __ks_get_prev(struct m0_be_tl_descr   *d,
-                          void                    *current,
-                          struct m0_be_list_link **link_prev)
+static void __ks_get_prev(struct m0_tl_descr   *d,
+                          void                 *current,
+                          struct m0_list_link **link_prev)
 {
-        struct m0_be_list_link *link;
-        int                     link_offset;
+        struct m0_list_link *link;
+        int                  link_offset;
 
         link_offset = d->td_link_offset;
 
-        link = &((struct m0_be_tlink *)(current + link_offset))->t_link;
+        link = &((struct m0_tlink *)(current + link_offset))->t_link;
 
-        *link_prev = link->ll_prev.n_virtual_address;
+        *link_prev = link->ll_prev;
 }
 
-static void __ks_get_next(struct m0_be_tl_descr   *d,
-                          void                    *current,
-                          struct m0_be_list_link **link_next)
+static void __ks_get_next(struct m0_tl_descr   *d,
+                          void                 *current,
+                          struct m0_list_link **link_next)
 {
-        struct m0_be_list_link *link;
-        int                     link_offset;
+        struct m0_list_link *link;
+        int                  link_offset;
 
         link_offset = d->td_link_offset;
 
-        link = &((struct m0_be_tlink *)(current + link_offset))->t_link;
+        link = &((struct m0_tlink *)(current + link_offset))->t_link;
 
-        *link_next = link->ll_next.n_virtual_address;
+        *link_next = link->ll_next;
 }
 
-static void __ks_get_current(struct m0_be_tl_descr  *d,
-                             void                   *current,
-                             struct m0_be_list_link **link_current)
+static void __ks_get_current(struct m0_tl_descr   *d,
+                             void                 *current,
+                             struct m0_list_link **link_current)
 {
-        struct m0_be_list_link *link;
+        struct m0_list_link *link;
         int                     link_offset;
 
         link_offset = d->td_link_offset;
 
-        link = &((struct m0_be_tlink *)(current + link_offset))->t_link;
+        link = &((struct m0_tlink *)(current + link_offset))->t_link;
 
         *link_current = link;
 }
@@ -657,10 +637,10 @@ static void __ks_prev_next_add_cred(struct m0_be_kv_store *handle,
         struct m0_be_reg         *prev_reg;
         struct m0_be_reg         *next_reg;
         struct m0_be_reg         *curr_reg;
-        struct m0_be_list_link   *link_prev;
-        struct m0_be_list_link   *link_curr;
-        struct m0_be_list_link   *link_next = NULL;
-        struct m0_be_tl_descr    *ks_list_descr;
+        struct m0_list_link      *link_prev;
+        struct m0_list_link      *link_curr;
+        struct m0_list_link      *link_next = NULL;
+        struct m0_tl_descr       *ks_list_descr;
         struct m0_be_domain      *ks_dom;
         struct m0_sm_group       *sm_group;
 
diff --git a/be/kv_store.h b/be/kv_store.h
index 468bac3..8a65bf7 100644
--- a/be/kv_store.h
+++ b/be/kv_store.h
@@ -23,7 +23,7 @@
 
 #include "be/be.h"
 #include "be/tx.h"
-#include "be/be_tlist.h"
+#include "lib/tlist.h"
 
 /**
    @defgroup kv_store Key Value Store
@@ -31,7 +31,7 @@
    Key value store module provides functionality to store objects based on
    "keys". A single kv-store is managed by a handle of type
    struct m0_be_kv_store. Key value store is recoverable. For this purpose,
-   key value store internally uses m0_be_tlist to store these objects and make
+   key value store internally uses m0_tlist to store these objects and make
    them persistent on storage.
 
    The kv_store handle is divided in two parts:
@@ -40,18 +40,18 @@
              the kv_store again.
         2. struct m0_be_kv_store_rvm;
              Fields that have to be made persistent. i.e. fields like the
-             m0_be_tlist that stores the objects.
+             m0_tlist that stores the objects.
 
    The kv_store is instructed to initialise either in "create" or recovery mode.
    Depending upon the mode, the handle is either created or retrieved from RVM.
 
    The object to be inserted should look like:
-   
+
    @code:
    struct foo {
         ....
         char               key[];
-        struct m0_be_tlink link;
+        struct m0_tlink link;
         uint64_t           magic;
         ....
    };
@@ -68,7 +68,7 @@
        int function_compare(void *, void *);
 
        struct m0_be_kv_store *handle;
-       struct m0_be_tl_descr *list_descr;
+       struct m0_tl_descr    *list_descr;
        struct m0_be_domain   *dom;
        kv_key_cmp             cmp_routine;
        kv_key_match           match_routine;
@@ -82,7 +82,7 @@
    Insertion:
        PRE: object to be allocated MUST be allocated memory via m0_be_alloc
             on RVM.
-       
+
        @code
        int                     status;
        struct foo             *object;
@@ -141,7 +141,7 @@ typedef int     (*kv_key_match)(void *, void *);
  */
 struct m0_be_kv_store_rvm {
         /* The tlist */
-        struct m0_be_tl         ks_tlist;
+        struct m0_tl         ks_tlist;
 };
 
 /**
@@ -149,7 +149,7 @@ struct m0_be_kv_store_rvm {
  */
 struct m0_be_kv_store_heap {
         /** List descriptor for the tlist. */
-        struct m0_be_tl_descr   *ks_list_descr;
+        struct m0_tl_descr      *ks_list_descr;
         /** Domain pointer. */
         struct m0_be_domain     *ks_dom;
         /** Compare function from user. */
@@ -176,7 +176,7 @@ struct m0_be_kv_store {
   @param handle        :       the rvm_handle to be returned to the caller.
  */
 M0_INTERNAL void m0_be_ks_create_handle(struct m0_be_domain        *dom,
-                                        struct m0_be_tl_descr      *descr,
+                                        struct m0_tl_descr         *descr,
                                         struct m0_be_kv_store_rvm **handle);
 
 /**
@@ -192,12 +192,12 @@ M0_INTERNAL void m0_be_ks_create_handle(struct m0_be_domain        *dom,
                                recovered.
                                Allowed modes: CREATE/RECOVER or create/recover.
  */
-M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store    **handle,
-                               struct m0_be_tl_descr     *descr,
-                               struct m0_be_domain       *dom,
-                               kv_key_cmp                 cmp_fp,
-                               kv_key_match               match_fp,
-                               char                      *mode);
+M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store **handle,
+                               struct m0_tl_descr     *descr,
+                               struct m0_be_domain    *dom,
+                               kv_key_cmp              cmp_fp,
+                               kv_key_match            match_fp,
+                               char                   *mode);
 
 /**
   Insert a key value pair in the tlist contained in @handle.
@@ -243,13 +243,13 @@ M0_INTERNAL int m0_be_ks_delete(struct m0_be_kv_store *handle,
                                 struct m0_be_tx       *tx);
 
 /**
-  Finds the m0_be_reference i.e logical address of the object present next to
+  Returns the linkage  of the object present next to
   @obj in the tlist contained in @handle.
 
-  @return               :       logical address of next object.
+  @return               :       linkage of next object.
   @return               :       NULL on failure.
  */
-M0_INTERNAL struct m0_be_reference
+M0_INTERNAL struct m0_list_link
 *m0_be_ks_get_next_val(struct m0_be_kv_store *handle, void *obj);
 
 /**
diff --git a/be/ut/be_tlist.c b/be/ut/be_tlist.c
index 85db5d6..392785b 100644
--- a/be/ut/be_tlist.c
+++ b/be/ut/be_tlist.c
@@ -100,6 +100,7 @@ void alloc_memory_tlist_rvm()
 
         m0_be_tx_fini(tx);
         m0_free(tx);
+        m0_free(reg);
 }
 
 /** Adds a new @obj to the tlist. */
@@ -247,6 +248,7 @@ void test_add_be_tlist(struct foo **new_obj, int incoming_key,
         m0_sm_group_unlock(m0_be_domain_sm_group(tx.bt_dom));
 
         m0_be_tx_fini(&tx);
+        m0_free(reg);
 }
 
 
diff --git a/be/ut/kv_store.c b/be/ut/kv_store.c
index 2c082b3..9a6e700 100644
--- a/be/ut/kv_store.c
+++ b/be/ut/kv_store.c
@@ -41,16 +41,16 @@
 struct m0_kv_store_obj {
         char                    key[MAX_KEY_SIZE];
         int                     obj_val;
-        struct m0_be_tlink      linkage;
+        struct m0_tlink      linkage;
         uint64_t                magic;
 };
 
-struct m0_be_tl_descr kv_list_descr = M0_BE_TL_DESCR("kv_store_obj",
-                                                  struct m0_kv_store_obj,
-                                                  linkage,
-                                                  magic,
-                                                  0xab5ce55edba1b0a0,
-                                                  0xba1dba11adba0bab);
+struct m0_tl_descr kv_list_descr = M0_TL_DESCR("kv_store_obj",
+                                                struct m0_kv_store_obj,
+                                                linkage,
+                                                magic,
+                                                0xab5ce55edba1b0a0,
+                                                0xba1dba11adba0bab);
 
 struct m0_be_domain        *kv_dom;
 struct m0_be_seg           *kv_seg;
@@ -189,7 +189,6 @@ static int insert(char *key_name, int val)
 
         m0_free(tx);
         m0_free(obj_reg);
-
 exit:
         return status;
 }
@@ -282,7 +281,7 @@ void test_kv_store()
                         strcpy(obj_name, "akv");
         }
 
-        length = m0_be_tlist_length(&kv_list_descr,
+        length = m0_tlist_length(&kv_list_descr,
                                     &handle->handle_rvm->ks_tlist);
         M0_ASSERT(length == 10);
 
@@ -300,13 +299,13 @@ void test_kv_store()
                 else
                         strcpy(obj_name, "akv");
         }
-        
+
         /* Delete'em */
         for(i =0; i < 10; i++) {
                 status = delete(ret_obj[i]);
                 M0_ASSERT(status == BE_KV_SUCCESS);
         }
-        length = m0_be_tlist_length(&kv_list_descr,
+        length = m0_tlist_length(&kv_list_descr,
                                     &handle->handle_rvm->ks_tlist);
 
         M0_ASSERT(length == 0);
diff --git a/utils/ut_main.c b/utils/ut_main.c
index 5626afa..88e989f 100644
--- a/utils/ut_main.c
+++ b/utils/ut_main.c
@@ -96,8 +96,8 @@ void add_uts(void)
         m0_ut_add(&libm0_ut); /* test lib first */
         m0_ut_add(&ad_ut);
         m0_ut_add(&adieu_ut);
-        m0_ut_add(&be_hs_ut);
-        /*m0_ut_add(&be_kv_store_ut);*/
+        /*m0_ut_add(&be_hs_ut);*/
+        m0_ut_add(&be_kv_store_ut);
         /*m0_ut_add(&be_tlist_ut);*/
         /*m0_ut_add(&be_ut);*/
 	m0_ut_add(&balloc_ut);
-- 
1.8.3.2

