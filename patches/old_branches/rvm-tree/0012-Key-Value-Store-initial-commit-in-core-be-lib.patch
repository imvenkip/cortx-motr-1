From 7c93cc3b8954e1dfb6ba5aa85a9cf90385f875a0 Mon Sep 17 00:00:00 2001
From: Prashant Dhange <prashant_dhange@xyratex.com>
Date: Tue, 18 Dec 2012 08:07:53 -0800
Subject: [PATCH 12/94] Key Value Store initial commit in core/be/lib/

---
 be/Makefile.sub         |  20 +-
 be/lib/be_kv_store.c    | 522 ++++++++++++++++++++++++++++++++++++++++++++++++
 be/lib/be_kv_store.h    | 188 +++++++++++++++++
 be/lib/ut/Makefile      |   4 +-
 be/lib/ut/Makefile.sub  |   3 +-
 be/lib/ut/be_kv_store.c | 138 +++++++++++++
 6 files changed, 864 insertions(+), 11 deletions(-)
 create mode 100644 be/lib/be_kv_store.c
 create mode 100644 be/lib/be_kv_store.h
 create mode 100644 be/lib/ut/be_kv_store.c

diff --git a/be/Makefile.sub b/be/Makefile.sub
index 536754e..0dab17e 100644
--- a/be/Makefile.sub
+++ b/be/Makefile.sub
@@ -2,13 +2,15 @@ nobase_mero_include_HEADERS +=  be/be.h                 \
 				be/lib/be_buf.h         \
 				be/lib/be_list.h        \
 				be/lib/be_tlist.h       \
-				be/lib/be_types.h
+				be/lib/be_types.h	\
+				be/lib/be_kv_store.h	
 
-mero_libmero_la_SOURCES  += be/be.c                     \
-			    be/be_domain.c              \
-			    be/be_seg.c                 \
-			    be/be_rvm.c                 \
-			    be/be_tx.c                  \
-			    be/lib/be_buf.c             \
-			    be/lib/be_list.c            \
-			    be/lib/be_tlist.c
+mero_libmero_la_SOURCES	    += 	be/be.c                 \
+			      	be/be_domain.c          \
+			    	be/be_seg.c             \
+			    	be/be_rvm.c             \
+			    	be/be_tx.c              \
+			    	be/lib/be_buf.c         \
+			    	be/lib/be_list.c        \
+			    	be/lib/be_tlist.c	\
+				be/lib/be_kv_store.c	
diff --git a/be/lib/be_kv_store.c b/be/lib/be_kv_store.c
new file mode 100644
index 0000000..143f91c
--- /dev/null
+++ b/be/lib/be_kv_store.c
@@ -0,0 +1,522 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author              : Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original creation date       : 12/14/2012
+ */
+
+#include "be/lib/be_kv_store.h"
+#include <string.h>
+#include <stdlib.h>
+
+/**
+   @addtogroup be_kv_store
+   @{
+ */
+
+int m0_ks_init_domain_and_segment(struct m0_be_domain  *dom,
+                                  struct m0_be_seg    *seg,
+                                  struct m0_stob      *ns_stob,
+                                  struct m0_stob      *stob,
+                                  struct m0_stob      *log_stob)
+{
+        /* Initializing domain and segment */
+        m0_be_domain_init(dom, ns_stob, log_stob);
+        m0_be_seg_init(seg, dom, &(dom->bd_impl.sm_group), 0);
+        dom->bd_data.bs_sm.sm_state = M0_BESEG_ACTIVE;
+
+        m0_be_seg_create(seg, NULL, stob);
+        m0_sm_group_lock(seg->bs_impl.sm_group);
+        m0_sm_timedwait(&(seg->bs_sm),
+                        (1 << M0_BESEG_CREATED)|(1 << M0_BESEG_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(seg->bs_impl.sm_group);
+
+        /* If segment creation failed, then return */
+        if (seg->bs_sm.sm_state == M0_BESEG_FAILED ) {
+                return BE_KV_FAILURE;
+        }
+
+        m0_be_seg_open(seg);
+        m0_sm_group_lock(seg->bs_impl.sm_group);
+        m0_sm_timedwait(&(seg->bs_sm),
+                        (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(seg->bs_impl.sm_group);
+        return BE_KV_SUCCESS;
+}
+
+/**
+ * Initialise a descriptor @d with values specified
+ *
+ * @param d		:	list descriptor to be initialised
+ * @param list_name	:	name to be given to the tlist
+ * @param link_magic	:	magic value for the linkage in the tlist
+ * @param head_magic	:	magic value for the head in the tlist
+ */
+static void __m0_ks_list_init(struct m0_be_tl_descr *d,
+                              char                  *list_name,
+			      uint64_t               link_magic,
+		     	      uint64_t               head_magic)
+{
+	d->td_name  	        = list_name;
+        d->td_link_offset       = offsetof(struct m0_kv_store_obj, kvs_linkage);
+        d->td_link_magic_offset = offsetof(struct m0_kv_store_obj,
+					   kvs_ref_magic);
+        d->td_link_magic        = link_magic;
+        d->td_head_magic        = head_magic;
+}
+
+static void __get_prev(struct m0_be_tl_descr   *d,
+                       struct m0_kv_store_obj *current,
+                       struct m0_be_list_link **link_prev)
+{
+        *link_prev = current->kvs_linkage.t_link.ll_prev.virtual_address;
+}
+
+static void __get_next(struct m0_be_tl_descr   *d,
+                       struct m0_kv_store_obj *current,
+                       struct m0_be_list_link **link_next)
+{
+        *link_next = current->kvs_linkage.t_link.ll_next.virtual_address;
+}
+
+static void __prep_prev_next_reg(struct m0_kv_store     *handle,
+                                 struct m0_be_buf       *prev_buf,
+                                 struct m0_be_buf       *next_buf,
+                                 struct m0_be_reg       *prev_reg,
+                                 struct m0_be_reg       *next_reg,
+                                 struct m0_be_list_link *link_prev,
+                                 struct m0_be_list_link *link_next)
+{
+        prev_reg->br_sm.sm_state = M0_BEREG_DONE;
+        next_reg->br_sm.sm_state = M0_BEREG_DONE;
+
+        m0_be_buf_init(prev_buf, NULL, sizeof(struct m0_be_list_link), 0, 0, 0);
+        m0_be_buf_init(next_buf, NULL, sizeof(struct m0_be_list_link), 0, 0, 0);
+
+        m0_be_reg_init(prev_reg, NULL, handle->ks_seg, prev_buf);
+        m0_be_reg_init(next_reg, NULL, handle->ks_seg, next_buf);
+
+        prev_reg->br_buf.b_addr = (void *)link_prev;
+        next_reg->br_buf.b_addr = (void *)link_next;
+}
+
+static int malloc_for_reg(struct m0_be_reg **prev_reg,
+                          struct m0_be_reg **next_reg,
+                          struct m0_be_buf **prev_buf,
+                          struct m0_be_buf **next_buf)
+{
+        *prev_buf = (struct m0_be_buf *)malloc(sizeof(struct m0_be_buf));
+        if (prev_buf == NULL)
+                return BE_KV_FAILURE;
+
+        *next_buf = (struct m0_be_buf *)malloc(sizeof(struct m0_be_buf));
+        if (next_buf == NULL) {
+                free(prev_buf);
+                return BE_KV_FAILURE;
+        }
+
+        *prev_reg = (struct m0_be_reg *)malloc(sizeof(struct m0_be_reg));
+        if (*prev_reg == NULL) {
+                free(prev_buf);
+                free(next_buf);
+                return BE_KV_FAILURE;
+        }
+
+       *next_reg = (struct m0_be_reg *)malloc(sizeof(struct m0_be_reg));
+       if (next_reg == NULL) {
+                free(prev_buf);
+                free(next_buf);
+                free(*prev_reg);
+                return BE_KV_FAILURE;
+       }
+       return BE_KV_SUCCESS;
+}
+
+
+void m0_ks_init(struct m0_kv_store *handle,
+                char               *list_name,
+		uint64_t            link_magic,
+                uint64_t            head_magic)
+{
+        /* Initialise tlist descriptor */
+        __m0_ks_list_init(&handle->ks_list_descr, list_name,
+			  link_magic, head_magic);
+
+        /* be_tlist init */
+	m0_be_tlist_init(&handle->ks_list_descr, &handle->ks_tlist);
+}
+
+void m0_ks_update_handle(struct m0_kv_store  *handle, struct m0_be_domain *dom,
+                         struct m0_be_seg    *seg, struct m0_stob      *ns_stob,
+                         struct m0_stob      *stob,
+                         struct m0_stob      *log_stob)
+{
+        handle->ks_dom          = dom;
+        handle->ks_seg          = seg;
+        handle->ks_ns_stob      = ns_stob;
+        handle->ks_stob         = stob;
+        handle->ks_log_stob     = log_stob;
+}
+
+struct m0_be_buf *m0_ks_find(struct m0_kv_store *handle,
+		             struct m0_kv_key   *key)
+{
+        struct m0_be_buf       *ret_buf = NULL;
+        struct m0_kv_store_obj *scan;
+
+	/* Ensure valid key is sent from user */
+	if (key->kv_logical_addr.kv_magic !=
+            handle->ks_list_descr.td_link_magic)
+			return NULL;
+
+	/*
+         * Magic check success. Proceed to find the correct <key, value>
+	 * pair in the node
+	 */
+
+	m0_be_tlist_for(&handle->ks_list_descr, &handle->ks_tlist, scan) {
+		if (strcmp(scan->kvs_key_hold.kv_key, key->kv_key) == 0) {
+                        ret_buf = &scan->kvs_val_reg->br_buf;
+                        break;
+		}
+	}m0_be_tlist_endfor;
+
+	return ret_buf;
+}
+
+struct m0_be_reg *m0_ks_delete(struct m0_kv_store  *handle,
+                               struct m0_kv_key    *key,
+                               struct m0_be_credit *cred)
+{
+        int                    ret_val;
+	struct m0_kv_store_obj *scan;
+	struct m0_kv_store_obj *target  = NULL;
+        struct m0_be_reg       *ret_reg = NULL;
+        struct m0_be_buf       *prev_buf  = NULL;
+        struct m0_be_buf       *next_buf  = NULL;
+        struct m0_be_reg       *prev_reg  = NULL;
+        struct m0_be_reg       *next_reg  = NULL;
+        struct m0_be_list_link *link_prev = NULL;
+        struct m0_be_list_link *link_next = NULL;
+
+	m0_be_tlist_for(&handle->ks_list_descr, &handle->ks_tlist, scan) {
+		if (strcmp(scan->kvs_key_hold.kv_key, key->kv_key) == 0)
+				target = scan;
+	}m0_be_tlist_endfor;
+
+	if (target != NULL) {
+                /*
+                 * Add the previous and next pointers about to
+                 * be modified to the credit.
+                 */
+               ret_val = malloc_for_reg(&prev_reg, &next_reg, &prev_buf,
+                                        &next_buf);
+
+               if (ret_val == BE_KV_FAILURE || prev_reg == NULL ||
+                   next_reg == NULL)
+                        return NULL;
+         
+                __get_prev(&handle->ks_list_descr, scan, &link_prev);
+                __get_next(&handle->ks_list_descr, scan, &link_next);
+
+                __prep_prev_next_reg(handle, prev_buf, next_buf, prev_reg,
+                                     next_reg, link_prev, link_next);
+
+                m0_be_credit_add(cred, prev_reg);
+                m0_be_credit_add(cred, next_reg);
+
+                /* collect return values */
+                ret_reg = target->kvs_val_reg;
+                /* Now delete */
+		m0_be_tlink_del_fini(&handle->ks_list_descr, target);
+		return ret_reg;
+	}
+        return ret_reg;
+}
+
+static int __ks_alloc_memory_obj(struct m0_kv_store      *handle,
+                                 struct m0_kv_store_obj **new_obj,
+                                 struct m0_be_buf       **ret_buf,
+                                 struct m0_be_credit     *cred,
+                                 struct m0_be_tx         *tx)
+{
+        /* Be Domain Transaction */
+        struct m0_be_buf        *obj_buf;
+        struct m0_be_reg        *obj_reg;
+
+        obj_reg = (struct m0_be_reg *)malloc(sizeof(struct m0_be_reg));
+        obj_buf = (struct m0_be_buf *)malloc(sizeof(struct m0_be_buf));
+
+        if(obj_reg == NULL || obj_buf == NULL)
+                return BE_KV_FAILURE;
+
+        obj_reg->br_sm.sm_state = M0_BEREG_INIT;
+        m0_be_buf_init(obj_buf, NULL, sizeof(struct m0_kv_store_obj), 0, 0, 0);
+        m0_be_reg_init(obj_reg, NULL, (handle->ks_seg), obj_buf);
+        m0_be_credit_add(cred, obj_reg);
+
+        /* Initialise and start transaction */
+        m0_be_tx_init(tx, handle->ks_dom, 0);
+
+        m0_sm_group_lock(tx->bt_impl.sm_group);
+        m0_sm_timedwait(&tx->bt_sm,
+                        (1 << M0_BETX_PREPARING) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(tx->bt_impl.sm_group);
+
+        m0_be_tx_prep(tx, cred);
+
+        m0_sm_group_lock(tx->bt_impl.sm_group);
+        m0_sm_timedwait(&tx->bt_sm,
+                        (1 << M0_BETX_PREPARED) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(tx->bt_impl.sm_group);
+
+        m0_be_tx_start(tx);
+        
+        m0_sm_group_lock(tx->bt_impl.sm_group);
+        m0_sm_timedwait(&tx->bt_sm,
+                        (1 << M0_BETX_OPEN) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(tx->bt_impl.sm_group);
+
+
+
+        /* Allocate the memory to the object from @reg.br_buf */
+        *new_obj = (struct m0_kv_store_obj *)obj_reg->br_buf.b_addr;
+
+        /* Update return buf, used while m0_be_tlink_init */
+        *ret_buf  = &(obj_reg->br_buf);
+        if (*new_obj == NULL) {
+                return BE_KV_FAILURE;
+        }
+
+        return BE_KV_SUCCESS;
+}
+
+static int __obj_memory_alloc(struct m0_kv_store      *handle,
+                              struct m0_be_credit     *cred,
+                              struct m0_kv_store_obj **new,
+                              struct m0_kv_key        *key,
+                              struct m0_be_buf        *buf,
+                              struct m0_be_tx         *tx)
+{
+        int      ret_val;
+        uint64_t link_magic;
+        uint64_t seg_id;
+        uint64_t offset;
+
+        /* Allocate memory to the object in which the key will be stored */
+        ret_val = __ks_alloc_memory_obj(handle, new, &buf, cred, tx);
+	if (new == NULL || buf == NULL || ret_val == BE_KV_FAILURE)
+                return BE_KV_FAILURE;
+
+	link_magic = handle->ks_list_descr.td_link_magic;
+	seg_id	   = buf->logical_address.segid_offset.u_hi;
+	offset	   = buf->logical_address.segid_offset.u_lo;
+
+	/* prepare kv_key */
+	strcpy((*new)->kvs_key_hold.kv_key, key->kv_key);
+
+	/* update incoming key structure's @segid & @offset */
+	key->kv_logical_addr.kv_magic  = link_magic;
+	key->kv_logical_addr.kv_segid  = seg_id;
+	key->kv_logical_addr.kv_offset = offset;
+
+	/* initialise the tlink linkage */
+	m0_be_tlink_init(&handle->ks_list_descr, buf->logical_address);
+
+        return BE_KV_SUCCESS;
+}
+
+static int __add_at_tail_to_tlist(struct m0_kv_store     *handle,
+                                  struct m0_kv_store_obj *new,
+                                  struct m0_be_credit    *cred,
+                                  struct m0_kv_key       *key,
+                                  struct m0_be_buf       *buf,
+                                  struct m0_be_tx        *tx)
+{
+        int                        ret_val;
+        struct m0_be_buf          *prev_buf  = NULL;
+        struct m0_be_reg          *prev_reg  = NULL;
+        struct m0_be_reg          *temp_reg  = NULL;
+        struct m0_be_list_link    *link_prev = NULL;
+        struct m0_kv_store_obj    *obj_t     = NULL;
+
+        /* Add current tail to credit */
+        prev_buf = (struct m0_be_buf *)malloc(sizeof(struct m0_be_buf));
+        if (prev_buf == NULL)
+                return BE_KV_FAILURE;
+
+        prev_reg = (struct m0_be_reg *)malloc(sizeof(struct m0_be_reg));
+        if (prev_reg == NULL) {
+                free(prev_buf);
+                return BE_KV_FAILURE;
+        }
+
+        obj_t = (struct m0_kv_store_obj *)
+                 m0_be_tlist_tail(&handle->ks_list_descr, &handle->ks_tlist);
+
+        link_prev = obj_t->kvs_linkage.t_link.ll_prev.virtual_address;
+
+        prev_reg->br_sm.sm_state = M0_BEREG_DONE;
+        m0_be_buf_init(prev_buf, NULL, sizeof(struct m0_be_list_link),
+                       0, 0, 0);
+
+        m0_be_reg_init(prev_reg, NULL, handle->ks_seg, prev_buf);
+        prev_reg->br_buf.b_addr = (void *)link_prev;
+
+        m0_be_credit_add(cred, prev_reg);
+
+        /* Now allocate memory to the object and add at tail */
+        ret_val          = __obj_memory_alloc(handle, cred, &new, key,
+                                              buf, tx);
+        temp_reg         = (struct m0_be_reg *)
+                            m0_be_reg_tlist_head(&(cred->bc_tl));
+        new->kvs_val_reg = temp_reg;
+        
+        if (ret_val == BE_KV_SUCCESS) {
+                m0_be_tlist_add_tail(&handle->ks_list_descr,
+                                     &handle->ks_tlist, new);
+                }
+        return ret_val;
+}
+
+
+int m0_ks_insert(struct m0_kv_store  *handle, struct m0_kv_key *key,
+                 struct m0_be_credit *cred, struct m0_be_tx    *tx)
+{
+	struct m0_be_buf 		*buf       = NULL;
+        struct m0_be_buf                *prev_buf  = NULL;
+        struct m0_be_buf                *next_buf  = NULL;
+        struct m0_be_reg                *prev_reg  = NULL;
+        struct m0_be_reg                *next_reg  = NULL;
+        struct m0_be_reg                *reg_t     = NULL; /* temporary use*/
+        struct m0_be_list_link          *link_prev = NULL;
+        struct m0_be_list_link          *link_next = NULL;
+	struct m0_kv_store_obj 		*new       = NULL;
+        struct m0_be_tl_descr           *desc_t    = NULL; /* temporary use*/
+        struct m0_kv_store_obj 		*scan;
+	struct m0_be_list_link 		*head;
+        int                              ret_val;
+
+	head = (void *)&handle->ks_tlist.t_head;
+
+        /* Check for duplicate insertion */
+        m0_be_tlist_for(&handle->ks_list_descr, &handle->ks_tlist, scan) {
+	        if (strcmp(key->kv_key,
+                           scan->kvs_key_hold.kv_key) == 0) {
+                		return BE_KV_FAILURE;
+	        }
+        }m0_be_tlist_endfor;
+
+	if ((head->ll_next.virtual_address == (void *)head) &&
+	    (head->ll_prev.virtual_address == (void *)head)) {
+
+                /* Check if list empty, if yes then add as head */
+                ret_val           = __obj_memory_alloc(handle, cred, &new, key,
+                                                       buf, tx);
+                new->kvs_val_reg  = (struct m0_be_reg *)
+                                     m0_be_reg_tlist_head(&(cred->bc_tl));
+
+               	if(ret_val == BE_KV_SUCCESS) {
+                        m0_be_tlist_add(&handle->ks_list_descr,
+                                        &handle->ks_tlist, new);
+                }
+
+	} else {
+                /* Else, find the appropriate position for the obj and insert */
+		m0_be_tlist_for(&handle->ks_list_descr, &handle->ks_tlist, scan)
+                {
+			if (strcmp(key->kv_key,
+                            scan->kvs_key_hold.kv_key) < 0) {
+                                /*
+                                 * Add the previous and next pointers about to
+                                 * be modified to the credit.
+                                 */
+                                ret_val = malloc_for_reg(&prev_reg, &next_reg,
+                                                         &prev_buf, &next_buf);
+                                if (ret_val == BE_KV_FAILURE)
+                                        return BE_KV_FAILURE;
+
+                                __get_prev(&handle->ks_list_descr, scan,
+                                           &link_prev);
+                                __get_next(&handle->ks_list_descr, scan,
+                                           &link_next);
+
+                                __prep_prev_next_reg(handle, prev_buf, next_buf,
+                                                     prev_reg, next_reg,
+                                                     link_prev, link_next);
+
+                                m0_be_credit_add(cred, prev_reg);
+                                m0_be_credit_add(cred, next_reg);
+
+                                /*
+                                 * Now allocate memory to the object to be
+                                 * stored in the list
+                                 */
+                                ret_val = __obj_memory_alloc(handle, cred, &new,
+                                                             key, buf, tx);
+                                reg_t   = (struct m0_be_reg *)
+                                           m0_be_reg_tlist_head(&(cred->bc_tl)
+                                                               );
+                                new->kvs_val_reg = reg_t;
+
+               	        	if(ret_val == BE_KV_SUCCESS) {
+                                        desc_t = &handle->ks_list_descr;
+                                        m0_be_tlist_add_before(desc_t, scan,
+                                                               new);
+                                }
+
+				return ret_val;
+		        }
+	        }m0_be_tlist_endfor;
+
+		/* If key is largest in the list, add at tail */
+                /* First capture the original tail to add in credit */
+                ret_val = __add_at_tail_to_tlist(handle, new, cred, key, buf,
+                                                 tx);
+	}
+	return ret_val;
+}
+
+void m0_be_ks_obj_fini(struct m0_be_tx *tx)
+{
+        m0_be_tx_done(tx);
+        m0_sm_group_lock(tx->bt_impl.sm_group);
+        m0_sm_timedwait(&tx->bt_sm,
+                        (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(tx->bt_impl.sm_group);
+
+
+        m0_be_tx_fini(tx);
+        rvm_truncate();
+}
+
+/* @} end of be_kv_store group */
+
+/*
+ * Local variables:
+ * c-indentation-style: "K&R"
+ * c-basic-offset: 8
+ * tab-width: 8
+ * fill-column: 80
+ * scroll-step: 1
+ * End:
+ */
diff --git a/be/lib/be_kv_store.h b/be/lib/be_kv_store.h
new file mode 100644
index 0000000..966f839
--- /dev/null
+++ b/be/lib/be_kv_store.h
@@ -0,0 +1,188 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: 	   Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original creation date: 12/06/2012
+ */
+#pragma once
+#ifndef __MERO_BE_LIB_BE_KV_STORE_H__
+#define __MERO_BE_LIB_BE_KV_STORE_H__
+
+#include "be/lib/be_tlist.h"
+#include "be/lib/be_buf.h"
+#include "be/lib/be_types.h"
+#include "be/be.h"
+
+#define BE_KV_FAILURE     -1
+#define BE_KV_SUCCESS      0
+#define BE_KV_INVALID_REQ  1
+#define MAX_KEY_SIZE  	   256
+/**
+   @defgroup be_kv_store Key Value Store
+ */
+
+/*
+ *	Structure to hold logical address for object that stores key
+ */
+struct m0_kv_key_ref {
+	/* segment id of the key's object */
+	uint64_t	kv_segid;
+	/* offset within the segment */
+	uint64_t	kv_offset;
+	/* magic value, set to the linkage magic value */
+	uint64_t	kv_magic;
+};
+
+/*
+ *	Structure to hold the key
+ */
+struct m0_kv_key {
+	/* actual key */
+	char 			kv_key[MAX_KEY_SIZE];
+	/* logical_address details of key's object */
+	struct m0_kv_key_ref	kv_logical_addr;
+};
+
+/**
+ *	Structure to hold the actual <key, value> pair in an object
+ */
+struct m0_kv_store_obj {
+	struct m0_kv_key   	kvs_key_hold;
+	struct m0_be_reg       *kvs_val_reg;
+	struct m0_be_tlink 	kvs_linkage;
+        uint64_t 	   	kvs_ref_magic;
+};
+
+/**
+ *	Structure to hold the handle to current tlist and its descriptor
+ */
+struct m0_kv_store {
+	/* List descriptor for the tlist */
+	struct m0_be_tl_descr   ks_list_descr;
+	/* The tlist itself */
+	struct m0_be_tl	        ks_tlist;
+        /* Segment pointer */
+        struct m0_be_seg        *ks_seg;
+        /* Domain pointer */
+        struct m0_be_domain     *ks_dom;
+
+        struct m0_stob          *ks_ns_stob;
+        struct m0_stob          *ks_stob;
+        struct m0_stob          *ks_log_stob;
+};
+
+/**
+ * Initialises the domain and segment to be used in the tlist.
+ *
+ * @param dom           :       be_domain to be initialised
+ * @param seg           :       segment in the domain to be initialised
+ * @param ns_stob       :       underlying storage object(given to seg in @dom)
+ * @param stob          :       storage object to create the segment
+ * @param log_stob      :       Stob which is used as log device for entire back
+ *                              -end domain.
+ */
+int m0_ks_init_domain_and_segment(struct m0_be_domain *dom,
+                                   struct m0_be_seg    *seg,
+                                   struct m0_stob      *ns_stob,
+                                   struct m0_stob      *stob,
+                                   struct m0_stob      *log_stob);
+
+/*
+ * Create and return the handle the user for the key_value_store
+ *
+ * @param handle	:	pointer to the handle, out parameter
+ * @param list_name	:	name to be given the @tlist in @list_descr
+ * link_magic		:	magic value to be assigned to the linkage in
+  				the tlist
+ * head_magic		:	magic value to be assigned to the head in the
+  				tlist
+ */
+void  m0_ks_init(struct m0_kv_store *handle, char *list_name,
+		 uint64_t link_magic, uint64_t head_magic);
+
+/**
+ * Updates the domain, segment and values in the @handle
+ *
+ * @param handle        :       handle to be updated
+ * @param dom           :       be_domain pointer
+ * @param seg           :       segment pointer to be assigned
+ * @param ns_stob       :       underlying storage object(given to seg in @dom)
+ * @param stob          :       storage object in @seg to be assigned
+ * @param log_stob      :       log device storage object to be assigned
+ */
+void m0_ks_update_handle(struct m0_kv_store  *handle,
+                         struct m0_be_domain *dom,
+                         struct m0_be_seg    *seg,
+                         struct m0_stob      *ns_stob,
+                         struct m0_stob      *stob,
+                         struct m0_stob      *log_stob);
+
+/*
+ * Insert a key value pair in the tlist contained in @handle.
+ * Returns BE_KV_FAILURE or BE_KV_SUCCESS
+ *
+ * @param handle	:	handle containing the tlist in which the
+ 				<key, value> pair has to be stored
+ * @param key		:	key to be inserted into the list
+ * @param ref_value	:	value associated with the key
+ */
+int  m0_ks_insert(struct m0_kv_store  *handle, struct m0_kv_key *key,
+		  struct m0_be_credit *cred,   struct m0_be_tx  *tx);
+
+/*
+ * Find value with the @key in the tlist contained in @handle.
+ * Returns the value associated if the key is found, else NULL
+ *
+ * @param handle	:	handle containing the tlist in which the
+ 				<key, value> pair has to be stored
+ * @param key		:	key to be searched into the list
+ */
+struct m0_be_buf  *m0_ks_find(struct m0_kv_store *handle,
+                              struct m0_kv_key   *key);
+
+/*
+ * Delete the object with the @key in the tlist contained in @handle.
+ * Returns NULL in case of failures.
+ * Returns the region associated with the key. User may decide the fate of
+ * return value
+ *
+ * @param handle	:	handle containing the tlist in which the
+ 				<key, value> pair has to be stored
+ * @param key		:	key to be removed from the list
+ */
+struct m0_be_reg  *m0_ks_delete(struct m0_kv_store *handle,
+                                struct m0_kv_key *key,
+                                struct m0_be_credit *cred);
+
+/*
+ * Fini and end the transaction.
+ */
+void m0_be_ks_obj_fini(struct m0_be_tx *tx);
+
+/** @} end of be_kv_store group */
+
+/* __MERO_BE_LIB_BE_KV_STORE_H__ */
+#endif
+
+/*
+ * Local variables:
+ * c-indentation-style: "K&R"
+ * c-basic-offset: 8
+ * tab-width: 8
+ * fill-column: 80
+ * scroll-step: 1
+ * End:
+ */
diff --git a/be/lib/ut/Makefile b/be/lib/ut/Makefile
index 42bcd1c..f607b7f 100644
--- a/be/lib/ut/Makefile
+++ b/be/lib/ut/Makefile
@@ -2,7 +2,9 @@
 
 all:
 	gcc .libs/ut_libmero_ut_la-be_tlist.o  ../../../mero/.libs/libmero.a  -o ./be_tlist_ut  -lpthread  -ldb  -lrt -laio -lrvm -lrds -lseg -L../../../../rvm/rvm/.libs -L../../../../rvm/rds/.libs -L../../../../rvm/seg/.libs
+	gcc .libs/ut_libmero_ut_la-be_kv_store.o  ../../../mero/.libs/libmero.a  -o ./be_kv_store_ut  -lpthread  -ldb  -lrt -laio -lrvm -lrds -lseg -L../../../../rvm/rvm/.libs -L../../../../rvm/rds/.libs -L../../../../rvm/seg/.libs
 	rm -rf /tmp/log_file
 clean:
-	rm -rf ./be_tlist_ut
+	rm -f ./be_tlist_ut
+	rm -f ./be_kv_store_ut
 	rm -f  /tmp/log_file
diff --git a/be/lib/ut/Makefile.sub b/be/lib/ut/Makefile.sub
index ed8358f..96ba583 100644
--- a/be/lib/ut/Makefile.sub
+++ b/be/lib/ut/Makefile.sub
@@ -1 +1,2 @@
-ut_libmero_ut_la_SOURCES += be/lib/ut/be_tlist.c
+ut_libmero_ut_la_SOURCES += be/lib/ut/be_tlist.c	\
+			    be/lib/ut/be_kv_store.c
diff --git a/be/lib/ut/be_kv_store.c b/be/lib/ut/be_kv_store.c
new file mode 100644
index 0000000..e1e3627
--- /dev/null
+++ b/be/lib/ut/be_kv_store.c
@@ -0,0 +1,138 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: 	   Zishan Shaikh <zishan_shaikh@xyratex.com>
+ * Original creation date: 12/18/2012
+ */
+
+#include "be/lib/be_kv_store.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define link_magic 0xab5ce55edba1b0a0
+#define head_magic 0xba1dba11adba0bab
+
+struct m0_be_domain     dom;
+struct m0_be_seg        seg;
+struct m0_stob          ns_stob;
+struct m0_stob          stob;
+struct m0_stob          log_stob;
+
+int main() {
+        struct m0_be_credit      cred;
+	struct m0_kv_store       handle;
+	struct m0_kv_key         key1;
+        struct m0_kv_key         key2;
+        struct m0_kv_key         key3;
+        struct m0_be_reg         obj1_reg;
+        struct m0_be_reg         obj2_reg;
+        struct m0_be_reg         obj3_reg;
+        struct m0_be_buf        obj1_buf;
+        struct m0_be_buf        obj2_buf;
+        struct m0_be_buf        obj3_buf;
+        struct m0_be_buf        *ret1_buf = NULL;
+        struct m0_be_buf        *ret2_buf = NULL;
+        struct m0_be_buf        *ret3_buf = NULL;
+        struct m0_be_tx         *tx1      = NULL;
+        struct m0_be_tx         *tx2      = NULL;
+        struct m0_be_tx         *tx3      = NULL;
+
+	int                     status = -2;
+        char                    list_name[]="list";
+	char                    obj1_name[] = "abc";
+        char                    obj2_name[] = "def";
+        char                    obj3_name[] = "ghi";
+
+        m0_ks_init_domain_and_segment(&dom, &seg, &ns_stob, &stob, &log_stob);
+        m0_ks_init(&handle,  list_name, 0xab5ce55edba1b0a0, 0xba1dba11adba0bab);
+        m0_ks_update_handle(&handle, &dom, &seg, &ns_stob, &stob, &log_stob);
+
+        /* insert "name" */
+        obj1_reg.br_sm.sm_state = M0_BEREG_INIT;
+        m0_be_credit_init(&cred);
+        m0_be_buf_init(&obj1_buf, NULL, sizeof(struct m0_kv_store_obj), 0, 0, 0);
+        m0_be_reg_init(&obj1_reg, NULL, handle.ks_seg, &obj1_buf);
+        m0_be_credit_add(&cred, &obj1_reg);
+
+        tx1 = (struct m0_be_tx *)malloc(sizeof(struct m0_be_tx));
+
+	strcpy(key1.kv_key, obj1_name);
+	status = m0_ks_insert(&handle, &key1, &cred, tx1);
+	if (status == BE_KV_SUCCESS)
+		printf("inserted obj1_name\n");
+
+        m0_be_ks_obj_fini(tx1);
+        m0_be_credit_fini(&cred);
+
+        /* insert midname */
+        obj2_reg.br_sm.sm_state = M0_BEREG_INIT;
+        m0_be_credit_init(&cred);
+        m0_be_buf_init(&obj2_buf, NULL, sizeof(struct m0_kv_store_obj), 0, 0, 0);
+        m0_be_reg_init(&obj2_reg, NULL, handle.ks_seg, &obj2_buf);
+        m0_be_credit_add(&cred, &obj2_reg);
+
+        tx2 = (struct m0_be_tx *)malloc(sizeof(struct m0_be_tx));
+
+	strcpy(key2.kv_key, obj2_name);
+	status = m0_ks_insert(&handle, &key2, &cred, tx2);
+	if (status == BE_KV_SUCCESS)
+		printf("inserted obj2_name\n");
+
+        m0_be_ks_obj_fini(tx2);
+        m0_be_credit_fini(&cred);
+
+        /* insert surname */
+        obj3_reg.br_sm.sm_state = M0_BEREG_INIT;
+        m0_be_credit_init(&cred);
+        m0_be_buf_init(&obj3_buf, NULL, sizeof(struct m0_kv_store_obj), 0, 0, 0);
+        m0_be_reg_init(&obj3_reg, NULL, handle.ks_seg, &obj3_buf);
+        m0_be_credit_add(&cred, &obj3_reg);
+
+        tx3 = (struct m0_be_tx *)malloc(sizeof(struct m0_be_tx));
+
+	strcpy(key3.kv_key, obj3_name);
+	status = m0_ks_insert(&handle, &key3, &cred, tx3);
+	if (status == BE_KV_SUCCESS)
+		printf("inserted obj3_name\n");
+
+        m0_be_ks_obj_fini(tx3);
+        m0_be_credit_fini(&cred);
+
+        ret1_buf = m0_ks_find(&handle, &key1);
+        ret2_buf = m0_ks_find(&handle, &key2);
+        ret3_buf = m0_ks_find(&handle, &key3);
+
+        if (ret1_buf != NULL)
+                printf("Found obj1\n");
+
+        if (ret2_buf != NULL)
+                printf("Found obj2\n");
+
+        if (ret3_buf != NULL)
+                printf("Found obj3\n");
+
+        return 0;
+}
+/*
+ * Local variables:
+ * c-indentation-style: "K&R"
+ * c-basic-offset: 8
+ * tab-width: 8
+ * fill-column: 80
+ * scroll-step: 1
+ * End:
+ */
-- 
1.8.3.2

