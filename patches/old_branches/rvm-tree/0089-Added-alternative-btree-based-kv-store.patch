From f558641bf21b77a9cc67b67ffba32ab24e3e26c2 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Wed, 24 Apr 2013 16:56:48 +0300
Subject: [PATCH 89/94] Added alternative btree-based kv-store.

---
 be/Makefile.sub |   2 +
 be/kvs.c        | 291 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 be/kvs.h        |  95 ++++++++++++++++++
 be/tree.c       |  30 +++---
 be/tree.h       |  28 +++---
 be/ut/be.c      |  24 ++---
 6 files changed, 433 insertions(+), 37 deletions(-)
 create mode 100644 be/kvs.c
 create mode 100644 be/kvs.h

diff --git a/be/Makefile.sub b/be/Makefile.sub
index 05dd845..3922af9 100644
--- a/be/Makefile.sub
+++ b/be/Makefile.sub
@@ -4,6 +4,7 @@ nobase_mero_include_HEADERS +=  be/be.h
 				be/helper.h		\
 				be/handle_store.h	\
 				be/kv_store.h           \
+				be/kvs.h		\
 				be/tree.h		\
 				be/pool.h
 
@@ -17,6 +18,7 @@ mero_libmero_la_SOURCES	    +=	be/be_init.c		\
 				be/helper.c		\
 				be/handle_store.c	\
 				be/kv_store.c		\
+				be/kvs.c		\
 				be/handler.c            \
 				be/tree.c		\
 				be/pool.c
diff --git a/be/kvs.c b/be/kvs.c
new file mode 100644
index 0000000..9fb293a
--- /dev/null
+++ b/be/kvs.c
@@ -0,0 +1,291 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original creation date: 17/04/2013
+ */
+#undef M0_TRACE_SUBSYSTEM
+#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_BE
+#include "lib/trace.h"
+#include "lib/errno.h"
+#include "lib/memory.h"
+#include "be/domain.h"
+#include "be/tree.h"
+#include "be/pool.h"
+#include "be/seg.h"
+#include "be/reg.h"
+#include "be/kvs.h"
+#include "be/be.h"
+#include "be/tx.h"
+
+/* XXX: name of the segment */
+#define BE_KV_SEG_NAME "kv_store"
+enum { TREE_FAN_OUT = 5 };
+
+/* XXX: naive pool */
+static struct m0_be_tx_pool pool;
+
+static int sm_wait(struct m0_sm_group *group, struct m0_sm *sm, uint64_t states,
+		   m0_time_t deadline);
+
+/* -------------------------------------------------------------------------
+ * Tx pool ops
+ * ----------------------------------------------------------------------- */
+static void* p_alloc(struct btree_tx_impl *tx, size_t size)
+{
+	pool.tp_tx = tx;
+
+	return m0_be_tx_pool_alloc(&pool, size);
+}
+
+static int p_free(struct btree_tx_impl *tx, void *p, size_t size)
+{
+	pool.tp_tx = tx;
+	return m0_be_tx_pool_free(&pool, p, size);
+}
+
+static int p_update(struct btree_tx_impl *tx, void *p, size_t size)
+{
+	pool.tp_tx = tx;
+	return m0_be_tx_pool_update(&pool, p, size);
+}
+
+static const struct btree_tx_ops tx_ops = {
+	.update    = p_update,
+	.alloc     = p_alloc,
+	.free      = p_free
+};
+
+/* -------------------------------------------------------------------------
+ * Tx-Helpers
+ * ----------------------------------------------------------------------- */
+static int be_tx_commit(struct m0_be_tx *tx, bool prepare)
+{
+	struct m0_sm_group *sm_group;
+
+	if (prepare)
+		m0_be_tx_prep(tx);
+
+        m0_be_tx_start(tx);
+        m0_be_tx_done(tx);
+
+	sm_group = m0_be_domain_sm_group(tx->bt_dom);
+	sm_wait(sm_group, &tx->bt_sm, M0_BITS(M0_BETX_DONE, M0_BETX_FAILED),
+		M0_TIME_NEVER);
+
+	return m0_be_tx_state(tx) == M0_BETX_DONE ? 0 : -1;
+}
+
+static struct m0_be_tx *be_tx_init(struct m0_be_domain *dom)
+{
+	struct m0_be_tx *tx;
+
+        M0_ALLOC_PTR(tx);
+	if (tx == NULL)
+		return NULL;
+
+        m0_be_tx_init(tx, dom, 0);
+	if (m0_be_tx_state(tx) == M0_BETX_FAILED) {
+		m0_free(tx);
+		return NULL;
+	}
+
+	return tx;
+}
+
+static void be_tx_fini(struct m0_be_tx *tx)
+{
+	m0_be_tx_fini(tx);
+        m0_free(tx);
+}
+
+/* -------------------------------------------------------------------------
+ * Helpers
+ * ----------------------------------------------------------------------- */
+static int sm_wait(struct m0_sm_group *group, struct m0_sm *sm, uint64_t states,
+		   m0_time_t deadline)
+{
+        m0_sm_group_lock(group);
+        m0_sm_timedwait(sm, states, deadline);
+        m0_sm_group_unlock(group);
+
+	return sm->sm_rc;
+}
+
+static int kvs_seg_create(struct m0_be_kvs *ks)
+{
+	struct m0_sm_group *sm_group;
+	int result;
+
+        result = m0_be_domain_lookup(ks->bk_dom, BE_KV_SEG_NAME, &ks->bk_seg);
+	if (result)
+		return -EEXIST;
+
+	M0_ALLOC_PTR(ks->bk_seg);
+	if (ks->bk_seg == NULL)
+		return -ENOMEM;
+
+        sm_group = m0_be_domain_sm_group(ks->bk_dom);
+	m0_be_seg_init(ks->bk_seg, ks->bk_dom, sm_group, 0);
+	m0_be_seg_create(ks->bk_seg, NULL, BE_KV_SEG_NAME, NULL);
+
+	sm_wait(sm_group, &ks->bk_seg->bs_sm,
+		M0_BITS(M0_BESEG_ACTIVE, M0_BESEG_FAILED), M0_TIME_NEVER);
+
+        if (m0_be_seg_state(ks->bk_seg) == M0_BESEG_FAILED)
+		return -1;
+
+	return 0;
+}
+
+static int kvs_seg_restore(struct m0_be_kvs *ks)
+{
+	struct m0_sm_group *sm_group;
+
+	M0_ALLOC_PTR(ks->bk_seg);
+	if (ks->bk_seg == NULL)
+		return -ENOMEM;
+
+        sm_group = m0_be_domain_sm_group(ks->bk_dom);
+        m0_be_domain_seg_restore(ks->bk_dom, BE_KV_SEG_NAME, ks->bk_seg);
+
+	sm_wait(sm_group, &ks->bk_seg->bs_sm,
+		M0_BITS(M0_BESEG_ACTIVE, M0_BESEG_FAILED), M0_TIME_NEVER);
+
+        if (m0_be_seg_state(ks->bk_seg) == M0_BESEG_FAILED)
+                return -1;
+
+	return 0;
+}
+
+struct btree *handle_restore(struct m0_be_seg *seg, uint64_t index,
+			     const struct btree_ops *ops)
+{
+	struct btree     **tree;
+
+	tree = (struct btree**) m0_be_static_reg_get_handle_addr(seg, index);
+	if (tree == NULL)
+		return NULL;
+
+	(*tree)->tops = ops;
+	(*tree)->ops = &tx_ops;
+
+	return *tree;
+}
+
+struct btree *handle_create(struct m0_be_kvs *ks, const struct btree_ops *ops)
+{
+	struct m0_be_tx *tx;
+	struct btree    *tree;
+	int rc;
+
+	tx = be_tx_init(ks->bk_dom);
+	if (tx == NULL)
+		return NULL;
+
+	tree = btree_create(TREE_FAN_OUT, tx, &tx_ops, ops);
+
+	if (tree == NULL)
+		return NULL;
+
+	rc = be_tx_commit(tx, true);
+	be_tx_fini(tx);
+
+	return rc == 0 ? tree : NULL;
+}
+
+/* -------------------------------------------------------------------------
+ * Interfaces implementation
+ * ----------------------------------------------------------------------- */
+M0_INTERNAL int m0_be_kvs_init(struct m0_be_kvs		*ks,
+			       struct m0_be_domain	*dom,
+			       const struct btree_ops	*ops,
+			       enum m0_be_kvs_mode	 mode,
+			       uint64_t			 index)
+{
+	int rc;
+
+	*ks = (struct m0_be_kvs) {
+		.bk_dom  = dom,
+		.bk_mode = mode
+	};
+
+	rc = mode == M0_BE_KVS_RESTORE
+		? kvs_seg_restore(ks)
+		: kvs_seg_create(ks);
+
+	if (rc != 0)
+		goto err;
+
+	ks->bk_tree = mode == M0_BE_KVS_RESTORE
+		? handle_restore(ks->bk_seg, index, ops)
+		: handle_create(ks, ops);
+
+	if (ks->bk_tree == NULL) {
+		rc = -ENOMEM;
+		goto err;
+	}
+
+	pool.tp_seg = ks->bk_seg;
+
+	return 0;
+err:
+	m0_be_kvs_fini(ks);
+	return rc;
+}
+
+M0_INTERNAL void m0_be_kvs_fini(struct m0_be_kvs *ks)
+{
+	if (ks->bk_mode == M0_BE_KVS_CREATE)
+		rvm_truncate();
+
+        m0_be_seg_done(ks->bk_seg);
+}
+
+M0_INTERNAL int m0_be_kvs_update(struct m0_be_kvs        *ks,
+				 struct m0_be_tx         *tx,
+				 const struct bt_key_val *kv)
+{
+	return -1;
+}
+
+M0_INTERNAL int m0_be_kvs_delete(struct m0_be_kvs *ks,
+				 struct m0_be_tx  *tx,
+				 const void       *key)
+{
+	return -1;
+}
+
+M0_INTERNAL int m0_be_kvs_insert(struct m0_be_kvs        *ks,
+				 struct m0_be_tx         *tx,
+				 const struct bt_key_val *kv)
+{
+	return -1;
+}
+
+M0_INTERNAL void *m0_be_kvs_lookup(struct m0_be_kvs *ks,
+				   const void       *key)
+{
+	return NULL;
+}
+
+M0_INTERNAL struct bt_key_val *m0_be_kvs_pair_setup(const struct m0_be_kvs *ks,
+						    struct m0_be_tx        *tx,
+						    void *key, size_t key_size,
+						    void *val, size_t val_size)
+{
+	return NULL;
+}
diff --git a/be/kvs.h b/be/kvs.h
new file mode 100644
index 0000000..7efc57f
--- /dev/null
+++ b/be/kvs.h
@@ -0,0 +1,95 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Anatoliy Bilenko <Anatoliy_Bilenko@xyratex.com>
+ * Original creation date: 17/04/2013
+ */
+#pragma once
+#ifndef __MERO_BE_KVS_H__
+#define __MERO_BE_KVS_H__
+#include "lib/types.h"
+
+struct m0_be_domain;
+struct m0_be_seg;
+struct m0_be_tx;
+struct btree_ops;
+struct bt_key_val;
+struct btree;
+
+/*  */
+enum m0_be_kvs_mode {
+	M0_BE_KVS_CREATE,
+	M0_BE_KVS_RESTORE
+};
+
+/*  */
+struct m0_be_kvs {
+	/*  */
+	struct m0_be_domain    *bk_dom;
+	/*  */
+	struct m0_be_seg       *bk_seg;
+	/*  */
+	struct btree	       *bk_tree;
+	/*  */
+	enum m0_be_kvs_mode     bk_mode;
+};
+
+/*  */
+M0_INTERNAL int m0_be_kvs_init(struct m0_be_kvs		*ks,
+			       struct m0_be_domain	*dom,
+			       const struct btree_ops	*ops,
+			       enum m0_be_kvs_mode	 mode,
+			       uint64_t			 index);
+/*  */
+M0_INTERNAL void m0_be_kvs_fini(struct m0_be_kvs *ks);
+
+/*  */
+M0_INTERNAL int m0_be_kvs_update(struct m0_be_kvs        *ks,
+				 struct m0_be_tx         *tx,
+				 const struct bt_key_val *kv);
+
+/*  */
+M0_INTERNAL int m0_be_kvs_delete(struct m0_be_kvs *ks,
+				 struct m0_be_tx  *tx,
+				 const void       *key);
+
+/*  */
+M0_INTERNAL int m0_be_kvs_insert(struct m0_be_kvs        *ks,
+				 struct m0_be_tx         *tx,
+				 const struct bt_key_val *kv);
+
+/*  */
+M0_INTERNAL void *m0_be_kvs_lookup(struct m0_be_kvs *ks,
+				   const void       *key);
+
+
+/*  */
+M0_INTERNAL struct bt_key_val *m0_be_kvs_pair_setup(const struct m0_be_kvs *ks,
+						    struct m0_be_tx        *tx,
+						    void *key, size_t key_size,
+						    void *val, size_t val_size);
+
+#endif /* __MERO_BE_KVS_H__ */
+
+/*
+ * Local variables:
+ * c-indentation-style: "K&R"
+ * c-basic-offset: 8
+ * tab-width: 8
+ * fill-column: 80
+ * scroll-step: 1
+ * End:
+ */
diff --git a/be/tree.c b/be/tree.c
index eb5344c..9430ff6 100644
--- a/be/tree.c
+++ b/be/tree.c
@@ -16,9 +16,9 @@
 #define CHILDREN_SIZE(btree)  (2*btree->order * sizeof(struct bt_node *))
 #define PRINT(...) M0_LOG(M0_DEBUG, __VA_ARGS__)
 
-#define KEY_LT(key0, key1) (btree->compare(key0, key1)  <  0)
-#define KEY_GT(key0, key1) (btree->compare(key0, key1)  >  0)
-#define KEY_EQ(key0, key1) (btree->compare(key0, key1) ==  0)
+#define KEY_LT(key0, key1) (btree->tops->compare(key0, key1)  <  0)
+#define KEY_GT(key0, key1) (btree->tops->compare(key0, key1)  >  0)
+#define KEY_EQ(key0, key1) (btree->tops->compare(key0, key1) ==  0)
 
 enum position_t { left = -1, right = 1 };
 
@@ -94,9 +94,10 @@ static int node_update(struct bt_node	    *node,
  *	@param order The order of the B-tree
  *	@return The an empty B-tree
  */
-M0_INTERNAL struct btree *btree_create(unsigned int		  order,
-				       struct btree_tx_impl	 *tx,
-				       const struct btree_tx_ops *ops)
+M0_INTERNAL struct btree *btree_create(unsigned int               order,
+				       struct btree_tx_impl      *tx,
+				       const struct btree_tx_ops *ops,
+				       const struct btree_ops    *tree_ops)
 {
 	struct btree *btree;
 	btree = MEM_ALLOC0(ops->alloc, tx, sizeof(struct btree));
@@ -104,6 +105,7 @@ M0_INTERNAL struct btree *btree_create(unsigned int		  order,
 
 	btree->order = order;
 	btree->ops = ops;
+	btree->tops = tree_ops;
 	btree->root = allocate_btree_node(btree, tx);
 	btree->root->leaf = true;
 	btree->root->nr_active = 0;
@@ -595,12 +597,12 @@ int delete_key_from_node(struct btree		 *btree,
 	}
 
 	if (key_val->key) {
-		MEM_FREE(tx, key_val->key, btree->key_size(key_val->key));
+		MEM_FREE(tx, key_val->key, btree->tops->key_size(key_val->key));
 		key_val->key = NULL;
 	}
 
 	if (key_val->val) {
-		MEM_FREE(tx, key_val->val, btree->data_size(key_val->val));
+		MEM_FREE(tx, key_val->val, btree->tops->data_size(key_val->val));
 		key_val->val = NULL;
 	}
 
@@ -956,14 +958,14 @@ static void copy_key_val(struct btree		 *btree,
 
 	M0_ENTRY();
 
-	keysize = btree->key_size(src->key);
+	keysize = btree->tops->key_size(src->key);
 	dst->key = (void *)MEM_ALLOC(tx, keysize);
 	M0_ASSERT(dst->key != NULL);	/* @todo: analyse return code */
 
 	bcopy(src->key, dst->key, keysize);
 
 	if (src->val) {
-		datasize = btree->data_size(src->val);
+		datasize = btree->tops->data_size(src->val);
 		dst->val = (void *)MEM_ALLOC(tx, datasize);
 		M0_ASSERT(dst->val != NULL);	/* @todo: analyse return code */
 		bcopy(src->val, dst->val, datasize);
@@ -1003,8 +1005,8 @@ M0_INTERNAL struct bt_key_val *btree_pair_setup(struct btree	     *btree,
 {
 	struct bt_key_val *kv;
 
-	M0_PRE(val_size == btree->data_size(val));
-	M0_PRE(key_size == btree->key_size(key));
+	M0_PRE(val_size == btree->tops->data_size(val));
+	M0_PRE(key_size == btree->tops->key_size(key));
 
 	/* XXX: ENOMEM has to be checked */
 
@@ -1053,8 +1055,8 @@ static void print_single_node(struct btree *btree, struct bt_node *node)
 		void *key = node->key_vals[i]->key;
 		void *val = node->key_vals[i]->val;
 
-		if (is_kv_string(key, btree->key_size(key)) &&
-		    is_kv_string(val, btree->data_size(val)))
+		if (is_kv_string(key, btree->tops->key_size(key)) &&
+		    is_kv_string(val, btree->tops->data_size(val)))
 			PRINT("key: %s, val: %s, level: %d",
 			      (char *)key, (char *)val, node->level);
 		else
diff --git a/be/tree.h b/be/tree.h
index 79b917a..433ab3f 100644
--- a/be/tree.h
+++ b/be/tree.h
@@ -8,6 +8,7 @@
 // struct btree_tx_impl;
 struct m0_be_tx;
 #define btree_tx_impl m0_be_tx
+
 // Operations set by the user.
 struct btree_tx_ops {
 	void* (*alloc)  (struct btree_tx_impl *tx, size_t size);
@@ -15,6 +16,14 @@ struct btree_tx_ops {
 	int   (*update) (struct btree_tx_impl *tx, void *p, size_t size);
 };
 
+// Operations set by the user.
+struct btree_ops {
+        unsigned int  (*key_size) (void *key);  // Return the key size
+        unsigned int  (*data_size)(void *data); // Return the data size
+	int           (*compare)  (void *key0,  // 1 if v0 > v1, -1 if v0 < v2,
+				   void *key1); // 0 if v0 == v2
+};
+
 struct bt_key_val {
         void *key;
         void *val;
@@ -34,19 +43,16 @@ struct bt_node {
 };
 
 struct btree {
-	unsigned int    order;			// B-Tree order
-	struct bt_node *root;			// Root of the B-Tree
-        unsigned int  (*key_size) (void *key);  // Return the key size
-        unsigned int  (*data_size)(void *data); // Return the data size
-	int           (*compare)  (void *key0,  // 1 if v0 > v1, -1 if v0 < v2,
-				   void *key1); // 0 if v0 == v2
-
-	const struct btree_tx_ops *ops;	        // Operations made on transactions
+	unsigned int    order;		 // B-Tree order
+	struct bt_node *root;		 // Root of the B-Tree
+	const struct btree_tx_ops *ops;	 // Operations made on transactions
+	const struct btree_ops    *tops;
 };
 
-M0_INTERNAL struct btree *btree_create(unsigned int order,
-				       struct btree_tx_impl *tx,
-				       const struct btree_tx_ops *ops);
+M0_INTERNAL struct btree *btree_create(unsigned int               order,
+				       struct btree_tx_impl      *tx,
+				       const struct btree_tx_ops *ops,
+				       const struct btree_ops    *tree_ops);
 
 M0_INTERNAL int btree_insert_key(struct btree *btree,
 				 struct btree_tx_impl *tx,
diff --git a/be/ut/be.c b/be/ut/be.c
index 6a8d79d..a692075 100644
--- a/be/ut/be.c
+++ b/be/ut/be.c
@@ -47,8 +47,8 @@
 #include "be/reg.h"
 #include "be/tx.h"
 
-#define RVM_CREATE 1
-#define RVM_LOADED_UPDATE 1
+#define RVM_CREATE 0
+#define RVM_LOADED_UPDATE 0
 
 static struct m0_be_seg         *seg;
 static struct m0_sm_group       *sm_group;
@@ -267,12 +267,18 @@ static int p_update (struct btree_tx_impl *tx, void *p, size_t size)
 	return m0_be_tx_pool_update(&pool, p, size);
 }
 
-static const struct btree_tx_ops tops = {
+static const struct btree_tx_ops ops = {
 	.update = p_update,
 	.alloc  = p_alloc,
 	.free   = p_free
 };
 
+static const struct btree_ops tops = {
+	.compare   = tree_cmp,
+	.key_size  = tree_key_size,
+	.data_size = tree_data_size
+};
+
 static void be_tx_commit(struct m0_be_tx *tx, bool prepare)
 {
 	if (prepare)
@@ -323,13 +329,9 @@ M0_UNUSED static void test_be_tree_create(void)
 	/*
 	 * Start manupulating tree here...
 	 */
-	tree = btree_create(TREE_FAN_OUT, tx, &tops);
+	tree = btree_create(TREE_FAN_OUT, tx, &ops, &tops);
 	M0_UT_ASSERT(tree != NULL);
 
-	tree->compare   = tree_cmp;
-	tree->key_size  = tree_key_size;
-	tree->data_size = tree_data_size;
-
 	for (i = 0; i < TREE_KV_NR; ++i) {
 		sprintf(kv, "%d", i);
 
@@ -413,10 +415,8 @@ M0_UNUSED static void test_be_tree_load(void)
 	 * To those who did forget to do the following a painfull debug session
 	 * is guaranteed... Restored segment contains rubbish at that place.
 	 */
-	(*tree)->compare   = tree_cmp;
-	(*tree)->key_size  = tree_key_size;
-	(*tree)->data_size = tree_data_size;
-	(*tree)->ops       = &tops;
+	(*tree)->ops  = &ops;
+	(*tree)->tops = &tops;
 
 	btree_log(tree);
 
-- 
1.8.3.2

