From 6e36802c7d4648a7b0c27f53fbb6acb6e45a35fb Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Mon, 4 Mar 2013 23:17:41 -0800
Subject: [PATCH 59/94] Modified kv_store UB, rvm_heap size is now 300MB

---
 be/seg.c            |  51 +++++++-----
 be/seg.h            |   4 +-
 be/ut/kv_store.c    |   2 +-
 be/ut/kv_store_ub.c | 221 ++++++++++++++++++++++------------------------------
 utils/ub_main.c     |   8 +-
 5 files changed, 132 insertions(+), 154 deletions(-)

diff --git a/be/seg.c b/be/seg.c
index 811ca04..a12701c 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -272,6 +272,33 @@ M0_INTERNAL void m0_be_seg_fail(struct m0_be_seg *seg)
         M0_LEAVE();
 }
 
+static int be_rvm_rds_zap_heap(char *file_path)
+{
+        char                     *start_Addr        = (char *)0xbebd000;
+        long                      rds_static_len    = 0;
+        long                      nlist             = RVM_NLIST;
+        long                      chunk_size        = RVM_CHUNK_SIZE;
+        unsigned long             dev_length        = RVM_SEGMENT_SIZE;
+        unsigned long             heap_length       = RVM_HEAP_SIZE;
+        int                       result;
+        int                       err;
+
+        /* @todo - need to handle rvm errors in callback. */
+        /* Create heap structure. */
+        rds_static_len    = RVM_ROUND_LENGTH_DOWN_TO_PAGE_SIZE(4096);
+
+        result = rds_zap_heap(file_path,
+                              RVM_LENGTH_TO_OFFSET(dev_length),
+                              start_Addr,
+                              rds_static_len,
+                              heap_length,
+                              nlist,
+                              chunk_size,
+                              &err);
+
+        return result;
+}
+
 /**
  * The function calls rvm api's to create and open segment.
  *
@@ -283,21 +310,15 @@ M0_INTERNAL void m0_be_seg_create_cb(void *cb_data)
         struct m0_stob_domain    *stob_dom;
         struct linux_stob        *lstob;
         struct linux_domain      *ldom;
-        char                     *start_Addr        = (char *)0xbebd000;
-        char                     *static_addr       = NULL;
-        long                      rds_static_len    = 0;
-        long                      nlist             = RVM_NLIST;
-        long                      chunk_size        = RVM_CHUNK_SIZE;
-        unsigned long             dev_length        = RVM_SEGMENT_SIZE;
-        unsigned long             heap_length       = RVM_HEAP_SIZE;
         bool                      stob_directio     = true;
         int                       nbytes            = 0;
         struct  m0_stob_id        stob_id;
+        char                     *static_addr       = NULL;
         int                       result;
         int                       err;
+        unsigned long             dev_length        = RVM_SEGMENT_SIZE;
         enum m0_be_seg_state      seg_state = 0;
 
-
         seg                     = (struct m0_be_seg *)cb_data;
         M0_ASSERT(seg != NULL);
 
@@ -346,19 +367,7 @@ M0_INTERNAL void m0_be_seg_create_cb(void *cb_data)
                 goto exit;
         }
 
-        /* @todo - need to handle rvm errors in callback. */
-        /* Create heap structure. */
-        rds_static_len    = RVM_ROUND_LENGTH_DOWN_TO_PAGE_SIZE(4096);
-
-        result = rds_zap_heap(seg->bs_impl.path_name,
-                              RVM_LENGTH_TO_OFFSET(dev_length),
-                              start_Addr,
-                              rds_static_len,
-                              heap_length,
-                              nlist,
-                              chunk_size,
-                              &err);
-
+        result = be_rvm_rds_zap_heap(seg->bs_impl.path_name);
         if (result < 0) {
                 M0_LOG(M0_ERROR, "rds_zap_heap failed in m0_be_seg_create_cb");
                 seg_state = M0_BESEG_FAILED;
diff --git a/be/seg.h b/be/seg.h
index 0861847..ca593c4 100644
--- a/be/seg.h
+++ b/be/seg.h
@@ -33,10 +33,12 @@
  * These params will be used to call rvm API's from segment layer.
  */
 enum BE_RVM_PARAMS {
-        RVM_HEAP_SIZE     = 100 * 1024 * 1024,
+        /*RVM_HEAP_SIZE     = 1073741824,*/
+        RVM_HEAP_SIZE     = 314572800,
         /** RVM_PAGE_SIZE was conflicting with RVM variable declarations. */
         RVM_PG_SIZE       = 1024 * 4,
         RVM_SEGMENT_SIZE  = RVM_PG_SIZE + RVM_HEAP_SIZE + RVM_PG_SIZE,
+        /*RVM_SEGMENT_SIZE  = 341572800,*/
         RVM_NLIST         = 16,
         RVM_CHUNK_SIZE    = 64,
 };
diff --git a/be/ut/kv_store.c b/be/ut/kv_store.c
index dfa81fe..2ed605d 100644
--- a/be/ut/kv_store.c
+++ b/be/ut/kv_store.c
@@ -288,7 +288,7 @@ static void __insert(int start, int last, char *obj_name, char *cat_name,
 }
 
 static void __find(int start, int last, char *obj_name, char *cat_name,
-                char *cp_name)
+                   char *cp_name)
 {
         int i;
 
diff --git a/be/ut/kv_store_ub.c b/be/ut/kv_store_ub.c
index dbd9620..47202dc 100644
--- a/be/ut/kv_store_ub.c
+++ b/be/ut/kv_store_ub.c
@@ -30,7 +30,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#define MAX_KEY_SIZE 256
+#define MAX_KEY_SIZE 1050
 
 /** User defined structure. */
 struct m0_kv_store_obj {
@@ -54,11 +54,16 @@ struct m0_kv_store_obj     *ret_obj[1024]  = {NULL};
 struct m0_be_kv_store      *handle         = NULL;
 struct m0_be_kv_store_rvm  *handle_rvm     = NULL;
 struct m0_sm_group         *sm_group;
+struct m0_be_reference      ins_ref[1024];
 
 static const char          *stob_dir  = "./__be/o";
 static const char          *stob_file = "0000000000000000.0000000000000001";
 extern const char          *log_file;
 char                        kv_cmd[1024];
+char                        obj_name[MAX_KEY_SIZE]    = "a";
+char                        search_name[MAX_KEY_SIZE] = "a";
+int                         ref_i      = 0;
+int                         find_index = 0;
 
 /** Key compare routine. */
 int function_comp(void *key1, void *key2)
@@ -79,13 +84,10 @@ int function_match(void *in_obj, void *key)
         return strcmp(obj->key, (char *)key);
 }
 
-static int __insert(char *key_name, int val)
+static void ub_kv_insert()
 {
         int32_t                  status;
         struct m0_be_tx         *tx;
-        struct m0_be_reference  *obj_ref;
-        struct m0_be_reg        *obj_reg;
-        struct m0_be_buf        *obj_buf;
 
         M0_ALLOC_PTR(tx);
 
@@ -93,51 +95,31 @@ static int __insert(char *key_name, int val)
                 status = BE_KV_FAILURE;
                 goto exit;
         }
-        M0_ALLOC_PTR(obj_buf);
-        M0_ASSERT(obj_buf != NULL);
 
         sm_group = m0_be_domain_sm_group(kv_dom);
 
         m0_be_tx_init(tx, kv_dom, 0);
 
-        /* Prepare a region for the object */
-        M0_ALLOC_PTR(obj_reg);
-        M0_ASSERT(obj_reg != NULL);
-        obj_buf->b_nob = sizeof *object[val];
-        m0_be_reg_init(obj_reg, tx, kv_seg, obj_buf);
-
         /* As nothing in credit list, so can start tx directly */
         m0_be_tx_start(tx);
 
-        /* Memory alloc to the object via rvm */
-        object[val] = (struct m0_kv_store_obj *)m0_be_ks_obj_malloc(obj_reg,
-                                                                    &obj_ref);
-        if (object[val] == NULL) {
-                status = BE_KV_FAILURE;
-                goto exit;
-        }
-        M0_ASSERT(obj_ref != NULL);
-
-        /* Make changes to object */
-        strncpy(object[val]->key, key_name, strlen(key_name));
-        object[val]->obj_val = val;
-
-        /* Insert this into the kv_store */
-        status = m0_be_ks_insert(handle, obj_ref, tx);
+        /* Insert current object identified by ref_i into the kv_store */
+        status = m0_be_ks_insert(handle, &ins_ref[ref_i], tx);
         if (status == BE_KV_FAILURE || status == BE_KV_OUT_OF_DOMAIN ||
-            status == BE_KV_DUPLICATE)
+            status == BE_KV_DUPLICATE) {
+                M0_LOG(M0_FATAL, "Failed to insert object number %d", ref_i);
                 goto exit;
+        }
 
         m0_be_tx_done(tx);
         m0_be_wait(sm_group, &tx->bt_sm,
                    M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
 
         m0_be_tx_fini(tx);
-        m0_free(tx);
-        m0_free(obj_reg);
-        m0_free(obj_buf);
+
 exit:
-        return status;
+        ref_i++;
+        m0_free(tx);
 }
 
 static void *__find(char *key)
@@ -196,97 +178,13 @@ static int __delete(struct m0_kv_store_obj *target)
         return ret_val;
 }
 
-static void __loop_insert(int start, int last, char *obj_name, char *cat_name,
-                     char *cp_name)
-{
-        int     i;
-        int32_t status;
-        for(i = start; i < last; i++) {
-                status = __insert(obj_name, i);
-                M0_ASSERT(status != BE_KV_FAILURE);
-                M0_ASSERT(status != BE_KV_OUT_OF_DOMAIN);
-                M0_ASSERT(status != BE_KV_DUPLICATE);
-
-                if (strlen(obj_name) < 254)
-                        strcat(obj_name, cat_name);
-                else
-                        strcpy(obj_name, cp_name);
-        }
-}
-
-static void __loop_find(int start, int last, char *obj_name, char *cat_name,
-                   char *cp_name)
-{
-        int i;
-
-        for(i = start; i < last; i++) {
-                ret_obj[i]  = (struct m0_kv_store_obj *)__find(obj_name);
-                M0_ASSERT(ret_obj[i] != NULL);
-
-                if (strlen(obj_name) < 254)
-                        strcat(obj_name, cat_name);
-                else
-                        strcpy(obj_name, cp_name);
-        }
-
-}
-
-static void ub_kv_insert()
-{
-        bool    ret_dom;
-        size_t  length                   =  0;
-        char    obj_name[MAX_KEY_SIZE]   = "a";
-
-        /*
-         * Lookup for the kv_store segment to be used for allocations while
-         * insertion
-         */
-        sm_group = m0_be_domain_sm_group(kv_dom);
-
-        ret_dom = m0_be_domain_lookup(kv_dom, BE_KV_SEG_NAME, &kv_seg);
-        M0_ASSERT(ret_dom);
-        M0_ASSERT(kv_seg != NULL);
-
-        strcat(obj_name, "b");
-        __loop_insert(0, 256, obj_name, "a", "akv");
-
-        strcpy(obj_name, "a");
-        strcat(obj_name, "c");
-        __loop_insert(256, 512, obj_name, "b", "bkv");
-
-        strcpy(obj_name, "a");
-        strcat(obj_name, "d");
-        __loop_insert(512, 768, obj_name, "c", "ckv");
-
-        strcpy(obj_name, "a");
-        strcat(obj_name, "e");
-        __loop_insert(768, 1024, obj_name, "d", "dkv");
-
-        length = m0_tlist_length(&kv_list_descr,
-                                 &handle->ks_handle_rvm->ksr_tlist);
-        M0_ASSERT(length == 1024);
-}
-
 static void ub_kv_find()
 {
-        char    obj_name[MAX_KEY_SIZE]  = "a";
-
-        strcat(obj_name, "b");
-
-        __loop_find(0, 256, obj_name, "a", "akv");
-
-        strcpy(obj_name, "a");
-        strcat(obj_name, "c");
-        __loop_find(256, 512, obj_name, "b", "bkv");
-
-        strcpy(obj_name, "a");
-        strcat(obj_name, "d");
-        __loop_find(512, 768, obj_name, "c", "ckv");
-
-        strcpy(obj_name, "a");
-        strcat(obj_name, "e");
-        __loop_find(768, 1024, obj_name, "d", "dkv");
+        ret_obj[find_index]  = (struct m0_kv_store_obj *)__find(search_name);
+        M0_ASSERT(ret_obj[find_index] != NULL);
 
+        strcat(search_name, "b");
+        find_index++;
 }
 
 void ub_kv_delete()
@@ -294,12 +192,14 @@ void ub_kv_delete()
         int32_t status;
         int     i;
         size_t  length;
+        length = m0_tlist_length(&kv_list_descr,
+                                 &handle->ks_handle_rvm->ksr_tlist);
 
-        /* Delete the object. */
-        for(i =0; i < 1024; i++) {
+        for(i =0; i < length; i++) {
                 status = __delete(ret_obj[i]);
                 M0_ASSERT(status == BE_KV_SUCCESS);
         }
+
         length = m0_tlist_length(&kv_list_descr,
                                  &handle->ks_handle_rvm->ksr_tlist);
 
@@ -307,13 +207,19 @@ void ub_kv_delete()
 }
 
 enum {
-	UB_ITER   = 1,
+	UB_ITER   = 1000,
 };
 
 static void ub_init(void)
 {
-        int                 rc;
-        struct m0_sm_group *sm_group;
+        struct m0_be_tx         *tx;
+        struct m0_be_reference  *obj_ref;
+        struct m0_be_reg        *obj_reg;
+        struct m0_be_buf        *obj_buf;
+        struct m0_sm_group      *sm_group;
+        bool                     ret_dom;
+        int                      rc;
+        int                      val;
 
         M0_LOG(M0_DEBUG,"KV Store Initialization");
         sprintf(kv_cmd, "rm -rf %s", log_file);
@@ -325,7 +231,7 @@ static void ub_init(void)
         M0_ASSERT(rc == 0);
 
         sprintf(kv_cmd,
-                "dd if=/dev/zero of=%s/%s bs=1024 count=102408 2>/dev/null",
+                "dd if=/dev/zero of=%s/%s bs=1024 count=512000 2>/dev/null",
                 stob_dir, stob_file);
         rc = system(kv_cmd);
         M0_ASSERT(rc == 0);
@@ -352,6 +258,67 @@ static void ub_init(void)
                    M0_BITS(M0_BEKS_DONE));
 
         M0_ASSERT(handle->ks_handle_rvm != NULL);
+
+        ret_dom = m0_be_domain_lookup(kv_dom, BE_KV_SEG_NAME, &kv_seg);
+        M0_ASSERT(ret_dom);
+        M0_ASSERT(kv_seg != NULL);
+
+        /*
+         * Allocate memory to the objects to be inserted and keep them ready
+         * for insertion
+         */
+
+        for(val = 0; val < 1000; val++) {
+                M0_ALLOC_PTR(tx);
+                M0_ASSERT(tx != NULL);
+
+                M0_ALLOC_PTR(obj_buf);
+                M0_ASSERT(obj_buf != NULL);
+
+                m0_be_tx_init(tx, kv_dom, 0);
+
+                /* Prepare a region for the object */
+                M0_ALLOC_PTR(obj_reg);
+                M0_ASSERT(obj_reg != NULL);
+
+                obj_buf->b_nob = sizeof *object[val];
+                m0_be_reg_init(obj_reg, tx, kv_seg, obj_buf);
+
+                /* As nothing in credit list, so can start tx directly */
+                m0_be_tx_start(tx);
+
+                /* Memory alloc to the object via rvm */
+                obj_ref = NULL;
+                object[val] = (struct m0_kv_store_obj *)
+                               m0_be_ks_obj_malloc(obj_reg, &obj_ref);
+
+                if (object[val] == NULL) {
+                        M0_LOG(M0_FATAL,
+                               "Failed to allocate memory to object number %d",
+                               val);
+                }
+
+                M0_ASSERT(obj_ref != NULL);
+
+                /* This will be used for insertion */
+                ins_ref[val] = *obj_ref;
+
+                /* Make changes to object */
+                strncpy(object[val]->key, obj_name, strlen(obj_name));
+                object[val]->obj_val = val;
+
+                m0_be_tx_done(tx);
+                m0_be_wait(sm_group, &tx->bt_sm,
+                           M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
+
+                m0_be_tx_fini(tx);
+
+                m0_free(tx);
+                m0_free(obj_reg);
+                m0_free(obj_buf);
+                strcat(obj_name, "b");
+        }
+
 }
 
 static void ub_fini()
diff --git a/utils/ub_main.c b/utils/ub_main.c
index 0f3362b..543439b 100644
--- a/utils/ub_main.c
+++ b/utils/ub_main.c
@@ -53,7 +53,7 @@ int main(int argc, char *argv[])
 	if (unit_start(UB_SANDBOX) == 0) {
                 /* Note these tests are run in reverse order from the way
                    they are listed here */
-		m0_ub_set_add(&m0_memory_ub);
+                m0_ub_set_add(&m0_memory_ub);
                 m0_ub_set_add(&m0_adieu_ub);
                 m0_ub_set_add(&m0_ad_ub);
                 m0_ub_set_add(&m0_db_ub);
@@ -64,9 +64,9 @@ int main(int argc, char *argv[])
                 m0_ub_set_add(&m0_list_ub);
                 m0_ub_set_add(&m0_bitmap_ub);
                 m0_ub_set_add(&m0_parity_math_ub);
-		m0_ub_set_add(&m0_thread_ub);
-		m0_ub_set_add(&m0_trace_ub);
-		m0_ub_set_add(&m0_atomic_ub);
+                m0_ub_set_add(&m0_thread_ub);
+                m0_ub_set_add(&m0_trace_ub);
+                m0_ub_set_add(&m0_atomic_ub);
                 m0_ub_set_add(&m0_kvstore_ub);
 		m0_ub_run(rounds);
 
-- 
1.8.3.2

