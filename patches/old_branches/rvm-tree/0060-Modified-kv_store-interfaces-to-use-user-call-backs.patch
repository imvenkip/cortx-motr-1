From 44826461ac3d9d1f2f14bc732bdca3cccdcb0fd7 Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Thu, 7 Mar 2013 06:26:54 -0800
Subject: [PATCH 60/94] Modified kv_store interfaces to use user call backs.

---
 be/kv_store.c       | 146 +++++++++++++++++++++++++++++++++++-----------------
 be/kv_store.h       | 110 +++++++++++++++++++++++----------------
 be/seg.h            |   5 +-
 be/ut/kv_store.c    | 139 ++++++++++++++++++++++++++++++++++++++++++-------
 be/ut/kv_store_ub.c |  10 ++--
 5 files changed, 291 insertions(+), 119 deletions(-)

diff --git a/be/kv_store.c b/be/kv_store.c
index 08858be..e0ca507 100644
--- a/be/kv_store.c
+++ b/be/kv_store.c
@@ -28,6 +28,7 @@
 #include "be/handler.h"
 #include "be/kv_store_private.h"
 #include <string.h>
+#include <stdlib.h>
 
 /**
    @addtogroup be_kv_store
@@ -128,14 +129,16 @@ M0_INTERNAL void m0_be_ks_create(struct m0_tl_descr      *descr,
 }
 M0_EXPORTED(m0_be_ks_create);
 
-M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store  *handle,
-                               char                   *mode)
+M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store     *handle,
+                               struct m0_be_kv_store_cb  *cb_info,
+                               char                      *mode)
 {
         struct m0_sm_group         *sm_group;
         struct m0_be_seg           *rvm_handle_seg = NULL;
         struct m0_be_ks_opdata     *bk_opdata;
         struct m0_tl_descr         *descr;
         struct m0_be_domain        *dom;
+        struct m0_be_kv_store_cb   *bko_cbinfo;
         kv_key_cmp_t                cmp_fp;
         kv_key_match_t              match_fp;
 
@@ -174,15 +177,37 @@ M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store  *handle,
         bk_opdata->bko_handle   = handle;
         bk_opdata->bko_ksi_mode = mode;
         bk_opdata->bko_seg      = rvm_handle_seg;
+
+        /*
+         * If user has provided a callback function to be called after
+         * completion of ks_init, then maintain it in our own call back data
+         */
+        if (cb_info != NULL) {
+                M0_ALLOC_PTR(bko_cbinfo);
+                M0_ASSERT(bko_cbinfo != NULL);
+
+                bko_cbinfo->ksc_cb     = cb_info->ksc_cb;
+                bko_cbinfo->ksc_cbdata = cb_info->ksc_cbdata;
+
+                bk_opdata->bko_cbinfo = bko_cbinfo;
+        }
+        else {
+                /* Assures bko_cbinfo won't contain garbage info */
+                bk_opdata->bko_cbinfo->ksc_cbdata = NULL;
+                bk_opdata->bko_cbinfo->ksc_cb     = NULL;
+        }
+
         m0_sm_enqueue_post(sm_group, bk_opdata, m0_be_ksi_handle_cb);
         M0_LEAVE("handle: %p", handle);
 }
 M0_EXPORTED(m0_be_ks_init);
 
-M0_INTERNAL void m0_be_ks_fini(struct m0_be_kv_store *handle,
-                               struct m0_be_seg      *seg)
+M0_INTERNAL void m0_be_ks_fini(struct m0_be_kv_store     *handle,
+                               struct m0_be_kv_store_cb  *cb_info,
+                               struct m0_be_seg          *seg)
 {
         struct m0_be_domain *dom;
+        void                *ksc_cbdata;
 
         M0_ENTRY();
         M0_PRE(m0_be_ks_get_handle_state(handle) == M0_BEKS_DONE);
@@ -196,45 +221,26 @@ M0_INTERNAL void m0_be_ks_fini(struct m0_be_kv_store *handle,
 
         m0_be_domain_fini(dom);
         m0_free(dom);
-        m0_free(handle);
-        M0_LEAVE();
-}
-M0_EXPORTED(m0_be_ks_fini);
 
-M0_INTERNAL struct m0_list_link
-*m0_be_ks_get_next_val(struct m0_be_kv_store *handle, void *obj)
-{
-        struct m0_list_link     *link_next;
-        void                    *temp_tail;
-        struct m0_tl            *ks_tlist;
-        struct m0_tl_descr      *ks_list_descr;
-
-        M0_ENTRY();
-
-        ks_tlist      = &handle->ks_handle_rvm->ksr_tlist;
-        ks_list_descr = handle->ks_handle_heap.ksh_list_descr;
-        temp_tail     = m0_tlist_tail(ks_list_descr, ks_tlist);
-
-        /* If object is last in linked list, then its next will be itself */
-        if (temp_tail == obj) {
-                __ks_get_current(ks_list_descr, obj, &link_next);
-                link_next = NULL;
-                goto get_ref;
+        /* Call the callback function provided by the user. */
+        if (cb_info != NULL) {
+                ksc_cbdata = cb_info->ksc_cbdata;
+                M0_ASSERT(ksc_cbdata != NULL);
+                cb_info->ksc_cb(ksc_cbdata);
         }
 
-        __ks_get_next(ks_list_descr, obj, &link_next);
-
-get_ref:
+        m0_free(handle);
         M0_LEAVE();
-        return link_next;
 }
-M0_EXPORTED(m0_be_ks_get_next_value);
+M0_EXPORTED(m0_be_ks_fini);
 
-M0_INTERNAL void *m0_be_ks_find(struct m0_be_kv_store *handle,
-                                void                  *key)
+M0_INTERNAL void *m0_be_ks_find(struct m0_be_kv_store     *handle,
+                                struct m0_be_kv_store_cb  *cb_info,
+                                void                      *key)
 {
         void                    *scan;
         void                    *target;
+        void                    *ksc_cbdata;
         struct m0_tl            *ks_tlist;
         struct m0_tl_descr      *ks_list_descr;
 
@@ -254,17 +260,26 @@ M0_INTERNAL void *m0_be_ks_find(struct m0_be_kv_store *handle,
         target = NULL;
 
 exit_find:
+        /* Call the callback function provided by the user. */
+        if (cb_info != NULL) {
+                ksc_cbdata = cb_info->ksc_cbdata;
+                M0_ASSERT(ksc_cbdata != NULL);
+                cb_info->ksc_cb(ksc_cbdata);
+        }
+
         M0_LEAVE("target: %p", target);
         return target;
 }
 M0_EXPORTED(m0_be_ks_find);
 
-M0_INTERNAL int32_t m0_be_ks_delete(struct m0_be_kv_store  *handle,
-                                    void                   *obj,
-                                    struct m0_be_tx        *tx)
+M0_INTERNAL int32_t m0_be_ks_delete(struct m0_be_kv_store     *handle,
+                                    struct m0_be_kv_store_cb  *cb_info,
+                                    void                      *obj,
+                                    struct m0_be_tx           *tx)
 {
         void                    *scan;
         void                    *target = NULL;
+        void                    *ksc_cbdata;
         struct m0_be_reg        *t_head_reg;
         struct m0_list_link     *temp_link;
         struct m0_list_link     *t_head_link;
@@ -273,6 +288,7 @@ M0_INTERNAL int32_t m0_be_ks_delete(struct m0_be_kv_store  *handle,
         struct m0_tl_descr      *ks_list_descr;
         struct m0_be_domain     *ks_dom;
         struct m0_sm_group      *sm_group;
+        int32_t                  ret_val;
         bool                     target_found;
 
         M0_ENTRY();
@@ -314,12 +330,20 @@ M0_INTERNAL int32_t m0_be_ks_delete(struct m0_be_kv_store  *handle,
 
                 /* Now delete */
                 m0_tlink_del_fini(ks_list_descr, target);
-                M0_LEAVE();
-                return BE_KV_SUCCESS;
+                ret_val = BE_KV_SUCCESS;
         } else {
-                M0_LEAVE();
-                return BE_KV_FAILURE;
+                ret_val = BE_KV_FAILURE;
+        }
+
+        /* Call the callback function provided by the user. */
+        if (cb_info != NULL) {
+                ksc_cbdata = cb_info->ksc_cbdata;
+                M0_ASSERT(ksc_cbdata != NULL);
+                cb_info->ksc_cb(ksc_cbdata);
         }
+
+        M0_LEAVE();
+        return ret_val;
 }
 M0_EXPORTED(m0_be_ks_delete);
 
@@ -361,9 +385,10 @@ M0_INTERNAL int32_t __ks_tlist_add_at_tail(struct m0_be_kv_store     *handle,
         return BE_KV_SUCCESS;
 }
 
-M0_INTERNAL int32_t m0_be_ks_insert(struct m0_be_kv_store   *handle,
-                                    struct m0_be_reference  *obj_ref,
-                                    struct m0_be_tx         *tx)
+M0_INTERNAL int32_t m0_be_ks_insert(struct m0_be_kv_store     *handle,
+                                    struct m0_be_kv_store_cb  *cb_info,
+                                    struct m0_be_reference    *obj_ref,
+                                    struct m0_be_tx           *tx)
 {
         struct m0_be_domain     *dom;
         struct m0_tl            *ks_tlist;
@@ -372,6 +397,7 @@ M0_INTERNAL int32_t m0_be_ks_insert(struct m0_be_kv_store   *handle,
         struct m0_sm_group      *sm_group;
         void                    *scan;
         void                    *new;
+        void                    *ksc_cbdata;
         int32_t                  ret_val       = BE_KV_INVALID_REQ;
 
         M0_ENTRY("handle: %p obj:%p", handle, obj_ref->be_virtual_address);
@@ -441,6 +467,13 @@ M0_INTERNAL int32_t m0_be_ks_insert(struct m0_be_kv_store   *handle,
         }
 
 exit_insert:
+        /* Call the callback function provided by the user. */
+        if (cb_info != NULL) {
+                ksc_cbdata = cb_info->ksc_cbdata;
+                M0_ASSERT(ksc_cbdata != NULL);
+                cb_info->ksc_cb(ksc_cbdata);
+        }
+
         M0_LEAVE("ret_val: %d", ret_val);
         return ret_val;
 }
@@ -736,10 +769,12 @@ M0_INTERNAL void m0_be_ksi_tx_cb(void *cb_data)
 
 M0_INTERNAL void m0_be_ksi_init_done(void *cb_data)
 {
-        struct m0_be_ks_opdata  *bk_opdata;
-        struct m0_be_domain     *dom;
-        struct m0_be_kv_store   *handle;
-        struct m0_sm_group      *sm_group;
+        struct m0_be_ks_opdata     *bk_opdata;
+        struct m0_be_kv_store      *handle;
+        struct m0_be_kv_store_cb   *cb_info;
+        struct m0_be_domain        *dom;
+        struct m0_sm_group         *sm_group;
+        void                       *ksc_cbdata;
 
         M0_ENTRY();
 
@@ -748,15 +783,30 @@ M0_INTERNAL void m0_be_ksi_init_done(void *cb_data)
         handle = bk_opdata->bko_handle;
         dom    = handle->ks_handle_heap.ksh_dom;
 
+        if (bk_opdata->bko_cbinfo->ksc_cbdata != NULL)
+                cb_info = bk_opdata->bko_cbinfo;
+        else
+                cb_info = NULL;
+
         M0_ASSERT(handle != NULL);
         M0_ASSERT(dom    != NULL);
 
         /* Set kv-store state to done */
         sm_group = m0_be_domain_sm_group(dom);
+
         m0_sm_group_lock(sm_group);
         m0_sm_state_set(&handle->ks_handle_heap.ksh_sm, M0_BEKS_DONE);
         m0_sm_group_unlock(sm_group);
 
+        /* If provided, call the callback function assigned by the user */
+        if (cb_info != NULL) {
+                ksc_cbdata = cb_info->ksc_cbdata;
+                M0_ASSERT(ksc_cbdata != NULL);
+                cb_info->ksc_cb(ksc_cbdata);
+                /* Was allocated in m0_be_ks_init */
+                m0_free(cb_info);
+        }
+
         m0_free(cb_data);
         M0_LEAVE();
 }
diff --git a/be/kv_store.h b/be/kv_store.h
index 9ea8915..37c199a 100644
--- a/be/kv_store.h
+++ b/be/kv_store.h
@@ -152,7 +152,7 @@ typedef int     (*kv_key_match_t)(void *, void *);
   persistent.
  */
 struct m0_be_kv_store_rvm {
-        /* The tlist */
+        /** The underlying tlist. */
         struct m0_tl             ksr_tlist;
 };
 
@@ -161,44 +161,60 @@ struct m0_be_kv_store_rvm {
  */
 struct m0_be_kv_store_heap {
         /** State machine for kv store. */
-        struct m0_sm             ksh_sm;
+        struct m0_sm               ksh_sm;
         /** List descriptor for the tlist. */
-        struct m0_tl_descr      *ksh_list_descr;
+        struct m0_tl_descr        *ksh_list_descr;
         /** Domain pointer. */
-        struct m0_be_domain     *ksh_dom;
+        struct m0_be_domain       *ksh_dom;
         /** Compare function from user. */
-        kv_key_cmp_t             ksh_key_cmp;
+        kv_key_cmp_t               ksh_key_cmp;
         /** Match function from user. */
-        kv_key_match_t           ksh_key_match;
+        kv_key_match_t             ksh_key_match;
 };
 
 /**
   Structure to hold the handle to current tlist and its descriptor.
  */
 struct m0_be_kv_store {
+        /** Persistent part of the handle. */
         struct m0_be_kv_store_rvm  *ks_handle_rvm;
+        /** Heap part of the handle, that need not be made persistent. */
         struct m0_be_kv_store_heap  ks_handle_heap;
 };
 
 /**
+  Structure that stores the callback function and the call back data that would
+  used after completion of kv-store operations.
+ */
+struct m0_be_kv_store_cb {
+        /** Call back data to be used. */
+        void            *ksc_cbdata;
+        /** The call back function. */
+        void           (*ksc_cb)(void *cb_data);
+};
+
+
+/**
   Structure to hold callback data when transferring control
   from callback to another.
  */
 struct m0_be_ks_opdata {
-        /* key value store state machine */
-        struct m0_sm             bko_sm;
-        /* Actual kv-store handle */
-        struct m0_be_kv_store   *bko_handle;
-        /* Segment used as input to hs_update */
-        struct m0_be_seg        *bko_seg;
-        /* Region on which handle is created */
-        struct m0_be_reg        *bko_reg;
-        /* Transaction pointer under which handle is created */
-        struct m0_be_tx         *bko_tx;
-        /* Buffer used for bko_reg */
-        struct m0_be_buf        *bko_buf;
-        /* kv-store init mode */
-        char                    *bko_ksi_mode;
+        /** Key value store state machine. */
+        struct m0_sm               bko_sm;
+        /** Actual kv-store handle. */
+        struct m0_be_kv_store     *bko_handle;
+        /** Segment used as input to hs_update. */
+        struct m0_be_seg          *bko_seg;
+        /** Region on which handle is created. */
+        struct m0_be_reg          *bko_reg;
+        /** Transaction pointer under which handle is created. */
+        struct m0_be_tx           *bko_tx;
+        /** Buffer used for bko_reg. */
+        struct m0_be_buf          *bko_buf;
+        /** Callback information to be used after operation completion. */
+        struct m0_be_kv_store_cb  *bko_cbinfo;
+        /** Kv-store init mode. */
+        char                      *bko_ksi_mode;
 };
 
 /**
@@ -248,33 +264,39 @@ M0_INTERNAL void m0_be_ks_create(struct m0_tl_descr      *descr,
   of the @handle.
 
   @param handle        :       pointer to the handle.
-  @param descr         :       the tlist descriptor to be given to the tlist in
-                               kv_store.
-  @param dom           :       the domain pointer to be given to the handle.
-  @param cmp_fp        :       user defined function to compare keys.
-  @param match_fp      :       user defined function to match keys.
+  @param cb_info       :       the callback information that will be used to
+                               call the callback function after completion of
+                               initialization.
   @param mode          :       decides whether kv_store is new or has to be
                                recovered.
                                allowed modes: CREATE/RECOVER or create/recover.
  */
-M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store  *handle,
-                               char                   *mode);
+M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store     *handle,
+                               struct m0_be_kv_store_cb  *cb_info,
+                               char                      *mode);
 
 /**
   Finalise a kv-store.
 
   @param handle        :        the kv-store handle.
+  @param cb_info       :        the callback information that will be used
+                                to call the callback function after completion
+                                of fini operation.
   @param seg           :        segment used by kv-store.
 
   @todo: as we have just segment now, segment parameter needed for now.
  */
 M0_INTERNAL void m0_be_ks_fini(struct m0_be_kv_store *handle,
+                               struct m0_be_kv_store_cb  *cb_info,
                                struct m0_be_seg      *seg);
 /**
   Insert a key value pair in the tlist contained in @handle.
 
   @param handle                :      Handle containing the tlist in which the
                                       object will be stored.
+  @param cb_info               :      the callback information that will be used
+                                      to call the callback function after
+                                      completion of insertion.
   @param obj_ref               :      the m0_be_reference of the object to
                                       be inserted
   @param tx                    :      transaction handle.
@@ -284,43 +306,43 @@ M0_INTERNAL void m0_be_ks_fini(struct m0_be_kv_store *handle,
   @retval BE_KV_OUT_OF_DOMAIN  :      when there's a mismatch in the object
                                       magic and the domain magic in handle.
  */
-M0_INTERNAL int32_t  m0_be_ks_insert(struct m0_be_kv_store  *handle,
-                                     struct m0_be_reference *obj_ref,
-                                     struct m0_be_tx        *tx);
+M0_INTERNAL int32_t  m0_be_ks_insert(struct m0_be_kv_store     *handle,
+                                     struct m0_be_kv_store_cb  *cb_info,
+                                     struct m0_be_reference    *obj_ref,
+                                     struct m0_be_tx           *tx);
 
 /**
   Find the object with @key in the tlist contained in @handle.
 
   @param handle        :       handle containing the tlist in which the
                                object containing the @key is stored.
+  @param cb_info       :       the callback information that will be used
+                               to call the callback function after  completion
+                               of lookup.
   @param key           :       the key to be searched for in the list.
   @return              :       object holding the @key or NULL if fails.
  */
-M0_INTERNAL void  *m0_be_ks_find(struct m0_be_kv_store *handle,  void *key);
+M0_INTERNAL void  *m0_be_ks_find(struct m0_be_kv_store     *handle,
+                                 struct m0_be_kv_store_cb  *cb_info,
+                                 void                      *key);
 
 /**
   Delete the object in the tlist contained in @handle.
 
   @param handle         :       handle containing the tlist in which the @obj is
                                 stored.
+  @param cb_info       :        the callback information that will be used
+                                to call the callback function after  completion
+                                of deletion.
   @param obj            :       the object to be deleted.
   @param tx             :       transaction handle.
   @retval BE_KV_FAILURE :       in case of failures.
   @retval BE_KV_SUCCESS :       in case of success.
  */
-M0_INTERNAL int32_t m0_be_ks_delete(struct m0_be_kv_store *handle,
-                                    void                  *obj,
-                                    struct m0_be_tx       *tx);
-
-/**
-  Returns the linkage  of the object present next to
-  @obj in the tlist contained in @handle.
-
-  @return               :       linkage of next object.
-  @return               :       NULL on failure.
- */
-M0_INTERNAL struct m0_list_link
-*m0_be_ks_get_next_val(struct m0_be_kv_store *handle, void *obj);
+M0_INTERNAL int32_t m0_be_ks_delete(struct m0_be_kv_store     *handle,
+                                    struct m0_be_kv_store_cb  *cb_info,
+                                    void                      *obj,
+                                    struct m0_be_tx           *tx);
 
 /** @} end of kv_store group */
 #endif /* __MERO_BE_KV_STORE_H__ */
diff --git a/be/seg.h b/be/seg.h
index ca593c4..ffecfa8 100644
--- a/be/seg.h
+++ b/be/seg.h
@@ -33,12 +33,11 @@
  * These params will be used to call rvm API's from segment layer.
  */
 enum BE_RVM_PARAMS {
-        /*RVM_HEAP_SIZE     = 1073741824,*/
-        RVM_HEAP_SIZE     = 314572800,
+        RVM_HEAP_SIZE     = 104857600,
+        /*RVM_HEAP_SIZE     = 314572800,*/
         /** RVM_PAGE_SIZE was conflicting with RVM variable declarations. */
         RVM_PG_SIZE       = 1024 * 4,
         RVM_SEGMENT_SIZE  = RVM_PG_SIZE + RVM_HEAP_SIZE + RVM_PG_SIZE,
-        /*RVM_SEGMENT_SIZE  = 341572800,*/
         RVM_NLIST         = 16,
         RVM_CHUNK_SIZE    = 64,
 };
diff --git a/be/ut/kv_store.c b/be/ut/kv_store.c
index 2ed605d..d8f7bd3 100644
--- a/be/ut/kv_store.c
+++ b/be/ut/kv_store.c
@@ -68,6 +68,36 @@ extern const char          *log_file;
 char                        kv_cmd[1024];
 int                         kv_val;
 
+/** Callback function to be called after operation completion. */
+void init_operation_callback(void *operation_name)
+{
+        m0_free(operation_name);
+}
+
+/** Callback function to be called after operation completion. */
+void fini_operation_callback(void *operation_name)
+{
+        m0_free(operation_name);
+}
+
+/** Callback function to be called after operation completion. */
+void insert_operation_callback(void *operation_name)
+{
+        m0_free(operation_name);
+}
+
+/** Callback function to be called after operation completion. */
+void find_operation_callback(void *operation_name)
+{
+        m0_free(operation_name);
+}
+
+/** Callback function to be called after operation completion. */
+void delete_operation_callback(void *operation_name)
+{
+        m0_free(operation_name);
+}
+
 /** Key compare routine. */
 int function_comp(void *key1, void *key2)
 {
@@ -89,7 +119,9 @@ int function_match(void *in_obj, void *key)
 
 static int ts_kv_store_init()
 {
-        int  rc;
+        struct m0_be_kv_store_cb  *cb_info;
+        int                        rc;
+        char                      *operation_name;
 
         M0_LOG(M0_DEBUG,"KV Store Initialization");
         sprintf(kv_cmd, "rm -rf %s", log_file);
@@ -101,7 +133,7 @@ static int ts_kv_store_init()
         M0_ASSERT(rc == 0);
 
         sprintf(kv_cmd,
-                "dd if=/dev/zero of=%s/%s bs=1024 count=102408 2>/dev/null",
+                "dd if=/dev/zero of=%s/%s bs=1024 count=204800 2>/dev/null",
                 stob_dir, stob_file);
         rc = system(kv_cmd);
         M0_ASSERT(rc == 0);
@@ -122,37 +154,64 @@ static int ts_kv_store_init()
 
         sm_group = m0_be_domain_sm_group(kv_dom);
 
+        /* Set the callback information */
+        M0_ALLOC_PTR(cb_info);
+        M0_ASSERT(cb_info != NULL);
+
+        operation_name = (char *)malloc(10);
+        strcpy(operation_name, "KS_INIT");
+
+        cb_info->ksc_cb                 = init_operation_callback;
+        cb_info->ksc_cbdata             = (void *)operation_name;
+
         /* Initialise the kv-store i.e. create or recover from RVM */
-        m0_be_ks_init(handle, "create");
+        m0_be_ks_init(handle, cb_info, "create");
         m0_be_wait(sm_group, &handle->ks_handle_heap.ksh_sm,
                    M0_BITS(M0_BEKS_DONE));
 
         M0_ASSERT(handle->ks_handle_rvm != NULL);
         M0_LOG(M0_INFO, "kv_store initialised!");
+        m0_free(cb_info);
         return 0;
 }
 
 static int ts_kv_store_fini()
 {
-        int rc;
+        struct m0_be_kv_store_cb  *cb_info;
+        char                      *operation_name;
+        int                        rc;
+
+        /* Set the callback information */
+        M0_ALLOC_PTR(cb_info);
+        M0_ASSERT(cb_info != NULL);
+
+        operation_name = (char *)malloc(10);
+        strcpy(operation_name, "KS_FINI");
 
-        m0_be_ks_fini(handle, kv_seg);
+        cb_info->ksc_cbdata     = (void *)operation_name;
+        cb_info->ksc_cb         = fini_operation_callback;
+
+        m0_be_ks_fini(handle, cb_info, kv_seg);
 
         sprintf(kv_cmd, "rm -rf %s", stob_dir);
         rc = system(kv_cmd);
         M0_ASSERT(rc == 0);
 
+        m0_free(cb_info);
+        m0_free(operation_name);
         return 0;
 }
 
 static int insert(char *key_name, int val)
 {
-        int32_t                  status  = -2;
-        struct m0_be_tx         *tx;
-        struct m0_be_reference  *obj_ref;
-        struct m0_be_reg        *obj_reg;
-        struct m0_be_buf        *obj_buf;
-        struct m0_sm_group      *sm_group;
+        int32_t                    status  = -2;
+        struct m0_be_tx           *tx;
+        struct m0_be_reference    *obj_ref;
+        struct m0_be_reg          *obj_reg;
+        struct m0_be_buf          *obj_buf;
+        struct m0_sm_group        *sm_group;
+        struct m0_be_kv_store_cb  *cb_info;
+        char                      *operation_name;
 
         kv_val = val;
 
@@ -193,8 +252,18 @@ static int insert(char *key_name, int val)
         strncpy(object[val]->key, key_name, strlen(key_name));
         object[val]->obj_val = kv_val;
 
+        /* Set the callback information */
+        M0_ALLOC_PTR(cb_info);
+        M0_ASSERT(cb_info != NULL);
+
+        operation_name = (char *)malloc(10);
+        strcpy(operation_name, "KS_INSERT");
+
+        cb_info->ksc_cbdata     = (void *)operation_name;
+        cb_info->ksc_cb         = insert_operation_callback;
+
         /* Insert this into the kv_store */
-        status = m0_be_ks_insert(handle, obj_ref, tx);
+        status = m0_be_ks_insert(handle, cb_info, obj_ref, tx);
         if (status == BE_KV_FAILURE || status == BE_KV_OUT_OF_DOMAIN ||
             status == BE_KV_DUPLICATE)
                 goto exit;
@@ -206,22 +275,42 @@ static int insert(char *key_name, int val)
         m0_free(tx);
         m0_free(obj_reg);
         m0_free(obj_buf);
+        m0_free(cb_info);
 exit:
         return status;
 }
 
 static void *find(char *key)
 {
-        return m0_be_ks_find(handle, key);
+        struct m0_be_kv_store_cb  *cb_info;
+        char                      *operation_name;
+        void                      *ret_val;
+
+        /* Set the callback information */
+        M0_ALLOC_PTR(cb_info);
+        M0_ASSERT(cb_info != NULL);
+
+        operation_name = (char *)malloc(10);
+        strcpy(operation_name, "KS_FIND");
+
+        cb_info->ksc_cbdata     = (void *)operation_name;
+        cb_info->ksc_cb         = find_operation_callback;
+
+        ret_val =  m0_be_ks_find(handle, cb_info, key);
+        m0_free(cb_info);
+
+        return ret_val;
 }
 
 static int delete(struct m0_kv_store_obj *target)
 {
-        struct m0_be_tx      *tx = NULL;
-        struct m0_be_buf     *obj_buf;
-        struct m0_be_reg     *obj_reg = NULL;
-        struct m0_sm_group   *sm_group;
-        int32_t               ret_val;
+        struct m0_be_tx           *tx = NULL;
+        struct m0_be_buf          *obj_buf;
+        struct m0_be_reg          *obj_reg = NULL;
+        struct m0_sm_group        *sm_group;
+        struct m0_be_kv_store_cb  *cb_info;
+        char                      *operation_name;
+        int32_t                    ret_val;
 
         M0_ALLOC_PTR(tx);
 
@@ -249,8 +338,18 @@ static int delete(struct m0_kv_store_obj *target)
         m0_be_tx_prep(tx);
         m0_be_tx_start(tx);
 
+        /* Set the callback information */
+        M0_ALLOC_PTR(cb_info);
+        M0_ASSERT(cb_info != NULL);
+
+        operation_name = (char *)malloc(10);
+        strcpy(operation_name, "KS_DELETE");
+
+        cb_info->ksc_cbdata     = (void *)operation_name;
+        cb_info->ksc_cb         = delete_operation_callback;
+
         /* Delete this obj from kv store */
-        ret_val = m0_be_ks_delete(handle, (void *)target, tx);
+        ret_val = m0_be_ks_delete(handle, cb_info, (void *)target, tx);
 
         if (ret_val == BE_KV_SUCCESS) {
                 m0_be_tx_done(tx);
@@ -265,6 +364,7 @@ static int delete(struct m0_kv_store_obj *target)
         m0_free(tx);
         m0_free(obj_reg);
         m0_free(obj_buf);
+        m0_free(cb_info);
         return ret_val;
 }
 
@@ -359,6 +459,7 @@ void test_kv_store()
         __find(768, 1024, obj_name, "d", "dkv");
 
         /* Delete'em */
+
         for(i =0; i < 1024; i++) {
                 status = delete(ret_obj[i]);
                 M0_ASSERT(status == BE_KV_SUCCESS);
diff --git a/be/ut/kv_store_ub.c b/be/ut/kv_store_ub.c
index 47202dc..d4c43a4 100644
--- a/be/ut/kv_store_ub.c
+++ b/be/ut/kv_store_ub.c
@@ -104,7 +104,7 @@ static void ub_kv_insert()
         m0_be_tx_start(tx);
 
         /* Insert current object identified by ref_i into the kv_store */
-        status = m0_be_ks_insert(handle, &ins_ref[ref_i], tx);
+        status = m0_be_ks_insert(handle, NULL, &ins_ref[ref_i], tx);
         if (status == BE_KV_FAILURE || status == BE_KV_OUT_OF_DOMAIN ||
             status == BE_KV_DUPLICATE) {
                 M0_LOG(M0_FATAL, "Failed to insert object number %d", ref_i);
@@ -124,7 +124,7 @@ exit:
 
 static void *__find(char *key)
 {
-        return m0_be_ks_find(handle, key);
+        return m0_be_ks_find(handle, NULL, key);
 }
 
 static int __delete(struct m0_kv_store_obj *target)
@@ -161,7 +161,7 @@ static int __delete(struct m0_kv_store_obj *target)
         m0_be_tx_start(tx);
 
         /* Delete this obj from kv store */
-        ret_val = m0_be_ks_delete(handle, (void *)target, tx);
+        ret_val = m0_be_ks_delete(handle, NULL, (void *)target, tx);
 
         if (ret_val != BE_KV_FAILURE) {
                 m0_be_tx_done(tx);
@@ -253,7 +253,7 @@ static void ub_init(void)
         sm_group = m0_be_domain_sm_group(kv_dom);
 
         /* Initialise the kv-store i.e. create or recover from RVM */
-        m0_be_ks_init(handle, "create");
+        m0_be_ks_init(handle, NULL, "create");
         m0_be_wait(sm_group, &handle->ks_handle_heap.ksh_sm,
                    M0_BITS(M0_BEKS_DONE));
 
@@ -325,7 +325,7 @@ static void ub_fini()
 {
         int rc;
 
-        m0_be_ks_fini(handle, kv_seg);
+        m0_be_ks_fini(handle, NULL, kv_seg);
 
         sprintf(kv_cmd, "rm -rf %s", stob_dir);
         rc = system(kv_cmd);
-- 
1.8.3.2

