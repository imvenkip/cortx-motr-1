From e407481de04c86ba13946ac0e79aa881b94c0a01 Mon Sep 17 00:00:00 2001
From: Sachin Patil <sachin_patil@xyratex.com>
Date: Mon, 18 Feb 2013 06:39:23 -0800
Subject: [PATCH 52/94] Added enqueue/dequeue mechanism to perform async
 operations. Made kv-store init operation async

---
 be/Makefile.sub     |   3 +-
 be/be.h             |   9 ++
 be/be_impl.h        |   4 +
 be/be_init.c        |   3 +-
 be/be_private.h     |  10 ++
 be/domain.c         |  47 ++++---
 be/handle_store.c   |  96 +++++++++-----
 be/handle_store.h   |  20 ++-
 be/handler.c        | 147 ++++++++++++++++++++++
 be/handler.h        |  59 +++++++++
 be/helper.c         |  29 -----
 be/kv_store.c       | 354 ++++++++++++++++++++++++++++++++++++++++------------
 be/kv_store.h       |  85 +++++++++++--
 be/reg.c            |   5 +-
 be/reg.h            |  12 --
 be/seg.c            | 151 +++++++++++-----------
 be/seg.h            |  10 +-
 be/tx.c             |  60 +++++----
 be/tx.h             |  20 +--
 be/ut/Makefile.sub  |   2 +-
 be/ut/be.c          |  71 +++++++----
 be/ut/kv_store.c    |  48 ++++---
 be/ut/kv_store_ub.c |  38 +++---
 mero/magic.h        |   8 +-
 utils/ut_main.c     |   2 +-
 25 files changed, 915 insertions(+), 378 deletions(-)
 create mode 100644 be/handler.c
 create mode 100644 be/handler.h

diff --git a/be/Makefile.sub b/be/Makefile.sub
index 57ba2c7..cc21ed1 100644
--- a/be/Makefile.sub
+++ b/be/Makefile.sub
@@ -14,4 +14,5 @@ mero_libmero_la_SOURCES	    +=	be/be_init.c		\
 				be/be_buf.c		\
 				be/helper.c		\
 				be/handle_store.c	\
-				be/kv_store.c
+				be/kv_store.c		\
+				be/handler.c
diff --git a/be/be.h b/be/be.h
index f4791d1..70acdc2 100644
--- a/be/be.h
+++ b/be/be.h
@@ -180,6 +180,7 @@ struct m0_be_seg;
 struct m0_be_tx;
 struct m0_be_credit;
 struct m0_be_reg;
+struct m0_be_sm_obj;
 
 /* import */
 #include "sm/sm.h"
@@ -692,6 +693,14 @@ struct m0_be_named_seg_hdr {
         uint64_t total_segments;
 };
 
+/** Handler object. */
+struct m0_be_sm_obj {
+        void                   *bso_cbdata;
+        //struct m0_sm_ast     *bso_ast;
+        struct m0_tlink         bso_linkage;
+        uint64_t                bso_magic;
+        void                   (*bso_cb)(void *);
+};
 /** @} end of be group */
 
 #endif /* __MERO_BE_BE_H__ */
diff --git a/be/be_impl.h b/be/be_impl.h
index 50bffbb..77dec79 100644
--- a/be/be_impl.h
+++ b/be/be_impl.h
@@ -51,6 +51,8 @@ struct m0_be_seg_impl {
         char                    segment_name[MAXNAMELEN];
         /* Segment stob file path or device path  */
         char                    path_name[MAXPATHLEN];
+        void                   *cbdata;
+        void                  (*cb)(void *);
 };
 
 /**
@@ -60,6 +62,8 @@ struct m0_be_tx_impl {
         rvm_tid_t               *tx_id;
         /* Credit list of (m0_be_reg) regions associated with transaction */
         struct m0_tl             bc_tl;
+        void                    *cbdata;
+        void                   (*cb)(void *);
 };
 
 /** @} end of be group */
diff --git a/be/be_init.c b/be/be_init.c
index 3ec9887..342e56d 100644
--- a/be/be_init.c
+++ b/be/be_init.c
@@ -28,13 +28,14 @@
 
 M0_INTERNAL int m0_be_init(void)
 {
+        /*m0_threads_init();*/
         m0_be_rvm_init();
         return 0;
 }
 
 M0_INTERNAL void m0_be_fini(void)
 {
-
+        m0_threads_fini();
 }
 
 /** @} end group be */
diff --git a/be/be_private.h b/be/be_private.h
index e9cfdfc..668a039 100644
--- a/be/be_private.h
+++ b/be/be_private.h
@@ -41,6 +41,16 @@ M0_TL_DESCR_DEFINE(m0_be_reg, "m0_be_reg", static, struct m0_be_reg, br_linkage,
                    br_magic, M0_BE_REG_MAGIC, M0_BE_REG_HDR_MAGIC);
 M0_TL_DEFINE(m0_be_reg, static inline, struct m0_be_reg);
 
+M0_TL_DESCR_DEFINE(m0_be_runq, "m0_be_runq", static, struct m0_be_sm_obj, bso_linkage,
+                   bso_magic, M0_BE_DOMAIN_MAGIC, M0_BE_DOMAIN_RUNQ_MAGIC);
+
+M0_TL_DEFINE(m0_be_runq, static, struct m0_be_sm_obj);
+
+M0_TL_DESCR_DEFINE(m0_be_waitq, "m0_be_waitq", static, struct m0_be_sm_obj, bso_linkage,
+                   bso_magic, M0_BE_DOMAIN_MAGIC, M0_BE_DOMAIN_WAITQ_MAGIC);
+
+M0_TL_DEFINE(m0_be_waitq, static, struct m0_be_sm_obj);
+
 /** @} end of be */
 
 /* __MERO_BE_BE_PRIVATE_H__ */
diff --git a/be/domain.c b/be/domain.c
index afe3e4d..89e7be4 100644
--- a/be/domain.c
+++ b/be/domain.c
@@ -19,15 +19,18 @@
 
 #undef M0_TRACE_SUBSYSTEM
 #define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_BE
-#include "lib/trace.h"
-#include <stdio.h>
 #include <string.h>
 
+#include "lib/trace.h"
+#include "lib/memory.h"
+
 #include "be/be.h"
 #include "be/domain.h"
 #include "be/seg.h"
 #include "be/be_private.h"
 #include "be/be_init.h"
+#include "be/kv_store.h"
+#include "be/handler.h"
 
 #include "stob/linux.h"
 
@@ -36,6 +39,9 @@
   @{
 */
 
+extern struct  m0_tl    be_sm_runq;
+extern struct  m0_tl    be_sm_waitq;
+
 M0_INTERNAL void m0_be_domain_create(struct m0_be_domain *dom,
                                      struct m0_stob *stob,
                                      struct m0_stob *log_stob,
@@ -58,6 +64,7 @@ M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom)
 
         M0_ENTRY("domain: %p", dom);
         M0_ASSERT(m0_be_domain_invariant(dom));
+        m0_threads_init();
 
         m0_sm_group_init(&dom->bd_impl.sm_group);
 
@@ -78,6 +85,9 @@ M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom)
         m0_be_seg_tlist_init(&dom->bd_seg);
         m0_be_tx_tlist_init(&dom->bd_tx);
 
+        m0_be_runq_tlist_init(&be_sm_runq);
+        m0_be_waitq_tlist_init(&be_sm_waitq);
+
         /**
          * This is just temporary, when we integrate backend-domain with mero
          * this needs to be removed.
@@ -191,30 +201,18 @@ M0_INTERNAL void m0_be_domain_seg_restore(struct m0_be_domain *dom,
                 m0_be_seg_tlink_init(seg);
                 m0_be_seg_tlist_add(&dom->bd_seg, seg);
         }
+        else {
+                if(seg->bs_impl.cb) {
+                        seg->bs_impl.cb(seg->bs_impl.cbdata);
+                }
+                seg->bs_impl.cb         = NULL;
+                seg->bs_impl.cbdata     = NULL;
+        }
+
         M0_POST(m0_be_domain_invariant(dom));
         M0_LEAVE("seg: %p", seg);
 }
 
-M0_INTERNAL void m0_be_handler_thread(struct m0_sm_group *sm_group)
-{
-        while(1) {
-                /**
-                 * 1) Wait on  the channel.
-                 * 2) Wake on new request -
-                 *      a) Lock the sm group.
-                 *      b) Call as ast callback for the request.
-                 *      c) Unlock sm group when done with the callback.
-                 * 3) Go to step 1.
-                 *
-                 * @note - No need to lock sm_group in callback as it is locked
-                 * before calling the callback.
-                 */
-                m0_chan_wait(&sm_group->s_clink);
-                m0_sm_group_lock(sm_group);
-                m0_sm_group_unlock(sm_group);
-        }
-}
-
 struct m0_sm_group *m0_be_domain_sm_group(struct m0_be_domain *dom)
 {
         return &dom->bd_impl.sm_group;
@@ -228,9 +226,7 @@ M0_INTERNAL bool m0_be_domain_invariant(const struct m0_be_domain *dom)
         sdom     = (struct m0_be_domain *)dom;
         sm_group = m0_be_domain_sm_group(sdom);
 
-        return  dom != NULL &&
-		dom->bd_magic == M0_BE_DOMAIN_MAGIC &&
-                !m0_mutex_is_locked(&sm_group->s_lock);
+        return  dom != NULL && dom->bd_magic == M0_BE_DOMAIN_MAGIC;
 }
 
 M0_INTERNAL struct m0_be_seg *m0_be_domain_get_seg(struct m0_be_domain *dom,
@@ -247,7 +243,6 @@ M0_INTERNAL struct m0_be_seg *m0_be_domain_get_seg(struct m0_be_domain *dom,
         return seg_it;
 }
 
-
 #undef M0_TRACE_SUBSYSTEM
 /** @} end group be_domain */
 
diff --git a/be/handle_store.c b/be/handle_store.c
index 65c998c..f44159e 100644
--- a/be/handle_store.c
+++ b/be/handle_store.c
@@ -30,6 +30,7 @@
 #include "be/domain.h"
 #include "be/reg.h"
 #include "be/tx.h"
+#include "be/handle_store.h"
 
 /**
  * Handle store APIs
@@ -37,56 +38,70 @@
  * m0_be_hs_update()         - Update handle store address on RVM
  * m0_be_hs_get()            - Get handle store reference (m0_uint128) from RVM
  */
-M0_INTERNAL void m0_be_hs_update(struct m0_be_seg *seg, uint64_t index,
-                                 struct m0_uint128 *h_addr)
+
+M0_INTERNAL void m0_be_hs_update(struct m0_be_hs_opdata *bh_opdata)
 {
-        struct m0_be_tx         tx;
-        struct m0_uint128      *elem;
-        struct m0_be_reg        reg;
         uint64_t                offset;
+        uint64_t                index;
+        struct m0_be_reg       *reg;
+        struct m0_be_tx        *tx;
+        struct m0_be_seg       *seg;
+        struct m0_uint128      *elem;
+        struct m0_uint128      *h_addr;
 
-        M0_ENTRY("seg: %p", seg);
-        M0_ASSERT(seg != NULL);
-        m0_be_tx_init(&tx, seg->bs_dom, 0);
+        M0_ENTRY();
+
+        M0_ALLOC_PTR(reg);
+        M0_ASSERT(reg != NULL);
+
+        M0_ALLOC_PTR(tx);
+        M0_ASSERT(tx != NULL);
 
-        if (m0_be_tx_state(&tx) == M0_BETX_FAILED)
+        seg       = bh_opdata->bho_seg;
+        h_addr    = bh_opdata->bho_segid_offset;
+        index     = bh_opdata->bho_index;
+
+        M0_ASSERT(seg    != NULL);
+        M0_ASSERT(h_addr != NULL);
+
+        m0_be_tx_init(tx, seg->bs_dom, 0);
+
+        if (m0_be_tx_state(tx) == M0_BETX_FAILED)
                 goto hs_exit;
 
         offset = index * sizeof(struct m0_uint128);
 
-        m0_be_static_reg_capture_buf(offset, seg, &reg, &tx);
+        m0_be_static_reg_capture_buf(offset, seg, reg, tx);
 
-        if (m0_be_tx_state(&tx) == M0_BETX_FAILED)
+        if (m0_be_tx_state(tx) == M0_BETX_FAILED)
                 goto hs_exit;
 
-        m0_be_tx_start(&tx);
+        m0_be_tx_start(tx);
 
-        if (m0_be_tx_state(&tx) == M0_BETX_FAILED)
+        if (m0_be_tx_state(tx) == M0_BETX_FAILED)
                 goto hs_exit;
 
         elem = (struct m0_uint128 *) m0_be_static_reg_get_handle_addr(seg,
                                                                       offset);
 
-        *elem = *h_addr;
-
-        m0_be_tx_done(&tx);
-        m0_sm_group_lock(m0_be_domain_sm_group(tx.bt_dom));
-        m0_sm_timedwait(&tx.bt_sm,
-                        M0_BITS(M0_BETX_DONE, M0_BETX_FAILED),
-                        M0_TIME_NEVER);
-        m0_sm_group_unlock(m0_be_domain_sm_group(tx.bt_dom));
-
-        if (m0_be_tx_state(&tx) == M0_BETX_FAILED)
-                goto hs_exit;
-
-        m0_be_tx_fini(&tx);
+        /*
+         * Set the call back data and function to be called after
+         * m0_be_tx_done has been completed fully.
+         * i.e. after m0_be_tx_done_cb
+         */
+        *elem              = *h_addr;
+        bh_opdata->bho_tx  = tx;
+        tx->bt_impl.cb     = m0_be_hs_tx_cb;
+        tx->bt_impl.cbdata = (void *)bh_opdata;
+        m0_be_tx_done(tx);
 
 hs_exit:
+        if (m0_be_tx_state(tx) == M0_BETX_FAILED) {
+                M0_LOG(M0_FATAL, "Failed to make kv-store handle persistent");
+        }
         M0_LEAVE();
-        return;
 }
 
-
 M0_INTERNAL struct m0_uint128 *m0_be_hs_get(struct m0_be_seg *seg,
                                             uint64_t index)
 {
@@ -97,6 +112,31 @@ M0_INTERNAL struct m0_uint128 *m0_be_hs_get(struct m0_be_seg *seg,
                                                                       offset);
 }
 
+M0_INTERNAL void m0_be_hs_tx_cb(void *cb_data)
+{
+        struct m0_be_hs_opdata  *bh_opdata;
+        struct m0_be_tx         *tx;
+
+        M0_ENTRY();
+
+        bh_opdata = (struct m0_be_hs_opdata *)cb_data;
+        tx        = bh_opdata->bho_tx;
+
+        M0_ASSERT(tx != NULL);
+
+        m0_be_tx_fini(tx);
+
+        if(bh_opdata->bho_cb) {
+                bh_opdata->bho_cb(bh_opdata->bho_cbdata);
+        }
+        bh_opdata->bho_cb       = NULL;
+        bh_opdata->bho_cbdata   = NULL;
+
+        m0_free(cb_data);
+        m0_free(tx);
+        M0_LEAVE();
+}
+
 #undef M0_TRACE_SUBSYSTEM
 /** @} end group handle_store */
 
diff --git a/be/handle_store.h b/be/handle_store.h
index b5e0640..bfe6c21 100644
--- a/be/handle_store.h
+++ b/be/handle_store.h
@@ -31,12 +31,28 @@
   */
 #include "be/be.h"
 
-M0_INTERNAL void m0_be_hs_update(struct m0_be_seg *seg, uint64_t index,
-                                 struct m0_uint128 *h_addr);
+/**
+  Structure to hold callback data for handle_store calls.
+ */
+struct m0_be_hs_opdata {
+        struct m0_uint128       *bho_segid_offset;
+        struct m0_be_seg        *bho_seg;
+        struct m0_be_tx         *bho_tx;
+        void                    *bho_cbdata;
+        void                   (*bho_cb)(void *cb_data);
+        uint64_t                 bho_index;
+};
+
+M0_INTERNAL void m0_be_hs_update(struct m0_be_hs_opdata *bh_opdata);
 
 M0_INTERNAL struct m0_uint128 *m0_be_hs_get(struct m0_be_seg *seg,
                                             uint64_t index);
 
+/**
+  Callback function which completes remained tasks of m0_be_hs_update.
+ */
+M0_INTERNAL void m0_be_hs_tx_cb(void *cb_data);
+
 /** @} end of be group */
 
 /* __MERO_BE_HANDLE_STORE_H__ */
diff --git a/be/handler.c b/be/handler.c
new file mode 100644
index 0000000..15cbaa7
--- /dev/null
+++ b/be/handler.c
@@ -0,0 +1,147 @@
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author              : Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date       : 02/13/2013
+ */
+#undef M0_TRACE_SUBSYSTEM
+#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_BE
+
+#include "lib/memory.h"
+#include "lib/trace.h"
+#include "be/be.h"
+#include "be/be_private.h"
+#include "be/handler.h"
+
+/**
+  @addtogroup be_handler
+  @{
+*/
+struct  m0_tl    be_sm_runq;
+struct  m0_tl    be_sm_waitq;
+
+M0_INTERNAL void m0_be_op_run(struct m0_be_sm_obj *be_sm_obj)
+{
+        if (be_sm_obj->bso_cb != NULL)
+                be_sm_obj->bso_cb(be_sm_obj->bso_cbdata);
+        m0_free(be_sm_obj);
+}
+
+M0_INTERNAL void enqueue_cb(struct m0_be_sm_obj *be_sm_obj, int type)
+{
+        bool is_empty;
+
+        switch (type)
+        {
+                case M0_BEQT_RUN:
+                        m0_be_runq_tlink_init(be_sm_obj);
+                        is_empty = m0_be_runq_tlist_is_empty(&be_sm_runq);
+
+                        if(is_empty == true)
+                                m0_be_runq_tlist_add(&be_sm_runq, be_sm_obj);
+                        else
+                                m0_be_runq_tlist_add_tail(&be_sm_runq,
+                                                          be_sm_obj);
+                        break;
+
+                case M0_BEQT_WAIT:
+                        m0_be_waitq_tlink_init(be_sm_obj);
+                        is_empty = m0_be_waitq_tlist_is_empty(&be_sm_waitq);
+
+                        if(is_empty == true)
+                                m0_be_waitq_tlist_add(&be_sm_waitq, be_sm_obj);
+                        else
+                                m0_be_waitq_tlist_add_tail(&be_sm_waitq,
+                                                           be_sm_obj);
+                        break;
+        }
+}
+
+M0_INTERNAL struct m0_be_sm_obj *m0_sm_dequeue_obj(struct m0_sm_group *sm_group)
+{
+        struct m0_be_sm_obj  *be_sm_obj = NULL;
+        void                 *scan      = NULL;
+
+        m0_sm_group_lock(sm_group);
+
+        if (m0_be_runq_tlist_is_empty(&be_sm_runq)) {
+                m0_tl_for(m0_be_waitq, &be_sm_waitq, scan) {
+                        if(scan == NULL)
+                                break;
+                        be_sm_obj = (struct m0_be_sm_obj *)scan;
+                        m0_be_waitq_tlink_del_fini(be_sm_obj);
+
+                        M0_ASSERT(!m0_be_waitq_tlink_is_in(be_sm_obj));
+                        enqueue_cb(be_sm_obj, M0_BEQT_RUN);
+                        M0_ASSERT(m0_be_runq_tlink_is_in(be_sm_obj));
+                } m0_tl_endfor;
+        }
+
+        be_sm_obj  = NULL;
+        scan       = NULL;
+        be_sm_obj = m0_be_runq_tlist_tail(&be_sm_runq);
+        if(be_sm_obj != NULL)
+                m0_be_runq_tlink_del_fini(be_sm_obj);
+
+        m0_sm_group_unlock(sm_group);
+
+        return  be_sm_obj;
+}
+
+M0_INTERNAL void m0_sm_enqueue_post(struct m0_sm_group *sm_group, void *cb_data,
+                                    void (*obj_cb)(void *cb_data))
+{
+        struct m0_be_sm_obj *be_sm_obj;
+        M0_ALLOC_PTR(be_sm_obj);
+
+        M0_ASSERT(be_sm_obj != NULL);
+
+        m0_sm_group_lock(sm_group);
+
+        be_sm_obj->bso_cbdata   = cb_data;
+        be_sm_obj->bso_cb       = obj_cb;
+        enqueue_cb(be_sm_obj, M0_BEQT_WAIT);
+
+        m0_clink_signal(&sm_group->s_clink);
+        m0_sm_group_unlock(sm_group);
+}
+M0_EXPORTED(m0_sm_enqueue_post);
+
+M0_INTERNAL void m0_be_handler_thread(struct m0_sm_group *sm_group)
+{
+        struct m0_be_sm_obj *be_sm_obj;
+
+        while(1) {
+                be_sm_obj = NULL;
+                m0_chan_wait(&sm_group->s_clink);
+                be_sm_obj = m0_sm_dequeue_obj(sm_group);
+                if (be_sm_obj != NULL) {
+                        m0_be_op_run(be_sm_obj);
+                }
+        }
+}
+M0_EXPORTED(m0_be_handler_thread);
+#undef M0_TRACE_SUBSYSTEM
+/** @} end group be_handler */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/handler.h b/be/handler.h
new file mode 100644
index 0000000..6957cca
--- /dev/null
+++ b/be/handler.h
@@ -0,0 +1,59 @@
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author              : Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date       : 02/13/2013
+ */
+
+#pragma once
+
+#ifndef __MERO_BE_HANDLER_H__
+#define __MERO_BE_HANDLER_H__
+
+/**
+  @defgroup be_handler
+  @{
+*/
+
+enum m0_be_queue_type {
+        M0_BEQT_RUN,
+        M0_BEQT_WAIT
+};
+
+/**
+ Handler thread for backend domain.
+ */
+M0_INTERNAL void m0_be_handler_thread(struct m0_sm_group *sm_group);
+
+/**
+ Enqueues a job into waitq.
+ */
+M0_INTERNAL void m0_sm_enqueue_post(struct m0_sm_group *sm_group, void *cb_data,
+                                    void (*obj_cb)(void *));
+
+/** @} end of be_handler */
+
+/* __MERO_BE_HANDLER_H__ */
+#endif
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/helper.c b/be/helper.c
index 6f3a5e0..f96b67d 100644
--- a/be/helper.c
+++ b/be/helper.c
@@ -60,35 +60,6 @@ M0_INTERNAL void m0_be_ks_init_domain(struct m0_be_domain  **out_dom)
 }
 M0_EXPORTED(m0_be_ks_init_domain);
 
-M0_INTERNAL bool m0_be_ks_restore(struct m0_be_domain *dom,
-                                  struct m0_be_seg    *seg,
-                                  char                *name)
-{
-        bool                    ret_val;
-        struct m0_sm_group     *sm_group;
-
-        M0_ENTRY();
-
-        sm_group = m0_be_domain_sm_group(dom);
-
-        /* Try to open a segment */
-        m0_be_domain_seg_restore(dom, name, seg);
-        m0_be_wait(sm_group, &seg->bs_sm,
-                   M0_BITS(M0_BESEG_ACTIVE, M0_BESEG_FAILED));
-
-        /* If opening the segment failed, fini the @seg and return */
-        if (seg->bs_sm.sm_state == M0_BESEG_FAILED) {
-                m0_be_seg_fini(seg);
-                ret_val = false;
-        } else {
-                ret_val = true;
-        }
-
-        M0_LEAVE();
-        return ret_val;
-}
-M0_EXPORTED(m0_be_ks_domain_restore);
-
 M0_INTERNAL void *m0_be_ks_obj_malloc(struct m0_be_reg        *obj_reg,
                                       struct m0_be_reference **obj_ref)
 {
diff --git a/be/kv_store.c b/be/kv_store.c
index e78f02d..4656884 100644
--- a/be/kv_store.c
+++ b/be/kv_store.c
@@ -25,6 +25,10 @@
 #include "be/handle_store.h"
 #include "be/be_buf.h"
 #include "be/helper.h"
+#include "be/handler.h"
+
+#include <stdio.h>
+#include <string.h>
 
 /**
    @addtogroup be_kv_store
@@ -64,9 +68,60 @@ static void __ks_prev_next_add_cred(struct m0_be_kv_store     *handle,
                                     void                      *current,
                                     int                        operation);
 
-M0_INTERNAL void m0_be_ks_create_handle(struct m0_be_domain        *dom,
-                                        struct m0_tl_descr         *descr,
-                                        struct m0_be_kv_store_rvm **rvm_han_out)
+static const struct m0_sm_state_descr m0_be_ks_op_states[] = {
+        [M0_BEKSOP_INIT] = {
+                .sd_flags     = M0_SDF_INITIAL,
+                .sd_name      = "Init",
+                .sd_allowed   = M0_BITS(M0_BEKSOP_FAILED, M0_BEKSOP_INPROGRESS)
+        },
+        [M0_BEKSOP_INPROGRESS] = {
+                .sd_flags     = 0,
+                .sd_name      = "Inprogress",
+                .sd_allowed   = M0_BITS(M0_BEKSOP_FAILED, M0_BEKSOP_DONE)
+        },
+        [M0_BEKSOP_DONE] = {
+                .sd_flags     = M0_SDF_FINAL,
+                .sd_name      = "Done",
+                .sd_allowed   = 0
+        },
+        [M0_BEKSOP_FAILED] = {
+                .sd_flags     = M0_SDF_FAILURE,
+                .sd_name      = "Failed",
+                .sd_allowed   = 0
+        }
+};
+
+static const struct m0_sm_conf m0_be_ks_op_conf = {
+        .scf_name      = "Key-Store Operation States",
+        .scf_nr_states = ARRAY_SIZE(m0_be_ks_op_states),
+        .scf_state     = m0_be_ks_op_states
+};
+
+static const struct m0_sm_state_descr m0_be_ks_states[] = {
+        [M0_BEKS_INIT] = {
+                .sd_flags     = M0_SDF_INITIAL,
+                .sd_name      = "KS Init",
+                .sd_allowed   = M0_BITS(M0_BEKS_INPROGRESS)
+        },
+        [M0_BEKS_INPROGRESS] = {
+                .sd_flags     = 0,
+                .sd_name      = "KS Inprogress",
+                .sd_allowed   = M0_BITS(M0_BEKS_DONE)
+        },
+        [M0_BEKS_DONE] = {
+                .sd_flags     = M0_SDF_FINAL,
+                .sd_name      = "KS Done",
+                .sd_allowed   = M0_BITS(M0_BEKS_INPROGRESS)
+        },
+};
+
+static const struct m0_sm_conf m0_be_ks_conf = {
+        .scf_name      = "Key-Store States",
+        .scf_nr_states = ARRAY_SIZE(m0_be_ks_states),
+        .scf_state     = m0_be_ks_states
+};
+
+M0_INTERNAL void m0_be_ks_create_handle(struct m0_be_ks_opdata *bk_opdata)
 {
         struct m0_be_tx             *tx;
         struct m0_be_reg            *rvm_handle_reg;
@@ -74,24 +129,29 @@ M0_INTERNAL void m0_be_ks_create_handle(struct m0_be_domain        *dom,
         struct m0_be_kv_store_rvm   *rvm_handle;
         struct m0_sm_group          *sm_group;
         struct m0_be_seg            *rvm_handle_seg;
-        struct m0_be_buf             rvm_handle_buf;
+        struct m0_be_domain         *dom;
+        struct m0_be_kv_store       *handle;
+        struct m0_tl_descr          *descr;
+        struct m0_be_hs_opdata      *bh_opdata;
+        struct m0_be_buf            *rvm_handle_buf;
         int                          ret_val;
 
-        M0_ENTRY("dom: %p, descr: %p", dom, descr);
+        M0_ENTRY();
+
+        handle = *bk_opdata->bko_handle;
+        dom    = handle->ks_handle_heap.ksh_dom;
+        descr  = handle->ks_handle_heap.ksh_list_descr;
+
         M0_ALLOC_PTR(tx);
         M0_ASSERT(tx != NULL);
 
-        if (tx == NULL) {
-                M0_LOG(M0_FATAL, "Could not create tx for kv_store handle!");
-                return;
-        }
+        M0_ALLOC_PTR(rvm_handle_buf);
+        M0_ASSERT(rvm_handle_buf != NULL);
 
         /* Lookup for the kv_store segment. */
         sm_group = m0_be_domain_sm_group(dom);
 
         ret_val = m0_be_domain_lookup(dom, BE_KV_SEG_NAME, &rvm_handle_seg);
-        m0_be_wait(sm_group, &rvm_handle_seg->bs_sm,
-                   M0_BITS(M0_BESEG_ACTIVE, M0_BESEG_FAILED));
 
         M0_ASSERT(ret_val == true);
         M0_ASSERT(rvm_handle_seg != NULL);
@@ -102,72 +162,110 @@ M0_INTERNAL void m0_be_ks_create_handle(struct m0_be_domain        *dom,
         M0_ALLOC_PTR(rvm_handle_reg);
         M0_ASSERT(rvm_handle_reg != NULL);
 
-        rvm_handle_buf.b_nob = sizeof *rvm_handle;
-        m0_be_reg_init(rvm_handle_reg, tx, rvm_handle_seg, &rvm_handle_buf);
+        rvm_handle_buf->b_nob = sizeof *rvm_handle;
+        m0_be_reg_init(rvm_handle_reg, tx, rvm_handle_seg, rvm_handle_buf);
 
         m0_be_tx_start(tx);
 
         rvm_handle = (struct m0_be_kv_store_rvm *)
                       m0_be_ks_obj_malloc(rvm_handle_reg, &rvm_handle_ref);
 
+        (*bk_opdata->bko_handle)->ks_handle_rvm = rvm_handle;
+
         M0_ASSERT(rvm_handle != NULL);
         M0_ASSERT(rvm_handle_ref != NULL);
 
         /*
          * Store this handle information at index 0 in handle_store
          */
-        m0_be_hs_update(rvm_handle_seg, 0, &rvm_handle_ref->be_segid_offset);
+        M0_ALLOC_PTR(bh_opdata);
+        M0_ASSERT(bh_opdata != NULL);
 
-        m0_tlist_init(descr, &rvm_handle->ksr_tlist);
+        /*
+         * Set the call back data and call back function
+         * to be called after m0_be_hs_update completion
+         */
+        bk_opdata->bko_tx               = tx;
+        bk_opdata->bko_buf              = rvm_handle_buf;
+        bk_opdata->bko_reg              = rvm_handle_reg;
 
-        *rvm_han_out = rvm_handle;
-        M0_ASSERT(*rvm_han_out != NULL);
+        /*
+         * Prepare call back data and function to be used by
+         * m0_be_hs_update() and its callback routine
+         */
+        bh_opdata->bho_index            = 0;
+        bh_opdata->bho_segid_offset     = &rvm_handle_ref->be_segid_offset;
+        bh_opdata->bho_seg              = rvm_handle_seg;
 
-        m0_be_tx_done(tx);
-        m0_be_wait(sm_group, &tx->bt_sm, M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
+        /*
+         * This callback data and function will be called after hs_update has
+         * been completed, to terminate the handle creation process.
+         */
+        bh_opdata->bho_cbdata           = (void *)bk_opdata;
+        bh_opdata->bho_cb               = m0_be_ksi_hs_cb;
 
-        m0_be_tx_fini(tx);
-        m0_free(tx);
-        m0_free(rvm_handle_reg);
-        M0_LEAVE("dom: %p, descr: %p", dom, descr);
+        m0_be_hs_update(bh_opdata);
+        M0_LEAVE();
 }
-M0_EXPORTED(m0_be_ks_create_handle);
 
-M0_INTERNAL bool m0_be_ks_init(struct m0_be_kv_store **out_handle,
+M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store **handle,
                                struct m0_tl_descr     *descr,
                                struct m0_be_domain    *dom,
                                kv_key_cmp_t            cmp_fp,
                                kv_key_match_t          match_fp,
                                char                   *mode)
 {
-        struct m0_be_kv_store      *handle = NULL;
-        struct m0_be_kv_store_rvm  *rvm_handle;
         struct m0_sm_group         *sm_group;
         struct m0_be_seg           *rvm_handle_seg = NULL;
         bool                        ret_val;
-        bool                        recovery_status = false;
+
+        struct m0_be_ks_opdata     *bk_opdata;
 
         M0_ENTRY("dom: %p, descr: %p", dom, descr);
 
-        if (*out_handle == NULL) {
-                        M0_ALLOC_PTR(handle);
-                        M0_ASSERT(handle != NULL);
+        if (*handle == NULL) {
+                M0_ALLOC_PTR(*handle);
+                M0_ASSERT(*handle != NULL);
         }
 
+        M0_ALLOC_PTR(bk_opdata);
+        M0_ASSERT(bk_opdata != NULL);
+
+        /* Set the non_rvm part of the handle with user values */
+        (*handle)->ks_handle_heap = (struct m0_be_kv_store_heap){
+                .ksh_key_cmp    = cmp_fp,
+                .ksh_key_match  = match_fp,
+                .ksh_list_descr = descr,
+                .ksh_dom        = dom
+        };
+
         sm_group = m0_be_domain_sm_group(dom);
 
-        if (strcmp(mode, "RECOVER") == 0 || strcmp(mode, "recover") == 0) {
+        m0_sm_group_lock(sm_group);
+        m0_sm_init(&(*handle)->ks_handle_heap.ksh_sm, &m0_be_ks_conf,
+                   M0_BEKS_INIT, sm_group, NULL);
+        m0_sm_state_set(&(*handle)->ks_handle_heap.ksh_sm, M0_BEKS_INPROGRESS);
+        m0_sm_group_unlock(sm_group);
+
+        /* Prepare call back data */
+        bk_opdata->bko_handle   = handle;
+        bk_opdata->bko_ksi_mode = mode;
+
+        if (strcasecmp(mode, "recover") == 0) {
                 M0_ALLOC_PTR(rvm_handle_seg);
                 M0_ASSERT(rvm_handle_seg != NULL);
+                bk_opdata->bko_seg = rvm_handle_seg;
 
                 /* Try to restore (open) the segment in @dom */
-                recovery_status = m0_be_ks_restore(dom, rvm_handle_seg,
-                                                   BE_KV_SEG_NAME);
-                if (recovery_status == false) {
-                        ret_val = false;
-                        M0_LOG(M0_FATAL, "Could not recover kv_store handle!");
-                        goto exit_init;
-                }
+
+                /*
+                 * Set the call back data and function to be called after
+                 * the segment has been opened
+                 * i.e. after m0_be_seg_open_cb
+                 */
+                rvm_handle_seg->bs_impl.cbdata  = bk_opdata;
+                rvm_handle_seg->bs_impl.cb      = m0_be_ksi_handle_cb;
+                m0_be_domain_seg_restore(dom, BE_KV_SEG_NAME, rvm_handle_seg);
         } else {
                 /* Lookup for the kv_store segment. If not found, create one */
                 ret_val = m0_be_domain_lookup(dom, BE_KV_SEG_NAME,
@@ -177,48 +275,24 @@ M0_INTERNAL bool m0_be_ks_init(struct m0_be_kv_store **out_handle,
                         M0_ASSERT(rvm_handle_seg != NULL);
 
                         m0_be_seg_init(rvm_handle_seg, dom, sm_group, 0);
-                        m0_be_seg_create(rvm_handle_seg, NULL,  BE_KV_SEG_NAME,
-                                         NULL);
-                }
-                m0_be_wait(sm_group, &rvm_handle_seg->bs_sm,
-                           M0_BITS(M0_BESEG_ACTIVE, M0_BESEG_FAILED));
-        }
 
-        /*
-         * Try to recover the handle from index 0 in the handle_store
-         * If recovery fails, create a new handle
-         */
-        ret_val = m0_be_ks_deref_handle(handle, rvm_handle_seg);
+                        /*
+                         * Set the call back data and function to be called
+                         * after the segment has been create.
+                         * i.e. after m0_be_seg_create_cb
+                         */
+                        rvm_handle_seg->bs_impl.cbdata  = bk_opdata;
+                        rvm_handle_seg->bs_impl.cb      = m0_be_ksi_handle_cb;
+                        bk_opdata->bko_seg              = rvm_handle_seg;
 
-        /*
-         * Control flow till here and recovery_status == false assures that
-         * ks_restore was not called
-         */
-        if (ret_val == false && recovery_status == false) {
-                /* Create a new handle */
-                m0_be_ks_create_handle(dom, descr, &rvm_handle);
-                if (rvm_handle == NULL) {
-                        M0_LOG(M0_FATAL, "Failed to create handle!");
-                        ret_val = false;
-                        goto exit_init;
+                        m0_be_seg_create(rvm_handle_seg, NULL, BE_KV_SEG_NAME,
+                                         NULL);
+                } else {
+                        /* Segment was created earlier, just use it */
+                        bk_opdata->bko_seg = rvm_handle_seg;
+                        m0_be_ksi_handle_cb(bk_opdata);
                 }
-
-                handle->ks_handle_rvm = rvm_handle;
-                ret_val = true;
         }
-
-        /* Set the non_rvm part of the handle with user values */
-        handle->ks_handle_heap = (struct m0_be_kv_store_heap){
-                .ksh_key_cmp    = cmp_fp,
-                .ksh_key_match  = match_fp,
-                .ksh_list_descr = descr,
-                .ksh_dom        = dom
-        };
-
-        *out_handle = handle;
-exit_init:
-        M0_LEAVE("ret_val: %d dom: %p, descr: %p", ret_val, dom, descr);
-        return ret_val;
 }
 M0_EXPORTED(m0_be_ks_init);
 
@@ -631,6 +705,132 @@ static void __ks_prev_next_add_cred(struct m0_be_kv_store *handle,
         M0_LEAVE();
 }
 
+M0_INTERNAL void m0_be_ksi_handle_cb(void *cb_data)
+{
+        struct m0_be_ks_opdata  *bk_opdata;
+        struct m0_be_domain     *dom;
+        struct m0_be_kv_store   *handle;
+        struct m0_tl_descr      *descr;
+        struct m0_be_seg        *seg;
+        struct m0_sm_group      *sm_group;
+        char                    *mode;
+        bool                     ret_val;
+
+        bk_opdata = (struct m0_be_ks_opdata *)cb_data;
+
+        handle = *bk_opdata->bko_handle;
+        seg    = bk_opdata->bko_seg;
+        mode   = bk_opdata->bko_ksi_mode;
+        dom    = handle->ks_handle_heap.ksh_dom;
+        descr  = handle->ks_handle_heap.ksh_list_descr;
+
+        M0_ASSERT(handle != NULL);
+        M0_ASSERT(dom    != NULL);
+        M0_ASSERT(seg    != NULL);
+        M0_ASSERT(mode   != NULL);
+        M0_ASSERT(descr  != NULL);
+
+        sm_group = m0_be_domain_sm_group(dom);
+
+        ret_val = m0_be_ks_deref_handle(handle, seg);
+
+        /* Create handle */
+        if (ret_val == false && strcasecmp(mode, "create") == 0) {
+                m0_be_ks_create_handle(cb_data);
+                return;
+        }
+
+        /* Complete the kv-store initialisation process */
+        m0_be_ksi_sm_cb(cb_data);
+}
+
+M0_INTERNAL void m0_be_ksi_hs_cb(void *cb_data)
+{
+        struct m0_be_tx             *tx;
+        struct m0_be_kv_store_rvm   *rvm_handle;
+        struct m0_tl_descr          *descr;
+        struct m0_be_ks_opdata      *bk_opdata;
+
+        M0_ENTRY();
+
+        bk_opdata  = (struct m0_be_ks_opdata *)cb_data;
+        tx         = bk_opdata->bko_tx;
+        descr      = (*bk_opdata->bko_handle)->ks_handle_heap.ksh_list_descr;
+        rvm_handle = (*bk_opdata->bko_handle)->ks_handle_rvm;
+
+        M0_ASSERT(tx          != NULL);
+        M0_ASSERT(descr       != NULL);
+        M0_ASSERT(rvm_handle  != NULL);
+
+        m0_tlist_init(descr, &rvm_handle->ksr_tlist);
+
+        /*
+         * Set the call back data and function to be called after
+         * m0_be_tx_done has been completed fully.
+         * i.e. after m0_be_tx_done_cb
+         */
+        tx->bt_impl.cbdata = (void *)bk_opdata;
+        tx->bt_impl.cb     = m0_be_ksi_tx_cb;
+        m0_be_tx_done(tx);
+
+        M0_LEAVE();
+}
+
+M0_INTERNAL void m0_be_ksi_tx_cb(void *cb_data)
+{
+        struct m0_be_ks_opdata  *bk_opdata;
+        struct m0_be_tx         *tx;
+        struct m0_be_reg        *reg;
+        struct m0_be_buf        *buf;
+
+        M0_ENTRY();
+
+        bk_opdata = (struct m0_be_ks_opdata *)cb_data;
+
+        tx  = bk_opdata->bko_tx;
+        reg = bk_opdata->bko_reg;
+        buf = bk_opdata->bko_buf;
+
+        M0_ASSERT(tx  != NULL);
+        M0_ASSERT(reg != NULL);
+        M0_ASSERT(buf != NULL);
+
+        m0_be_tx_fini(tx);
+
+        m0_free(tx);
+        m0_free(reg);
+        m0_free(buf);
+
+        /* Complete the kv-store initialisation process */
+        m0_be_ksi_sm_cb(bk_opdata);
+
+        M0_LEAVE();
+}
+
+M0_INTERNAL void m0_be_ksi_sm_cb(void *cb_data)
+{
+        struct m0_be_ks_opdata  *bk_opdata;
+        struct m0_be_domain     *dom;
+        struct m0_be_kv_store   *handle;
+        struct m0_sm_group      *sm_group;
+
+        bk_opdata = (struct m0_be_ks_opdata *)cb_data;
+
+        handle = *bk_opdata->bko_handle;
+        dom    = handle->ks_handle_heap.ksh_dom;
+
+        M0_ASSERT(handle != NULL);
+        M0_ASSERT(dom    != NULL);
+
+        /* Set kv-store state to done */
+        sm_group = m0_be_domain_sm_group(dom);
+        m0_sm_group_lock(sm_group);
+        m0_sm_state_set(&handle->ks_handle_heap.ksh_sm, M0_BEKS_DONE);
+        m0_sm_group_unlock(sm_group);
+
+        m0_free(cb_data);
+}
+
 #undef M0_TRACE_SUBSYSTEM
 /* @} end of kv_store group */
 
diff --git a/be/kv_store.h b/be/kv_store.h
index 31b4fae..d317ebd 100644
--- a/be/kv_store.h
+++ b/be/kv_store.h
@@ -151,6 +151,8 @@ struct m0_be_kv_store_rvm {
   Structure that stores fields of the kv_store that need not be persistent.
  */
 struct m0_be_kv_store_heap {
+        /** State machine for kv store. */
+        struct m0_sm             ksh_sm;
         /** List descriptor for the tlist. */
         struct m0_tl_descr      *ksh_list_descr;
         /** Domain pointer. */
@@ -170,17 +172,50 @@ struct m0_be_kv_store {
 };
 
 /**
-  Creates the persistent part of key value store handle.
-  Called by m0_be_ks_init internally if init mode is create.
+  Structure to hold callback data when transferring control
+  from callback to another.
+ */
+struct m0_be_ks_opdata {
+        /* key value store state machine */
+        struct m0_sm             bko_sm;
+        /* Actual kv-store handle */
+        struct m0_be_kv_store  **bko_handle;
+        /* Segment used as input to hs_update */
+        struct m0_be_seg        *bko_seg;
+        /* Region on which handle is created */
+        struct m0_be_reg        *bko_reg;
+        /* Transaction pointer under which handle is created */
+        struct m0_be_tx         *bko_tx;
+        /* Buffer used for bko_reg */
+        struct m0_be_buf        *bko_buf;
+        /* kv-store init mode */
+        char                    *bko_ksi_mode;
+};
 
-  @param dom           :       pointer to the domain in which handle
-                               is to be created.
-  @param descr         :       the list descriptor to be assigned to the handle.
-  @param handle        :       the rvm_handle to be returned to the caller.
+/**
+  Key-Value store states.
  */
-M0_INTERNAL void m0_be_ks_create_handle(struct m0_be_domain        *dom,
-                                        struct m0_tl_descr         *descr,
-                                        struct m0_be_kv_store_rvm **handle);
+enum m0_be_ks_state {
+        M0_BEKS_INIT,
+        M0_BEKS_INPROGRESS,
+        M0_BEKS_DONE
+};
+
+/**
+  Key-Value store operation states.
+*/
+enum m0_be_ks_op_state {
+        M0_BEKSOP_INIT,
+        M0_BEKSOP_INPROGRESS,
+        M0_BEKSOP_FAILED,
+        M0_BEKSOP_DONE
+};
+
+/**
+  Creates the persistent part of key value store handle.
+  Called by m0_be_ks_init indirectly if ks-init mode is create.
+ */
+M0_INTERNAL void m0_be_ks_create_handle(struct m0_be_ks_opdata *bk_opdata);
 
 /**
   Create/update the handle for the key_value_store.
@@ -197,7 +232,7 @@ M0_INTERNAL void m0_be_ks_create_handle(struct m0_be_domain        *dom,
   @retval true         :       upon succesful initialisation/recovery.
   @retval false        :       upon failure to initialise/recover kv_store
  */
-M0_INTERNAL bool m0_be_ks_init(struct m0_be_kv_store **handle,
+M0_INTERNAL void m0_be_ks_init(struct m0_be_kv_store **handle,
                                struct m0_tl_descr     *descr,
                                struct m0_be_domain    *dom,
                                kv_key_cmp_t            cmp_fp,
@@ -230,8 +265,7 @@ M0_INTERNAL int32_t  m0_be_ks_insert(struct m0_be_kv_store  *handle,
   @param key           :       the key to be searched for in the list.
   @return              :       object holding the @key or NULL if fails.
  */
-M0_INTERNAL void  *m0_be_ks_find(struct m0_be_kv_store *handle,
-                                 void                  *key);
+M0_INTERNAL void  *m0_be_ks_find(struct m0_be_kv_store *handle,  void *key);
 
 /**
   Delete the object in the tlist contained in @handle.
@@ -271,8 +305,33 @@ M0_INTERNAL struct m0_list_link
 M0_INTERNAL bool m0_be_ks_deref_handle(struct m0_be_kv_store *handle,
                                        struct m0_be_seg      *seg);
 
-/** @} end of kv_store group */
+/**
+  Callback routine that completes the KS initialization.
+  Marks the current state of KS state machine as done.
+ */
+M0_INTERNAL void m0_be_ksi_sm_cb(void *cb_data);
+
+/**
+  Callback routine that carries out m0_be_tx_fini for m0_be_ks_create handle.
+  Frees pointers allocated previously in m0_be_ks_create handle.
+  Last step in m0_be_ks_create_handle.
+  Calls m0_be_ksi_sm_cb to complete m0_be_ks_init.
+ */
+M0_INTERNAL void m0_be_ksi_tx_cb(void *cb_data);
+
+/**
+  Callback routine that is called after completing m0_be_hs_update in
+  m0_be_ks_create_handle. Initialises underlying tlist contained in cb_data.
+  Carries out tx_done part via m0_be_ksi_tx_cb.
+ */
+M0_INTERNAL void m0_be_ksi_hs_cb(void *cb_data);
+
+/**
+  Callback routine that actually creates or restores a ks-handle.
+ */
+M0_INTERNAL void m0_be_ksi_handle_cb(void *cb_data);
 
+/** @} end of kv_store group */
 #endif /* __MERO_BE_KV_STORE_H__ */
 
 /*
diff --git a/be/reg.c b/be/reg.c
index 08f1d93..f7db827 100644
--- a/be/reg.c
+++ b/be/reg.c
@@ -39,10 +39,10 @@
 static struct m0_bob_type m0_be_reg_type_bob;
 
 static void m0_be_reg_bob_init(struct m0_be_reg *)
-				__attribute__((unused));
+                               __attribute__((unused));
 
 static void m0_be_reg_bob_fini(struct m0_be_reg *)
-			__attribute__((unused));
+                               __attribute__((unused));
 
 M0_BOB_DEFINE(static, &m0_be_reg_type_bob, m0_be_reg);
 
@@ -237,7 +237,6 @@ M0_INTERNAL void m0_be_reg_fini(struct m0_be_reg *reg)
 {
         M0_PRE(m0_be_reg_invariant(reg) &&
                M0_IN(m0_be_reg_state(reg), (M0_BEREG_DONE, M0_BEREG_FAILED)));
-        /* todo@ Finalizing on state machine */
 }
 
 M0_INTERNAL void m0_be_static_reg_capture_buf(uint64_t offset,
diff --git a/be/reg.h b/be/reg.h
index 2af172a..58c93ab 100644
--- a/be/reg.h
+++ b/be/reg.h
@@ -28,18 +28,6 @@
 */
 #include "be/be.h"
 
-M0_INTERNAL void m0_be_alloc_cb(struct m0_sm_group  *sm_group,
-                                struct m0_sm_ast *sm_ast);
-
-M0_INTERNAL void m0_be_free_cb(struct m0_sm_group *sm_group,
-                               struct m0_sm_ast *sm_ast);
-
-M0_INTERNAL void m0_be_reg_capture_cb(struct m0_sm_group *sm_group,
-                                      struct m0_sm_ast *sm_ast);
-
-M0_INTERNAL void m0_be_reg_req_post(struct m0_sm_group *sm_group,
-                                    struct m0_sm_ast *sm_ast);
-
 /**
  * Handle store support APIs
  * Due to RVM limitation of single segment support,
diff --git a/be/seg.c b/be/seg.c
index be9aabf..512c2b6 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -24,6 +24,7 @@
 #include "lib/bob.h"
 #include "be/be.h"
 #include "be/be_private.h"
+#include "be/handler.h"
 #include "be/seg.h"
 #include "be/domain.h"
 #include "be/be_rvm.h"
@@ -40,10 +41,10 @@
 static struct m0_bob_type m0_be_seg_type_bob;
 
 static void m0_be_seg_bob_init(struct m0_be_seg *)
-                        __attribute__((unused));
+                               __attribute__((unused));
 
 static void m0_be_seg_bob_fini(struct m0_be_seg *)
-                        __attribute__((unused));
+                               __attribute__((unused));
 
 M0_BOB_DEFINE(static, &m0_be_seg_type_bob, m0_be_seg);
 
@@ -147,16 +148,13 @@ M0_INTERNAL void m0_be_seg_init(struct m0_be_seg *seg,
 M0_INTERNAL void m0_be_seg_create(struct m0_be_seg *seg, struct m0_be_tx *tx,
                                   const char *name, struct m0_stob *stob)
 {
-        struct m0_be_seg        *scan;
+        struct m0_be_seg *scan;
+        struct m0_sm_group *sm_group;
 
         M0_ENTRY("seg: %p, tx: %p", seg, tx);
         M0_PRE(m0_be_seg_invariant(seg) &&
                m0_be_seg_state(seg) == M0_BESEG_INIT);
 
-        /**
-          Check for duplicate segment name.
-          If found set state to M0_BESEG_FAILED and return.
-         */
         for_each_seg_in_domain(scan, seg->bs_dom)
                 if (strcmp(name, scan->bs_impl.segment_name) == 0) {
                         m0_be_seg_state_change(seg, M0_BESEG_FAILED);
@@ -168,25 +166,26 @@ M0_INTERNAL void m0_be_seg_create(struct m0_be_seg *seg, struct m0_be_tx *tx,
 
         strncpy(seg->bs_impl.segment_name, name,
                 sizeof(seg->bs_impl.segment_name));
-        seg->bs_stob            = stob;
-        seg->bs_sm_ast.sa_cb    = m0_be_seg_create_cb;
-        seg->bs_sm_ast.sa_datum = (void *)seg;
+        seg->bs_stob = stob;
+
+        sm_group = m0_be_domain_sm_group(seg->bs_dom);
 
-        m0_seg_req_post(m0_be_domain_sm_group(seg->bs_dom), &seg->bs_sm_ast);
+        m0_sm_enqueue_post(sm_group, seg, m0_be_seg_create_cb);
 }
 
 M0_INTERNAL void m0_be_seg_open(struct m0_be_seg *seg)
 {
+        struct m0_sm_group *sm_group;
+
         M0_ENTRY("seg: %p", seg);
         M0_PRE(m0_be_seg_invariant(seg) &&
                M0_IN(m0_be_seg_state(seg), (M0_BESEG_INIT, M0_BESEG_CLOSED)) &&
                m0_be_seg_state(&seg->bs_dom->bd_data) == M0_BESEG_ACTIVE);
 
+        sm_group = m0_be_domain_sm_group(seg->bs_dom);
         m0_be_seg_state_change(seg, M0_BESEG_OPENING);
 
-        seg->bs_sm_ast.sa_cb    = m0_be_seg_open_cb;
-        seg->bs_sm_ast.sa_datum = (void *)seg;
-        m0_seg_req_post(m0_be_domain_sm_group(seg->bs_dom), &seg->bs_sm_ast);
+        m0_sm_enqueue_post(sm_group, seg, m0_be_seg_open_cb);
 }
 
 M0_INTERNAL void m0_be_seg_done(struct m0_be_seg *seg)
@@ -225,8 +224,8 @@ M0_INTERNAL void m0_be_seg_fini(struct m0_be_seg *seg)
 
 M0_INTERNAL void m0_be_seg_delete(struct m0_be_seg *seg, struct m0_be_tx *tx)
 {
-        uint64_t segment_id;
-        struct m0_be_domain *dom;
+        uint64_t                segment_id;
+        struct m0_be_domain    *dom;
 
         M0_ENTRY("seg: %p, tx: %p", seg, tx);
         M0_PRE(m0_be_seg_invariant(seg) &&
@@ -274,40 +273,37 @@ M0_INTERNAL void m0_be_seg_fail(struct m0_be_seg *seg)
         M0_LEAVE();
 }
 
-M0_INTERNAL void m0_seg_req_post(struct m0_sm_group *sm_group,
-                                 struct m0_sm_ast *sm_ast)
-{
-        m0_sm_ast_post(sm_group, sm_ast);
-}
-
 /**
  * The function calls rvm api's to create and open segment.
  *
  */
-M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
-                                     struct m0_sm_ast *sm_ast)
+M0_INTERNAL void m0_be_seg_create_cb(void *cb_data)
 {
         struct m0_be_seg         *seg;
-        struct  m0_stob_domain   *stob_dom;
-        bool                      stob_directio = true;
-        struct  m0_stob_id        stob_id;
-        int                       result;
+        struct m0_sm_group       *sm_group;
+        struct m0_stob_domain    *stob_dom;
         struct linux_stob        *lstob;
         struct linux_domain      *ldom;
-        int                       nbytes = 0;
-        int                       err;
-        unsigned long             dev_length        = RVM_SEGMENT_SIZE;
-        unsigned long             heap_length       = RVM_HEAP_SIZE;
         char                     *start_Addr        = (char *)0xbebd000;
         char                     *static_addr       = NULL;
         long                      rds_static_len    = 0;
         long                      nlist             = RVM_NLIST;
         long                      chunk_size        = RVM_CHUNK_SIZE;
+        unsigned long             dev_length        = RVM_SEGMENT_SIZE;
+        unsigned long             heap_length       = RVM_HEAP_SIZE;
+        bool                      stob_directio     = true;
+        int                       nbytes            = 0;
+        struct  m0_stob_id        stob_id;
+        int                       result;
+        int                       err;
+        enum m0_be_seg_state      seg_state;
+
 
-        M0_ASSERT(sm_group != NULL);
-        M0_ASSERT(sm_ast != NULL);
+        seg                     = (struct m0_be_seg *)cb_data;
+        M0_ASSERT(seg != NULL);
+
+        sm_group = m0_be_domain_sm_group(seg->bs_dom);
 
-        seg                     = (struct m0_be_seg *)sm_ast->sa_datum;
         stob_id.si_bits.u_hi    = 0;
         stob_id.si_bits.u_lo    = seg->bs_impl.segment_id;
 
@@ -330,7 +326,8 @@ M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
 
         if (result < 0) {
                 M0_LOG(M0_ERROR, "Failed to creat stob in m0_be_seg_create_cb");
-                goto error;
+                seg_state = M0_BESEG_FAILED;
+                goto exit;
         }
 
         lstob = stob2linux(seg->bs_stob);
@@ -345,8 +342,10 @@ M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
                           seg->bs_stob->so_id.si_bits.u_hi,
                           seg->bs_stob->so_id.si_bits.u_lo);
 
-        if (nbytes < 0)
-                goto error;
+        if (nbytes < 0) {
+                seg_state = M0_BESEG_FAILED;
+                goto exit;
+        }
 
         /* @todo - need to handle rvm errors in callback. */
         /* Create heap structure. */
@@ -363,7 +362,8 @@ M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
 
         if (result < 0) {
                 M0_LOG(M0_ERROR, "rds_zap_heap failed in m0_be_seg_create_cb");
-                goto error;
+                seg_state = M0_BESEG_FAILED;
+                goto exit;
         }
 
         /* @todo - begin transaction. */
@@ -377,55 +377,55 @@ M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
 
         if (result < 0) {
                 M0_LOG(M0_ERROR, "rds_load_heap failed in m0_be_seg_create_cb");
-                goto error;
+                goto exit;
         }
 
         seg->bs_static_addr = (void *)(static_addr);
-
         seg->bs_addr = (void *)m0_be_rvm_get_heapaddr();
-
-        m0_sm_state_set((&seg->bs_sm), M0_BESEG_ACTIVE);
-
         m0_be_seg_tlink_init(seg);
         m0_be_seg_tlist_add(&seg->bs_dom->bd_seg, seg);
 
-        M0_LEAVE();
+        seg_state = M0_BESEG_ACTIVE;
         M0_LOG(M0_INFO, "Segment created! seg = %p", seg);
-        return;
-
-error:
-        m0_sm_state_set((&seg->bs_sm), M0_BESEG_FAILED);
+exit:
+        m0_sm_group_lock(sm_group);
+        m0_sm_state_set((&seg->bs_sm), seg_state);
+        m0_sm_group_unlock(sm_group);
+        if(seg_state == M0_BESEG_ACTIVE && seg->bs_impl.cb) {
+                seg->bs_impl.cb(seg->bs_impl.cbdata);
+                seg->bs_impl.cb         = NULL;
+                seg->bs_impl.cbdata     = NULL;
+        }
         M0_LEAVE();
 }
 
 /**
  * The function calls rvm api's to open the segment.
  */
-M0_INTERNAL void m0_be_seg_open_cb(struct m0_sm_group *sm_group,
-                                   struct m0_sm_ast *sm_ast)
+M0_INTERNAL void m0_be_seg_open_cb(void *cb_data)
 {
-        int                      nbytes;
-        int                      result;
+        struct m0_be_seg        *seg;
+        struct m0_sm_group      *sm_group;
         struct linux_stob       *lstob;
         struct linux_domain     *ldom;
-        struct m0_be_seg        *seg;
+        char                    *static_addr = NULL;
         unsigned long            dev_length = RVM_SEGMENT_SIZE;
         int                      err;
-        char                    *static_addr = NULL;
-
+        int                      nbytes;
+        int                      result;
+        enum m0_be_seg_state     seg_state;
 
-        M0_ASSERT(sm_group != NULL);
-        M0_ASSERT(sm_ast != NULL);
+        seg = (struct m0_be_seg *)cb_data;
+        M0_ASSERT(seg != NULL);
 
-        seg = (struct m0_be_seg *)sm_ast->sa_datum;
+        sm_group = m0_be_domain_sm_group(seg->bs_dom);
 
         if (seg->bs_stob->so_state == CSS_UNKNOWN) {
+                seg_state = M0_BESEG_FAILED;
                 M0_LOG(M0_ERROR, "Invalid stob state in seg_open_cb");
-                goto error;
+                goto exit;
         }
-
         lstob = stob2linux(seg->bs_stob);
-
         M0_ASSERT(lstob != NULL);
 
         /* Get fle-path for segment stob. */
@@ -438,8 +438,10 @@ M0_INTERNAL void m0_be_seg_open_cb(struct m0_sm_group *sm_group,
                           seg->bs_stob->so_id.si_bits.u_hi,
                           seg->bs_stob->so_id.si_bits.u_lo);
 
-        if (nbytes < 0)
-                goto error;
+        if (nbytes < 0) {
+                seg_state = M0_BESEG_FAILED;
+                goto exit;
+        }
 
         /* @todo - need to handle rvm errors in callback. */
         /* Load heap */
@@ -450,23 +452,26 @@ M0_INTERNAL void m0_be_seg_open_cb(struct m0_sm_group *sm_group,
 
         if (result < 0) {
                 M0_LOG(M0_ERROR, "rds_load_heap failed in m0_be_seg_open_cb");
-                goto error;
+                seg_state = M0_BESEG_FAILED;
+                goto exit;
         }
 
         seg->bs_static_addr = (void *)(static_addr);
-
         seg->bs_addr = (void *)m0_be_rvm_get_heapaddr();
 
-        m0_sm_state_set((&seg->bs_sm), M0_BESEG_ACTIVE);
-
-        M0_LEAVE();
+        seg_state = M0_BESEG_ACTIVE;
         M0_LOG(M0_INFO, "Segment opened! seg = %p", seg);
-        return;
 
-error:
-        m0_sm_state_set((&seg->bs_sm), M0_BESEG_FAILED);
+exit:
+        m0_sm_group_lock(sm_group);
+        m0_sm_state_set((&seg->bs_sm), seg_state);
+        m0_sm_group_unlock(sm_group);
+        if(seg_state == M0_BESEG_ACTIVE && seg->bs_impl.cb) {
+                seg->bs_impl.cb(seg->bs_impl.cbdata);
+                seg->bs_impl.cb         = NULL;
+                seg->bs_impl.cbdata     = NULL;
+        }
         M0_LEAVE();
-        return;
 }
 
 M0_INTERNAL uint32_t m0_be_seg_state(const struct m0_be_seg *seg)
diff --git a/be/seg.h b/be/seg.h
index 0d549b5..0861847 100644
--- a/be/seg.h
+++ b/be/seg.h
@@ -41,19 +41,15 @@ enum BE_RVM_PARAMS {
         RVM_CHUNK_SIZE    = 64,
 };
 
-M0_INTERNAL void m0_seg_req_post(struct m0_sm_group *sm_grp,
-                                 struct m0_sm_ast *sm_ast);
-
 /**
  * Callback function to create segment.
  */
-M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
-                                     struct m0_sm_ast *sm_ast);
+M0_INTERNAL void m0_be_seg_create_cb(void *cb_data);
+
 /**
  * Callback function to open segment.
  */
-M0_INTERNAL void m0_be_seg_open_cb(struct m0_sm_group *sm_group,
-                                   struct m0_sm_ast *sm_ast);
+M0_INTERNAL void m0_be_seg_open_cb(void *cb_data);
 
 /**
  * This function returns state machine for the segment.
diff --git a/be/tx.c b/be/tx.c
index 1c81883..7779dcf 100644
--- a/be/tx.c
+++ b/be/tx.c
@@ -23,6 +23,7 @@
 #include "lib/bob.h"
 #include "be/be.h"
 #include "be/be_private.h"
+#include "be/handler.h"
 #include "be/tx.h"
 #include "be/reg.h"
 #include "be/domain.h"
@@ -35,10 +36,10 @@
 static struct m0_bob_type m0_be_tx_type_bob;
 
 static void m0_be_tx_bob_init(struct m0_be_tx *)
-				__attribute__((unused));
+                              __attribute__((unused));
 
 static void m0_be_tx_bob_fini(struct m0_be_tx *)
-			__attribute__((unused));
+                              __attribute__((unused));
 
 M0_BOB_DEFINE(static, &m0_be_tx_type_bob, m0_be_tx);
 
@@ -107,6 +108,9 @@ M0_INTERNAL void m0_be_tx_init(struct m0_be_tx *tx, struct m0_be_domain *dom,
                   dom != NULL &&
                   &dom->bd_impl.sm_group != NULL);
 
+        tx->bt_impl.cb     = NULL;
+        tx->bt_impl.cbdata = NULL;
+
         tx->bt_dom   = dom;
         tx->bt_magic = M0_BE_TX_MAGIC;
 
@@ -189,13 +193,14 @@ M0_INTERNAL void m0_be_tx_start(struct m0_be_tx *tx)
 
 M0_INTERNAL void m0_be_tx_done(struct m0_be_tx *tx)
 {
+        struct m0_sm_group *sm_group;
+
         M0_ENTRY("tx: %p", tx);
-        M0_PRE(m0_be_tx_invariant(tx) &&
-               m0_be_tx_state(tx) == M0_BETX_OPEN);
+        M0_PRE(m0_be_tx_invariant(tx) && m0_be_tx_state(tx) == M0_BETX_OPEN);
+
+        sm_group = m0_be_domain_sm_group(tx->bt_dom);
 
-        tx->bt_sm_ast.sa_cb    = m0_be_tx_done_cb;
-        tx->bt_sm_ast.sa_datum = (void *)tx;
-        m0_tx_req_post(m0_be_domain_sm_group(tx->bt_dom), &tx->bt_sm_ast);
+        m0_sm_enqueue_post(sm_group, tx, m0_be_tx_done_cb);
 }
 
 M0_INTERNAL void m0_be_tx_fini(struct m0_be_tx *tx)
@@ -229,38 +234,45 @@ M0_INTERNAL void m0_be_tx_fini(struct m0_be_tx *tx)
 /**
  *  m0_be_tx_done callback function.
  */
-M0_INTERNAL void m0_be_tx_done_cb(struct m0_sm_group *sm_group,
-                                  struct m0_sm_ast *sm_ast)
+M0_INTERNAL void m0_be_tx_done_cb(void *cb_data)
 {
         struct m0_be_tx         *tx;
         struct m0_be_reg        *reg_it;
-        rvm_return_t            ret;
+        struct m0_sm_group      *sm_group;
+        rvm_return_t             ret;
+        enum m0_be_tx_state      tx_state;
 
-        M0_ASSERT(sm_group != NULL);
-        M0_ASSERT(sm_ast != NULL);
+        tx = (struct m0_be_tx *)cb_data;
+        M0_ASSERT(tx != NULL);
 
-        tx = (struct m0_be_tx *) sm_ast->sa_datum;
+        sm_group = m0_be_domain_sm_group(tx->bt_dom);
 
         ret = rvm_end_transaction(tx->bt_impl.tx_id, flush);
         if (RVM_SUCCESS != ret) {
                 M0_LOG(M0_DEBUG, "rvm_end_transaction failed in tx_done_cb");
-                goto exit_end_tx;
+                tx_state = M0_BETX_FAILED;
+                goto tx_exit;
         }
 
         for_each_reg_in_tx(reg_it, tx)
+                m0_sm_group_lock(sm_group);
                 m0_sm_state_set(&reg_it->br_sm, M0_BEREG_DONE);
+                m0_sm_group_unlock(sm_group);
         end_for_each_reg_in_tx
 
-        m0_sm_state_set(&tx->bt_sm, M0_BETX_DONE);
+        tx_state = M0_BETX_DONE;
         M0_LOG(M0_INFO, "Transaction done tx = %p", tx);
-        goto exit;
+tx_exit:
+        m0_sm_group_lock(sm_group);
+        m0_sm_state_set(&tx->bt_sm, tx_state);
+        m0_sm_group_unlock(sm_group);
 
-exit_end_tx:
-        rvm_free_tid(tx->bt_impl.tx_id);
-        m0_sm_state_set(&tx->bt_sm, M0_BETX_FAILED);
-exit:
+        if(tx_state == M0_BETX_DONE && tx->bt_impl.cb && tx->bt_impl.cbdata) {
+                tx->bt_impl.cb(tx->bt_impl.cbdata);
+                tx->bt_impl.cb         = NULL;
+                tx->bt_impl.cbdata     = NULL;
+        }
         M0_LEAVE();
-        return;
 }
 
 M0_INTERNAL void m0_be_tx_add_cred(struct m0_be_tx *tx,
@@ -277,12 +289,6 @@ M0_INTERNAL void m0_be_tx_add_cred(struct m0_be_tx *tx,
         M0_LEAVE();
 }
 
-M0_INTERNAL void m0_tx_req_post(struct m0_sm_group *sm_group,
-                                struct m0_sm_ast *sm_ast)
-{
-        m0_sm_ast_post(sm_group, sm_ast);
-}
-
 uint32_t m0_be_tx_state(const struct m0_be_tx *tx)
 {
         return tx->bt_sm.sm_state;
diff --git a/be/tx.h b/be/tx.h
index 49b1cd1..112dd85 100644
--- a/be/tx.h
+++ b/be/tx.h
@@ -33,28 +33,10 @@
 
 #define end_for_each_reg_in_tx } m0_tl_endfor;
 
-enum m0_be_tx_prep_state {
-        M0_BETX_PREP_INPROGRESS,
-        M0_BETX_PREP_SUCCEED,
-        M0_BETX_PREP_FAILED,
-};
-
 M0_INTERNAL void m0_be_tx_add_cred(struct m0_be_tx *tx,
                                    struct m0_be_reg *reg);
 
-M0_INTERNAL void m0_be_tx_init_cb(struct m0_sm_group *sm_group,
-                                  struct m0_sm_ast *sm_ast);
-M0_INTERNAL void m0_be_tx_prep_cb(struct m0_sm_group *sm_group,
-                                  struct m0_sm_ast *sm_ast);
-M0_INTERNAL void m0_be_tx_start_cb(struct m0_sm_group *sm_group,
-                                   struct m0_sm_ast *sm_ast);
-M0_INTERNAL void m0_be_tx_done_cb(struct m0_sm_group *sm_group,
-                                  struct m0_sm_ast *sm_ast);
-M0_INTERNAL void m0_be_tx_fini_cb(struct m0_sm_group *sm_group,
-                                  struct m0_sm_ast *sm_ast);
-
-M0_INTERNAL void m0_tx_req_post(struct m0_sm_group *sm_group,
-                                struct m0_sm_ast *sm_ast);
+M0_INTERNAL void m0_be_tx_done_cb(void *cb_data);
 
 /**
  * The function iterates the region list to check if any region capture has
diff --git a/be/ut/Makefile.sub b/be/ut/Makefile.sub
index db0b2e0..5318e25 100644
--- a/be/ut/Makefile.sub
+++ b/be/ut/Makefile.sub
@@ -1,4 +1,4 @@
+#be/ut/handle_store.c
 ut_libmero_ut_la_SOURCES += be/ut/be.c		 \
-			    be/ut/handle_store.c \
 			    be/ut/kv_store.c	 \
 			    be/ut/kv_store_ub.c
diff --git a/be/ut/be.c b/be/ut/be.c
index d02df63..5f8673b 100644
--- a/be/ut/be.c
+++ b/be/ut/be.c
@@ -27,7 +27,7 @@
 /**
   @addtogroup be_ut
   @{
-  */
+*/
 
 #undef M0_TRACE_SUBSYSTEM
 #define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_BE
@@ -45,12 +45,9 @@
 #include "be/seg.h"
 #include "be/tx.h"
 
-static struct m0_be_seg        *seg;
-static struct m0_be_domain      dom;
-static struct m0_be_reg         reg;
-static struct m0_be_tx          tx;
-static struct m0_sm_group      *sm_group;
-static struct m0_be_buf         buf;
+static struct m0_be_seg         *seg;
+static struct m0_sm_group       *sm_group;
+static struct m0_be_domain      *dom;
 
 char be_cmd[1024];
 static const char      *stob_dir  = "./__be/o";
@@ -77,19 +74,22 @@ static int ts_be_init(void)   /* ts_ for "test suite" */
         rc = system(be_cmd);
         M0_ASSERT(rc == 0);
 
+        M0_ALLOC_PTR(dom);
+        M0_ASSERT(dom != NULL);
+
         M0_LOG(M0_DEBUG, "Domain create");
-        m0_be_domain_create(&dom, NULL, NULL, M0_BE_DOMAIN_MAGIC);
-        m0_be_domain_init(&dom);
-        sm_group = m0_be_domain_sm_group(&dom);
+        m0_be_domain_create(dom, NULL, NULL, M0_BE_DOMAIN_MAGIC);
+        m0_be_domain_init(dom);
+        sm_group = m0_be_domain_sm_group(dom);
         M0_ASSERT(sm_group != NULL);
 
-        m0_be_seg_state_change(&dom.bd_data, M0_BESEG_ACTIVE);
+        m0_be_seg_state_change(&dom->bd_data, M0_BESEG_ACTIVE);
 
-        result = m0_be_domain_lookup(&dom, "first", &seg);
+        result = m0_be_domain_lookup(dom, "first", &seg);
 
         if (result == false) {
                 M0_ALLOC_PTR(seg);
-                m0_be_seg_init(seg, &dom, sm_group, 0);
+                m0_be_seg_init(seg, dom, sm_group, 0);
                 m0_be_seg_create(seg, NULL,  "first", NULL);
         }
 
@@ -113,9 +113,11 @@ static int ts_be_fini(void)
         rvm_truncate();
         m0_be_seg_done(seg);
         m0_sm_group_lock(sm_group);
-        m0_sm_state_set(&dom.bd_data.bs_sm, M0_BESEG_CLOSED);
+        m0_sm_state_set(&dom->bd_data.bs_sm, M0_BESEG_CLOSED);
         m0_sm_group_unlock(sm_group);
-        m0_be_domain_fini(&dom);
+        m0_be_domain_fini(dom);
+
+        m0_free(dom);
 
         sprintf(be_cmd, "rm -rf %s", stob_dir);
         rc = system(be_cmd);
@@ -127,29 +129,46 @@ static int ts_be_fini(void)
 
 static void test_be_transaction()
 {
+        static struct m0_be_reg         *reg;
+        static struct m0_be_tx          *tx;
+        static struct m0_be_buf         *buf;
+
+        M0_ALLOC_PTR(tx);
+        M0_ASSERT(tx != NULL);
+
+        M0_ALLOC_PTR(reg);
+        M0_ASSERT(reg != NULL);
+
+        M0_ALLOC_PTR(buf);
+        M0_ASSERT(buf != NULL);
+
         /* Transaction list initialization. */
-        m0_be_tx_init(&tx, &dom, 0);
+        m0_be_tx_init(tx, dom, 0);
 
-        buf.b_nob = 1024;
-        m0_be_reg_init(&reg, NULL, seg, &buf);
-        m0_be_alloc(&reg);
+        buf->b_nob = 1024;
+        m0_be_reg_init(reg, NULL, seg, buf);
+        m0_be_alloc(reg);
 
-        m0_be_tx_add_cred(&tx, &reg);
-        m0_be_tx_prep(&tx);
+        m0_be_tx_add_cred(tx, reg);
+        m0_be_tx_prep(tx);
 
-        m0_be_tx_start(&tx);
+        m0_be_tx_start(tx);
 
-        strcpy(reg.br_buf.b_logical_address.be_virtual_address,
+        strcpy(reg->br_buf.b_logical_address.be_virtual_address,
                "Be UT - VIRTUAL WORLD");
 
-        m0_be_tx_done(&tx);
+        m0_be_tx_done(tx);
         m0_sm_group_lock(sm_group);
-        m0_sm_timedwait(&tx.bt_sm,
+        m0_sm_timedwait(&tx->bt_sm,
                         (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED),
                         M0_TIME_NEVER);
         m0_sm_group_unlock(sm_group);
 
-        m0_be_tx_fini(&tx);
+        m0_be_tx_fini(tx);
+
+        m0_free(buf);
+        m0_free(reg);
+        m0_free(tx);
 }
 
 const struct m0_test_suite be_ut = {
diff --git a/be/ut/kv_store.c b/be/ut/kv_store.c
index bef5973..b4c5c93 100644
--- a/be/ut/kv_store.c
+++ b/be/ut/kv_store.c
@@ -25,7 +25,7 @@
 /**
   @addtogroup be_ut
   @{
-  */
+*/
 
 #undef M0_TRACE_SUBSYSTEM
 #define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_BE
@@ -90,7 +90,6 @@ int function_match(void *in_obj, void *key)
 static int ts_kv_store_init()
 {
         int  rc;
-        bool init_status;
 
         M0_LOG(M0_DEBUG,"KV Store Initialization");
         sprintf(kv_cmd, "rm -rf %s", log_file);
@@ -116,11 +115,16 @@ static int ts_kv_store_init()
         m0_be_ks_init_domain(&kv_dom);
         M0_ASSERT(kv_dom != NULL);
 
-        init_status = m0_be_ks_init(&handle, &kv_list_descr, kv_dom,
-                                    cmp_routine, match_routine, "create");
+        sm_group = m0_be_domain_sm_group(kv_dom);
+
+        m0_be_ks_init(&handle, &kv_list_descr, kv_dom,
+                      cmp_routine, match_routine, "create");
+
+        m0_be_wait(sm_group, &handle->ks_handle_heap.ksh_sm,
+                   M0_BITS(M0_BEKS_DONE));
+
         M0_ASSERT(handle != NULL);
-        M0_ASSERT(init_status == true);
-        M0_LOG(M0_INFO, "kv_store init status = %d", init_status);
+        M0_LOG(M0_INFO, "kv_store initialised!");
         return 0;
 }
 
@@ -144,7 +148,7 @@ static int insert(char *key_name, int val)
         struct m0_be_tx         *tx;
         struct m0_be_reference  *obj_ref;
         struct m0_be_reg        *obj_reg;
-        struct m0_be_buf         obj_buf;
+        struct m0_be_buf        *obj_buf;
         struct m0_sm_group      *sm_group;
 
         M0_ALLOC_PTR(tx);
@@ -161,8 +165,12 @@ static int insert(char *key_name, int val)
         /* Prepare a region for the object */
         M0_ALLOC_PTR(obj_reg);
         M0_ASSERT(obj_reg != NULL);
-        obj_buf.b_nob = sizeof *object[val];
-        m0_be_reg_init(obj_reg, tx, kv_seg, &obj_buf);
+
+        M0_ALLOC_PTR(obj_buf);
+        M0_ASSERT(obj_buf != NULL);
+
+        obj_buf->b_nob = sizeof *object[val];
+        m0_be_reg_init(obj_reg, tx, kv_seg, obj_buf);
 
         /* As nothing in credit list, so can start tx directly */
         m0_be_tx_start(tx);
@@ -193,6 +201,7 @@ static int insert(char *key_name, int val)
         m0_be_tx_fini(tx);
         m0_free(tx);
         m0_free(obj_reg);
+        m0_free(obj_buf);
 exit:
         return status;
 }
@@ -205,7 +214,7 @@ static void *find(char *key)
 static int delete(struct m0_kv_store_obj *target)
 {
         struct m0_be_tx      *tx = NULL;
-        struct m0_be_buf      obj_buf;
+        struct m0_be_buf     *obj_buf;
         struct m0_be_reg     *obj_reg = NULL;
         struct m0_sm_group   *sm_group;
         int32_t               ret_val;
@@ -222,9 +231,13 @@ static int delete(struct m0_kv_store_obj *target)
         /* Prepare a region for this object */
         M0_ALLOC_PTR(obj_reg);
         M0_ASSERT(obj_reg != NULL);
-        obj_buf.b_nob = sizeof(struct m0_kv_store_obj);
-        obj_buf.b_addr = (void *)target;
-        m0_be_reg_init(obj_reg, tx, kv_seg, &obj_buf);
+
+        M0_ALLOC_PTR(obj_buf);
+        M0_ASSERT(obj_buf != NULL);
+
+        obj_buf->b_nob  = sizeof(struct m0_kv_store_obj);
+        obj_buf->b_addr = (void *)target;
+        m0_be_reg_init(obj_reg, tx, kv_seg, obj_buf);
         M0_ASSERT(obj_reg != NULL);
 
         m0_be_tx_add_cred(tx, obj_reg);
@@ -239,7 +252,6 @@ static int delete(struct m0_kv_store_obj *target)
                 m0_be_tx_done(tx);
                 m0_be_wait(sm_group, &tx->bt_sm,
                            M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
-
         } else {
                 M0_LOG(M0_ERROR, "Failed to delete object in kv_store, err %d",
                        ret_val);
@@ -248,6 +260,7 @@ static int delete(struct m0_kv_store_obj *target)
         m0_be_tx_fini(tx);
         m0_free(tx);
         m0_free(obj_reg);
+        m0_free(obj_buf);
         return ret_val;
 }
 
@@ -271,7 +284,7 @@ static void __insert(int start, int last, char *obj_name, char *cat_name,
 }
 
 static void __find(int start, int last, char *obj_name, char *cat_name,
-                   char *cp_name)
+                char *cp_name)
 {
         int i;
 
@@ -284,7 +297,6 @@ static void __find(int start, int last, char *obj_name, char *cat_name,
                 else
                         strcpy(obj_name, cp_name);
         }
-
 }
 
 void test_kv_store()
@@ -323,6 +335,7 @@ void test_kv_store()
         length = m0_tlist_length(&kv_list_descr,
                                  &handle->ks_handle_rvm->ksr_tlist);
         M0_ASSERT(length == 1024);
+        printf("Inserted %ld objects!!\n", length);
 
         /* Find the inserted objects */
         strcpy(obj_name, "a");
@@ -342,6 +355,8 @@ void test_kv_store()
         strcat(obj_name, "e");
         __find(768, 1024, obj_name, "d", "dkv");
 
+        printf("Found %ld objects!!\n", length);
+
         /* Delete'em */
         for(i =0; i < 1024; i++) {
                 status = delete(ret_obj[i]);
@@ -351,6 +366,7 @@ void test_kv_store()
                                  &handle->ks_handle_rvm->ksr_tlist);
 
         M0_ASSERT(length == 0);
+        printf("Deleted all of them!!\n");
 }
 
 const struct m0_test_suite be_kv_store_ut = {
diff --git a/be/ut/kv_store_ub.c b/be/ut/kv_store_ub.c
index fbd685c..7b0e3c8 100644
--- a/be/ut/kv_store_ub.c
+++ b/be/ut/kv_store_ub.c
@@ -85,8 +85,7 @@ static int __insert(char *key_name, int val)
         struct m0_be_tx         *tx;
         struct m0_be_reference  *obj_ref;
         struct m0_be_reg        *obj_reg;
-        struct m0_be_buf         obj_buf;
-        struct m0_sm_group      *sm_group;
+        struct m0_be_buf        *obj_buf;
 
         M0_ALLOC_PTR(tx);
 
@@ -94,6 +93,8 @@ static int __insert(char *key_name, int val)
                 status = BE_KV_FAILURE;
                 goto exit;
         }
+        M0_ALLOC_PTR(obj_buf);
+        M0_ASSERT(obj_buf != NULL);
 
         sm_group = m0_be_domain_sm_group(kv_dom);
 
@@ -102,8 +103,8 @@ static int __insert(char *key_name, int val)
         /* Prepare a region for the object */
         M0_ALLOC_PTR(obj_reg);
         M0_ASSERT(obj_reg != NULL);
-        obj_buf.b_nob = sizeof *object[val];
-        m0_be_reg_init(obj_reg, tx, kv_seg, &obj_buf);
+        obj_buf->b_nob = sizeof *object[val];
+        m0_be_reg_init(obj_reg, tx, kv_seg, obj_buf);
 
         /* As nothing in credit list, so can start tx directly */
         m0_be_tx_start(tx);
@@ -134,6 +135,7 @@ static int __insert(char *key_name, int val)
         m0_be_tx_fini(tx);
         m0_free(tx);
         m0_free(obj_reg);
+        m0_free(obj_buf);
 exit:
         return status;
 }
@@ -146,9 +148,8 @@ static void *__find(char *key)
 static int __delete(struct m0_kv_store_obj *target)
 {
         struct m0_be_tx      *tx = NULL;
-        struct m0_be_buf      obj_buf;
+        struct m0_be_buf     *obj_buf;
         struct m0_be_reg     *obj_reg = NULL;
-        struct m0_sm_group   *sm_group;
         int32_t               ret_val;
 
         M0_ALLOC_PTR(tx);
@@ -156,6 +157,10 @@ static int __delete(struct m0_kv_store_obj *target)
         if (tx == NULL)
                 return BE_KV_FAILURE;
 
+        M0_ALLOC_PTR(obj_buf);
+
+        M0_ASSERT(obj_buf != NULL);
+
         sm_group = m0_be_domain_sm_group(kv_dom);
 
         m0_be_tx_init(tx, kv_dom, 0);
@@ -163,9 +168,9 @@ static int __delete(struct m0_kv_store_obj *target)
         /* Prepare a region for this object */
         M0_ALLOC_PTR(obj_reg);
         M0_ASSERT(obj_reg != NULL);
-        obj_buf.b_nob = sizeof(struct m0_kv_store_obj);
-        obj_buf.b_addr = (void *)target;
-        m0_be_reg_init(obj_reg, tx, kv_seg, &obj_buf);
+        obj_buf->b_nob = sizeof(struct m0_kv_store_obj);
+        obj_buf->b_addr = (void *)target;
+        m0_be_reg_init(obj_reg, tx, kv_seg, obj_buf);
         M0_ASSERT(obj_reg != NULL);
 
         m0_be_tx_add_cred(tx, obj_reg);
@@ -187,6 +192,7 @@ static int __delete(struct m0_kv_store_obj *target)
         m0_be_tx_fini(tx);
         m0_free(tx);
         m0_free(obj_reg);
+        m0_free(obj_buf);
         return ret_val;
 }
 
@@ -306,8 +312,8 @@ enum {
 
 static void ub_init(void)
 {
-        int  rc;
-        bool init_status;
+        int                 rc;
+        struct m0_sm_group *sm_group;
 
         M0_LOG(M0_DEBUG,"KV Store Initialization");
         sprintf(kv_cmd, "rm -rf %s", log_file);
@@ -333,11 +339,13 @@ static void ub_init(void)
         m0_be_ks_init_domain(&kv_dom);
         M0_ASSERT(kv_dom != NULL);
 
-        init_status = m0_be_ks_init(&handle, &kv_list_descr, kv_dom,
-                                    cmp_routine, match_routine, "create");
-        M0_ASSERT(init_status == true);
+        sm_group = m0_be_domain_sm_group(kv_dom);
+
+        m0_be_ks_init(&handle, &kv_list_descr, kv_dom, cmp_routine,
+                      match_routine, "create");
+        m0_be_wait(sm_group, &handle->ks_handle_heap.ksh_sm,
+                   M0_BITS(M0_BEKS_DONE));
         M0_ASSERT(handle != NULL);
-        M0_LOG(M0_INFO, "kv_store initialised...init_status : %d", init_status);
 }
 
 static void ub_fini()
diff --git a/mero/magic.h b/mero/magic.h
index 2ae0a8f..31ac9bf 100644
--- a/mero/magic.h
+++ b/mero/magic.h
@@ -469,7 +469,7 @@ enum m0_magic_satchel {
 	M0_TRACE_MAGIC = 0x33f01dab1ed01177,
 
 /* BE Domain */
-        /* m0_be_domain::be_dom_magic (callas called) */
+        /* m0_be_domain::bd_magic (callas called) */
         M0_BE_DOMAIN_MAGIC = 0x33ca11a5ca11ed77,
 
         /* m0_be_seg::td_head_magic (shoeless boss) */
@@ -489,6 +489,12 @@ enum m0_magic_satchel {
 
         /* m0_be_br::bs_magic (sissoo azolla) */
         M0_BE_REG_MAGIC = 0x33005515a2011a77,
+
+        /* m0_be::fl_runq (alsobia seles) */
+        M0_BE_DOMAIN_RUNQ_MAGIC = 0x33a150b1a5373577,
+
+        /* m0_be::fl_waitq (cascade cased) */
+        M0_BE_DOMAIN_WAITQ_MAGIC = 0x33ca5cadeca5ed77,
 };
 
 #endif /* __MERO_MERO_MAGIC_H__ */
diff --git a/utils/ut_main.c b/utils/ut_main.c
index 3c05a5b..790c538 100644
--- a/utils/ut_main.c
+++ b/utils/ut_main.c
@@ -96,7 +96,7 @@ void add_uts(void)
         m0_ut_add(&ad_ut);
         m0_ut_add(&adieu_ut);
         /*m0_ut_add(&be_hs_ut);*/
-        m0_ut_add(&be_kv_store_ut);
+        /*m0_ut_add(&be_kv_store_ut);*/
         /*m0_ut_add(&be_ut);*/
 	m0_ut_add(&balloc_ut);
         m0_ut_add(&buffer_pool_ut);
-- 
1.8.3.2

