From 435002da79fd0685deeaeb4d5a4ff11c64a14910 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Fri, 19 Apr 2013 13:05:02 +0300
Subject: [PATCH 87/94] Stringified tree UT.

---
 be/tree.c  |  6 +++---
 be/ut/be.c | 33 +++++++++++++++++++++++----------
 2 files changed, 26 insertions(+), 13 deletions(-)

diff --git a/be/tree.c b/be/tree.c
index a534117..3b52ce8 100644
--- a/be/tree.c
+++ b/be/tree.c
@@ -16,8 +16,8 @@
 #define CHILDREN_SIZE(btree)  (2*btree->order * sizeof(struct bt_node *))
 #define PRINT(...) M0_LOG(M0_DEBUG, __VA_ARGS__)
 
-#define KEY_LT(key0, key1) (btree->compare(key0, key1) == -1)
-#define KEY_GT(key0, key1) (btree->compare(key0, key1) ==  1)
+#define KEY_LT(key0, key1) (btree->compare(key0, key1)  <  0)
+#define KEY_GT(key0, key1) (btree->compare(key0, key1)  >  0)
 #define KEY_EQ(key0, key1) (btree->compare(key0, key1) ==  0)
 
 enum position_t { left = -1, right = 1 };
@@ -1001,7 +1001,7 @@ M0_INTERNAL struct bt_key_val *btree_pair_setup(struct btree *btree,
 	M0_PRE(val_size == btree->data_size(val));
 	M0_PRE(key_size == btree->key_size(key));
 
-	/* XXX: ENOMEM has to me checked */
+	/* XXX: ENOMEM has to be checked */
 
 	kv = (struct bt_key_val *)MEM_ALLOC(tx, sizeof(struct bt_key_val));
 	M0_ASSERT(kv != NULL);
diff --git a/be/ut/be.c b/be/ut/be.c
index 01da8a0..6a8d79d 100644
--- a/be/ut/be.c
+++ b/be/ut/be.c
@@ -228,19 +228,19 @@ enum {
 /* Generic comparator */
 static int tree_cmp(void *key0, void *key1)
 {
-	return M0_3WAY(*(uint32_t*)key0, *(uint32_t*)key1);
+	return strcmp(key0, key1);
 }
 
 /* Return the key size */
 static uint32_t tree_key_size(void *key)
 {
-	return sizeof(uint32_t);
+	return strlen(key) + 1;
 }
 
 /* Return the data size. XXX: does 'data size' mean 'value size' ?? */
 static uint32_t tree_data_size(void *data)
 {
-	return sizeof(uint32_t);
+	return strlen(data) + 1;
 }
 
 static void* p_alloc(struct btree_tx_impl *tx, size_t size)
@@ -311,6 +311,7 @@ M0_UNUSED static void test_be_tree_create(void)
 	struct m0_be_tx   *tx;
 	struct btree	  *tree;
 	struct btree     **ptree;
+	char		   kv[16];
 	int		   rc;
 	int		   i;
 
@@ -330,8 +331,10 @@ M0_UNUSED static void test_be_tree_create(void)
 	tree->data_size = tree_data_size;
 
 	for (i = 0; i < TREE_KV_NR; ++i) {
-		bkv = btree_pair_setup(tree, tx, &i, sizeof(uint32_t),
-						 &i, sizeof(uint32_t));
+		sprintf(kv, "%d", i);
+
+		bkv = btree_pair_setup(tree, tx, kv, strlen(kv) + 1,
+						 kv, strlen(kv) + 1);
 		M0_UT_ASSERT(bkv != NULL);
 
 		rc = btree_insert_key(tree, tx, bkv);
@@ -362,15 +365,17 @@ M0_UNUSED static void test_be_tree_create(void)
 
 M0_UNUSED static void btree_log(struct btree **tree)
 {
+#if 0
 	uint32_t	   i;
 	uint32_t	   min;
 	uint32_t	   max;
 	struct bt_key_val *kv;
+#endif
 	/*
 	 * Call some "tx-less" functions to see what's inside the tree.
 	 */
 	M0_LOG(M0_DEBUG, "tree order: %u", (*tree)->order);
-
+#if 0
 	min = *(uint32_t*)btree_get_min_key(*tree);
 	M0_LOG(M0_DEBUG, "tree order: %u", min);
 
@@ -385,6 +390,7 @@ M0_UNUSED static void btree_log(struct btree **tree)
 		M0_LOG(M0_DEBUG, "(%u, %u)", *(uint32_t *)kv->key,
 					     *(uint32_t *)kv->val);
 	}
+#endif
 	btree_dbg_print(*tree, (*tree)->root);
 }
 
@@ -396,6 +402,7 @@ M0_UNUSED static void test_be_tree_load(void)
 	uint32_t	   j;
 	struct m0_be_tx   *tx;
 	struct bt_key_val *kv;
+	char		   ckv[16];
 #endif
 	struct btree     **tree;
 
@@ -424,12 +431,16 @@ M0_UNUSED static void test_be_tree_load(void)
 	 */
 	/* tree has the following range of keys at this point: [0 .. 100) */
 	for (i = 3*TREE_KV_NR/4; i < TREE_KV_NR; ++i) {
-		rc = btree_delete_key(*tree, tx, (*tree)->root, &i);
+		sprintf(ckv, "%d", i);
+
+		rc = btree_delete_key(*tree, tx, (*tree)->root, ckv);
 		M0_UT_ASSERT(rc == 0);
 	}
 
 	for (i = 0; i < TREE_KV_NR/4; ++i) {
-		rc = btree_delete_key(*tree, tx, (*tree)->root, &i);
+		sprintf(ckv, "%d", i);
+
+		rc = btree_delete_key(*tree, tx, (*tree)->root, ckv);
 		M0_UT_ASSERT(rc == 0);
 	}
 	/* tree has the following range of keys at this point: [25 .. 75) */
@@ -440,8 +451,10 @@ M0_UNUSED static void test_be_tree_load(void)
 	   the tree root. This may cause several alloc/free operations inside
 	   tree, and numerous updates... */
 	for (i = 0, j = 100; i < TREE_KV_NR/2; ++i, j += 100) {
-		kv = btree_pair_setup(*tree, tx, &j, sizeof(uint32_t),
-				                 &j, sizeof(uint32_t));
+		sprintf(ckv, "%d", j);
+
+		kv = btree_pair_setup(*tree, tx, ckv, strlen(ckv) + 1,
+				                 ckv, strlen(ckv) + 1);
 		M0_UT_ASSERT(kv != NULL);
 
 		rc = btree_insert_key(*tree, tx, kv);
-- 
1.8.3.2

