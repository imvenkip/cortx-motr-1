From ff3aeecfb2e037b704969ae679e1c27a7cd279f6 Mon Sep 17 00:00:00 2001
From: Sachin Patil <sachin_patil@xyratex.com>
Date: Thu, 27 Dec 2012 08:44:28 -0800
Subject: [PATCH 19/94] Implemented sm for regions

---
 be/be.h              |  45 ++++++---
 be/be_domain.c       |   9 +-
 be/be_impl.h         |   7 ++
 be/be_reg.c          | 274 ++++++++++++++++++++++++++++++++++++---------------
 be/be_reg.h          |  55 +++++++++++
 be/be_tx.c           |  71 ++++++++++++-
 be/be_tx.h           |  11 +++
 be/lib/be_kv_store.c |   9 +-
 be/lib/ut/be_tlist.c |   6 +-
 be/ut/be.c           |   4 +-
 10 files changed, 378 insertions(+), 113 deletions(-)
 create mode 100644 be/be_reg.h

diff --git a/be/be.h b/be/be.h
index 8b7c4dc..c5b8b18 100644
--- a/be/be.h
+++ b/be/be.h
@@ -200,6 +200,7 @@ struct m0_be_reg;
 
 #include "be/be_seg.h"
 #include "be/be_tx.h"
+#include "be/be_reg.h"
 #include "be/be_rvm.h"
 
 struct m0_be_buf;
@@ -210,10 +211,9 @@ struct m0_be_buf;
  *
  * @post dom->bd_data.bs_sm.sm_state == M0_BESEG_CLOSED
  */
-//void m0_be_domain_init  (struct m0_be_domain *dom, struct m0_stob *stob);
-M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom,
-                                   struct m0_stob *stob,
-                                   struct m0_stob *log_stob);
+//void m0_be_domain_init  (struct m0_be_domain *dom, struct m0_stob *stob,
+//                                      struct m0_stob *log_stob);
+M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom);
 
 /**
  * Finalises the in-memory part of domain structure.
@@ -502,6 +502,20 @@ struct m0_be_domain {
 };
 
 /**
+ * Region callback data from transaction layer.
+ */
+
+struct m0_be_capture_cb {
+        void *datum;
+
+        /* pre-capture callback */
+        int (* m0_be_tx_pre_cb)(void *);
+
+        /* post-capture callback */
+        void (* m0_be_tx_post_cb)(void *);
+};
+
+/**
  * Back-end transaction.
  */
 struct m0_be_tx {
@@ -526,18 +540,25 @@ struct m0_be_tx {
  */
 struct m0_be_reg {
         /** State machine. @see enum m0_be_reg_state. */
-        struct m0_sm      br_sm;
+        struct m0_sm br_sm;
+        /* callback object for sm */
+        struct m0_sm_ast br_sm_ast;
         /** Transaction this region is used in. */
-        struct m0_be_tx  *br_tx;
+        struct m0_be_tx *br_tx;
+        /** This should be filled along with br_tx */
+        struct m0_be_capture_cb br_tx_cbdata;
+        /** Segment for this region */
         struct m0_be_seg *br_seg;
         /** Extent in the segment. */
-        struct m0_be_buf  br_buf;
-
+        struct m0_be_buf br_buf;
         /** Linkage in the list of credit list, m0_be_credit::bc_tl */
-        struct m0_tlink   bc_linkage;
+        struct m0_tlink br_linkage;
 
         /* tlink magic field */
-        uint64_t          bc_magic;
+        uint64_t br_magic;
+
+        /** Implementation private fields. */
+        struct m0_be_reg_impl br_impl;
 };
 
 enum m0_be_seg_state {
@@ -595,8 +616,8 @@ M0_TL_DESCR_DEFINE(m0_be_tx, "m0_be_tx", static, struct m0_be_tx, bt_linkage,
 M0_TL_DEFINE(m0_be_tx, static, struct m0_be_tx);
 
 /* m0_tlist definition for credit list - m0_be_crd_tlist */
-M0_TL_DESCR_DEFINE(m0_be_reg, "m0_be_reg", static, struct m0_be_reg, bc_linkage,
-                   bc_magic, 0xc2be3248c1be3248, 0x8423eb1c8423eb2c);
+M0_TL_DESCR_DEFINE(m0_be_reg, "m0_be_reg", static, struct m0_be_reg, br_linkage,
+                   br_magic, 0xc2be3248c1be3248, 0x8423eb1c8423eb2c);
 M0_TL_DEFINE(m0_be_reg, static, struct m0_be_reg);
 
 /** @} end of be group */
diff --git a/be/be_domain.c b/be/be_domain.c
index 6e1f737..ed5fd2b 100644
--- a/be/be_domain.c
+++ b/be/be_domain.c
@@ -59,19 +59,16 @@ M0_INTERNAL void m0_be_domain_create(struct m0_be_domain **out)
  *
  * @post dom->bd_data.bs_sm.sm_state == M0_BESEG_CLOSED
  */
-M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom,
-                                   struct m0_stob *stob,
-                                   struct m0_stob *log_stob)
+M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom)
 {
-
         /* Asserting on required pointers */
         M0_ASSERT(dom != NULL);
-        M0_ASSERT(stob != NULL);
-        M0_ASSERT(log_stob != NULL);
 
         /* Initialise domain structure with required values */
+        /*
         dom->bd_data.bs_stob    = stob;
         dom->bd_impl.log_stob   = log_stob;
+        */
 
         m0_be_seg_init(&(dom->bd_data), dom, &(dom->bd_impl.sm_group), 0);
 
diff --git a/be/be_impl.h b/be/be_impl.h
index 764c290..3b53d81 100644
--- a/be/be_impl.h
+++ b/be/be_impl.h
@@ -67,6 +67,13 @@ struct m0_be_tx_impl {
         struct m0_sm_group      *sm_group;
 };
 
+/**
+ * Backend regions private implementation.
+ */
+struct m0_be_reg_impl {
+        struct m0_sm_group *sm_group;
+};
+
 /** @} end of be group */
 
 /* __MERO_BE_BE_IMPL_H__ */
diff --git a/be/be_reg.c b/be/be_reg.c
index 4355f8c..0d3066a 100644
--- a/be/be_reg.c
+++ b/be/be_reg.c
@@ -34,8 +34,7 @@ static const struct m0_sm_state_descr reg_states[] = {
                 .sd_in        = NULL,
                 .sd_ex        = NULL,
                 .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BEREG_INPROGRESS)  |
-                                (1 << M0_BEREG_DONE)        |
+                .sd_allowed   = (1 << M0_BEREG_INPROGRESS)      |
                                 (1 << M0_BEREG_FAILED)
         },
         [M0_BEREG_INPROGRESS] = {
@@ -44,26 +43,25 @@ static const struct m0_sm_state_descr reg_states[] = {
                 .sd_in        = NULL,
                 .sd_ex        = NULL,
                 .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BEREG_DONE)        |
-                                (1 << M0_BEREG_SUCCEED)     |
+                .sd_allowed   = (1 << M0_BEREG_DONE)            |
+                                (1 << M0_BEREG_SUCCEED)         |
                                 (1 << M0_BEREG_FAILED)
         },
-        [M0_BEREG_DONE] = {
-                .sd_flags     = 0,
-                .sd_name      = "BE REG DONE",
+        [M0_BEREG_SUCCEED] = {
+                .sd_flags     = M0_SDF_FINAL,
+                .sd_name      = "BE REG SUCCEED",
                 .sd_in        = NULL,
                 .sd_ex        = NULL,
                 .sd_invariant = NULL,
-                .sd_allowed   = (1 << M0_BEREG_SUCCEED)     |
-                                (1 << M0_BEREG_FAILED)
+                .sd_allowed   = (1 << M0_BEREG_DONE)
         },
-        [M0_BEREG_SUCCEED] = {
+        [M0_BEREG_DONE] = {
                 .sd_flags     = M0_SDF_TERMINAL,
-                .sd_name      = "BE REG SUCCEED",
+                .sd_name      = "BE REG DONE",
                 .sd_in        = NULL,
                 .sd_ex        = NULL,
                 .sd_invariant = NULL,
-                .sd_allowed   = 0
+                .sd_allowed   = 0,
         },
         [M0_BEREG_FAILED] = {
                 .sd_flags     = M0_SDF_FAILURE,
@@ -94,7 +92,7 @@ M0_INTERNAL void m0_be_reg_init(struct m0_be_reg **reg_out, struct m0_be_tx *tx,
         M0_ASSERT(seg != NULL);
         M0_ASSERT(buf != NULL);
 
-        reg = (struct m0_be_reg *)malloc(sizeof(struct m0_be_reg)); 
+        M0_ALLOC_PTR(reg);
 
         if (reg == NULL) {
                 /* TODO@ : malloc failed */
@@ -103,19 +101,27 @@ M0_INTERNAL void m0_be_reg_init(struct m0_be_reg **reg_out, struct m0_be_tx *tx,
 
         /* Initialise region structure with required values */
         reg->br_tx  = tx;
+        reg->br_tx_cbdata.datum = (void *)tx;
+        reg->br_tx_cbdata.m0_be_tx_pre_cb = m0_be_tx_get_capture_status;
+        reg->br_tx_cbdata.m0_be_tx_post_cb = m0_be_tx_set_capture_status;
+
         reg->br_seg = seg;
+
+        /* sm_group is taken from tx, but we can take it from seg also */
+        reg->br_impl.sm_group = tx->bt_impl.sm_group;
+
         reg->br_buf.b_nob = buf->b_nob;
+        reg->br_buf.logical_address = buf->logical_address;
 
-        /* todo@ Locking sm_group is required before initializing sm */
-        /* todo@ Register the state machine of the region into sm_group */
-        /* todo@ unlock locked sm group */
+        /* Lock sm group */
+        m0_sm_group_lock(reg->br_impl.sm_group);
 
-        /* todo@ need to call function m0_sm_state_set() for same not
-         * set directly
-         */
-        reg->br_sm.sm_state = M0_BEREG_INIT;
+        /* Register the state machine of the tx into sm_group */
+        m0_sm_init(&(reg->br_sm), &reg_conf, M0_BEREG_INIT,
+                                        reg->br_impl.sm_group, NULL);
 
-        M0_POST(reg->br_sm.sm_state == M0_BEREG_INIT);
+        /* Unlock locked sm group */
+        m0_sm_group_unlock(reg->br_impl.sm_group);
 
         *reg_out = reg;
 
@@ -135,41 +141,23 @@ exit_error:
 
 M0_INTERNAL void m0_be_alloc(struct m0_be_reg *reg)
 {
-        int                      err;
-        rvm_tid_t               *tid;
-        struct m0_uint128       *toffset;
-
         /* Asserting on required pointers */
         M0_ASSERT(reg != NULL);
 
-        if (reg->br_tx == NULL)
-                tid = NULL;
-        else
-                tid = reg->br_tx->bt_impl.tx_id; 
-        /*
-         * Allocate memory from RDS Heap.
-         * Update br_buf to store virtual address.
-         */
-
-        /* extern char *rds_malloc(unsigned long size,
-         *                         rvm_tid_t *tid,
-         *                         int *err);
-         */
-        reg->br_buf.b_addr = (void *)rds_malloc(reg->br_buf.b_nob,
-                                                tid, &err);
+        /* Locking sm group before setting sm_state */
+        m0_sm_group_lock(reg->br_impl.sm_group);
 
-        toffset = &(reg->br_buf.logical_address.segid_offset);
+        m0_sm_state_set(&(reg->br_sm), M0_BEREG_INPROGRESS);
 
-        toffset->u_hi = reg->br_seg->bs_impl.segment_id;
-        toffset->u_lo = (reg->br_seg->bs_addr - reg->br_buf.b_addr);
+        /* Unlock locked sm group */
+        m0_sm_group_unlock(reg->br_impl.sm_group);
 
+        reg->br_sm_ast.sa_cb    = m0_be_alloc_cb;
+        reg->br_sm_ast.sa_datum = (void *)reg;
 
-       if (toffset->u_lo < 0)
-                toffset->u_lo = -(toffset->u_lo);
-
-        /* As heap always starts after segment header of size PAGE_SIZE */
-        toffset->u_lo += PAGE_SIZE;
+        m0_be_reg_req_post(reg->br_impl.sm_group, &(reg->br_sm_ast));
 
+        return;
 }
 
 /**
@@ -183,33 +171,17 @@ M0_INTERNAL void m0_be_alloc(struct m0_be_reg *reg)
  */
 M0_INTERNAL void m0_be_free(struct m0_be_reg *reg)
 {
-        int             err;
-        rvm_tid_t      *tid = NULL;
-
         /* Asserting on required pointers */
         M0_ASSERT(reg != NULL);
 
-        if (reg->br_tx != NULL)
-                tid = reg->br_tx->bt_impl.tx_id; 
-        /*
-         * Allocate memory from RDS Heap.
-         * Update br_buf to store virtual address.
-         */
-
-        rds_free((char *)reg->br_buf.b_addr, tid, &err);
+        /* @todo - Need to understand pre condition check */
 
-        if (err != SUCCESS) {
-                /* todo@ need to call function m0_sm_state_set() for same not
-                 * set directly
-                 */
-                reg->br_sm.sm_state = M0_BEREG_FAILED;
-                return;
-        }
+        reg->br_sm_ast.sa_cb    = m0_be_free_cb;
+        reg->br_sm_ast.sa_datum = (void *)reg;
 
-        reg->br_buf.b_addr                              = NULL;
-        reg->br_buf.logical_address.segid_offset.u_hi   = 0;
-        reg->br_buf.logical_address.segid_offset.u_lo   = 0;
+        m0_be_reg_req_post(reg->br_impl.sm_group, &(reg->br_sm_ast));
 
+        return;
 }
 
 /**
@@ -252,14 +224,29 @@ M0_INTERNAL void m0_be_put(const struct m0_be_reg *reg)
  */
 M0_INTERNAL void m0_be_reg_capture(struct m0_be_reg *reg)
 {
-        rvm_return_t ret;
-
         /* Asserting on required pointers */
         M0_ASSERT(reg != NULL);
         M0_ASSERT(reg->br_tx != NULL);
 
         M0_PRE(reg->br_sm.sm_state == M0_BEREG_INIT);
 
+        /* Locking sm group before setting sm_state */
+        m0_sm_group_lock(reg->br_impl.sm_group);
+
+        m0_sm_state_set(&(reg->br_sm), M0_BEREG_INPROGRESS);
+
+        /* Unlock locked sm group */
+        m0_sm_group_unlock(reg->br_impl.sm_group);
+
+        reg->br_sm_ast.sa_cb    = m0_be_reg_capture_cb;
+        reg->br_sm_ast.sa_datum = (void *)reg;
+
+        m0_be_reg_req_post(reg->br_impl.sm_group, &(reg->br_sm_ast));
+
+        return;
+
+        rvm_return_t ret;
+
         ret = rvm_set_range(reg->br_tx->bt_impl.tx_id,
                             reg->br_buf.b_addr,
                             reg->br_buf.b_nob);
@@ -285,24 +272,157 @@ M0_INTERNAL void m0_be_reg_capture(struct m0_be_reg *reg)
 M0_INTERNAL void m0_be_reg_fini(struct m0_be_reg *reg)
 {
 
+        M0_PRE(M0_IN(reg->br_sm.sm_state, (M0_BEREG_DONE, M0_BEREG_FAILED)));
+
         /* release memory allocated in m0_be_reg_init */
-        free(reg);
-        /* todo@ M0_PRE(M0_IN(reg->br_sm.sm_state, (M0_BEREG_DONE, 
-         *                                          M0_BEREG_FAILED)); */
+        m0_free(reg);
+
         /* todo@ Finalizing on state machine */
-        
 }
 
 /**
- * The function posts tx request to state machine thread
+ * The function posts reg request to state machine thread
  *
  */
-M0_INTERNAL void m0_reg_req_post(struct m0_sm_group *sm_group,
+M0_INTERNAL void m0_be_reg_req_post(struct m0_sm_group *sm_group,
                                  struct m0_sm_ast *sm_ast)
 {
         m0_sm_ast_post(sm_group, sm_ast);
 }
 
+/**
+ * Callback function for allocation of region
+ *
+ */
+
+M0_INTERNAL void m0_be_alloc_cb(struct m0_sm_group *sm_group,
+                                  struct m0_sm_ast *sm_ast)
+{
+        struct m0_be_reg *reg;
+        struct m0_uint128 *toffset;
+        rvm_tid_t *tid = NULL;
+        int             err;
+
+        /* Asserting on required pointers */
+        M0_ASSERT(sm_group != NULL);
+        M0_ASSERT(sm_ast != NULL);
+
+        reg = (struct m0_be_reg *)sm_ast->sa_datum;
+
+        M0_ASSERT(reg != NULL);
+
+        if (reg->br_tx != NULL)
+                tid = reg->br_tx->bt_impl.tx_id; 
+
+        reg->br_buf.b_addr = (void *)rds_malloc(reg->br_buf.b_nob,
+                                                tid, &err);
+
+        reg->br_buf.logical_address.magic = BE_ALLOC_REF_MAGIC;
+
+        toffset = &(reg->br_buf.logical_address.segid_offset);
+
+        toffset->u_hi = reg->br_seg->bs_impl.segment_id;
+        toffset->u_lo = (reg->br_seg->bs_addr - reg->br_buf.b_addr);
+
+
+       if (toffset->u_lo < 0)
+                toffset->u_lo = -(toffset->u_lo);
+
+        /* As heap always starts after segment header of size PAGE_SIZE */
+        toffset->u_lo += PAGE_SIZE;
+
+        m0_sm_state_set(&(reg->br_sm), M0_BEREG_SUCCEED);
+
+        return;
+}
+
+/**
+ * Callback function for freeing of region
+ *
+ */
+
+M0_INTERNAL void m0_be_free_cb(struct m0_sm_group *sm_group,
+                                  struct m0_sm_ast *sm_ast)
+{
+        int             err;
+        rvm_tid_t      *tid = NULL;
+        struct m0_be_reg *reg;
+
+        /* Asserting on required pointers */
+        M0_ASSERT(sm_group != NULL);
+        M0_ASSERT(sm_ast != NULL);
+
+        reg = (struct m0_be_reg *)sm_ast->sa_datum;
+
+        M0_ASSERT(reg != NULL);
+
+        if (reg->br_tx != NULL)
+                tid = reg->br_tx->bt_impl.tx_id; 
+        /*
+         * Allocate memory from RDS Heap.
+         * Update br_buf to store virtual address.
+         */
+
+        rds_free((char *)reg->br_buf.b_addr, tid, &err);
+
+        if (err != SUCCESS)
+                goto error_exit;
+
+        reg->br_buf.b_addr                              = NULL;
+        reg->br_buf.logical_address.segid_offset.u_hi   = 0;
+        reg->br_buf.logical_address.segid_offset.u_lo   = 0;
+
+        m0_sm_state_set(&(reg->br_sm), M0_BEREG_DONE);
+
+error_exit:
+        m0_sm_state_set(&(reg->br_sm), M0_BEREG_FAILED);
+}
+
+
+/**
+ * Callback function for capturing region
+ *
+ */
+M0_INTERNAL void m0_be_reg_capture_cb(struct m0_sm_group *sm_group,
+                                      struct m0_sm_ast *sm_ast)
+{
+        struct m0_be_reg *reg;
+        rvm_return_t ret;
+        int result;
+
+        /* Asserting on required pointers */
+        M0_ASSERT(sm_group != NULL);
+        M0_ASSERT(sm_ast != NULL);
+
+        reg = (struct m0_be_reg *)sm_ast->sa_datum;
+
+        M0_ASSERT(reg != NULL);
+
+        result = reg->br_tx_cbdata.m0_be_tx_pre_cb((void *)reg->br_tx);
+
+        /**
+         * Do not perform rvm_set_range on current region if region capture is
+         * failed for any previous region
+         */
+        if( result == M0_BETX_PREP_FAILED)
+                goto reg_done_exit;
+
+        ret = rvm_set_range(reg->br_tx->bt_impl.tx_id,
+                            reg->br_buf.b_addr,
+                            reg->br_buf.b_nob);
+
+        if (RVM_SUCCESS != ret)
+                goto error_exit;
+
+        reg->br_tx_cbdata.m0_be_tx_post_cb((void *)reg->br_tx);
+
+error_exit:
+        m0_sm_state_set(&(reg->br_sm), M0_BEREG_FAILED);
+reg_done_exit:
+        m0_sm_state_set(&(reg->br_sm), M0_BEREG_DONE);
+}
+
+
 /** @} end group be */
 
 /*
diff --git a/be/be_reg.h b/be/be_reg.h
new file mode 100644
index 0000000..78a6e75
--- /dev/null
+++ b/be/be_reg.h
@@ -0,0 +1,55 @@
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Sachin Patil <sachin_patil@xyratex.com>
+ * Original creation date: 27 Dec 2012
+ */
+
+#pragma once
+
+#ifndef __MERO_BE_BE_REG_H__
+#define __MERO_BE_BE_REG_H__
+
+/**
+  @defgroup be (Meta-data) back-end
+  @{
+  */
+#include "be/be.h"
+
+M0_INTERNAL void m0_be_alloc_cb(struct m0_sm_group  *sm_group,
+                                    struct m0_sm_ast *sm_ast);
+
+M0_INTERNAL void m0_be_free_cb(struct m0_sm_group *sm_group,
+                                   struct m0_sm_ast *sm_ast);
+
+M0_INTERNAL void m0_be_reg_capture_cb(struct m0_sm_group *sm_group,
+                                      struct m0_sm_ast *sm_ast);
+                                  
+M0_INTERNAL void m0_be_reg_req_post(struct m0_sm_group *sm_group,
+                                 struct m0_sm_ast *sm_ast);
+/** @} end of be group */
+
+/* __MERO_BE_BE_REG_H__ */
+#endif
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/be/be_tx.c b/be/be_tx.c
index 5dbb1c9..c250f6b 100644
--- a/be/be_tx.c
+++ b/be/be_tx.c
@@ -345,7 +345,7 @@ exit:
 }
 
 /*
- *    m0_be_tx_prep callback function
+ * m0_be_tx_prep callback function
  */
 M0_INTERNAL void m0_be_tx_prep_cb(struct m0_sm_group *sm_group,
                                   struct m0_sm_ast *sm_ast)
@@ -365,6 +365,7 @@ M0_INTERNAL void m0_be_tx_prep_cb(struct m0_sm_group *sm_group,
         m0_tlist_for(&m0_be_reg_tl, &(tx->bt_impl.bc_tl), reg_it) {
                 /* Assumption: reg_it->br_tx will be updated to tx */
                 reg_it->br_tx = tx;
+                reg_it->br_tx_cbdata.datum = (void *)tx;
 
                 /*
                 * Capture region function which changes
@@ -374,7 +375,7 @@ M0_INTERNAL void m0_be_tx_prep_cb(struct m0_sm_group *sm_group,
 
         } m0_tlist_endfor;
 
-        m0_sm_state_set(&(tx->bt_sm), M0_BETX_PREPARED);
+        return;
 }
 
 /*
@@ -463,6 +464,72 @@ M0_INTERNAL void m0_tx_req_post(struct m0_sm_group *sm_group,
         m0_sm_ast_post(sm_group, sm_ast);
 }
 
+/**
+ * The function iterates the region list to check if any region capture has 
+ * failed.
+ * If any earlier capture is failed, then the current region won't be captured.
+ */
+M0_INTERNAL int m0_be_tx_get_capture_status(void * data)
+{
+        struct m0_be_tx *tx = (struct m0_be_tx *)data;
+        struct m0_be_reg *reg_it;
+
+        int result = M0_BETX_PREP_INPROGRESS;
+
+        /* Iterate credit list to check the capture status for each region. */
+        m0_tlist_for(&m0_be_reg_tl, &(tx->bt_impl.bc_tl), reg_it) {
+                /* check reg_it->br_sm.sm_state for region state */
+
+                if (reg_it->br_sm.sm_state == M0_BEREG_FAILED) {
+                        result = M0_BETX_PREP_FAILED;
+                        break;
+                }
+
+        } m0_tlist_endfor;
+
+        return result;
+}
+
+/**
+ * The function iterates all the region list to check if they are captured 
+ * successfully.
+ * This is pre-requisite for transaction to be marked as PREPARED.
+ */
+M0_INTERNAL void m0_be_tx_set_capture_status(void * data)
+{
+        struct m0_be_tx *tx = (struct m0_be_tx *)data;
+        struct m0_be_reg *reg_it;
+
+        bool failed_res = false;
+        bool inprogress_res = false;
+
+        /* Iterate credit list to check the capture status for each region. */
+        m0_tlist_for(&m0_be_reg_tl, &(tx->bt_impl.bc_tl), reg_it) {
+                /* check if region capture is in prorgess */
+                if (reg_it->br_sm.sm_state == M0_BEREG_INPROGRESS) {
+                        inprogress_res = true;
+                        break;
+                }
+
+                /* check if region capture is failed */
+                if (reg_it->br_sm.sm_state == M0_BEREG_FAILED) {
+                        failed_res = true;
+                }
+
+        } m0_tlist_endfor;
+
+        if(!inprogress_res) {
+                if(failed_res) {
+                        M0_TX_SM_STATE_SET(tx, M0_BETX_FAILED);
+                }
+                else {
+                        M0_TX_SM_STATE_SET(tx, M0_BETX_PREPARED);
+                }
+        }
+
+        return;
+}
+
 /** @} end group be_trans */
 
 /*
diff --git a/be/be_tx.h b/be/be_tx.h
index f20d38d..5a6c3ed 100644
--- a/be/be_tx.h
+++ b/be/be_tx.h
@@ -33,6 +33,12 @@
         m0_sm_state_set(&((tx)->bt_sm), state);                       \
         m0_sm_group_unlock((tx)->bt_impl.sm_group);
 
+enum m0_be_tx_prep_state {
+        M0_BETX_PREP_INPROGRESS,
+        M0_BETX_PREP_SUCCEED,
+        M0_BETX_PREP_FAILED,
+};
+
 M0_INTERNAL void m0_be_tx_add_cred(struct m0_be_tx *tx,
                                    struct m0_be_reg *reg);
 
@@ -49,6 +55,11 @@ M0_INTERNAL void m0_be_tx_fini_cb(struct m0_sm_group *sm_group,
 
 M0_INTERNAL void m0_tx_req_post(struct m0_sm_group *sm_group,
                                 struct m0_sm_ast *sm_ast);
+
+M0_INTERNAL int m0_be_tx_get_capture_status(void * data);
+
+M0_INTERNAL void m0_be_tx_set_capture_status(void * data);
+
 /** @} end of be group */
 
 /* __MERO_BE_BE_TX_H__ */
diff --git a/be/lib/be_kv_store.c b/be/lib/be_kv_store.c
index 454a822..89a6050 100644
--- a/be/lib/be_kv_store.c
+++ b/be/lib/be_kv_store.c
@@ -31,19 +31,12 @@ M0_INTERNAL int m0_ks_init_domain(struct m0_kv_store    *handle,
                                   struct m0_be_domain  **dom)
 {
         struct m0_be_seg    *seg = NULL;
-        struct m0_stob      *ns_stob;
-        struct m0_stob      *log_stob;
 
         *dom = (struct m0_be_domain *)malloc(sizeof(struct m0_be_domain));
         M0_ASSERT(*dom != NULL);
 
-        ns_stob = (struct m0_stob *)malloc(2 * sizeof(struct m0_stob));
-        M0_ASSERT(ns_stob != NULL);
-
-        log_stob = (struct m0_stob *)(ns_stob + 1);
-
         /* Initializing domain and segment */
-        m0_be_domain_init(*dom, ns_stob, log_stob);
+        m0_be_domain_init(*dom);
         (*dom)->bd_data.bs_sm.sm_state = M0_BESEG_ACTIVE;
 
         /*Create and Open Segment */
diff --git a/be/lib/ut/be_tlist.c b/be/lib/ut/be_tlist.c
index d3cf329..84550bd 100644
--- a/be/lib/ut/be_tlist.c
+++ b/be/lib/ut/be_tlist.c
@@ -48,10 +48,6 @@ struct m0_be_tl_descr list_descr = M0_BE_TL_DESCR("foo",
 struct m0_be_tl         tlist;
 struct m0_be_seg        *seg;
 struct m0_be_domain     dom;
-struct m0_stob          ns_stob;
-struct m0_stob          stob;
-struct m0_stob          log_stob;
-
 
 /** Displays the @tlist */
 void print_list()
@@ -74,7 +70,7 @@ void add_to_tlist(struct foo *obj, struct m0_reference ref)
 void init_tlist_domain_and_segment()
 {
         /* Initializing domain and segment */
-        m0_be_domain_init(&dom, &ns_stob, &log_stob);
+        m0_be_domain_init(&dom);
         dom.bd_data.bs_sm.sm_state = M0_BESEG_ACTIVE;
 
         /*Create and Open Segment */
diff --git a/be/ut/be.c b/be/ut/be.c
index 0a2a63c..68ae5f0 100644
--- a/be/ut/be.c
+++ b/be/ut/be.c
@@ -36,8 +36,6 @@
 struct m0_be_seg *seg;
 struct m0_be_seg *lseg;
 struct m0_be_domain dom;
-struct m0_stob ns_stob, stob;
-struct m0_stob log_stob;
 
 int main()
 {
@@ -48,7 +46,7 @@ int main()
 
         /* Initializing domain */
         printf("\n\tBackend UT\n");
-        m0_be_domain_init(&dom, &ns_stob, &log_stob);
+        m0_be_domain_init(&dom);
         printf("\nDomain is initialized\n");
 
         /**
-- 
1.8.3.2

