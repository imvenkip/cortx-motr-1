From 0705466508adcbd3a5c43f453b8d138eeb97d9d3 Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Fri, 4 Jan 2013 04:53:46 -0800
Subject: [PATCH 25/94] Changed kv store according to new region sm, kv_store
 handle now on rvm

---
 be/lib/be_helper.c      |  63 ++++---
 be/lib/be_helper.h      |   8 +-
 be/lib/be_kv_store.c    | 428 ++++++++++++++++++++++++++----------------------
 be/lib/be_kv_store.h    |  33 +++-
 be/lib/ut/be_kv_store.c | 134 +++++++++------
 be/lib/ut/be_tlist.c    |   2 +-
 6 files changed, 385 insertions(+), 283 deletions(-)

diff --git a/be/lib/be_helper.c b/be/lib/be_helper.c
index 33f473a..3395f90 100644
--- a/be/lib/be_helper.c
+++ b/be/lib/be_helper.c
@@ -28,7 +28,7 @@
 M0_INTERNAL void m0_ks_init_domain(struct m0_be_domain  **out_dom)
 {
         struct m0_be_domain  *dom = NULL;
-        
+
         /* Allocate memory to @dom pointer */
         m0_be_domain_create(&dom);
         M0_ASSERT(dom != NULL);
@@ -49,47 +49,33 @@ M0_INTERNAL void m0_ks_domain_lookup(struct m0_be_domain    *dom,
 
         M0_BE_WAIT((*seg)->bs_impl.sm_group, &((*seg)->bs_sm),
                    (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED));
-
 }
 M0_EXPORTED(m0_ks_domain_lookup);
 
 M0_INTERNAL void *m0_ks_obj_malloc(struct m0_be_reg     *obj_reg,
-                                   struct m0_be_tx     **in_tx,
                                    struct m0_reference **obj_ref)
 {
-        struct m0_be_tx         *tx = (*in_tx);
         struct m0_be_domain     *dom;
         void                    *obj;
+
         M0_ASSERT(obj_reg != NULL);
 
         dom = obj_reg->br_seg->bs_dom;
 
-        if ((*in_tx) == NULL){
-                tx = (struct m0_be_tx *)malloc(sizeof(struct m0_be_tx));
-                /* NOTE: free(tx) should be called by user */
-                if (tx == NULL)
-                       goto exit_failure; 
-
-                m0_be_tx_init(tx, dom, 0);
-                M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm, 
-                           (1 << M0_BETX_PREPARING) | (1 << M0_BETX_FAILED));
-
-       }
-
         m0_be_alloc(obj_reg);
-        M0_BE_WAIT(obj_reg->br_impl.sm_group, &obj_reg->br_sm, 
+        M0_BE_WAIT(obj_reg->br_impl.sm_group, &obj_reg->br_sm,
                    (1 << M0_BEREG_ALLOCATED) | (1 << M0_BEREG_FAILED));
 
-        m0_be_tx_add_cred(tx, obj_reg);
-        /* TODO : reg_capture */
+        m0_be_reg_capture(obj_reg);
+        M0_BE_WAIT(obj_reg->br_impl.sm_group, &obj_reg->br_sm,
+                   (1 << M0_BEREG_CAPTURED) | (1 << M0_BEREG_FAILED));
+
         obj = obj_reg->br_buf.b_addr;
-        M0_ASSERT(obj != NULL);
+        if (obj == NULL)
+                goto exit_failure;
 
         (*obj_ref) = &(obj_reg->br_buf.logical_address);
 
-        if ((*in_tx) == NULL)
-                (*in_tx) = tx;
-        
         return obj;
 
 exit_failure:
@@ -108,7 +94,7 @@ M0_EXPORTED(m0_ks_fini);
 M0_INTERNAL void m0_ks_tx_prep(struct m0_be_tx *tx)
 {
         m0_be_tx_prep(tx);
-        M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm, 
+        M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
                    (1 << M0_BETX_PREPARED) | (1 << M0_BETX_FAILED));
 }
 M0_EXPORTED(m0_ks_tx_prep);
@@ -116,10 +102,37 @@ M0_EXPORTED(m0_ks_tx_prep);
 M0_INTERNAL void m0_ks_tx_start(struct m0_be_tx *tx)
 {
         m0_be_tx_start(tx);
-        M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm, 
+        M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
                    (1 << M0_BETX_OPEN) | (1 << M0_BETX_FAILED));
 }
 M0_EXPORTED(m0_ks_tx_prep_start);
+
+M0_INTERNAL void m0_ks_prep_link_reg(struct m0_be_domain    *dom,
+                                     struct m0_be_list_link *link,
+                                     struct m0_be_tx        *tx,
+                                     struct m0_be_reg      **reg)
+{
+        struct m0_be_buf   buf;
+        struct m0_uint128 *t_offset;
+        struct m0_be_seg  *seg;
+        uint64_t           segid;
+
+        buf.b_nob = sizeof(struct m0_be_list_link);
+
+        t_offset = &(link->ll_next.logical_address.segid_offset);
+        segid    = t_offset->u_hi;
+
+        m0_ks_domain_lookup(dom, &seg, segid);
+        M0_ASSERT(seg != NULL);
+
+        buf.b_addr = (void *)link;
+        m0_be_reg_init(reg, tx, seg, &buf);
+        M0_ASSERT((*reg) != NULL);
+}
+M0_EXPORTED(m0_ks_prep_link);
+
+
+
 /* @} end of be_helper group */
 
 /*
diff --git a/be/lib/be_helper.h b/be/lib/be_helper.h
index 97b58a4..6cce633 100644
--- a/be/lib/be_helper.h
+++ b/be/lib/be_helper.h
@@ -55,7 +55,6 @@ M0_INTERNAL void m0_ks_domain_lookup(struct m0_be_domain   *dom,
  * PRE: reg_init done on @obj_reg
  */
 M0_INTERNAL void *m0_ks_obj_malloc(struct m0_be_reg     *objreg,
-                                   struct m0_be_tx     **in_tx,
                                    struct m0_reference **obj_ref);
 
 /*
@@ -68,6 +67,13 @@ M0_INTERNAL void m0_ks_tx_prep(struct m0_be_tx *tx);
  */
 M0_INTERNAL void m0_ks_tx_start(struct m0_be_tx *tx);
 
+/*
+ * Prepares and carries out reg_init for @reg for the linkage @link
+ */
+M0_INTERNAL void m0_ks_prep_link_reg(struct m0_be_domain    *dom,
+                                     struct m0_be_list_link *link,
+                                     struct m0_be_tx        *tx,
+                                     struct m0_be_reg      **reg);
 
 /** @} end of be_helper group */
 
diff --git a/be/lib/be_kv_store.c b/be/lib/be_kv_store.c
index 924a20d..bdeae14 100644
--- a/be/lib/be_kv_store.c
+++ b/be/lib/be_kv_store.c
@@ -42,24 +42,82 @@ static void __get_next(struct m0_be_tl_descr   *d,
                        void                    *current,
                        struct m0_be_list_link **link_next);
 
-/*
- * Prepares the regions for the previous and next pointers to be modified in the
- * list. Called in __m0_ks_add_prev_next_to_cred
+/**
+ * Gives the linkage of the current object. The pointer is updated in
+ * @link_current.
  */
-static void __prep_prev_next_reg(struct m0_kv_store     *handle,
-                                 struct m0_be_reg       **prev_reg,
-                                 struct m0_be_reg       **next_reg,
-                                 struct m0_be_list_link *link_prev,
-                                 struct m0_be_list_link *link_next,
-                                 struct m0_be_tx        *tx);
+static void __get_current(struct m0_be_tl_descr   *d,
+                          void                    *current,
+                          struct m0_be_list_link **link_cuurent);
 
 /*
- * Adds the prepares and adds the regions of the next & previous pointers of
- * @current object
+ * Adds or captures the regions of the next & previous pointers of
+ * @current object, depending upon @in_tx_state.
  */
 static void __m0_ks_add_prev_next_to_cred(struct m0_kv_store     *handle,
-                                               struct m0_be_tx        *tx,
-                                               void                   *current);
+                                          struct m0_be_tx        *tx,
+                                          void                   *current,
+                                          int                     in_tx_state);
+
+M0_INTERNAL void m0_ks_create_handle(struct m0_be_domain    *dom,
+                                     struct m0_be_tl_descr  *descr,
+                                     struct m0_kv_store    **handle)
+{
+        struct m0_be_tx      *tx = NULL;
+        struct m0_be_reg     *handle_reg = NULL;
+        struct m0_be_seg     *handle_seg = NULL;
+        struct m0_be_buf      handle_buf;
+        struct m0_be_list    *head;
+        struct m0_uint128    *temp_head_offset;
+        struct m0_uint128    *temp_tail_offset;
+        struct m0_reference  *handle_ref = NULL;
+
+        M0_ALLOC_PTR(tx);
+
+        if (tx == NULL)
+                return;
+
+        /* For now segid is always == 1*/
+        m0_ks_domain_lookup(dom, &handle_seg, 1);
+        M0_ASSERT(handle_seg != NULL);
+
+        m0_be_tx_init(tx, dom, 0);
+        M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
+                   (1 << M0_BETX_PREPARING) | (1 << M0_BETX_FAILED));
+
+        /* Prepare a region of the handle */
+        handle_buf.b_nob = sizeof(struct m0_kv_store);
+        m0_be_reg_init(&handle_reg, tx, handle_seg, &handle_buf);
+
+        m0_ks_tx_start(tx);
+
+        (*handle) = (struct m0_kv_store *)m0_ks_obj_malloc(handle_reg,
+                                                           &handle_ref);
+        M0_ASSERT((*handle) != NULL);
+        M0_ASSERT(handle_ref != NULL);
+
+        /* be_tlist init */
+        m0_be_tlist_init(descr, &(*handle)->ks_tlist);
+
+        /* Update segment id & offset in head & tail */
+        head = &((*handle)->ks_tlist.t_head);
+
+        temp_head_offset       = &(head->l_head.logical_address.segid_offset);
+        temp_head_offset->u_hi = handle_ref->segid_offset.u_hi;
+        temp_head_offset->u_lo = handle_ref->segid_offset.u_lo;
+
+        temp_tail_offset       = &(head->l_tail.logical_address.segid_offset);
+        temp_tail_offset->u_hi = handle_ref->segid_offset.u_hi;
+        temp_tail_offset->u_lo = handle_ref->segid_offset.u_lo;
+
+        m0_be_tx_done(tx);
+        M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
+                   (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED));
+
+        m0_be_tx_fini(tx);
+        m0_free(tx);
+}
+M0_EXPORTED(m0_ks_create_handle);
 
 M0_INTERNAL void m0_ks_init(struct m0_kv_store     *handle,
                             struct m0_be_tl_descr  *descr,
@@ -67,32 +125,11 @@ M0_INTERNAL void m0_ks_init(struct m0_kv_store     *handle,
                             kv_key_cmp              cmp_fp,
                             kv_key_match            match_fp)
 {
-        /* TODO: make sure handle comes via be_alloc only */
-        struct m0_be_list  *head;
-        struct m0_uint128  *temp_head_offset;
-        struct m0_uint128  *temp_tail_offset;
-
-        /* Set compare and match routines */
+        M0_ASSERT(handle != NULL);
         handle->kv_key_cmp    = cmp_fp;
         handle->kv_key_match  = match_fp;
         handle->ks_list_descr = descr;
         handle->ks_dom        = dom;
-
-        /* be_tlist init */
-        m0_be_tlist_init(handle->ks_list_descr, &handle->ks_tlist);
-
-        /* TODO: update with correct segment id */
-
-        /* Temporary  ==1*/
-        head = &(handle->ks_tlist.t_head);
-
-        temp_head_offset      = &(head->l_head.logical_address.segid_offset);
-        temp_head_offset->u_hi = 1;
-       // temp_offset.u_lo =
-
-        temp_tail_offset      = &(head->l_tail.logical_address.segid_offset);
-        temp_tail_offset->u_hi = 1;
-        //temp_offset.u_lo =
 }
 M0_EXPORTED(m0_ks_init);
 
@@ -101,9 +138,19 @@ M0_INTERNAL struct m0_reference *m0_ks_get_next_val(struct m0_kv_store *handle,
 {
         struct m0_be_list_link          *link_next   = NULL;
         struct m0_reference             *ret_ref     = NULL;
+        void                            *temp_tail   = NULL;
+
+        temp_tail = m0_be_tlist_tail(handle->ks_list_descr, &handle->ks_tlist);
+
+        /* If object is last in linked list, then its next will be itself */
+        if (temp_tail == obj) {
+                __get_current(handle->ks_list_descr, obj, &link_next);
+                goto get_ref;
+        }
 
         __get_next(handle->ks_list_descr, obj, &link_next);
 
+get_ref:
         ret_ref  = &(link_next->ll_next.logical_address);
         return ret_ref;
 }
@@ -119,7 +166,6 @@ M0_INTERNAL void *m0_ks_find(struct m0_kv_store *handle,
         m0_be_tlist_for(handle->ks_list_descr, &handle->ks_tlist, scan) {
                 if (handle->kv_key_match(scan, key) == 0) {
                         target = scan;
-                        printf("\n In find...found target\n");
                         break;
                 }
         }m0_be_tlist_endfor;
@@ -129,41 +175,24 @@ M0_INTERNAL void *m0_ks_find(struct m0_kv_store *handle,
 M0_EXPORTED(m0_ks_find);
 
 M0_INTERNAL int m0_ks_delete(struct m0_kv_store  *handle,
-                             struct m0_reference *obj_ref,
+                             void                *obj,
                              struct m0_be_tx     *del_tx)
 {
         void                   *scan;
         void                   *target    = NULL;
-        void                   *obj       = NULL;
         struct m0_be_reg       *curr_reg  = NULL;
         struct m0_be_list_link *link_curr = NULL;
-        struct m0_be_seg       *curr_seg  = NULL;
         struct m0_be_tl_descr  *desc_t    = NULL; /* temporary */
-        struct m0_uint128      *t_offset;         /* temporary */
         struct m0_be_tx         *tx = del_tx;
-        struct m0_be_buf        curr_buf;
-        uint64_t                curr_segid;
-
-        /*
-         * Ensure incoming object reference has been given from be_alloc itself
-         */
-
-        /*
-         * TODO: Check magic with magic that would be defined in handle->ks_dom.
-         *       Coz this magic will be domain specific, will be defined in
-         *       be_alloc itself.
-         */
-        if (obj_ref->magic != BE_ALLOC_REF_MAGIC)
-                goto exit_failure;
-
-        obj = obj_ref->virtual_address;
+        int                     del_tx_state = IN_TX_NOT_NULL;
 
         if (del_tx == NULL) {
-                tx = (struct m0_be_tx *)malloc(sizeof(struct m0_be_tx));
+                del_tx_state = IN_TX_NULL;
+
+                M0_ALLOC_PTR(tx);
                 M0_ASSERT(tx != NULL);
 
                 m0_be_tx_init(tx, handle->ks_dom, 0);
-
                 M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
                            (1 << M0_BETX_PREPARING) | (1 << M0_BETX_FAILED));
         }
@@ -177,42 +206,46 @@ M0_INTERNAL int m0_ks_delete(struct m0_kv_store  *handle,
         if (target != NULL) {
                 desc_t = handle->ks_list_descr;
 
-                /* Add current object to transaction */
-                curr_buf.b_nob = sizeof(struct m0_be_list_link);
+                /* Add linkage of current object to transaction */
                 link_curr = &((struct m0_be_tlink *)
                               (target + desc_t->td_link_offset))->t_link;
+                
+                /* Init a region for this link */
+                m0_ks_prep_link_reg(handle->ks_dom, link_curr, tx,
+                                    &curr_reg);
+                M0_ASSERT(curr_reg != NULL);
 
-                t_offset = &(link_curr->ll_next.logical_address.segid_offset);
-                curr_segid  = t_offset->u_hi;
-
-                m0_ks_domain_lookup(handle->ks_dom, &curr_seg, curr_segid);
-                M0_ASSERT(curr_seg != NULL);
-
-                curr_buf.b_addr = (void *)link_curr;
-                m0_be_reg_init(&curr_reg, tx, curr_seg, &curr_buf);
-                m0_be_tx_add_cred(tx, curr_reg);
+                if (del_tx == NULL) {
+                        m0_be_tx_add_cred(tx, curr_reg);
+                } else {
+                        m0_be_reg_capture(curr_reg);
+                        M0_BE_WAIT(curr_reg->br_impl.sm_group, &curr_reg->br_sm,
+                                   (1 << M0_BEREG_CAPTURED) |
+                                   (1 << M0_BEREG_FAILED));
+                }
 
                 /*
                  * Add the previous and next pointers about to
-                 * be modified to the credit.
+                 * be modified to the credit or captures them depending
+                 * upon the transaction received.
                  */
-                __m0_ks_add_prev_next_to_cred(handle, tx, target);
-                m0_ks_tx_prep(tx);
-                m0_ks_tx_start(tx);
+                __m0_ks_add_prev_next_to_cred(handle, tx, target, del_tx_state);
+
+                if (del_tx == NULL) {
+                        m0_ks_tx_prep(tx);
+                        m0_ks_tx_start(tx);
+                }
 
                 /* Now delete */
                 m0_be_tlink_del_fini(handle->ks_list_descr, target);
 
                 if (del_tx == NULL) {
                         m0_be_tx_done(tx);
-
                         M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
                                    (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED));
-
                         m0_be_tx_fini(tx);
-                        free(tx);
+                        m0_free(tx);
                 }
-
                 goto exit_success;
         }
 
@@ -225,50 +258,53 @@ exit_failure:
 }
 M0_EXPORTED(m0_ks_delete);
 
-/*
- * Could be pruned later when TODO in this section is achieved
- */
 M0_INTERNAL int __add_at_tail_to_tlist(struct m0_kv_store     *handle,
                                        void                   *new,
-                                       struct m0_be_tx        *tx)
+                                       struct m0_be_tx        *tx,
+                                       int                     in_tx_state)
 {
         struct m0_be_reg          *tail_reg  = NULL;
         struct m0_be_list_link    *tail_link = NULL;
-        struct m0_be_seg          *tail_seg  = NULL;
+        struct m0_be_reg          *tail_obj_reg  = NULL;
+        struct m0_be_list_link    *tail_obj_link = NULL;
         struct m0_be_tl_descr     *desc_t    = NULL; /* temporary */
         void                      *tail_obj  = NULL;
-        struct m0_uint128         *temp_offset;
-        struct m0_be_buf           tail_buf;
-        uint64_t                   tail_segid;
-
-        /* Add current tail to credit */
-        /* TODO : add actual tail *pointer* also the credit....reg init etc.
-         * tail can be taken from
-         *
-         *       const struct m0_be_list *head;
-         *       head = &list->t_head;
-         *       actual_tail_ptr = head->l_tail;
-         */
-        tail_obj  = m0_be_tlist_tail(handle->ks_list_descr, &handle->ks_tlist);
+        struct m0_be_list         *list_head;
 
+        /* Add current tail object to credit */
+        tail_obj  = m0_be_tlist_tail(handle->ks_list_descr, &handle->ks_tlist);
         desc_t    = handle->ks_list_descr;
-        tail_link = &((struct m0_be_tlink *)
-                      (tail_obj + desc_t->td_link_offset))->t_link;
-
-        tail_buf.b_nob = sizeof(struct m0_be_list_link);
-
-        temp_offset    = &(tail_link->ll_next.logical_address.segid_offset);
-        tail_segid     = temp_offset->u_hi;
-
-        m0_ks_domain_lookup(handle->ks_dom, &tail_seg, tail_segid);
-        M0_ASSERT(tail_seg != NULL);
 
-        tail_buf.b_addr = (void *)tail_link;
-        m0_be_reg_init(&tail_reg, tx, tail_seg, &tail_buf);
-        m0_be_tx_add_cred(tx, tail_reg);
+        tail_obj_link = &((struct m0_be_tlink *)
+                          (tail_obj + desc_t->td_link_offset))->t_link;
+
+        /* Init a region for this link */
+        m0_ks_prep_link_reg(handle->ks_dom, tail_obj_link, tx, &tail_obj_reg);
+        M0_ASSERT(tail_obj_reg != NULL);
+
+        /* Add the current tail itself to credit */
+        list_head = &(handle->ks_tlist.t_head);
+        tail_link = list_head->l_tail.virtual_address;
+        M0_ASSERT(tail_link != NULL);
+ 
+        /* Init a region for this link */
+        m0_ks_prep_link_reg(handle->ks_dom, tail_link, tx, &tail_reg);
+        M0_ASSERT(tail_reg != NULL);
+
+        if (in_tx_state == IN_TX_NULL) {
+                m0_be_tx_add_cred(tx, tail_obj_reg);
+                m0_be_tx_add_cred(tx, tail_reg);
+                m0_ks_tx_prep(tx);
+                m0_ks_tx_start(tx);
+        } else {
+                m0_be_reg_capture(tail_obj_reg);
+                M0_BE_WAIT(tail_obj_reg->br_impl.sm_group, &tail_obj_reg->br_sm,
+                           (1 << M0_BEREG_CAPTURED) | (1 << M0_BEREG_FAILED));
 
-        m0_ks_tx_prep(tx);
-        m0_ks_tx_start(tx);
+                m0_be_reg_capture(tail_reg);
+                M0_BE_WAIT(tail_reg->br_impl.sm_group, &tail_reg->br_sm,
+                           (1 << M0_BEREG_CAPTURED) | (1 << M0_BEREG_FAILED));
+        }
 
         /* Finally, add at tail in tlist */
         m0_be_tlist_add_tail(desc_t, &handle->ks_tlist, new);
@@ -280,20 +316,17 @@ M0_INTERNAL int m0_ks_insert(struct m0_kv_store  *handle,
                              struct m0_be_tx     *ins_tx)
 {
         struct m0_be_reg        *obj_link_reg  = NULL;
+        struct m0_be_reg        *head_reg      = NULL;
         struct m0_be_tl_descr   *desc_t        = NULL; /* temporary */
+        struct m0_be_list_link  *link          = NULL;
+        struct m0_be_list_link  *link_head;
         struct m0_be_list_link  *head;
-        struct m0_be_list_link  *link = NULL;
-        struct m0_be_seg        *link_seg;
-        struct m0_be_tx         *tx = ins_tx;
-        struct m0_be_buf         obj_link_buf;
+        struct m0_be_list       *list_head     = NULL;
+        struct m0_be_tx         *tx            = ins_tx;
+        void                    *new           = NULL;
         void                    *scan;
-        void                    *new  = NULL;
-        int                      ret_val = BE_KV_INVALID_REQ;
-        uint64_t                 link_segid;
-
-        /*
-         * Ensure incoming object reference has been given from be_alloc itself
-         */
+        int                      ret_val       = BE_KV_INVALID_REQ;
+        int                      in_tx_state   = IN_TX_NOT_NULL;
 
         /*
          * TODO: Check magic with magic that would be defined in handle->ks_dom.
@@ -313,9 +346,9 @@ M0_INTERNAL int m0_ks_insert(struct m0_kv_store  *handle,
                 }
         }m0_be_tlist_endfor;
 
-        if (ins_tx == NULL){
-                /* BLOCKING */
-                tx = (struct m0_be_tx *)malloc(sizeof(struct m0_be_tx));
+        if (ins_tx == NULL) {
+                in_tx_state = IN_TX_NULL;
+                M0_ALLOC_PTR(tx);
                 M0_ASSERT(tx != NULL);
 
                 m0_be_tx_init(tx, handle->ks_dom, 0);
@@ -324,45 +357,58 @@ M0_INTERNAL int m0_ks_insert(struct m0_kv_store  *handle,
                            (1 << M0_BETX_PREPARING) | (1 << M0_BETX_FAILED));
         }
 
-        /* Could be a new state */
-
         /* Tlink init for this object */
         m0_be_tlink_init(handle->ks_list_descr, obj_ref);
 
-        obj_link_buf.b_nob = sizeof(struct m0_be_list_link);
-
-       /* Get segment for linkage in object */
         link = &((struct m0_be_tlink *)
                  (new + handle->ks_list_descr->td_link_offset))->t_link;
         M0_ASSERT(link != NULL);
 
-        link_segid = link->ll_next.logical_address.segid_offset.u_hi;
-
-        /* already waits */
-        m0_ks_domain_lookup(handle->ks_dom, &link_seg, link_segid);
-        M0_ASSERT(link_seg != NULL);
-
-        obj_link_buf.b_addr = (void *)link;
-        /* calls group lock */
-        m0_be_reg_init(&obj_link_reg, tx, link_seg, &obj_link_buf);
-
-        /* Add this region in the credit list */
-        m0_be_tx_add_cred(tx, obj_link_reg);
+        /* Init a region for this link */
+        m0_ks_prep_link_reg(handle->ks_dom, link, tx, &obj_link_reg);
+        M0_ASSERT(obj_link_reg != NULL);
+
+        /* Capture this region */
+        if (ins_tx == NULL)
+                m0_be_tx_add_cred(tx, obj_link_reg);
+        else {
+                m0_be_reg_capture(obj_link_reg);
+                M0_BE_WAIT(obj_link_reg->br_impl.sm_group, &obj_link_reg->br_sm,
+                           (1 << M0_BEREG_CAPTURED) | (1 << M0_BEREG_FAILED));
+        }
 
         head = (void *)&handle->ks_tlist.t_head;
 
         if ((head->ll_next.virtual_address == (void *)head) &&
             (head->ll_prev.virtual_address == (void *)head)) {
-                /* Check if list empty, if yes then add as head */
 
-                /* TODO: Add actual head pointer region in credit,
-                 * just like add_tail above
-                 */
-                m0_ks_tx_prep(tx);
-                m0_ks_tx_start(tx);
+                /* Check if list empty, if yes then add as head */
+                /* Capture actual head pointer */
+                list_head = &(handle->ks_tlist.t_head);
+                link_head = list_head->l_head.virtual_address;
+                M0_ASSERT(link_head != NULL);
+                
+                /* Init a region for head */
+                m0_ks_prep_link_reg(handle->ks_dom, link_head, tx, &head_reg);
+                M0_ASSERT(head_reg != NULL);
+
+                /* Capture this region */
+                if (ins_tx == NULL) {
+                        m0_be_tx_add_cred(tx, head_reg);
+                        m0_ks_tx_prep(tx);
+                        m0_ks_tx_start(tx);
+                } else {
+                        m0_be_reg_capture(head_reg);
+                        M0_BE_WAIT(head_reg->br_impl.sm_group,
+                                   &head_reg->br_sm,
+                                   (1 << M0_BEREG_CAPTURED) |
+                                   (1 << M0_BEREG_FAILED));
+                }
 
+                /* Add to tlist now */
                 m0_be_tlist_add(handle->ks_list_descr, &handle->ks_tlist, new);
                 ret_val = BE_KV_SUCCESS;
+
         } else {
                 /* Else, find the appropriate position for the obj and insert */
                 m0_be_tlist_for(handle->ks_list_descr, &handle->ks_tlist, scan)
@@ -372,9 +418,12 @@ M0_INTERNAL int m0_ks_insert(struct m0_kv_store  *handle,
                                  * Add the previous and next pointers about to
                                  * be modified to the credit.
                                  */
-                                __m0_ks_add_prev_next_to_cred(handle, tx, scan);
-                                m0_ks_tx_prep(tx);
-                                m0_ks_tx_start(tx);
+                                __m0_ks_add_prev_next_to_cred(handle, tx, scan,
+                                                              in_tx_state);
+                                if (ins_tx == NULL) {
+                                        m0_ks_tx_prep(tx);
+                                        m0_ks_tx_start(tx);
+                                }
 
                                 /*
                                  * Now add the object to the tlist
@@ -389,8 +438,10 @@ M0_INTERNAL int m0_ks_insert(struct m0_kv_store  *handle,
                 }m0_be_tlist_endfor;
 
                 /* If key is largest in the list, add at tail */
-                if (ret_val == BE_KV_INVALID_REQ)
-                        ret_val = __add_at_tail_to_tlist(handle, new, tx);
+                if (ret_val == BE_KV_INVALID_REQ) {
+                        ret_val = __add_at_tail_to_tlist(handle, new, tx,
+                                                         in_tx_state);
+                }
         }
 
         if (ins_tx == NULL) {
@@ -399,7 +450,7 @@ M0_INTERNAL int m0_ks_insert(struct m0_kv_store  *handle,
                 M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
                            (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED));
                 m0_be_tx_fini(tx);
-                free(tx);
+                m0_free(tx);
         }
 
         return ret_val;
@@ -437,51 +488,25 @@ static void __get_next(struct m0_be_tl_descr   *d,
         *link_next = link->ll_next.virtual_address;
 }
 
-static void __prep_prev_next_reg(struct m0_kv_store     *handle,
-                                 struct m0_be_reg       **prev_reg,
-                                 struct m0_be_reg       **next_reg,
-                                 struct m0_be_list_link *link_prev,
-                                 struct m0_be_list_link *link_next,
-                                 struct m0_be_tx        *tx)
+static void __get_current(struct m0_be_tl_descr  *d,
+                          void                   *current,
+                          struct m0_be_list_link **link_current)
 {
-        struct m0_be_seg *prev_seg = NULL;
-        struct m0_be_seg *next_seg = NULL;
-        struct m0_be_buf  prev_buf;
-        struct m0_be_buf  next_buf;
-        uint64_t          prev_segid;
-        uint64_t          next_segid;
-
-        prev_buf.b_nob  = sizeof(struct m0_be_list_link);
-        next_buf.b_nob  = sizeof(struct m0_be_list_link);
-
-        prev_segid = link_prev->ll_next.logical_address.segid_offset.u_hi;
-        next_segid = link_next->ll_prev.logical_address.segid_offset.u_hi;
-
-        if (prev_segid == next_segid) {
-                m0_ks_domain_lookup(handle->ks_dom, &prev_seg, prev_segid);
-                M0_ASSERT(prev_seg != NULL);
-                next_seg = prev_seg;
-
-        } else {
-                m0_ks_domain_lookup(handle->ks_dom, &next_seg, next_segid);
-                M0_ASSERT(next_seg != NULL);
-
-                m0_ks_domain_lookup(handle->ks_dom, &prev_seg, prev_segid);
-                M0_ASSERT(prev_seg != NULL);
+        int                     link_offset;
+        struct m0_be_list_link *link;
+        struct m0_be_list_link *temp;
 
-        }
+        link_offset = d->td_link_offset;
 
-        prev_buf.b_addr = (void *)link_prev;
-        next_buf.b_addr = (void *)link_next;
+        link = &((struct m0_be_tlink *)(current + link_offset))->t_link;
 
-        m0_be_reg_init(prev_reg, tx, prev_seg, &prev_buf);
-        m0_be_reg_init(next_reg, tx, next_seg, &next_buf);
-        /* reg_capture TODO */
+        temp = link->ll_prev.virtual_address;
+        *link_current = temp->ll_next.virtual_address;
 }
-
 static void __m0_ks_add_prev_next_to_cred(struct m0_kv_store *handle,
                                           struct m0_be_tx    *tx,
-                                          void               *current)
+                                          void               *current,
+                                          int                 in_tx_state)
 {
         struct m0_be_reg         *prev_reg  = NULL;
         struct m0_be_reg         *next_reg  = NULL;
@@ -491,11 +516,24 @@ static void __m0_ks_add_prev_next_to_cred(struct m0_kv_store *handle,
         __get_prev(handle->ks_list_descr, current, &link_prev);
         __get_next(handle->ks_list_descr, current, &link_next);
 
-        __prep_prev_next_reg(handle, &prev_reg, &next_reg, link_prev,
-                             link_next, tx);
+        m0_ks_prep_link_reg(handle->ks_dom, link_prev, tx, &prev_reg);
+        M0_ASSERT(prev_reg != NULL);
+
+        m0_ks_prep_link_reg(handle->ks_dom, link_next, tx, &next_reg);
+        M0_ASSERT(next_reg != NULL);
 
-        m0_be_tx_add_cred(tx, prev_reg);
-        m0_be_tx_add_cred(tx, next_reg);
+        if (in_tx_state == IN_TX_NULL) {
+                m0_be_tx_add_cred(tx, prev_reg);
+                m0_be_tx_add_cred(tx, next_reg);
+        } else {
+                m0_be_reg_capture(prev_reg);
+                M0_BE_WAIT(prev_reg->br_impl.sm_group, &prev_reg->br_sm,
+                           (1 << M0_BEREG_CAPTURED) | (1 << M0_BEREG_FAILED));
+
+                m0_be_reg_capture(next_reg);
+                M0_BE_WAIT(next_reg->br_impl.sm_group, &next_reg->br_sm,
+                           (1 << M0_BEREG_CAPTURED) | (1 << M0_BEREG_FAILED));
+        }
 }
 
 /* @} end of be_kv_store group */
diff --git a/be/lib/be_kv_store.h b/be/lib/be_kv_store.h
index dd9f997..9667013 100644
--- a/be/lib/be_kv_store.h
+++ b/be/lib/be_kv_store.h
@@ -30,6 +30,8 @@
 #define BE_KV_FAILURE     -1
 #define BE_KV_SUCCESS      0
 #define BE_KV_INVALID_REQ  1
+#define IN_TX_NULL         2
+#define IN_TX_NOT_NULL     3
 
 /**
    @defgroup be_kv_store Key Value Store
@@ -57,12 +59,26 @@ struct m0_kv_store {
 };
 
 /*
- * Create and return the handle the user for the key_value_store
+ * Creates a key value store handle.
+ * Returns NULL on failure.
  *
- * @param handle        :       pointer to the handle, out parameter
+ * @param dom           :       pointer to the domain in which handle
+ *                              is to be created
+ * @param descr         :       the list descriptor to be assigned to the handle
+ * @param handle        :       handle to be returned to the user.
+ */
+M0_INTERNAL void m0_ks_create_handle(struct m0_be_domain   *dom,
+                                     struct m0_be_tl_descr *descr,
+                                     struct m0_kv_store   **handle);
+
+
+/*
+ * Update the handle for the key_value_store
+ *
+ * @param handle        :       pointer to the handle
  * @param descr         :       the tlist descriptor to be given to the tlist in
  *                              kv_store
- * @param dom           :       the domain pointer to be initialised
+ * @param dom           :       the domain pointer to be given to the handle
  * @param cmp_fp        :       user defined function to compare keys
  * @param match_fp      :       user defined function to match keys
  */
@@ -71,6 +87,7 @@ M0_INTERNAL void m0_ks_init(struct m0_kv_store     *handle,
                             struct m0_be_domain    *dom,
                             kv_key_cmp              cmp_fp,
                             kv_key_match            match_fp);
+
 /*
  * Insert a key value pair in the tlist contained in @handle.
  * Returns BE_KV_FAILURE or BE_KV_SUCCESS
@@ -82,7 +99,7 @@ M0_INTERNAL void m0_ks_init(struct m0_kv_store     *handle,
  */
 M0_INTERNAL int  m0_ks_insert(struct m0_kv_store  *handle,
                               struct m0_reference *obj_ref,
-                              struct m0_be_tx  *tx);
+                              struct m0_be_tx     *tx);
 
 /*
  * Find object with @key in the tlist contained in @handle.
@@ -101,12 +118,12 @@ M0_INTERNAL void  *m0_ks_find(struct m0_kv_store *handle,
  *
  * @param handle        :       handle containing the tlist in which the @obj is
  *                              stored
- * @param obj_ref       :       the reference allocated to the actual object
+ * @param obj           :       the object to be deleted
  * @param tx            :       transaction handle. Can be NULL.
  */
 M0_INTERNAL int m0_ks_delete(struct m0_kv_store *handle,
-                             struct m0_reference *obj_ref,
-                             struct m0_be_tx *tx);
+                             void               *obj,
+                             struct m0_be_tx    *tx);
 
 /*
  * Returns the m0_reference i.e logical address of the object present next to
@@ -114,7 +131,7 @@ M0_INTERNAL int m0_ks_delete(struct m0_kv_store *handle,
  * Returns NULL on failure
  */
 M0_INTERNAL struct m0_reference *m0_ks_get_next_val(struct m0_kv_store *handle,
-                                                    void *obj);
+                                                    void               *obj);
 
 /** @} end of be_kv_store group */
 
diff --git a/be/lib/ut/be_kv_store.c b/be/lib/ut/be_kv_store.c
index 28a3b0d..84c5f51 100644
--- a/be/lib/ut/be_kv_store.c
+++ b/be/lib/ut/be_kv_store.c
@@ -41,7 +41,7 @@ struct m0_be_tl_descr list_descr = M0_BE_TL_DESCR("kv_store_obj",
 
 struct m0_be_domain     *dom;
 struct m0_be_seg        *seg;
-struct m0_kv_store      handle;
+struct m0_kv_store      *handle = NULL;
 
 int function_comp(void *key1, void *key2)
 {
@@ -70,7 +70,11 @@ static void init()
 
         m0_ks_init_domain(&dom);
         M0_ASSERT(dom != NULL);
-        m0_ks_init(&handle,  &list_descr, dom, cmp_routine, match_routine);
+
+        m0_ks_create_handle(dom, &list_descr, &handle);
+        M0_ASSERT(handle != NULL);
+
+        m0_ks_init(handle, &list_descr, dom, cmp_routine, match_routine);
 }
 
 static void fini()
@@ -78,7 +82,7 @@ static void fini()
         m0_ks_fini(dom, seg);
 }
 
-static struct m0_reference *insert(struct m0_kv_store_obj **obj,
+static int insert(struct m0_kv_store_obj **obj,
                                    char *key_name, int val)
 {
         int                      status  = -2;
@@ -87,81 +91,97 @@ static struct m0_reference *insert(struct m0_kv_store_obj **obj,
         struct m0_be_buf         obj_buf;
         struct m0_be_reg        *obj_reg = NULL;
 
-        tx = (struct m0_be_tx *)malloc(sizeof(struct m0_be_tx));
+        M0_ALLOC_PTR(tx);
+
         if (tx == NULL)
                 goto exit_failure;
 
         m0_be_tx_init(tx, dom, 0);
-
         M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
                    (1 << M0_BETX_PREPARING) | (1 << M0_BETX_FAILED));
 
+        /* Prepare a region for the object */
         obj_buf.b_nob = sizeof(struct m0_kv_store_obj);
         m0_be_reg_init(&obj_reg, tx, seg, &obj_buf);
 
-        (*obj) = (struct m0_kv_store_obj *)m0_ks_obj_malloc(obj_reg, &tx,
-                                                            &obj_ref);
+        /* as nothing in credit list, so can start tx directly */
+        m0_ks_tx_start(tx);
+
+        /* Memory alloc to the object via rvm */
+        (*obj) = (struct m0_kv_store_obj *)m0_ks_obj_malloc(obj_reg, &obj_ref);
+
         if ((*obj) == NULL)
                 goto exit_failure;
 
         M0_ASSERT(obj_ref != NULL);
 
+
         strcpy((*obj)->key, key_name);
         (*obj)->val = val;
 
-        status = m0_ks_insert(&handle, obj_ref, tx);
+        /* Insert this into the kv_store*/
+        status = m0_ks_insert(handle, obj_ref, tx);
         if (status == BE_KV_FAILURE)
                 goto exit_failure;
 
         m0_be_tx_done(tx);
         M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
                    (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED));
-        
+
         m0_be_tx_fini(tx);
 
-        free(tx);
-        return obj_ref;
+        m0_free(tx);
+        return BE_KV_SUCCESS;
 
 exit_failure:
-        return NULL;
+        return BE_KV_FAILURE;
 }
 
 static void *find(char *key)
 {
-        return m0_ks_find(&handle, key);
+        return m0_ks_find(handle, key);
 }
 
-static int delete(struct m0_reference *target)
+static int delete(struct m0_kv_store_obj *target)
 {
-        struct m0_be_tx       tx;
+        struct m0_be_tx      *tx = NULL;
         struct m0_be_buf      obj_buf;
         struct m0_be_reg     *obj_reg = NULL;
         int                   ret_val;
 
-        m0_be_tx_init(&tx, dom, 0);
+        M0_ALLOC_PTR(tx);
+
+        if (tx == NULL)
+                return BE_KV_FAILURE;
 
-        M0_BE_WAIT(tx.bt_impl.sm_group, &tx.bt_sm,
+        m0_be_tx_init(tx, dom, 0);
+        M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
                    (1 << M0_BETX_PREPARING) | (1 << M0_BETX_FAILED));
 
+        /* Prepare a region for this object */
         obj_buf.b_nob = sizeof(struct m0_kv_store_obj);
-        m0_be_reg_init(&obj_reg, &tx, seg, &obj_buf);
+        obj_buf.b_addr = (void *)target;
+        m0_be_reg_init(&obj_reg, tx, seg, &obj_buf);
         M0_ASSERT(obj_reg != NULL);
-        obj_reg->br_buf.b_addr = target->virtual_address;
 
-        m0_be_tx_add_cred(&tx, obj_reg);
+        m0_be_tx_add_cred(tx, obj_reg);
 
-        ret_val = m0_ks_delete(&handle, target, &tx);
-        if (ret_val != BE_KV_FAILURE) {
-                m0_be_free(obj_reg);
-                m0_be_tx_done(&tx);
+        m0_ks_tx_prep(tx);
+        m0_ks_tx_start(tx);
+
+        /* Delete this obj from kv store */
+        ret_val = m0_ks_delete(handle, (void *)target, tx);
 
-                M0_BE_WAIT(tx.bt_impl.sm_group, &tx.bt_sm,
+        if (ret_val != BE_KV_FAILURE) {
+                m0_be_tx_done(tx);
+                M0_BE_WAIT(tx->bt_impl.sm_group, &tx->bt_sm,
                            (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED));
 
                 ret_val = BE_KV_SUCCESS;
         }
 
-        m0_be_tx_fini(&tx);
+        m0_be_tx_fini(tx);
+        m0_free(tx);
         return ret_val;
 }
 
@@ -169,69 +189,77 @@ int main() {
         struct m0_kv_store_obj  *obj1 = NULL;
         struct m0_kv_store_obj  *obj2 = NULL;
         struct m0_kv_store_obj  *obj3 = NULL;
+        struct m0_kv_store_obj  *obj4 = NULL;
         struct m0_kv_store_obj  *ret_obj1 = NULL;
         struct m0_kv_store_obj  *ret_obj2 = NULL;
         struct m0_kv_store_obj  *ret_obj3 = NULL;
-        struct m0_reference     *obj1_ref = NULL;
-        struct m0_reference     *obj2_ref = NULL;
-        struct m0_reference     *obj3_ref = NULL;
+        struct m0_kv_store_obj  *ret_obj4 = NULL;
+
         int                      status = -2;
         char                     obj1_name[] = "abc";
-        char                     obj2_name[] = "ghi";
-        char                     obj3_name[] = "def";
+        char                     obj2_name[] = "def";
+        char                     obj3_name[] = "ghi";
+        char                     obj4_name[] = "jkl";
 
         init();
 
         m0_be_domain_lookup(dom, 1, &seg);
-        M0_BE_WAIT(seg->bs_impl.sm_group, &(seg->bs_sm), 
+        M0_BE_WAIT(seg->bs_impl.sm_group, &(seg->bs_sm),
                    (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED));
 
         M0_ASSERT(seg != NULL);
 
         /* insert obj1 */
-        obj1_ref = insert(&obj1, obj1_name, 1);
-        M0_ASSERT(obj1_ref != NULL);
+        status = insert(&obj1, obj1_name, 1);
+        M0_ASSERT(status == BE_KV_SUCCESS);
         printf("\nInserted obj1...\n");
+
         /* insert obj2 */
-        obj2_ref = insert(&obj2, obj2_name, 2);
-        M0_ASSERT(obj2_ref != NULL);
+        status = insert(&obj2, obj2_name, 2);
+        M0_ASSERT(status == BE_KV_SUCCESS);
         printf("Inserted obj2...\n");
 
         /* insert obj3 */
-        obj3_ref = insert(&obj3, obj3_name, 3);
-        M0_ASSERT(obj3_ref != NULL);
+        status = insert(&obj3, obj3_name, 3);
+        M0_ASSERT(status == BE_KV_SUCCESS);
         printf("Inserted obj3...\n");
 
+        /* insert obj4 */
+        status = insert(&obj4, obj4_name, 4);
+        M0_ASSERT(status == BE_KV_SUCCESS);
+        printf("Inserted obj4...\n");
 
-        printf("\nFinding obj1...\n");
         ret_obj1  = (struct m0_kv_store_obj *)find(obj1_name);
         M0_ASSERT(ret_obj1 != NULL);
-        printf("Found val = %d\n", ret_obj1->val);
+        printf("\nFound obj1 with val = %d\n", ret_obj1->val);
 
-        printf("Finding obj2\n");
         ret_obj2  = (struct m0_kv_store_obj *)find(obj2_name);
         M0_ASSERT(ret_obj2 != NULL);
-        printf("Found val = %d\n", ret_obj2->val);
+        printf("Found obj2 with val = %d\n", ret_obj2->val);
 
-        printf("Finding obj3\n");
         ret_obj3  = (struct m0_kv_store_obj *)find(obj3_name);
         M0_ASSERT(ret_obj3 != NULL);
-        printf("Found val = %d\n", ret_obj3->val);
+        printf("Found obj3 with val = %d\n", ret_obj3->val);
+
+        ret_obj4  = (struct m0_kv_store_obj *)find(obj4_name);
+        M0_ASSERT(ret_obj4 != NULL);
+        printf("Found obj4 with val = %d\n", ret_obj4->val);
+
+        status = delete(ret_obj1);
+        M0_ASSERT(status == BE_KV_SUCCESS);
+        printf("\nDeleted obj1\n");
 
-        printf("\nDeleting obj1\n");
-        status = delete(obj1_ref);
+        status = delete(ret_obj2);
         M0_ASSERT(status == BE_KV_SUCCESS);
-        printf("Deleted\n");
+        printf("Deleted obj2\n");
 
-        printf("Deleting obj2\n");
-        status = delete(obj2_ref);
+        status = delete(ret_obj3);
         M0_ASSERT(status == BE_KV_SUCCESS);
-        printf("Deleted\n");
+        printf("Deleted obj3\n");
 
-        printf("Deleting obj3\n");
-        status = delete(obj3_ref);
+        status = delete(ret_obj4);
         M0_ASSERT(status == BE_KV_SUCCESS);
-        printf("Deleted\n");
+        printf("Deleted obj4\n");
 
         fini();
         return 0;
diff --git a/be/lib/ut/be_tlist.c b/be/lib/ut/be_tlist.c
index ef2c536..b49c3e5 100644
--- a/be/lib/ut/be_tlist.c
+++ b/be/lib/ut/be_tlist.c
@@ -47,7 +47,7 @@ struct m0_be_tl_descr list_descr = M0_BE_TL_DESCR("foo",
 
 struct m0_be_tl         tlist;
 struct m0_be_seg        *seg;
-struct m0_be_domain     dom;
+struct m0_be_domain      dom;
 
 
 /** Displays the @tlist */
-- 
1.8.3.2

