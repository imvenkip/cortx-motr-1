From 038c323faf60b31a6ff773c05bd3e368fdb5f123 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Fri, 17 May 2013 13:56:10 +0300
Subject: [PATCH 94/94] TX pool allocator updated.

---
 be/kvs.c  |   2 +-
 be/pool.c | 128 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++----
 be/pool.h |  27 +++++++++++++
 3 files changed, 148 insertions(+), 9 deletions(-)

diff --git a/be/kvs.c b/be/kvs.c
index cb12a7c..d6370f8 100644
--- a/be/kvs.c
+++ b/be/kvs.c
@@ -277,7 +277,7 @@ M0_INTERNAL int m0_be_kvs_init(struct m0_be_kvs		*ks,
 		goto err;
 	}
 
-	return 0;
+	M0_RETURN(0);
 err:
 	m0_be_kvs_fini(ks);
 	M0_RETURN(rc);
diff --git a/be/pool.c b/be/pool.c
index 79f4f2b..94477c0 100644
--- a/be/pool.c
+++ b/be/pool.c
@@ -22,26 +22,46 @@
 #include "lib/errno.h"
 #include "be/pool.h"
 #include "be/tx.h"
+#include "be/be_private.h"
+
+static struct m0_be_reg *tx_pool_pick(struct m0_be_tx_pool *pool)
+{
+	struct m0_be_reg *reg = m0_be_reg_tlist_head(&pool->tp_rmupd);
+
+	if (reg != NULL)
+		m0_be_reg_tlist_del(reg);
+
+	return reg;
+}
+
+static struct m0_be_reg *tx_pool_alloc(struct m0_be_tx_pool *pool,
+				       size_t size)
+{
+	struct m0_be_reg *reg;
+
+	m0_tl_for(m0_be_reg, &pool->tp_alloc, reg) {
+		if (reg->br_buf.b_nob == size) {
+			m0_be_reg_tlist_del(reg);
+			return reg;
+		}
+	} m0_tl_endfor;
+
+	return NULL;
+}
 
 M0_INTERNAL void *m0_be_tx_pool_alloc(struct m0_be_tx_pool *pool, size_t size)
 {
 	struct m0_be_seg *seg = pool->tp_seg;
 	struct m0_be_tx  *tx  = pool->tp_tx;
 	struct m0_be_reg *reg;
-	struct m0_be_buf  buf;
 
 	M0_ENTRY("seg: %p, tx: %p, size: %zu", seg, tx, size);
 
 	/* @todo: should I free this reg somewhere, or it's freed? */
-        M0_ALLOC_PTR(reg);
+	reg = tx_pool_alloc(pool, size);
         if (reg == NULL)
 		return NULL;
 
-        buf = (struct m0_be_buf) { .b_nob = size };
-        m0_be_reg_init(reg, tx, seg, &buf);
-
-	/* @todo: return code should be analysed */
-        m0_be_alloc(reg);
 	m0_be_tx_add_cred(tx, reg);
 
 	M0_LEAVE("buf.addr: %p", reg->br_buf.b_addr);
@@ -59,7 +79,7 @@ static struct m0_be_reg *pool_reg_prepare(struct m0_be_tx_pool *pool,
 	M0_ENTRY("seg: %p, tx: %p, p: %p", seg, tx, p);
 
 	/* @todo: should I free this reg somewhere, or it's freed? */
-        M0_ALLOC_PTR(reg);
+	reg = tx_pool_pick(pool);
         if (reg == NULL)
 		return NULL;
 
@@ -102,6 +122,92 @@ M0_INTERNAL int m0_be_tx_pool_update(struct m0_be_tx_pool *pool,
 	M0_RETURN(0);
 }
 
+/* @todo: m0_be_alloc() should return error code */
+static int __m0_be_alloc(struct m0_be_reg *reg)
+{
+	m0_be_alloc(reg);
+	return 0;
+}
+
+static void tx_pool_release(struct m0_be_tx_pool *pool)
+{
+	struct m0_be_reg *reg;
+
+	m0_tl_for(m0_be_reg, &pool->tp_alloc, reg) {
+		m0_be_reg_tlist_del(reg);
+		m0_free(reg);
+	} m0_tl_endfor;
+
+	m0_tl_for(m0_be_reg, &pool->tp_rmupd, reg) {
+		m0_be_reg_tlist_del(reg);
+		m0_free(reg);
+	} m0_tl_endfor;
+}
+
+M0_INTERNAL int m0_be_tx_pool__alloc_prep(struct m0_be_tx_pool *pool,
+					  const size_t size[])
+{
+	struct m0_be_seg *seg = pool->tp_seg;
+	struct m0_be_tx  *tx  = pool->tp_tx;
+	struct m0_be_reg *reg;
+	struct m0_be_buf  buf;
+	int		  i;
+
+	M0_ENTRY("seg: %p, tx: %p", seg, tx);
+
+	for (i = 0; size[i] != 0; ++i) {
+		M0_ALLOC_PTR(reg);
+		if (reg == NULL) {
+			tx_pool_release(pool);
+			M0_RETURN(-ENOMEM);
+		}
+
+		buf = (struct m0_be_buf) { .b_nob = size[i] };
+		m0_be_reg_init(reg, tx, seg, &buf);
+		m0_be_reg_tlist_add(&pool->tp_alloc, reg);
+		M0_LOG(M0_DEBUG, "allocated reg %p, size: %zu", reg, size[i]);
+	}
+
+	M0_RETURN(0);
+}
+
+M0_INTERNAL int m0_be_tx_pool_rmupd_prep(struct m0_be_tx_pool *pool, size_t nr)
+{
+	struct m0_be_reg *reg;
+	int		  i;
+
+	/* just allocated some untied regions */
+	for (i = 0; i < nr; ++i) {
+		M0_ALLOC_PTR(reg);
+		if (reg == NULL) {
+			tx_pool_release(pool);
+			M0_RETURN(-ENOMEM);
+		}
+
+		m0_be_reg_tlist_add(&pool->tp_rmupd, reg);
+	}
+
+	M0_RETURN(0);
+}
+
+M0_INTERNAL int m0_be_tx_pool_open(struct m0_be_tx_pool *pool)
+{
+	struct m0_be_reg *reg;
+	int rc;
+
+	m0_tl_for(m0_be_reg, &pool->tp_alloc, reg) {
+		rc = __m0_be_alloc(reg);
+		if (rc != 0) {
+			/* do not free allocated regions at this point since
+			   we're not planning to commit this transaction */
+			tx_pool_release(pool);
+			return rc;
+		}
+	} m0_tl_endfor;
+
+	return rc;
+}
+
 M0_INTERNAL void m0_be_tx_pool_init(struct m0_be_tx_pool *pool,
 				    struct m0_be_seg *seg,
 				    struct m0_be_tx *tx)
@@ -110,10 +216,16 @@ M0_INTERNAL void m0_be_tx_pool_init(struct m0_be_tx_pool *pool,
 		.tp_seg = seg,
 		.tp_tx  = tx
 	};
+
+	m0_be_reg_tlist_init(&pool->tp_alloc);
+	m0_be_reg_tlist_init(&pool->tp_rmupd);
 }
 
 M0_INTERNAL void m0_be_tx_pool_fini(struct m0_be_tx_pool *pool)
 {
+	tx_pool_release(pool);
+	m0_be_reg_tlist_fini(&pool->tp_rmupd);
+	m0_be_reg_tlist_fini(&pool->tp_alloc);
 }
 
 #undef M0_TRACE_SUBSYSTEM
diff --git a/be/pool.h b/be/pool.h
index 6d7e2b8..c6bf41b 100644
--- a/be/pool.h
+++ b/be/pool.h
@@ -4,10 +4,12 @@
 #define __MERO_BE_POOL_H__
 
 #include "lib/types.h"
+#include "lib/tlist.h"
 
 /* fwd */
 struct m0_be_tx;
 struct m0_be_domain;
+struct m0_be_tx_pool_impl;
 
 /* pool */
 struct m0_be_tx_pool {
@@ -15,6 +17,10 @@ struct m0_be_tx_pool {
 	struct m0_be_tx     *tp_tx;
 	/** associated segment */
 	struct m0_be_seg    *tp_seg;
+	/** list of allocated m0_be_reg's with allocated ambient RVM regions */
+	struct m0_tl         tp_alloc;
+	/** list of allocated m0_be_reg's with updated or deleted RVM regions */
+	struct m0_tl         tp_rmupd;
 	/** associated domain */
 	/* struct m0_be_domain *tp_dom; */
 };
@@ -33,5 +39,26 @@ M0_INTERNAL void m0_be_tx_pool_init(struct m0_be_tx_pool *pool,
 
 M0_INTERNAL void m0_be_tx_pool_fini(struct m0_be_tx_pool *pool);
 
+/**
+ * Prepares @nr regions of @size in @pool allocated in m0_be_tx_pool_open().
+ */
+M0_INTERNAL int m0_be_tx_pool__alloc_prep(struct m0_be_tx_pool *pool,
+					  const size_t size[]);
+
+#define m0_be_tx_pool_alloc_prep(pool, ...)			  \
+	m0_be_tx_pool__alloc_prep((pool), (const size_t []) {	  \
+			__VA_ARGS__, 0 })
+
+/**
+ * Prepares @nr regions in @pool marked for update or delete in
+ * m0_be_tx_pool_open().
+ */
+M0_INTERNAL int m0_be_tx_pool_rmupd_prep(struct m0_be_tx_pool *pool, size_t nr);
+
+/**
+ * Does the actual rmv resources allocation used for allocation/deletion/update
+ * inside RVM subsystem.
+ */
+M0_INTERNAL int m0_be_tx_pool_open(struct m0_be_tx_pool *pool);
 
 #endif /* __MERO_BE_POOL_H__ */
-- 
1.8.3.2

