From 9a9d73dddfd473d485bb47cb5efc1ccda77aa21e Mon Sep 17 00:00:00 2001
From: Prashant Dhange <prashant_dhange@xyratex.com>
Date: Fri, 4 Jan 2013 04:15:05 -0800
Subject: [PATCH 24/94] Added functionality to store handles on static region,
 be_tx and be_reg changes, added handle store ut

---
 be/be.c              | 237 -------------------------------------------------
 be/be.h              |   5 +-
 be/be_reg.c          |  42 ++++++++-
 be/be_reg.h          |  16 +++-
 be/be_rvm.c          |   4 +
 be/be_rvm.h          |   4 +
 be/be_seg.c          |   8 +-
 be/be_tx.c           |  30 +++++--
 be/ut/Makefile       |   2 +
 be/ut/Makefile.sub   |   3 +-
 be/ut/be.c           |   2 +-
 be/ut/handle_store.c | 244 +++++++++++++++++++++++++++++++++++++++++++++++++++
 12 files changed, 342 insertions(+), 255 deletions(-)
 delete mode 100644 be/be.c
 create mode 100644 be/ut/handle_store.c

diff --git a/be/be.c b/be/be.c
deleted file mode 100644
index 5c65b0c..0000000
--- a/be/be.c
+++ /dev/null
@@ -1,237 +0,0 @@
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Sachin Patil <spatil@xyratex.com>
- * Original creation date: 30 Nov 2012
- */
-
-#include "be/be.h"
-
-/**
-        Back-end
-
-  @addtogroup be
-  @{
-  */
-
-/**
- * @post reg->br_sm.sm_state == M0_BEREG_INIT
- */
-M0_INTERNAL void m0_be_reg_init(struct m0_be_reg *reg, struct m0_be_tx *tx,
-                                struct m0_be_seg *seg, struct m0_be_buf *buf)
-{
-        /* Asserting on required pointers */
-        M0_ASSERT(reg != NULL);
-        M0_ASSERT(seg != NULL);
-        M0_ASSERT(buf != NULL);
-
-        /* Initialise region structure with required values */
-        reg->br_tx  = tx;
-        reg->br_seg = seg;
-        reg->br_buf = *buf;
-
-        /* todo@ Locking sm_group is required before initializing sm */
-        /* todo@ Register the state machine of the region into sm_group */
-        /* todo@ unlock locked sm group */
-
-        /* todo@ need to call function m0_sm_state_set() for same not
-         * set directly
-         */
-        reg->br_sm.sm_state = M0_BEREG_INIT;
-
-        M0_POST(reg->br_sm.sm_state == M0_BEREG_INIT);
-}
-
-/**
- * Allocates a region.
- * Updates m0_reference of region that can be used to persist pointers
- *
- * @pre reg->br_sm.sm_state == M0_BEREG_INIT
- * @pre reg->br_buf.b_addr == NULL
- * @post M0_IN(reg->br_sm.sm_state, (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
- *                                   M0_BEREG_FAILED))
- */
-
-M0_INTERNAL void m0_be_alloc(struct m0_be_reg *reg)
-{
-        int err;
-        rvm_tid_t               *tid;
-        struct m0_uint128       *toffset;
-        /* Asserting on required pointers */
-        M0_ASSERT(reg != NULL);
-
-        /*
-         * Allocate memory from RDS Heap.
-         * Update br_buf to store virtual address.
-         */
-
-        tid = reg->br_tx->bt_impl.tx_id;
-
-        if (tid == NULL) {
-                /* todo@ need to call function m0_sm_state_set() for same not
-                 * set directly
-                 */
-                reg->br_sm.sm_state = M0_BEREG_FAILED;
-
-                return;
-        }
-
-        /* extern char *rds_malloc(unsigned long size,
-         *                         rvm_tid_t *tid,
-         *                         int *err);
-         */
-        reg->br_buf.b_addr = (void *)rds_malloc(reg->br_buf.b_nob,
-                                                tid, &err);
-
-        toffset = &(reg->br_buf.logical_address.segid_offset);
-
-        toffset->u_hi = reg->br_seg->bs_impl.segment_id;
-        toffset->u_lo = (reg->br_seg->bs_addr - reg->br_buf.b_addr);
-
-
-       if (toffset->u_lo < 0)
-                toffset->u_lo = -(toffset->u_lo);
-
-        /* As heap always starts after segment header of size PAGE_SIZE */
-        toffset->u_lo += PAGE_SIZE;
-
-}
-
-/**
- * Frees a region.
- *
- * Freeing NULL is a no-op.
- *
- * @pre reg->br_sm.sm_state == M0_BEREG_INIT
- * @post M0_IN(reg->br_sm.sm_state, (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
- *                                   M0_BEREG_FAILED))
- */
-M0_INTERNAL void m0_be_free(struct m0_be_reg *reg)
-{
-        int err;
-
-        /* Asserting on required pointers */
-        M0_ASSERT(reg != NULL);
-
-        /*
-         * Allocate memory from RDS Heap.
-         * Update br_buf to store virtual address.
-         */
-
-        rds_free((char *)reg->br_buf.b_addr, NULL, &err);
-
-        if (err != SUCCESS) {
-                /* todo@ need to call function m0_sm_state_set() for same not
-                 * set directly
-                 */
-                reg->br_sm.sm_state = M0_BEREG_FAILED;
-                return;
-        }
-
-        reg->br_buf.b_addr                              = NULL;
-        reg->br_buf.logical_address.segid_offset.u_hi   = 0;
-        reg->br_buf.logical_address.segid_offset.u_lo   = 0;
-
-}
-
-/**
- * Pre-fetches a region.
- *
- * This doesn't incur a state change in region state machine and doesn't report
- * failures.
- *
- * @pre reg->br_sm.sm_state == M0_BEREG_INIT
- * @pre reg->br_buf.b_addr != NULL
- */
-M0_INTERNAL void m0_be_prefetch(const struct m0_be_reg *reg)
-{
-
-        return;
-}
-
-
-/**
- * Un-pins the region, pinned by m0_be_get().
- *
- * @pre reg->br_sm.sm_state == M0_BEREG_INIT
- * @pre reg->br_buf.b_addr != NULL
- * @post M0_IN(reg->br_sm.sm_state, (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
- *                                   M0_BEREG_FAILED))
- */
-M0_INTERNAL void m0_be_put(const struct m0_be_reg *reg)
-{
-
-        return;
-}
-
-/**
- * Captures a region in a transaction.
- *
- * @pre tx->bt_sm.sm_state == M0_BETX_OPEN
- * @pre reg->br_sm.sm_state == M0_BEREG_INIT
- * @post M0_IN(reg->br_sm.sm_state, (M0_BEREG_INPROGRESS, M0_BEREG_SUCCEED,
- *                                   M0_BEREG_FAILED))
- */
-M0_INTERNAL void m0_be_reg_capture(struct m0_be_reg *reg)
-{
-        rvm_return_t ret;
-
-        /* Asserting on required pointers */
-        M0_ASSERT(reg != NULL);
-        M0_ASSERT(reg->br_tx != NULL);
-
-        ret = rvm_set_range(reg->br_tx->bt_impl.tx_id,
-                            reg->br_buf.b_addr,
-                            reg->br_buf.b_nob);
-
-        if (RVM_SUCCESS != ret) {
-                /* Is it right to set reg->br_sm.sm_state to M0_BEREG_FAILED? */
-                /* todo@ need to call function m0_sm_state_set() for same not
-                 * set directly
-                 */
-                reg->br_sm.sm_state = M0_BEREG_FAILED;
-                return;
-        }
-
-        /* todo@ need to call function m0_sm_state_set() for same not
-         * set directly
-         */
-        reg->br_sm.sm_state = M0_BEREG_INPROGRESS;
-}
-
-/**
- * @pre reg->br_sm.sm_state != M0_BEREG_INPROGRESS
- */
-M0_INTERNAL void m0_be_reg_fini(struct m0_be_reg *reg)
-{
-
-        /* Asserting on required pointers */
-        M0_ASSERT(reg != NULL);
-
-        /* todo@ M0_PRE(reg->br_sm.sm_state == M0_BEREG_INPROGRESS); */
-        /* todo@ Finalizing on state machine */
-}
-
-/** @} end group be */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/be/be.h b/be/be.h
index 8eeb7fd..d913909 100644
--- a/be/be.h
+++ b/be/be.h
@@ -472,7 +472,9 @@ struct m0_be_seg {
 
         /** Starting address in primary store. This field is valid in
             M0_BESEG_ACTIVE state. */
-        void                 *bs_addr;
+        void                 *bs_heap_addr;
+
+        void                 *bs_static_addr;
 
         /* be_page which stores mapped page info */
         /* @todo - this stores single page, we need to maintain list
@@ -576,6 +578,7 @@ enum m0_be_seg_state {
 
 
 enum m0_be_tx_state {
+        M0_BETX_INITIALIZING,
         M0_BETX_INIT,
         M0_BETX_PREPARING,
         /* M0_BETX_OPENING renamed to M0_BETX_PREPARED */
diff --git a/be/be_reg.c b/be/be_reg.c
index ed3ad4b..406a041 100644
--- a/be/be_reg.c
+++ b/be/be_reg.c
@@ -36,6 +36,7 @@ static const struct m0_sm_state_descr reg_states[] = {
                 .sd_invariant = NULL,
                 .sd_allowed   = (1 << M0_BEREG_ALLOCATING)      |
                                 (1 << M0_BEREG_FREEING)         |
+                                (1 << M0_BEREG_CAPTURING)       |
                                 (1 << M0_BEREG_FAILED)
         },
         [M0_BEREG_ALLOCATING] = {
@@ -118,6 +119,9 @@ static const struct m0_sm_conf reg_conf = {
         .scf_state     = reg_states
 };
 
+
+static void *static_reg_start_addr = NULL;
+
 /**
  * @post reg->br_sm.sm_state == M0_BEREG_INIT
  */
@@ -140,7 +144,7 @@ M0_INTERNAL void m0_be_reg_init(struct m0_be_reg **reg_out, struct m0_be_tx *tx,
 
         /* Initialise region structure with required values */
         reg->br_tx  = tx;
-        reg->br_tx_cbdata.datum = (void *)tx;
+        reg->br_tx_cbdata.datum = NULL;
         reg->br_tx_cbdata.m0_be_tx_pre_cb = m0_be_tx_get_capture_status;
         reg->br_tx_cbdata.m0_be_tx_post_cb = m0_be_tx_set_capture_status;
 
@@ -215,6 +219,11 @@ M0_INTERNAL void m0_be_free(struct m0_be_reg *reg)
         M0_ASSERT(reg != NULL);
 
         /* @todo - Need to understand pre condition check */
+        /* Locking sm group before setting sm_state */
+        m0_sm_group_lock(reg->br_impl.sm_group);
+        m0_sm_state_set(&(reg->br_sm), M0_BEREG_FREEING);
+        /* Unlock locked sm group */
+        m0_sm_group_unlock(reg->br_impl.sm_group);
 
         reg->br_sm_ast.sa_cb    = m0_be_free_cb;
         reg->br_sm_ast.sa_datum = (void *)reg;
@@ -349,7 +358,7 @@ M0_INTERNAL void m0_be_alloc_cb(struct m0_sm_group *sm_group,
         toffset = &(reg->br_buf.logical_address.segid_offset);
 
         toffset->u_hi = reg->br_seg->bs_impl.segment_id;
-        toffset->u_lo = (reg->br_seg->bs_addr - reg->br_buf.b_addr);
+        toffset->u_lo = (reg->br_seg->bs_heap_addr - reg->br_buf.b_addr);
 
 
        if (toffset->u_lo < 0)
@@ -457,6 +466,35 @@ reg_done_exit:
 }
 
 
+M0_INTERNAL void m0_be_static_reg_init(void *start_addr)
+{
+        static_reg_start_addr = start_addr;
+}
+
+M0_INTERNAL void m0_be_static_reg_update_buf(u_int64_t offset,
+                                             struct m0_be_buf *ubuf,
+                                             struct m0_be_seg *seg,
+                                             struct m0_be_tx *tx)
+{
+        struct m0_be_reg       *reg;
+        struct m0_be_buf        buf;
+
+        m0_be_buf_init(&buf, NULL, ubuf->b_nob, 0, 0, 0);       
+
+        buf.b_addr = static_reg_start_addr + offset;
+
+        m0_be_reg_init(&reg, NULL, seg, &buf);
+
+        m0_be_tx_add_cred(tx, reg);
+
+        m0_be_tx_prep(tx);
+}
+
+M0_INTERNAL void *m0_be_static_reg_get_handle_addr(u_int64_t offset)
+{
+        return (static_reg_start_addr + offset);
+}
+
 /** @} end group be */
 
 /*
diff --git a/be/be_reg.h b/be/be_reg.h
index 78a6e75..1e5f57b 100644
--- a/be/be_reg.h
+++ b/be/be_reg.h
@@ -29,16 +29,26 @@
 #include "be/be.h"
 
 M0_INTERNAL void m0_be_alloc_cb(struct m0_sm_group  *sm_group,
-                                    struct m0_sm_ast *sm_ast);
+                                struct m0_sm_ast *sm_ast);
 
 M0_INTERNAL void m0_be_free_cb(struct m0_sm_group *sm_group,
-                                   struct m0_sm_ast *sm_ast);
+                               struct m0_sm_ast *sm_ast);
 
 M0_INTERNAL void m0_be_reg_capture_cb(struct m0_sm_group *sm_group,
                                       struct m0_sm_ast *sm_ast);
                                   
 M0_INTERNAL void m0_be_reg_req_post(struct m0_sm_group *sm_group,
-                                 struct m0_sm_ast *sm_ast);
+                                    struct m0_sm_ast *sm_ast);
+
+M0_INTERNAL void m0_be_static_reg_init();
+
+M0_INTERNAL void m0_be_static_reg_update_buf(u_int64_t offset,
+                                             struct m0_be_buf *buf,
+                                             struct m0_be_seg *seg,
+                                             struct m0_be_tx *tx);
+
+M0_INTERNAL void *m0_be_static_reg_get_handle_addr(u_int64_t offset);
+
 /** @} end of be group */
 
 /* __MERO_BE_BE_REG_H__ */
diff --git a/be/be_rvm.c b/be/be_rvm.c
index adff75d..aa356ff 100644
--- a/be/be_rvm.c
+++ b/be/be_rvm.c
@@ -52,6 +52,10 @@ void m0_be_rvm_init()
 
 };
 
+void *m0_be_rvm_get_heapaddr()
+{
+        return RecoverableHeapStartAddress;
+}
 /** @} end group be_rvm */
 
 /*
diff --git a/be/be_rvm.h b/be/be_rvm.h
index d63dc93..5f08ff1 100644
--- a/be/be_rvm.h
+++ b/be/be_rvm.h
@@ -28,8 +28,12 @@
   */
 #define LOG_FILE  "/tmp/log_file"
 
+extern void *RecoverableHeapStartAddress;
+
 void m0_be_rvm_init();
 
+void *m0_be_rvm_get_heapaddr();
+
 /** @} end of be_rvm interface */
 
 /* __MERO_BE_BE_RVM_H__ */
diff --git a/be/be_seg.c b/be/be_seg.c
index 954ca28..312a786 100644
--- a/be/be_seg.c
+++ b/be/be_seg.c
@@ -594,7 +594,9 @@ M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
 
         printf("\nstatic_addr : %p\n", static_addr);
 
-        seg->bs_addr = (void *)(static_addr);
+        seg->bs_static_addr = (void *)(static_addr);
+
+        seg->bs_heap_addr = (void *)m0_be_rvm_get_heapaddr();
 
         m0_sm_state_set((&seg->bs_sm), M0_BESEG_ACTIVE);
 
@@ -661,7 +663,9 @@ M0_INTERNAL void m0_be_seg_open_cb(struct m0_sm_group *sm_group,
 
         printf("\nstatic_addr : %p\n", static_addr);
 
-        seg->bs_addr = (void *)(static_addr);
+        seg->bs_static_addr = (void *)(static_addr);
+
+        seg->bs_heap_addr = (void *)m0_be_rvm_get_heapaddr();
 
         m0_sm_state_set((&seg->bs_sm), M0_BESEG_ACTIVE);
 
diff --git a/be/be_tx.c b/be/be_tx.c
index ec132bb..eb30553 100644
--- a/be/be_tx.c
+++ b/be/be_tx.c
@@ -52,12 +52,21 @@
 
 /* State machine variable declarations  */
 static const struct m0_sm_state_descr tx_states[] = {
-        [M0_BETX_INIT] = {
+         [M0_BETX_INITIALIZING] = {
                 .sd_flags     = M0_SDF_INITIAL,
                 .sd_name      = "BE TX INIT",
                 .sd_in        = NULL,
                 .sd_ex        = NULL,
                 .sd_invariant = NULL,
+                .sd_allowed   = (1 << M0_BETX_INIT)        |
+                                (1 << M0_BETX_FAILED)
+        },
+        [M0_BETX_INIT] = {
+                .sd_flags     = 0,
+                .sd_name      = "BE TX INIT",
+                .sd_in        = NULL,
+                .sd_ex        = NULL,
+                .sd_invariant = NULL,
                 .sd_allowed   = (1 << M0_BETX_PREPARING)   |
                                 (1 << M0_BETX_FAILED)
         },
@@ -167,7 +176,7 @@ M0_INTERNAL void m0_be_tx_init(struct m0_be_tx *tx,
         m0_sm_group_lock(tx->bt_impl.sm_group);
 
         /* Register the state machine of the tx into sm_group */
-        m0_sm_init(&tx->bt_sm, &tx_conf, M0_BETX_INIT,
+        m0_sm_init(&tx->bt_sm, &tx_conf, M0_BETX_INITIALIZING,
                    tx->bt_impl.sm_group, NULL);
 
         /* unlock locked sm group */
@@ -182,7 +191,7 @@ M0_INTERNAL void m0_be_tx_init(struct m0_be_tx *tx,
 /**
  * Indicates that a transaction will use certain amount of resources.
  *
- * @pre tx->bt_sm.sm_state == M0_BETX_PREPARING
+ * @pre tx->bt_sm.sm_state == M0_BETX_INIT
  *
  */
 M0_INTERNAL void m0_be_tx_prep(struct m0_be_tx *tx)
@@ -192,8 +201,8 @@ M0_INTERNAL void m0_be_tx_prep(struct m0_be_tx *tx)
         /* Asserting on required pointers */
         M0_ASSERT(tx != NULL);
 
-        /* Is tx->bt_sm.sm_state in M0_BETX_PREPARING state */
-        M0_PRE(tx->bt_sm.sm_state == M0_BETX_PREPARING);
+        /* Is tx->bt_sm.sm_state in M0_BETX_INIT state */
+        M0_PRE(tx->bt_sm.sm_state == M0_BETX_INIT);
 
         /* Iterate credit list of regions */
         m0_tlist_for(&m0_be_reg_tl, &(tx->bt_impl.bc_tl), reg_it) {
@@ -210,6 +219,8 @@ M0_INTERNAL void m0_be_tx_prep(struct m0_be_tx *tx)
 
         } m0_tlist_endfor;
 
+        M0_TX_SM_STATE_SET(tx, M0_BETX_PREPARING);
+
         tx->bt_sm_ast.sa_cb    = m0_be_tx_prep_cb;
         tx->bt_sm_ast.sa_datum = (void *)tx;
 
@@ -235,8 +246,11 @@ M0_INTERNAL void m0_be_tx_start(struct m0_be_tx *tx)
 
         M0_ASSERT(tx != NULL);
 
-        /* Is tx->bt_sm.sm_state in M0_BETX_PREPARED state */
-        M0_PRE(tx->bt_sm.sm_state == M0_BETX_PREPARED);
+        /*
+         * Added M0_IN support to call start when theres nothing in
+         * credit list i.e. without calling tx_prep
+         */
+        M0_IN(tx->bt_sm.sm_state, (M0_BETX_PREPARED, M0_BETX_PREPARING));
 
         tx->bt_sm_ast.sa_cb    = m0_be_tx_start_cb;
         tx->bt_sm_ast.sa_datum = (void *)tx;
@@ -335,7 +349,7 @@ M0_INTERNAL void m0_be_tx_init_cb(struct m0_sm_group *sm_group,
                 /* TODO@ add error log message */
                 goto exit_begin_tx;
         }
-        m0_sm_state_set(&(tx->bt_sm), M0_BETX_PREPARING);
+        m0_sm_state_set(&(tx->bt_sm), M0_BETX_INIT);
         goto exit;
 
 exit_begin_tx:
diff --git a/be/ut/Makefile b/be/ut/Makefile
index 3510a7f..12c3a8f 100644
--- a/be/ut/Makefile
+++ b/be/ut/Makefile
@@ -2,7 +2,9 @@
 
 all:
 	gcc .libs/ut_libmero_ut_la-be.o  ../../mero/.libs/libmero.a  -o ./be_ut  -lpthread  -ldb  -lrt -laio -lrvm -lrds -lseg -L../../../rvm/rvm/.libs -L../../../rvm/rds/.libs -L../../../rvm/seg/.libs
+	gcc .libs/ut_libmero_ut_la-handle_store.o  ../../mero/.libs/libmero.a  -o ./be_hstore -lpthread -ldb -lrt -laio -lrvm -lrds -lseg -L../../../rvm/rvm/.libs -L../../../rvm/rds/.libs -L../../../rvm/seg/.libs
 	rm -rf /tmp/log_file
 
 clean:
 	rm -rf ./be_ut
+	rm -rf ./be_kv_table
diff --git a/be/ut/Makefile.sub b/be/ut/Makefile.sub
index 260d876..6c4175e 100644
--- a/be/ut/Makefile.sub
+++ b/be/ut/Makefile.sub
@@ -1 +1,2 @@
-ut_libmero_ut_la_SOURCES += be/ut/be.c
+ut_libmero_ut_la_SOURCES += be/ut/be.c \
+			    be/ut/handle_store.c
diff --git a/be/ut/be.c b/be/ut/be.c
index 109815e..210296f 100644
--- a/be/ut/be.c
+++ b/be/ut/be.c
@@ -94,7 +94,7 @@ int main()
 
         m0_sm_group_lock(tx.bt_impl.sm_group);
         m0_sm_timedwait(&tx.bt_sm,
-                        (1 << M0_BETX_PREPARING) | (1 << M0_BETX_FAILED),
+                        (1 << M0_BETX_INIT) | (1 << M0_BETX_FAILED),
                         M0_TIME_NEVER);
         m0_sm_group_unlock(tx.bt_impl.sm_group);
         printf("\nTx is initiated\n");
diff --git a/be/ut/handle_store.c b/be/ut/handle_store.c
new file mode 100644
index 0000000..1d39fd8
--- /dev/null
+++ b/be/ut/handle_store.c
@@ -0,0 +1,244 @@
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Prashant Dhange <prashant_dhange@xyratex.com>
+ * Original creation date: 28 Dec 2012
+ */
+
+/**
+ *              Be Domain UT
+ *
+ * The UT does not create Named Segment and thus named segment related
+ * function is not completed for time being
+ */
+
+/**
+  @addtogroup be_ut
+  @{
+  */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include "be/be.h"
+
+struct m0_be_seg *seg;
+struct m0_be_domain *dom;
+struct m0_stob ns_stob, stob;
+struct m0_stob log_stob;
+struct m0_be_tx tx;
+
+void __init()
+{
+        /* Initializing domain */
+        printf("\n\tBackend UT\n");
+        m0_be_domain_create(&dom);
+        m0_be_domain_init(dom);
+        printf("\nDomain is initialized\n");
+
+        /**
+         * This is just done to work other part of the code.
+         * We are not dealing with named segment for this moment.
+         */
+        dom->bd_data.bs_sm.sm_state = M0_BESEG_ACTIVE;
+
+        m0_be_domain_lookup(dom, 1, &seg);
+
+        m0_sm_group_lock(seg->bs_impl.sm_group);
+        m0_sm_timedwait(&(seg->bs_sm),
+                        (1 << M0_BESEG_ACTIVE) | (1 << M0_BESEG_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(seg->bs_impl.sm_group);
+
+
+        if (M0_BESEG_FAILED == seg->bs_sm.sm_state) {
+                printf("\nFailed to create segment \n");
+                return;
+        }
+        printf("\nSegment is opened\n");
+        printf("\nheap addr : %p\n", seg->bs_heap_addr);
+        printf("\nstatic addr : %p\n", seg->bs_static_addr);
+}
+
+
+void __kv_store_table_add(int64_t index, struct m0_uint128 kv_addr)
+{
+        struct m0_be_tx         tx;
+        struct m0_be_buf        buf;
+        struct m0_uint128      *elem;
+        u_int64_t               offset;
+
+        m0_be_tx_init(&tx, dom, 0);
+
+        m0_sm_group_lock(tx.bt_impl.sm_group);
+        m0_sm_timedwait(&tx.bt_sm,
+                        (1 << M0_BETX_INIT) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(tx.bt_impl.sm_group);
+
+        m0_be_buf_init(&buf, NULL, sizeof(struct m0_uint128), 0, 0, 0);
+        offset = index * sizeof(struct m0_uint128);
+        m0_be_static_reg_update_buf(offset, &buf, seg, &tx); 
+
+        m0_sm_group_lock(tx.bt_impl.sm_group);
+        m0_sm_timedwait(&tx.bt_sm,
+                        (1 << M0_BETX_PREPARED) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(tx.bt_impl.sm_group);
+
+        m0_be_tx_start(&tx);
+        m0_sm_group_lock(tx.bt_impl.sm_group);
+        m0_sm_timedwait(&tx.bt_sm,
+                        (1 << M0_BETX_OPEN) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(tx.bt_impl.sm_group);
+
+        elem = (struct m0_uint128 *) m0_be_static_reg_get_handle_addr(offset);
+
+        elem->u_hi = kv_addr.u_hi;
+        elem->u_lo = kv_addr.u_lo;
+
+        m0_be_tx_done(&tx);
+
+        m0_sm_group_lock(tx.bt_impl.sm_group);
+        m0_sm_timedwait(&tx.bt_sm,
+                        (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(tx.bt_impl.sm_group);
+        m0_be_tx_fini(&tx);
+}
+
+
+void __kv_store_table_delete(int64_t index)
+{
+        struct m0_be_tx     tx;
+        struct m0_be_reg *reg;
+        struct m0_be_buf buf;
+        struct m0_uint128  *elem;
+
+        m0_be_tx_init(&tx, dom, 0);
+
+        m0_sm_group_lock(tx.bt_impl.sm_group);
+        m0_sm_timedwait(&tx.bt_sm,
+                        (1 << M0_BETX_PREPARING) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(tx.bt_impl.sm_group);
+        printf("\nTx is initiated\n");
+
+        m0_be_buf_init(&buf, NULL, sizeof(struct m0_uint128), 0, 0, 0);
+        m0_be_reg_init(&reg, NULL, seg, &buf);
+
+        m0_be_tx_add_cred(&tx, reg);
+
+        printf("reg : %p reg_state[%d]\n", reg, reg->br_sm.sm_state);
+        m0_be_tx_prep(&tx);
+
+        m0_sm_group_lock(tx.bt_impl.sm_group);
+        m0_sm_timedwait(&tx.bt_sm,
+                        (1 << M0_BETX_PREPARED) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(tx.bt_impl.sm_group);
+        printf("\nTx is Opening\n");
+
+        m0_be_tx_start(&tx);
+        m0_sm_group_lock(tx.bt_impl.sm_group);
+        m0_sm_timedwait(&tx.bt_sm,
+                        (1 << M0_BETX_OPEN) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(tx.bt_impl.sm_group);
+        printf("\nTx Opened\n");
+
+        elem = (struct m0_uint128 *) m0_be_static_reg_get_handle_addr(0);
+
+        elem->u_hi = 0;
+        elem->u_lo = 0;
+
+        m0_be_tx_done(&tx);
+        m0_sm_group_lock(tx.bt_impl.sm_group);
+        m0_sm_timedwait(&tx.bt_sm,
+                        (1 << M0_BETX_DONE) | (1 << M0_BETX_FAILED),
+                        M0_TIME_NEVER);
+        m0_sm_group_unlock(tx.bt_impl.sm_group);
+        m0_be_tx_fini(&tx);
+        
+}
+
+
+void __kv_store_table_printele(int64_t index)
+{
+        struct m0_uint128 *elem;
+
+        elem = (struct m0_uint128 *) m0_be_static_reg_get_handle_addr(index * sizeof(struct m0_uint128 ));
+
+        printf("Elem %p : [%ld, %ld] \n", elem, elem->u_hi, elem->u_lo);
+}
+
+void __fini()
+{
+        rvm_truncate();
+        rvm_flush();
+
+        m0_be_seg_done(seg);
+        dom->bd_data.bs_sm.sm_state = M0_BESEG_CLOSED;
+        m0_be_domain_fini(dom);
+
+        printf("\nExiting from Backend UT\n");
+
+        printf("\n");
+}
+
+
+int main(int argc, char *argv[])
+{
+        int i=0;
+        int run_mode = atoi(argv[1]);
+
+        __init();
+
+        if (!run_mode) {
+                m0_be_static_reg_init(seg->bs_static_addr);
+                for (i = 0; i < 10; i++) { 
+                        struct m0_uint128 kvstore1;
+                        kvstore1.u_hi = 1 + i;
+                        kvstore1.u_lo = 55229233941 + i;
+                        __kv_store_table_add(i, kvstore1);
+                        __kv_store_table_printele(i);
+                }
+                printf("Address of kv_store_tbl : %p\n", m0_be_static_reg_get_handle_addr(0));
+                for (i = 0; i < 10; i = i+2) {
+                        __kv_store_table_printele(i);
+                }
+        } else {
+                m0_be_static_reg_init(seg->bs_static_addr);
+                //__kv_store_table_delete(2);
+                for (i = 0; i < 10; i = i+2) {
+                        __kv_store_table_printele(i);
+                }
+        }
+        __fini();
+        return 0;
+}
+
+/** @} end group be_ut */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
-- 
1.8.3.2

