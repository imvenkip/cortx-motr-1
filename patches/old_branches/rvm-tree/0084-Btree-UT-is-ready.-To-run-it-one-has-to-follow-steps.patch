From 44999719aaa130ac620d93e3745811500ec51cc3 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Wed, 17 Apr 2013 17:14:59 +0300
Subject: [PATCH 84/94] Btree UT is ready. To run it one has to follow steps:

      1) Create RVM segment and write it into stob:
      	 set in ut/be.c #define RVM_CREATE 1
      	 make
	 ;; run
	 rm -rf /tmp/log_file
	 ./utils/ut.sh -t be-ut:be-tree -p short -e call+ -m be -k | tee tree_create.log

      2) Recover from existing stob and apply some changes to it:
      	 set in ut/be.c #define RVM_CREATE 0
      	 set in ut/be.c #define RVM_LOADED_UPDATE 1
      	 make
	 ;; run
	 rm -rf /tmp/log_file
	 ./utils/ut.sh -t be-ut:be-tree -p short -e call+ -m be -k | tee tree_apply.log

      3) See changes applied in (2)
      	 set in ut/be.c #define RVM_CREATE 0
      	 set in ut/be.c #define RVM_LOADED_UPDATE 0
      	 make
	 ;; run
	 rm -rf /tmp/log_file
	 ./utils/ut.sh -t be-ut:be-tree -p short -e call+ -m be -k | tee tree_show.log
---
 be/ut/be.c | 69 +++++++++++++++++++++++++++++++++++++-------------------------
 1 file changed, 41 insertions(+), 28 deletions(-)

diff --git a/be/ut/be.c b/be/ut/be.c
index 7dfe341..1776b18 100644
--- a/be/ut/be.c
+++ b/be/ut/be.c
@@ -47,7 +47,8 @@
 #include "be/reg.h"
 #include "be/tx.h"
 
-#define RVM_CREATE 0
+#define RVM_CREATE 1
+#define RVM_LOADED_UPDATE 1
 
 static struct m0_be_seg         *seg;
 static struct m0_sm_group       *sm_group;
@@ -363,27 +364,12 @@ M0_UNUSED static void test_be_tree_create(void)
 	m0_free(static_reg);
 }
 
-M0_UNUSED static void test_be_tree_load(void)
+M0_UNUSED static void btree_log(struct btree **tree)
 {
-	int		   rc		M0_UNUSED;
-	uint32_t	   i		M0_UNUSED;
-	uint32_t	   j		M0_UNUSED;
-	uint32_t           min		M0_UNUSED;
-	uint32_t           max		M0_UNUSED;
-	struct btree     **tree;
-	struct m0_be_tx   *tx		M0_UNUSED;
-	struct bt_key_val *kv		M0_UNUSED;
-
-	tree = (struct btree**) m0_be_static_reg_get_handle_addr(seg, 0);
-	/*
-	 * To those who did forget to do the following a painfull debug session
-	 * is guaranteed... Restored segment contains rubbish at that place.
-	 */
-	(*tree)->value     = tree_value;
-	(*tree)->key_size  = tree_key_size;
-	(*tree)->data_size = tree_data_size;
-	(*tree)->ops       = &tops;
-
+	uint32_t	   i;
+	uint32_t	   min;
+	uint32_t	   max;
+	struct bt_key_val *kv;
 	/*
 	 * Call some "tx-less" functions to see what's inside the tree.
 	 */
@@ -404,8 +390,35 @@ M0_UNUSED static void test_be_tree_load(void)
 					     *(uint32_t *)kv->val);
 	}
 	btree_dbg_print(*tree, (*tree)->root);
+}
+
+M0_UNUSED static void test_be_tree_load(void)
+{
+#if RVM_LOADED_UPDATE
+	int		   rc;		/* M0_UNUSED; */
+	uint32_t	   i;		/* M0_UNUSED; */
+	uint32_t	   j;		/* M0_UNUSED; */
+	struct m0_be_tx   *tx;		/* M0_UNUSED; */
+	struct bt_key_val *kv;		/* M0_UNUSED; */
+#endif
+	struct btree     **tree;	/* M0_UNUSED; */
+
+	tree = (struct btree**) m0_be_static_reg_get_handle_addr(seg, 0);
+	M0_UT_ASSERT(tree != NULL);
 
 	/*
+	 * To those who did forget to do the following a painfull debug session
+	 * is guaranteed... Restored segment contains rubbish at that place.
+	 */
+	(*tree)->value     = tree_value;
+	(*tree)->key_size  = tree_key_size;
+	(*tree)->data_size = tree_data_size;
+	(*tree)->ops       = &tops;
+
+	btree_log(tree);
+
+#if RVM_LOADED_UPDATE
+	/*
 	 * Start using transaction...
 	 */
 	tx = be_tx_init();
@@ -413,7 +426,6 @@ M0_UNUSED static void test_be_tree_load(void)
 	/*
 	 * Delete, insert...
 	 */
-#if 0
 	/* tree has the following range of keys at this point: [0 .. 100) */
 	for (i = 3*TREE_KV_NR/4; i < TREE_KV_NR; ++i) {
 		rc = btree_delete_key(*tree, tx, (*tree)->root, &i);
@@ -425,13 +437,13 @@ M0_UNUSED static void test_be_tree_load(void)
 		M0_UT_ASSERT(rc == 0);
 	}
 	/* tree has the following range of keys at this point: [25 .. 75) */
-	btree_dbg_print(*tree, (*tree)->root);
-#endif
-#if 0
+	btree_log(tree);
+
+
 	/* Inserting >2 keys which value is more than 75 most likely will change
 	   the tree root. This may cause several alloc/free operations inside
 	   tree, and numerous updates... */
-	for (i = 0, j = 0; i < TREE_KV_NR/2; ++i, j = 100*(i+1)) {
+	for (i = 0, j = 100; i < TREE_KV_NR/2; ++i, j += 100) {
 		kv = btree_pair_setup(*tree, tx, &j, sizeof(uint32_t),
 				                 &j, sizeof(uint32_t));
 		M0_UT_ASSERT(kv != NULL);
@@ -441,13 +453,14 @@ M0_UNUSED static void test_be_tree_load(void)
 	}
 	/* tree has the following range of keys at this point:
 	   [25 .. 75) | [100 .. +100 .. 5000) */
-	btree_dbg_print(*tree, (*tree)->root);
-#endif
+	btree_log(tree);
+
 	/*
 	 * Finish with transactions...
 	 */
 	be_tx_commit(tx, true);
 	be_tx_fini(tx);
+#endif
 }
 
 
-- 
1.8.3.2

