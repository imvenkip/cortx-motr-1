From 8e534d208be753c5641c13ec851b7beeb4d8c670 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Mon, 29 Apr 2013 14:34:08 +0300
Subject: [PATCH 93/94] RVM: Updated COB interfaces w.r.t. new KV-store.

     - WARNING: tx-pool still requires integration.
---
 be/kvs.c         |   23 +-
 be/kvs.h         |   19 +-
 be/tree.c        |   12 +-
 be/tree.h        |    6 +-
 be/ut/be.c       |    2 +-
 cob/Makefile.sub |    8 +-
 cob/rvm_cob.c    | 1394 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 cob/rvm_cob.h    |  768 ++++++++++++++++++++++++++++++
 cob/ut/rvm_cob.c |  423 +++++++++++++++++
 9 files changed, 2638 insertions(+), 17 deletions(-)
 create mode 100644 cob/rvm_cob.c
 create mode 100644 cob/rvm_cob.h
 create mode 100644 cob/ut/rvm_cob.c

diff --git a/be/kvs.c b/be/kvs.c
index e7b2ca0..cb12a7c 100644
--- a/be/kvs.c
+++ b/be/kvs.c
@@ -338,15 +338,17 @@ M0_INTERNAL struct bt_key_val *m0_be_kvs_pair_setup(const struct m0_be_kvs *ks,
 	return btree_pair_setup(ks->bk_tree, tx, key, key_size, val, val_size);
 }
 
+M0_INTERNAL void m0_be_kvs_pair_release(const struct m0_be_kvs *ks,
+					struct m0_be_tx        *tx,
+					struct bt_key_val      *kv)
+{
+	btree_pair_release(ks->bk_tree, tx, kv);
+}
 
 /* -------------------------------------------------------------------------
  * Interfaces implementation: Cursors.
  * ----------------------------------------------------------------------- */
 
-struct m0_be_kvs_cursor {
-	struct btree_cursor cursor;
-};
-
 /*  */
 M0_INTERNAL void m0_be_kvs_cur_init(struct m0_be_kvs *kvs,
 				    struct m0_be_kvs_cursor *cur)
@@ -355,24 +357,27 @@ M0_INTERNAL void m0_be_kvs_cur_init(struct m0_be_kvs *kvs,
 }
 
 /*  */
-M0_INTERNAL int m0_be_kvs_cur_get(struct m0_be_kvs_cursor *cur, void *key)
+M0_INTERNAL void m0_be_kvs_cur_fini(struct m0_be_kvs_cursor *cur)
 {
-	return 	btree_cur_get(&cur->cursor, key);
 }
 
+/*  */
+M0_INTERNAL int m0_be_kvs_cur_get(struct m0_be_kvs_cursor *cur, void *key,
+				  struct bt_key_val **kv)
+{
+	return btree_cur_get(&cur->cursor, key, kv);
+}
 
 /*  */
 M0_INTERNAL int m0_be_kvs_cur_next(struct m0_be_kvs_cursor *cur,
 				   struct bt_key_val **kv)
 {
-	return 	btree_cur_next(&cur->cursor, kv);
+	return btree_cur_next(&cur->cursor, kv);
 }
 
-
 /*  */
 M0_INTERNAL int m0_be_kvs_cur_prev(struct m0_be_kvs_cursor *cur,
 				   struct bt_key_val **kv)
 {
 	return 	btree_cur_prev(&cur->cursor, kv);
 }
-
diff --git a/be/kvs.h b/be/kvs.h
index d37e49d..ab9e7fa 100644
--- a/be/kvs.h
+++ b/be/kvs.h
@@ -82,15 +82,30 @@ M0_INTERNAL struct bt_key_val *m0_be_kvs_pair_setup(const struct m0_be_kvs *ks,
 						    struct m0_be_tx        *tx,
 						    void *key, size_t key_size,
 						    void *val, size_t val_size);
+/*  */
+M0_INTERNAL void m0_be_kvs_pair_release(const struct m0_be_kvs *ks,
+					struct m0_be_tx        *tx,
+					struct bt_key_val      *kv);
+
 
 /* Have to hide some btree interfaces, kvs will be used instead */
-struct m0_be_kvs_cursor;
+
+/* XXX */
+#include "be/tree.h"
+struct m0_be_kvs_cursor {
+	struct btree_cursor cursor;
+};
 
 /*  */
 M0_INTERNAL void m0_be_kvs_cur_init(struct m0_be_kvs *kvs,
 				    struct m0_be_kvs_cursor *cur);
+
+/*  */
+M0_INTERNAL void m0_be_kvs_cur_fini(struct m0_be_kvs_cursor *cur);
+
 /*  */
-M0_INTERNAL int m0_be_kvs_cur_get(struct m0_be_kvs_cursor *cur, void *key);
+M0_INTERNAL int m0_be_kvs_cur_get(struct m0_be_kvs_cursor *cur, void *key,
+				  struct bt_key_val **kv);
 
 /*  */
 M0_INTERNAL int m0_be_kvs_cur_next(struct m0_be_kvs_cursor *cur,
diff --git a/be/tree.c b/be/tree.c
index e550a6c..294530f 100644
--- a/be/tree.c
+++ b/be/tree.c
@@ -994,6 +994,15 @@ M0_INTERNAL void *btree_get_min_key(struct btree *btree)
 	return node_pos.node->key_vals[node_pos.index]->key;
 }
 
+M0_INTERNAL void btree_pair_release(struct btree *btree,
+				    struct btree_tx_impl *tx,
+				    struct bt_key_val *kv)
+{
+	MEM_FREE(tx, kv->val, btree->tops->data_size(kv->val));
+	MEM_FREE(tx, kv->key, btree->tops->key_size(kv->key));
+	MEM_FREE(tx, kv, sizeof(struct bt_key_val));
+}
+
 M0_INTERNAL struct bt_key_val *btree_pair_setup(struct btree	     *btree,
 						struct btree_tx_impl *tx,
 						void *key, size_t key_size,
@@ -1136,7 +1145,7 @@ M0_INTERNAL void btree_cur_init(struct btree *btree, struct btree_cursor *cur)
 	btree->root->prev = cur->node;
 }
 
-M0_INTERNAL int btree_cur_get(struct btree_cursor *cur, void *key)
+M0_INTERNAL int btree_cur_get(struct btree_cursor *cur, void *key, struct bt_key_val **kv)
 {
 	cur->last = get_btree_node(cur->tree, key);
 	if (cur->last.node == NULL)
@@ -1144,6 +1153,7 @@ M0_INTERNAL int btree_cur_get(struct btree_cursor *cur, void *key)
 
 	cur->pos = cur->last.index;
 	cur->node = cur->last.node;
+	*kv = cur->node->key_vals[cur->pos];
 
 	return 0;
 }
diff --git a/be/tree.h b/be/tree.h
index 87d086e..26810db 100644
--- a/be/tree.h
+++ b/be/tree.h
@@ -72,6 +72,10 @@ M0_INTERNAL void *btree_get_max_key(struct btree *btree);
 
 M0_INTERNAL void *btree_get_min_key(struct btree *btree);
 
+M0_INTERNAL void btree_pair_release(struct btree *btree,
+				    struct btree_tx_impl *tx,
+				    struct bt_key_val *kv);
+
 M0_INTERNAL struct bt_key_val *btree_pair_setup(struct btree *btree,
 						struct btree_tx_impl *tx,
 						void *key, size_t key_size,
@@ -93,7 +97,7 @@ struct btree_cursor {
 };
 
 M0_INTERNAL void btree_cur_init(struct btree *btree, struct btree_cursor *cur);
-M0_INTERNAL int btree_cur_get(struct btree_cursor *cur, void *key);
+M0_INTERNAL int btree_cur_get(struct btree_cursor *cur, void *key, struct bt_key_val **kv);
 M0_INTERNAL int btree_cur_next(struct btree_cursor *cur, struct bt_key_val **kv);
 M0_INTERNAL int btree_cur_prev(struct btree_cursor *cur, struct bt_key_val **kv);
 
diff --git a/be/ut/be.c b/be/ut/be.c
index 6d55b44..b632be3 100644
--- a/be/ut/be.c
+++ b/be/ut/be.c
@@ -377,7 +377,7 @@ static void be_tree_cursor_test(struct btree *tree, bool forward)
 	btree_cur_init(tree, &cur);
 
 	sprintf(ckv, "%d", 55);
-	rc = btree_cur_get(&cur, ckv);
+	rc = btree_cur_get(&cur, ckv, &kv);
 	M0_UT_ASSERT(rc == 0);
 
 	while (true) {
diff --git a/cob/Makefile.sub b/cob/Makefile.sub
index e7721f5..4839169 100644
--- a/cob/Makefile.sub
+++ b/cob/Makefile.sub
@@ -1,4 +1,6 @@
-nobase_mero_include_HEADERS += cob/cob.h \
+nobase_mero_include_HEADERS += cob/cob.h	\
+			       cob/rvm_cob.h	\
 			       cob/ns_iter.h
-mero_libmero_la_SOURCES  += cob/cob.c \
-			    cob/ns_iter.c
+mero_libmero_la_SOURCES  += cob/cob.c		\
+			    cob/ns_iter.c 	\
+			    cob/rvm_cob.c
diff --git a/cob/rvm_cob.c b/cob/rvm_cob.c
new file mode 100644
index 0000000..f2be8f8
--- /dev/null
+++ b/cob/rvm_cob.c
@@ -0,0 +1,1394 @@
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Nathan Rutman <nathan_rutman@xyratex.com>
+ * Original creation date: 10/24/2010
+ *
+ * Mdstore changes: Yuriy Umanets <yuriy_umanets@xyratex.com>
+ */
+
+#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_COB
+#include "lib/trace.h"        /* M0_LOG and M0_ENTRY */
+
+#include "lib/misc.h"   /* M0_SET0 */
+#include "lib/cdefs.h"
+#include "lib/arith.h"   /* M0_3WAY */
+#include "lib/errno.h"
+#include "lib/assert.h"
+#include "lib/memory.h"
+#include "lib/bitstring.h"
+#include "cob/rvm_cob.h"
+
+/**
+   @addtogroup cob
+   @{
+*/
+
+enum {
+        XX_COB_NAME_MAX = 256
+};
+
+/**
+   Storage virtual root. All cobs are placed in it.
+ */
+const struct m0_fid XX_COB_ROOT_FID = {
+        .f_container = 1ULL,
+        .f_key       = 1ULL
+};
+
+/**
+   Root session fid. All sessions are placed in it.
+*/
+const struct m0_fid XX_COB_SESSIONS_FID = {
+        .f_container = 1ULL,
+        .f_key       = 2ULL
+};
+
+/**
+   Metadata hierarchry root fid.
+*/
+const struct m0_fid XX_COB_SLASH_FID = {
+        .f_container = 1ULL,
+        .f_key       = 3ULL
+};
+
+const char XX_COB_ROOT_NAME[] = "ROOT";
+const char XX_COB_SESSIONS_NAME[] = "SESSIONS";
+
+static const struct m0_addb_ctx_type xx_cob_domain_addb = {
+        .act_name = "cob-domain"
+};
+
+static const struct m0_addb_ctx_type xx_cob_addb = {
+        .act_name = "cob"
+};
+
+static const struct m0_addb_loc cob_addb_loc = {
+        .al_name = "cob"
+};
+
+M0_INTERNAL void xx_cob_oikey_make(struct xx_cob_oikey *oikey,
+				   const struct m0_fid *fid, int linkno)
+{
+        oikey->cok_fid = *fid;
+        oikey->cok_linkno = linkno;
+}
+
+M0_INTERNAL int xx_cob_nskey_make(struct xx_cob_nskey **keyh,
+				  const struct m0_fid *pfid,
+				  const char *name, size_t namelen)
+{
+        struct xx_cob_nskey *key;
+
+        key = m0_alloc(sizeof *key + namelen);
+        if (key == NULL)
+                return -ENOMEM;
+        key->cnk_pfid = *pfid;
+        m0_bitstring_copy(&key->cnk_name, name, namelen);
+        *keyh = key;
+        return 0;
+}
+
+M0_INTERNAL int xx_cob_nskey_cmp(const struct xx_cob_nskey *k0,
+				 const struct xx_cob_nskey *k1)
+{
+        int rc;
+
+        M0_PRE(m0_fid_is_set(&k0->cnk_pfid));
+        M0_PRE(m0_fid_is_set(&k1->cnk_pfid));
+
+        rc = m0_fid_cmp(&k0->cnk_pfid, &k1->cnk_pfid);
+        return rc ?: m0_bitstring_cmp(&k0->cnk_name, &k1->cnk_name);
+}
+
+M0_INTERNAL size_t xx_cob_nskey_size(const struct xx_cob_nskey *cnk)
+{
+        return sizeof *cnk +
+                m0_bitstring_len_get(&cnk->cnk_name);
+}
+
+/**
+   Fabrec size taking into account symlink length.
+ */
+static size_t xx_cob_fabrec_size(const struct xx_cob_fabrec *rec)
+{
+        return sizeof *rec + rec->cfb_linklen;
+}
+
+M0_INTERNAL int xx_cob_fabrec_make(struct xx_cob_fabrec **rech,
+				   const char *link, size_t linklen)
+{
+        struct xx_cob_fabrec *rec;
+
+        rec = m0_alloc(sizeof(struct xx_cob_fabrec) + linklen);
+        if (rec == NULL)
+                return -ENOMEM;
+        rec->cfb_linklen = linklen;
+        if (linklen > 0)
+                memcpy(rec->cfb_link, link, linklen);
+        *rech = rec;
+        return 0;
+}
+
+/**
+   Maximal possible fabrec size.
+ */
+static size_t xx_cob_max_fabrec_size(void)
+{
+        return sizeof(struct xx_cob_fabrec) + XX_COB_NAME_MAX;
+}
+
+/**
+   Allocate memory for maximal possible size of fabrec.
+ */
+static int xx_cob_max_fabrec_make(struct xx_cob_fabrec **rech)
+{
+        struct xx_cob_fabrec *rec;
+
+        rec = m0_alloc(xx_cob_max_fabrec_size());
+        if (rec == NULL)
+                return -ENOMEM;
+        rec->cfb_linklen = XX_COB_NAME_MAX;
+        *rech = rec;
+        return 0;
+}
+
+/**
+   Make nskey for iterator. Allocate space for max possible name
+   but put real string len into the struct.
+*/
+#if 0 /* XXX */
+static int xx_cob_max_nskey_make(struct xx_cob_nskey **keyh,
+                                 const struct m0_fid *pfid,
+                                 const char *name,
+                                 int namelen)
+{
+        struct xx_cob_nskey *key;
+
+        key = m0_alloc(sizeof *key + XX_COB_NAME_MAX);
+        if (key == NULL)
+                return -ENOMEM;
+        key->cnk_pfid = *pfid;
+        m0_bitstring_copy(&key->cnk_name, name, namelen);
+        *keyh = key;
+        return 0;
+}
+#endif /* /XXX */
+
+/**
+   Key size for iterator in which case we don't know exact length of key
+   and want to allocate it for worst case scenario, that is, for max
+   possible name len.
+ */
+static size_t xx_cob_nskey_size_max(const struct xx_cob_nskey *cnk)
+{
+        return sizeof *cnk + XX_COB_NAME_MAX;
+}
+
+/**
+   Namespace table definition.
+*/
+static int ns_cmp(void *key0, void *key1)
+{
+        return xx_cob_nskey_cmp((const struct xx_cob_nskey *)key0,
+                                (const struct xx_cob_nskey *)key1);
+}
+
+static uint32_t ns_key_sz(void *key)
+{
+	return xx_cob_nskey_size_max(key);
+}
+
+static uint32_t ns_rec_sz(void *rec)
+{
+	return sizeof(struct xx_cob_nsrec);
+}
+
+/**
+   Object index table definition.
+*/
+static int oi_cmp(void *key0, void *key1)
+{
+        const struct xx_cob_oikey *cok0 = key0;
+        const struct xx_cob_oikey *cok1 = key1;
+        int                        rc;
+
+        M0_PRE(m0_fid_is_set(&cok0->cok_fid));
+        M0_PRE(m0_fid_is_set(&cok1->cok_fid));
+
+        rc = m0_fid_cmp(&cok0->cok_fid, &cok1->cok_fid);
+        return rc ?: M0_3WAY(cok0->cok_linkno, cok1->cok_linkno);
+}
+
+static uint32_t oi_key_sz(void *key)
+{
+	return sizeof(struct xx_cob_oikey);
+}
+
+/* static uint32_t oi_rec_sz(void *rec) */
+/* { */
+/* } */
+
+static int fb_cmp(void *key0, void *key1)
+{
+        const struct xx_cob_fabkey *cok0 = key0;
+        const struct xx_cob_fabkey *cok1 = key1;
+
+        M0_PRE(m0_fid_is_set(&cok0->cfb_fid));
+        M0_PRE(m0_fid_is_set(&cok1->cfb_fid));
+
+        return m0_fid_cmp(&cok0->cfb_fid, &cok1->cfb_fid);
+}
+
+static uint32_t fb_key_sz(void *key)
+{
+	return sizeof(struct xx_cob_fabkey);
+}
+
+/* static uint32_t fb_rec_sz(const void *rec) */
+/* { */
+/* } */
+
+/**
+   Omg table definition.
+*/
+static int omg_cmp(void *key0, void *key1)
+{
+        struct xx_cob_omgkey *cok0 = key0;
+        struct xx_cob_omgkey *cok1 = key1;
+        return M0_3WAY(cok0->cok_omgid, cok1->cok_omgid);
+}
+
+static uint32_t omg_key_sz(void *key)
+{
+	return sizeof(struct xx_cob_omgkey);
+}
+
+static uint32_t omg_rec_sz(void *rec)
+{
+	return sizeof(struct xx_cob_omgrec);
+}
+#if 0 /* XXX*/
+static char *cob_dom_id_make(char *buf, const struct xx_cob_domain_id *id,
+                             const char *prefix)
+{
+        sprintf(buf, "%s%u", prefix ? prefix : "", id->id);
+        return buf;
+}
+#endif
+
+/* XXX */
+enum kvs_table_id {
+	KVS_TREE_NS,
+	KVS_TREE_OI,
+	KVS_TREE_FB,
+	KVS_TREE_FO
+};
+
+static const struct btree_ops cob_ns_ops = {
+	.compare   = ns_cmp,
+	.key_size  = ns_key_sz,
+	.data_size = ns_rec_sz
+};
+
+static const struct btree_ops cob_oi_ops = {
+	.compare   = oi_cmp,
+	.key_size  = oi_key_sz,
+	.data_size = NULL/* oi_rec_sz XXX */
+};
+
+static const struct btree_ops cob_fab_ops = {
+	.compare   = fb_cmp,
+	.key_size  = fb_key_sz,
+	.data_size = NULL/* fb_rec_sz XXX */
+};
+
+static const struct btree_ops cob_omg_ops = {
+	.compare   = omg_cmp,
+	.key_size  = omg_key_sz,
+	.data_size = omg_rec_sz
+};
+
+/**
+   Set up a new cob domain
+
+   Tables are identified by the domain id, which must be set before calling
+   this function.
+  */
+int xx_cob_domain_init(struct xx_cob_domain *dom, struct m0_be_domain *be_dom,
+		       const struct xx_cob_domain_id *id)
+{
+        int rc;
+	int i;
+
+	struct {
+		struct m0_be_kvs       *table;
+		enum kvs_table_id       id;
+		const struct btree_ops *ops;
+	} tables[] = {
+		{ &dom->cd_namespace,      KVS_TREE_NS, &cob_ns_ops },
+		{ &dom->cd_object_index,   KVS_TREE_OI, &cob_oi_ops },
+		{ &dom->cd_fileattr_basic, KVS_TREE_FB, &cob_fab_ops },
+		{ &dom->cd_fileattr_omg,   KVS_TREE_FO, &cob_omg_ops },
+	};
+
+        dom->cd_id = *id;
+        M0_PRE(dom->cd_id.id != 0);
+	M0_PRE(dom->cd_id.id == 1); /* XXX: for now */
+
+        m0_addb_ctx_init(&dom->cd_addb, &xx_cob_domain_addb,
+			 &m0_addb_global_ctx);
+
+	for (rc = i = 0; rc == 0 && i < ARRAY_SIZE(tables); ++i)
+		rc = m0_be_kvs_init(tables[i].table, be_dom, tables[i].ops,
+				    M0_BE_KVS_CREATE, tables[i].id);
+
+	while (i > 0)
+		m0_be_kvs_fini(tables[--i].table);
+
+        return rc;
+}
+
+void xx_cob_domain_fini(struct xx_cob_domain *dom)
+{
+        m0_be_kvs_fini(&dom->cd_fileattr_omg);
+        m0_be_kvs_fini(&dom->cd_fileattr_basic);
+        m0_be_kvs_fini(&dom->cd_object_index);
+        m0_be_kvs_fini(&dom->cd_namespace);
+        m0_addb_ctx_fini(&dom->cd_addb);
+}
+M0_EXPORTED(xx_cob_domain_fini);
+
+#ifndef __KERNEL__
+#include <sys/stat.h>    /* S_ISDIR */
+
+#define MKFS_ROOT_SIZE          4096
+#define MKFS_ROOT_BLKSIZE       4096
+#define MKFS_ROOT_BLOCKS        16
+
+/**
+ * Create intial files system structures, such as: entire storage root, root cob
+ * for sessions and root cob for hierarchy. Latter is only one of them visible
+ * to user on client.
+ */
+M0_INTERNAL int xx_cob_domain_mkfs(struct xx_cob_domain *dom,
+				   const struct m0_fid *rootfid,
+				   const struct m0_fid *sessfid,
+				   struct m0_be_tx *tx)
+{
+        struct xx_cob_nskey  *nskey;
+        struct xx_cob_nsrec   nsrec;
+        struct xx_cob_omgkey  omgkey;
+        struct xx_cob_omgrec  omgrec;
+        struct xx_cob_fabrec *fabrec;
+        struct bt_key_val    *pair;
+        struct m0_cob        *cob;
+        time_t                now;
+        int                   rc;
+
+        /**
+           Create terminator omgid record with id == ~0ULL.
+         */
+        omgkey.cok_omgid = ~0ULL;
+
+        M0_SET0(&omgrec);
+
+	pair = m0_be_kvs_pair_setup(&dom->cd_fileattr_omg, tx,
+				    &omgkey, sizeof omgkey,
+				    &omgrec, sizeof omgrec);
+	if (pair == NULL)
+		return -ENOMEM;
+
+	rc = m0_be_kvs_insert(&dom->cd_fileattr_omg, tx, pair);
+        if (rc != 0) {
+		m0_be_kvs_pair_release(&dom->cd_fileattr_omg, tx, pair);
+                return rc;
+	}
+
+        /**
+           Create root cob where all namespace is stored.
+         */
+        M0_SET0(&nsrec);
+
+        rc = xx_cob_alloc(dom, &cob);
+        if (rc != 0)
+                return rc;
+
+        rc = xx_cob_nskey_make(&nskey, &XX_COB_ROOT_FID, XX_COB_ROOT_NAME,
+                               strlen(XX_COB_ROOT_NAME));
+        if (rc != 0) {
+            xx_cob_put(cob);
+            return rc;
+        }
+
+        nsrec.cnr_omgid = 0;
+        nsrec.cnr_fid = *rootfid;
+
+        nsrec.cnr_nlink = 1;
+        nsrec.cnr_size = MKFS_ROOT_SIZE;
+        nsrec.cnr_blksize = MKFS_ROOT_BLKSIZE;
+        nsrec.cnr_blocks = MKFS_ROOT_BLOCKS;
+        if (time(&now) < 0) {
+                xx_cob_put(cob);
+                m0_free(nskey);
+                return errno;
+        }
+        nsrec.cnr_atime = nsrec.cnr_mtime = nsrec.cnr_ctime = now;
+
+        omgrec.cor_uid = 0;
+        omgrec.cor_gid = 0;
+        omgrec.cor_mode = S_IFDIR |
+                          S_IRUSR | S_IWUSR | S_IXUSR | /* rwx for owner */
+                          S_IRGRP | S_IXGRP |           /* r-x for group */
+                          S_IROTH | S_IXOTH;            /* r-x for others */
+
+        rc = xx_cob_fabrec_make(&fabrec, NULL, 0);
+        if (rc != 0) {
+                xx_cob_put(cob);
+                m0_free(nskey);
+                return rc;
+        }
+
+        rc = xx_cob_create(cob, nskey, &nsrec, fabrec, &omgrec, tx);
+        xx_cob_put(cob);
+        if (rc != 0) {
+                m0_free(nskey);
+                m0_free(fabrec);
+                return rc;
+        }
+
+        /**
+           Create root session.
+         */
+        M0_SET0(&nsrec);
+
+        rc = xx_cob_alloc(dom, &cob);
+        if (rc != 0)
+                return rc;
+
+        rc = xx_cob_nskey_make(&nskey, &XX_COB_ROOT_FID, XX_COB_SESSIONS_NAME,
+                               strlen(XX_COB_SESSIONS_NAME));
+        if (rc != 0) {
+                xx_cob_put(cob);
+                return rc;
+        }
+
+        nsrec.cnr_omgid = 0;
+        nsrec.cnr_fid = *sessfid;
+
+        nsrec.cnr_nlink = 1;
+        nsrec.cnr_size = MKFS_ROOT_SIZE;
+        nsrec.cnr_blksize = MKFS_ROOT_BLKSIZE;
+        nsrec.cnr_blocks = MKFS_ROOT_BLOCKS;
+        nsrec.cnr_atime = nsrec.cnr_mtime = nsrec.cnr_ctime = now;
+
+        omgrec.cor_uid = 0;
+        omgrec.cor_gid = 0;
+        omgrec.cor_mode = S_IFDIR |
+                          S_IRUSR | S_IWUSR | S_IXUSR | /* rwx for owner */
+                          S_IRGRP | S_IXGRP |           /* r-x for group */
+                          S_IROTH | S_IXOTH;            /* r-x for others */
+
+        rc = xx_cob_fabrec_make(&fabrec, NULL, 0);
+        if (rc != 0) {
+                xx_cob_put(cob);
+                m0_free(nskey);
+        }
+
+        fabrec->cfb_version.vn_lsn = M0_LSN_RESERVED_NR + 2;
+        fabrec->cfb_version.vn_vc = 0;
+
+        rc = xx_cob_create(cob, nskey, &nsrec, fabrec, &omgrec, tx);
+        xx_cob_put(cob);
+        if (rc != 0) {
+                m0_free(nskey);
+                m0_free(fabrec);
+                return rc;
+        }
+        return 0;
+}
+#endif
+
+static void cob_free_cb(struct m0_ref *ref);
+
+static void cob_init(struct xx_cob_domain *dom, struct m0_cob *cob)
+{
+        m0_addb_ctx_init(&cob->co_addb, &xx_cob_addb, &dom->cd_addb);
+        m0_ref_init(&cob->co_ref, 1, cob_free_cb);
+        cob->co_fid = &cob->co_nsrec.cnr_fid;
+        cob->co_nskey = NULL;
+        cob->co_dom = dom;
+        cob->co_flags = 0;
+}
+
+static void cob_fini(struct m0_cob *cob)
+{
+        if (cob->co_flags & M0_CA_NSKEY_FREE)
+                m0_free(cob->co_nskey);
+        if (cob->co_flags & M0_CA_FABREC)
+                m0_free(cob->co_fabrec);
+        m0_addb_ctx_fini(&cob->co_addb);
+}
+
+/**
+   Return cob memory to the pool
+ */
+static void cob_free_cb(struct m0_ref *ref)
+{
+        struct m0_cob *cob;
+
+        cob = container_of(ref, struct m0_cob, co_ref);
+        cob_fini(cob);
+        m0_free(cob);
+}
+
+M0_INTERNAL void xx_cob_get(struct m0_cob *cob)
+{
+        m0_ref_get(&cob->co_ref);
+}
+
+M0_INTERNAL void xx_cob_put(struct m0_cob *cob)
+{
+        m0_ref_put(&cob->co_ref);
+}
+
+M0_INTERNAL int xx_cob_alloc(struct xx_cob_domain *dom, struct m0_cob **out)
+{
+        struct m0_cob *cob;
+
+        M0_ALLOC_PTR_ADDB(cob, &dom->cd_addb, &cob_addb_loc);
+        if (cob == NULL)
+                return -ENOMEM;
+
+        cob_init(dom, cob);
+        *out = cob;
+
+        return 0;
+}
+
+static int cob_ns_lookup(struct m0_cob *cob, struct m0_be_tx *txx);
+static int cob_oi_lookup(struct m0_cob *cob, struct m0_be_tx *txx);
+static int cob_fab_lookup(struct m0_cob *cob, struct m0_be_tx *txx);
+
+/**
+   Search for a record in the namespace table
+
+   If the lookup fails, we return error and co_flags accurately reflects
+   the missing fields.
+
+   @see cob_oi_lookup
+ */
+static int cob_ns_lookup(struct m0_cob *cob, struct m0_be_tx *tx)
+{
+        struct bt_key_val *pair;
+
+        M0_PRE(cob->co_nskey != NULL && m0_fid_is_set(&cob->co_nskey->cnk_pfid));
+
+	pair = m0_be_kvs_lookup(&cob->co_dom->cd_namespace, cob->co_nskey);
+	if (pair == NULL)
+		return -ENOENT;
+
+	cob->co_nsrec = *(struct xx_cob_nsrec *)pair->val; /* XXX? */
+	cob->co_flags |= M0_CA_NSREC;
+	M0_ASSERT(cob->co_nsrec.cnr_linkno > 0 ||
+		  cob->co_nsrec.cnr_nlink > 0);
+	M0_POST(m0_fid_is_set(cob->co_fid));
+
+        return 0;
+}
+
+/**
+   Search for a record in the object index table.
+   Most likely we want stat data for a given fid, so let's do that as well.
+
+   @see cob_ns_lookup
+ */
+static int cob_oi_lookup(struct m0_cob *cob, struct m0_be_tx *txx)
+{
+        struct m0_be_kvs_cursor  cursor;
+        struct xx_cob_oikey      oldkey;
+        struct xx_cob_nskey     *nskey;
+        int                      rc;
+
+        if (cob->co_flags & M0_CA_NSKEY)
+                return 0;
+
+        if (cob->co_flags & M0_CA_NSKEY_FREE) {
+                m0_free(cob->co_nskey);
+                cob->co_flags &= ~M0_CA_NSKEY_FREE;
+        }
+
+        oldkey = cob->co_oikey;
+
+        /*
+         * Find the name from the object index table. Note the key buffer
+         * is out of scope outside of this function, but the record is good
+         * until m0_db_pair_fini.
+         */
+        //m0_db_pair_setup(&cob->co_oipair, &cob->co_dom->cd_object_index,
+        //                 &cob->co_oikey, sizeof cob->co_oikey, NULL, 0);
+
+        /*
+         * We use cursor here because in some situations we need
+         * to find most suitable position instead of exact location.
+         */
+	m0_be_kvs_cur_init(&cob->co_dom->cd_object_index, &cursor);
+
+        rc = m0_be_kvs_cur_get(&cursor, &cob->co_oikey, &cob->co_oipair);
+        if (rc != 0) {
+                M0_LOG(M0_DEBUG, "m0_be_kvs_cur_get() failed with %d", rc);
+                goto out;
+        }
+
+        /*
+         * Found position should have same fid.
+         */
+        if (!m0_fid_eq(&oldkey.cok_fid, &cob->co_oikey.cok_fid)) {
+                rc = -ENOENT;
+                goto out;
+        }
+
+        nskey = (struct xx_cob_nskey *)cob->co_oipair->val; /* XXX? */
+        rc = xx_cob_nskey_make(&cob->co_nskey, &nskey->cnk_pfid,
+                               m0_bitstring_buf_get(&nskey->cnk_name),
+                               m0_bitstring_len_get(&nskey->cnk_name));
+        cob->co_flags |= (M0_CA_NSKEY | M0_CA_NSKEY_FREE);
+out:
+	m0_be_kvs_cur_fini(&cursor);
+        return rc;
+}
+
+/**
+   Search for a record in the fileattr_basic table.
+
+   @see cob_ns_lookup
+   @see cob_oi_lookup
+ */
+static int cob_fab_lookup(struct m0_cob *cob, struct m0_be_tx *txx)
+{
+        struct xx_cob_fabkey  fabkey;
+        struct bt_key_val    *pair;
+        int                   rc;
+
+        if (cob->co_flags & M0_CA_FABREC)
+                return 0;
+
+        fabkey.cfb_fid = *cob->co_fid;
+        rc = xx_cob_max_fabrec_make(&cob->co_fabrec);
+        if (rc != 0)
+                return rc;
+
+	pair = m0_be_kvs_lookup(&cob->co_dom->cd_fileattr_basic, &fabkey);
+
+        if (pair != NULL) {
+                cob->co_flags |= M0_CA_FABREC;
+		/* XXX sz=xx_cob_max_fabrec_size() can be more than really is */
+		memcpy(cob->co_fabrec, pair->val, xx_cob_max_fabrec_size());
+	} else
+                cob->co_flags &= ~M0_CA_FABREC;
+
+        return rc;
+}
+
+/**
+   Search for a record in the fileattr_omg table.
+   @see cob_fab_lookup
+ */
+static int cob_omg_lookup(struct m0_cob *cob, struct m0_be_tx *txx)
+{
+        struct xx_cob_omgkey  omgkey;
+        struct bt_key_val    *pair;
+        int                   rc;
+
+        if (cob->co_flags & M0_CA_OMGREC)
+                return 0;
+
+        omgkey.cok_omgid = cob->co_nsrec.cnr_omgid;
+
+	pair = m0_be_kvs_lookup(&cob->co_dom->cd_fileattr_omg, &omgkey);
+
+        if (pair != NULL) {
+                cob->co_flags |= M0_CA_OMGREC;
+		cob->co_omgrec = *(struct xx_cob_omgrec *)pair->val;
+		rc = 0;
+        } else {
+                cob->co_flags &= ~M0_CA_OMGREC;
+		rc = -ENOENT;
+	}
+
+        return rc;
+}
+
+/**
+   Load fab and omg records according with @need flags.
+ */
+static int cob_get_fabomg(struct m0_cob *cob, uint64_t flags,
+                          struct m0_be_tx *tx)
+{
+        int rc = 0;
+
+        if (flags & M0_CA_FABREC) {
+                rc = cob_fab_lookup(cob, tx);
+                if (rc != 0)
+                        return rc;
+        }
+
+        /*
+         * Get omg attributes as well if we need it.
+         */
+        if (flags & M0_CA_OMGREC) {
+                rc = cob_omg_lookup(cob, tx);
+                if (rc != 0)
+                        return rc;
+        }
+        return rc;
+}
+
+M0_INTERNAL int xx_cob_lookup(struct xx_cob_domain *dom,
+			      struct xx_cob_nskey *nskey, uint64_t flags,
+			      struct m0_cob **out, struct m0_be_tx *tx)
+{
+        struct m0_cob *cob;
+        int            rc;
+
+        M0_ASSERT(out != NULL);
+        *out = NULL;
+
+        rc = xx_cob_alloc(dom, &cob);
+        if (rc != 0)
+                return rc;
+
+        cob->co_nskey = nskey;
+        cob->co_flags |= M0_CA_NSKEY;
+
+        if (flags & M0_CA_NSKEY_FREE)
+                cob->co_flags |= M0_CA_NSKEY_FREE;
+
+        rc = cob_ns_lookup(cob, tx);
+        if (rc != 0) {
+                xx_cob_put(cob);
+                return rc;
+        }
+
+        rc = cob_get_fabomg(cob, flags, tx);
+        if (rc != 0) {
+                xx_cob_put(cob);
+                return rc;
+        }
+
+        *out = cob;
+        return rc;
+}
+
+M0_INTERNAL int xx_cob_locate(struct xx_cob_domain *dom,
+			      struct xx_cob_oikey *oikey, uint64_t flags,
+			      struct m0_cob **out, struct m0_be_tx *tx)
+{
+        struct m0_cob *cob;
+        int rc;
+
+        M0_PRE(m0_fid_is_set(&oikey->cok_fid));
+
+        /*
+         * Zero out "out" just in case that if we fail here, it is
+         * easier to find abnormal using of NULL cob.
+         */
+        M0_ASSERT(out != NULL);
+        *out = NULL;
+
+        /* Get cob memory. */
+        rc = xx_cob_alloc(dom, &cob);
+        if (rc != 0)
+                return rc;
+
+        cob->co_oikey = *oikey;
+        rc = cob_oi_lookup(cob, tx);
+        if (rc != 0) {
+                M0_LOG(M0_DEBUG, "cob_oi_lookup() failed with %d", rc);
+                xx_cob_put(cob);
+                return rc;
+        }
+
+        rc = cob_ns_lookup(cob, tx);
+        if (rc != 0) {
+                M0_LOG(M0_DEBUG, "cob_ns_lookup() failed with %d", rc);
+                xx_cob_put(cob);
+                return rc;
+        }
+
+        rc = cob_get_fabomg(cob, flags, tx);
+        if (rc != 0) {
+                M0_LOG(M0_DEBUG, "cob_get_fabomg() failed with %d", rc);
+                xx_cob_put(cob);
+                return rc;
+        }
+
+        *out = cob;
+        return rc;
+}
+
+#if 0 /* XXX: disable iterators for a while */
+M0_INTERNAL int xx_cob_iterator_init(struct m0_cob *cob,
+				     struct xx_cob_iterator *it,
+				     struct m0_bitstring *name,
+				     struct m0_be_tx *tx)
+{
+        int rc;
+
+        /*
+         * Prepare entry key using passed started pos.
+         */
+        rc = xx_cob_max_nskey_make(&it->ci_key, cob->co_fid,
+                                   m0_bitstring_buf_get(name),
+                                   m0_bitstring_len_get(name));
+        if (rc != 0)
+                return rc;
+
+        /*
+         * Init iterator cursor with max possible key size.
+         */
+        m0_db_pair_setup(&it->ci_pair, &cob->co_dom->cd_namespace,
+                         it->ci_key, xx_cob_nskey_size_max(it->ci_key),
+                         &it->ci_rec, sizeof it->ci_rec);
+
+        rc = m0_db_cursor_init(&it->ci_cursor,
+                               &cob->co_dom->cd_namespace, tx, 0);
+        if (rc != 0) {
+                m0_db_pair_release(&it->ci_pair);
+                m0_db_pair_fini(&it->ci_pair);
+                m0_free(it->ci_key);
+                return rc;
+        }
+        it->ci_cob = cob;
+        return rc;
+}
+
+M0_INTERNAL int xx_cob_iterator_get(struct xx_cob_iterator *it)
+{
+        int rc;
+
+        rc = m0_db_cursor_get(&it->ci_cursor, &it->ci_pair);
+
+        /*
+         * Exact position found.
+         */
+        if (rc == 0)
+                return 1;
+
+        /*
+         * Not exact position found.
+         */
+        return 0;
+}
+
+M0_INTERNAL int xx_cob_iterator_next(struct xx_cob_iterator *it)
+{
+        int rc;
+
+        rc = m0_db_cursor_next(&it->ci_cursor, &it->ci_pair);
+        if (rc == -ENOENT)
+                return 1;
+        else if (rc != 0)
+                return rc;
+
+        if (!m0_fid_eq(&it->ci_key->cnk_pfid, it->ci_cob->co_fid))
+                return 1;
+
+        return 0;
+}
+
+M0_INTERNAL void xx_cob_iterator_fini(struct xx_cob_iterator *it)
+{
+        m0_db_pair_release(&it->ci_pair);
+        m0_db_pair_fini(&it->ci_pair);
+        m0_db_cursor_fini(&it->ci_cursor);
+        m0_free(it->ci_key);
+}
+#endif /* /XXX */
+
+/**
+   For assertions only.
+ */
+static bool xx_cob_is_valid(struct m0_cob *cob)
+{
+        return m0_fid_is_set(cob->co_fid);
+}
+
+M0_INTERNAL int xx_cob_alloc_omgid(struct xx_cob_domain *dom,
+				   struct m0_be_tx *txx, uint64_t *omgid)
+{
+        struct bt_key_val       *pair;
+        struct xx_cob_omgkey     omgkey;
+        struct xx_cob_omgrec     omgrec;
+        struct m0_be_kvs_cursor  cursor;
+        int                      rc;
+
+	m0_be_kvs_cur_init(&dom->cd_fileattr_omg, &cursor);
+
+        /**
+           Lookup for ~0ULL terminator record and do step back to find last
+           allocated omgid. Terminator record should be prepared in storage
+           init time (mkfs or else).
+         */
+        omgkey.cok_omgid = ~0ULL;
+
+	rc = m0_be_kvs_cur_get(&cursor, &omgkey, &pair);
+
+        /**
+           In case of error, most probably no terminator record found,
+           one needs to run mkfs.
+         */
+        if (rc == 0) {
+		omgrec = *(struct xx_cob_omgrec *) pair->val; /* XXX */
+                rc = m0_be_kvs_cur_prev(&cursor, &pair);
+                if (omgid) {
+                        if (rc == 0) {
+                                /**
+                                 * We found last allocated omgid. Bump it
+                                 * by one.
+                                 */
+
+				/* XXX */
+				omgkey = *(struct xx_cob_omgkey *) pair->key;
+
+                                *omgid = ++omgkey.cok_omgid;
+                        } else {
+                                /**
+                                 * No last allocated found, this first alloc
+                                 * call.
+                                 */
+                                *omgid = 0;
+                        }
+                }
+                rc = 0;
+        }
+        m0_be_kvs_cur_fini(&cursor);
+        return rc;
+}
+
+M0_INTERNAL int xx_cob_create(struct m0_cob *cob,
+			      struct xx_cob_nskey *nskey,
+			      struct xx_cob_nsrec *nsrec,
+			      struct xx_cob_fabrec *fabrec,
+			      struct xx_cob_omgrec *omgrec,
+			      struct m0_be_tx *tx)
+{
+        struct bt_key_val    *pair;
+        struct xx_cob_omgkey  omgkey;
+        struct xx_cob_fabkey  fabkey;
+        int                   rc;
+
+        M0_PRE(cob != NULL);
+        M0_PRE(nskey != NULL);
+        M0_PRE(nsrec != NULL);
+        M0_PRE(fabrec != NULL);
+        M0_PRE(omgrec != NULL);
+        M0_PRE(m0_fid_is_set(&nsrec->cnr_fid));
+        M0_PRE(m0_fid_is_set(&nskey->cnk_pfid));
+
+        rc = xx_cob_alloc_omgid(cob->co_dom, tx, &nsrec->cnr_omgid);
+        if (rc != 0)
+                goto out;
+
+        cob->co_nskey = nskey;
+        cob->co_flags |= M0_CA_NSKEY;
+
+        /*
+         * This is what name_add will use to create new name.
+         */
+        cob->co_nsrec = *nsrec;
+        cob->co_flags |= M0_CA_NSREC;
+        cob->co_nsrec.cnr_cntr = 0;
+
+        /*
+         * Intialize counter with 1 which is what will be used
+         * for adding second name. We do it this way to avoid
+         * doing special xx_cob_update() solely for having
+         * this field stored in db.
+         */
+        nsrec->cnr_cntr = 1;
+
+        /*
+         * Let's create name, statdata and object index.
+         */
+        rc = xx_cob_name_add(cob, nskey, nsrec, tx);
+        if (rc != 0)
+                goto out;
+
+        /*
+         * Prepare key for attribute tables.
+         */
+        fabkey.cfb_fid = *cob->co_fid;
+
+        /*
+         * Now let's update file attributes. Cache the fabrec.
+         */
+        cob->co_fabrec = fabrec;
+
+        /*
+         * Add to fileattr-basic table.
+         */
+	pair = m0_be_kvs_pair_setup(&cob->co_dom->cd_fileattr_basic, tx,
+				    &fabkey, sizeof fabkey, cob->co_fabrec,
+				    xx_cob_fabrec_size(cob->co_fabrec));
+	if (pair == NULL)
+		goto out;
+
+	rc = m0_be_kvs_insert(&cob->co_dom->cd_fileattr_basic, tx, pair);
+	if (pair != 0) {
+		m0_be_kvs_pair_release(&cob->co_dom->cd_fileattr_basic, tx, pair);
+		goto out;
+	}
+
+        /*
+         * Prepare omg key.
+         */
+        omgkey.cok_omgid = nsrec->cnr_omgid;
+
+        /*
+         * Now let's update omg attributes. Cache the omgrec.
+         */
+        cob->co_omgrec = *omgrec;
+        cob->co_flags |= M0_CA_OMGREC;
+
+        /*
+         * Add to fileattr-omg table.
+         */
+	pair = m0_be_kvs_pair_setup(&cob->co_dom->cd_fileattr_omg, tx,
+				    &omgkey,         sizeof omgkey,
+				    &cob->co_omgrec, sizeof cob->co_omgrec);
+	if (pair == NULL)
+		goto out;
+
+	rc = m0_be_kvs_insert(&cob->co_dom->cd_fileattr_omg, tx, pair);
+        if (rc == 0)
+                cob->co_flags |= M0_CA_NSKEY_FREE | M0_CA_FABREC;
+out:
+        M0_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc,
+                    m0_addb_func_fail, "cob_create", rc);
+        return rc;
+}
+
+M0_INTERNAL int xx_cob_delete(struct m0_cob *cob, struct m0_be_tx *tx)
+{
+        struct xx_cob_fabkey fabkey;
+        struct xx_cob_omgkey omgkey;
+        struct xx_cob_oikey  oikey;
+        bool                 sdname;
+        struct m0_cob       *sdcob;
+        int                  rc;
+
+        M0_PRE(xx_cob_is_valid(cob));
+        M0_PRE(cob->co_flags & M0_CA_NSKEY);
+
+        xx_cob_oikey_make(&oikey, cob->co_fid, 0);
+        rc = xx_cob_locate(cob->co_dom, &oikey, 0, &sdcob, tx);
+        if (rc != 0)
+                goto out;
+        sdname = (xx_cob_nskey_cmp(cob->co_nskey, sdcob->co_nskey) == 0);
+        xx_cob_put(sdcob);
+
+        /*
+         * Delete last name from namespace and object index.
+         */
+        rc = xx_cob_name_del(cob, cob->co_nskey, tx);
+        if (rc != 0)
+                goto out;
+
+        /*
+         * Is this a statdata name?
+         */
+        if (sdname) {
+                /*
+                 * Remove from the fileattr_basic table.
+                 */
+                fabkey.cfb_fid = *cob->co_fid;
+
+                /*
+                 * Ignore errors; it's a dangling table entry but causes
+                 * no harm.
+                 */
+		m0_be_kvs_delete(&cob->co_dom->cd_fileattr_basic, tx, &fabkey);
+
+                /*
+                 * @todo: Omgrec may be shared between multiple objects.
+                 * Delete should take this into account as well as update.
+                 */
+                omgkey.cok_omgid = cob->co_nsrec.cnr_omgid;
+
+                /*
+                 * Remove from the fileattr_omg table.
+                 */
+
+                /*
+                 * Ignore errors; it's a dangling table entry but causes
+                 * no harm.
+                 */
+		m0_be_kvs_delete(&cob->co_dom->cd_fileattr_omg, tx, &omgkey);
+        }
+out:
+        M0_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc,
+                    m0_addb_func_fail, "cob_delete", rc);
+        return rc;
+}
+
+M0_INTERNAL int xx_cob_delete_put(struct m0_cob *cob, struct m0_be_tx *txx)
+{
+	int rc = xx_cob_delete(cob, txx);
+	xx_cob_put(cob);
+	return rc;
+}
+
+M0_INTERNAL int xx_cob_update(struct m0_cob *cob,
+			      struct xx_cob_nsrec *nsrec,
+			      struct xx_cob_fabrec *fabrec,
+			      struct xx_cob_omgrec *omgrec,
+			      struct m0_be_tx *tx)
+{
+        struct xx_cob_omgkey  omgkey;
+        struct xx_cob_fabkey  fabkey;
+        struct bt_key_val    *pair;
+        int                   rc;
+
+        M0_PRE(xx_cob_is_valid(cob));
+        M0_PRE(cob->co_flags & M0_CA_NSKEY);
+
+        if (nsrec != NULL) {
+                M0_ASSERT(nsrec->cnr_nlink > 0);
+
+                cob->co_nsrec = *nsrec;
+                cob->co_flags |= M0_CA_NSREC;
+
+		pair = m0_be_kvs_pair_setup(&cob->co_dom->cd_namespace, tx,
+					    cob->co_nskey, xx_cob_nskey_size(cob->co_nskey),
+					    &cob->co_nsrec, sizeof cob->co_nsrec);
+		if (pair == NULL)
+			goto out;
+
+		rc = m0_be_kvs_update(&cob->co_dom->cd_namespace, tx, pair);
+                if (rc != 0) {
+			m0_be_kvs_pair_release(&cob->co_dom->cd_namespace, tx,
+					       pair);
+                        goto out;
+		}
+        }
+
+        if (fabrec != NULL) {
+                fabkey.cfb_fid = *cob->co_fid;
+                if (fabrec != cob->co_fabrec) {
+                        if (cob->co_flags & M0_CA_FABREC)
+                                m0_free(cob->co_fabrec);
+                        cob->co_fabrec = fabrec;
+                }
+                cob->co_flags |= M0_CA_FABREC;
+
+		pair = m0_be_kvs_pair_setup(&cob->co_dom->cd_fileattr_basic, tx,
+                                 &fabkey, sizeof fabkey, cob->co_fabrec,
+                                 xx_cob_fabrec_size(cob->co_fabrec));
+		if (pair == NULL)
+			goto out;
+
+		rc = m0_be_kvs_update(&cob->co_dom->cd_fileattr_basic, tx, pair);
+                if (rc != 0) {
+			m0_be_kvs_pair_release(&cob->co_dom->cd_fileattr_basic,
+					       tx, pair);
+                        goto out;
+		}
+        }
+
+        if (omgrec != NULL) {
+                /*
+                 * @todo: Omgrec may be shared between multiple objects.
+                 * We need to take this into account.
+                 */
+                omgkey.cok_omgid = cob->co_nsrec.cnr_omgid;
+
+                cob->co_omgrec = *omgrec;
+                cob->co_flags |= M0_CA_OMGREC;
+
+		pair = m0_be_kvs_pair_setup(&cob->co_dom->cd_fileattr_omg, tx,
+                                 &omgkey, sizeof omgkey,
+                                 &cob->co_omgrec, sizeof cob->co_omgrec);
+		if (pair == NULL)
+			goto out;
+
+		rc = m0_be_kvs_update(&cob->co_dom->cd_fileattr_omg, tx, pair);
+        }
+out:
+        M0_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc,
+                    m0_addb_func_fail, "cob_update", rc);
+        return rc;
+}
+
+M0_INTERNAL int xx_cob_name_add(struct m0_cob *cob,
+				struct xx_cob_nskey *nskey,
+				struct xx_cob_nsrec *nsrec, struct m0_be_tx *tx)
+{
+        struct xx_cob_oikey  oikey;
+        struct bt_key_val   *pair;
+        int                  rc;
+
+        M0_PRE(cob != NULL);
+        M0_PRE(nskey != NULL);
+        M0_PRE(m0_fid_is_set(&nskey->cnk_pfid));
+        M0_PRE(xx_cob_is_valid(cob));
+
+        /**
+         * Add new name to object index table. Table insert should fail
+         * if name already exists.
+         */
+        xx_cob_oikey_make(&oikey, &nsrec->cnr_fid,
+                          cob->co_nsrec.cnr_cntr);
+
+	pair = m0_be_kvs_pair_setup(&cob->co_dom->cd_object_index, tx,
+				    &oikey, sizeof oikey, nskey,
+				    xx_cob_nskey_size(nskey));
+	if (pair == NULL)
+		return -ENOMEM;
+
+	rc = m0_be_kvs_insert(&cob->co_dom->cd_object_index, tx, pair);
+        if (rc != 0) {
+		m0_be_kvs_pair_release(&cob->co_dom->cd_object_index, tx, pair);
+                goto out;
+	}
+
+	pair = m0_be_kvs_pair_setup(&cob->co_dom->cd_namespace, tx,
+				    nskey, xx_cob_nskey_size(nskey),
+				    nsrec, sizeof *nsrec);
+	if (pair == NULL)
+		return -ENOMEM;
+
+	rc = m0_be_kvs_insert(&cob->co_dom->cd_namespace, tx, pair);
+
+	if (rc != 0)
+		m0_be_kvs_pair_release(&cob->co_dom->cd_namespace, tx, pair);
+out:
+        M0_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc,
+                    m0_addb_func_fail, "cob_name_add", rc);
+        return rc;
+}
+
+M0_INTERNAL int xx_cob_name_del(struct m0_cob *cob,
+				struct xx_cob_nskey *nskey,
+				struct m0_be_tx *tx)
+{
+        struct xx_cob_oikey oikey;
+        struct xx_cob_nsrec nsrec;
+        int                 rc;
+
+        M0_PRE(xx_cob_is_valid(cob));
+        M0_PRE(cob->co_flags & M0_CA_NSKEY);
+
+        /*
+         * Kill name from namespace.
+         */
+	rc = m0_be_kvs_delete(&cob->co_dom->cd_namespace, tx, nskey);
+        if (rc != 0)
+                goto out;
+
+        /*
+         * Let's also kill object index entry.
+         */
+        xx_cob_oikey_make(&oikey, cob->co_fid, nsrec.cnr_linkno);
+	rc = m0_be_kvs_delete(&cob->co_dom->cd_object_index, tx, &oikey);
+out:
+        M0_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc,
+                    m0_addb_func_fail, "cob_del_name", rc);
+        return rc;
+}
+
+M0_INTERNAL int xx_cob_name_update(struct m0_cob *cob,
+				   struct xx_cob_nskey *srckey,
+				   struct xx_cob_nskey *tgtkey,
+				   struct m0_be_tx *tx)
+{
+        struct xx_cob_nsrec  nsrec;
+        struct bt_key_val   *pair;
+        struct xx_cob_oikey  oikey;
+        int                  rc;
+
+        M0_PRE(xx_cob_is_valid(cob));
+        M0_PRE(srckey != NULL && tgtkey != NULL);
+
+        /*
+         * Insert new record with nsrec found with srckey.
+         */
+	pair = m0_be_kvs_lookup(&cob->co_dom->cd_namespace, srckey);
+        if (pair == NULL)
+                goto out;
+	nsrec = *(struct xx_cob_nsrec *) pair->val; /* XXX */
+
+	pair = m0_be_kvs_pair_setup(&cob->co_dom->cd_namespace, tx,
+				    tgtkey, xx_cob_nskey_size(tgtkey),
+				    &nsrec, sizeof nsrec);
+	if (pair == NULL)
+		goto out;
+
+	rc = m0_be_kvs_insert(&cob->co_dom->cd_namespace, tx, pair);
+        if (rc != 0) {
+		m0_be_kvs_pair_release(&cob->co_dom->cd_namespace, tx, pair);
+                goto out;
+	}
+
+        /*
+         * Kill old record. Error will be returned if
+         * nothing found.
+         */
+	rc = m0_be_kvs_delete(&cob->co_dom->cd_namespace, tx, srckey);
+        if (rc != 0)
+                goto out;
+
+        /* Update object index */
+        xx_cob_oikey_make(&oikey, cob->co_fid, nsrec.cnr_linkno);
+	pair = m0_be_kvs_pair_setup(&cob->co_dom->cd_object_index, tx,
+				    &oikey, sizeof oikey, tgtkey,
+				    xx_cob_nskey_size(tgtkey));
+	if (pair == NULL)
+		goto out;
+
+	rc = m0_be_kvs_insert(&cob->co_dom->cd_object_index, tx, pair);
+        if (rc != 0) {
+		m0_be_kvs_pair_release(&cob->co_dom->cd_object_index, tx, pair);
+                goto out;
+	}
+
+        /*
+         * Update key to new one.
+         */
+        if (cob->co_flags & M0_CA_NSKEY_FREE)
+                m0_free(cob->co_nskey);
+        xx_cob_nskey_make(&cob->co_nskey, &tgtkey->cnk_pfid,
+                          m0_bitstring_buf_get(&tgtkey->cnk_name),
+                          m0_bitstring_len_get(&tgtkey->cnk_name));
+        cob->co_flags |= M0_CA_NSKEY_FREE;
+out:
+        M0_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc,
+                    m0_addb_func_fail, "cob_update_name", rc);
+        return rc;
+}
+
+/** @} end group cob */
+
+#undef M0_TRACE_SUBSYSTEM
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/cob/rvm_cob.h b/cob/rvm_cob.h
new file mode 100644
index 0000000..741a7e1
--- /dev/null
+++ b/cob/rvm_cob.h
@@ -0,0 +1,768 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Nathan Rutman <nathan_rutman@xyratex.com>
+ * Original creation date: 10/24/2010
+ *
+ * Mdstore changes: Yuriy Umanets <yuriy_umanets@xyratex.com>
+ * RVM changes    : Anatoliy Bilenko <Anatoliy_Bilenko@xyratex>
+ */
+
+#pragma once
+
+#ifndef __MERO_RVM_COB_COB_H__
+#define __MERO_RVM_COB_COB_H__
+
+#include "lib/atomic.h"
+#include "lib/cdefs.h"
+#include "lib/rwlock.h"
+#include "lib/refs.h"
+#include "lib/adt.h"
+#include "lib/bitstring.h"
+#include "addb/addb.h"
+#include "db/db.h"
+#include "fid/fid.h"
+#include "stob/stob.h"
+#include "dtm/verno.h"
+
+#include "be/kvs.h"
+#include "be/tree.h"
+
+/* import */
+struct m0_be_tx;
+
+/**
+   @defgroup cob Component objects
+
+   A Component object is a metadata layer that holds metadata
+   information.  It references a single storage object and contains
+   metadata describing the object. The metadata is stored in database
+   tables. A M0 Global Object (i.e. file) is made up of a collection
+   of Component Objects (stripes).
+
+   Component object metadata includes:
+
+   - namespace information: parent object id, name, links;
+   - file attributes: owner/mode/group, size, m/a/ctime, acls;
+   - fol reference information: log sequence number (lsn), version counter.
+
+   Metadata organization:
+
+   COB uses four db tables for storing the following pieces of
+   information:
+
+   - Namespace - stores file names and file attributes for readdir
+   speedup.  In case of "ls -al" request some metadata needed to
+   complete it and it is why minimum necessary attributes are stored
+   in namespace table;
+
+   - Object Index - stores links of file (all names of the file);
+
+   - File attributes - stores file version, some replicator fields,
+   basically anything that is not needed during stat and readdir
+   operations;
+
+   - One more table is needed for so called "omg" records
+   (owner/mode/group). They store mode/uid/gid file attributes.
+
+   For traditional file systems' namespace we need two tables: name
+   space and object index. These tables are used as following:
+
+   Suppose that there is a file F that has got three names:
+
+   "a/f0", "b/f1", "c/f2"
+
+   Then namespace will have the following records:
+
+   (a.fid, "f0") -> (F stat data, 0)
+   (b.fid, "f1") -> (F, 1)
+   (c.fid, "f2") -> (F, 2)
+
+   where, in first record, we have "DB key" constructed of f0's
+   parent fid (the directory fid) and "f0", the filename itself.
+   The namespace record contains the fid of file "f0" together with
+   with its stat data, plus the link number for this name.
+
+   Here "stat data" means that this record contains file attributes
+   that usually extracted by stat utility or ls -la.
+
+   First name stores the stat data (basic file system attributes)
+   and has link number zero.
+
+   All the other records have keys constructed from their parent
+   fid and child name ("f1", "f2"), and the record contains only
+   file fid and link number that this record describes.
+
+   When the first file name is deleted, the stat data is migrated
+   to another name record of the file (if any). This will be shown
+   below.
+
+   The object index contains records:
+
+   (F, 0) -> (a.fid, "f0")
+   (F, 1) -> (b.fid, "f1")
+   (F, 2) -> (c.fid, "f2")
+
+   where the key is constructed of file fid and its link number.
+   The record contains the parent fid plus the file name. That is,
+   the object index enumerates all the names that a file has. As
+   we have already noted, the object index table values have the
+   same format as namespace keys and may be used for getting namespace
+   data and cob object itself using object's fid.
+
+   When doing "rm a/f0" we need to kill 1 namespace and 1 object
+   index record.  That is, we need a key containing (a.fid, "f0").
+   Using this key we can find its position in namespace table and
+   delete the record.  But before killing it, we need to check if
+   this record stores the stat data and whether we should move it
+   to another hardlink filename.  If ->xx_cob_nsrec::cnr_nlink > 0
+   this means that it is stat data record and there are other
+   hardlinks for the file, so stat data should be moved.  To find
+   out were to move stat data quickly, we just do lookup in the
+   object index for the next linkno of the file:
+
+   (F, 0 + 1) -> (b.fid, "f1")
+
+   Now we can use its record as a key for namespace table and move
+   stat data to its record.
+
+   Now kill the record in the object index.
+
+   Stat data could be located in namespace table by using the very
+   first record in object index table, which will be (F, 1) now.
+   We still can initialize object index key with linkno=0 to find
+   it and rely on database cursor which returns the first record
+   in the table with the least linkno available.
+
+   We are done with unlink operation. Of course for cases when
+   killing name that does not hold stat data, algorithm is much
+   simpler. We just need to kill one record in name, find and update
+   stat data record in namespace table (decremented nlink should
+   be updated in the store), and kill one record in object index.
+
+   File attributes that are stored in separate tables may also be
+   easily accessed using key constructed of F, where F is file fid.
+
+   Rationale:
+
+   Hard-links are rare, make common case fast by placing attributes
+   in the file's directory entry, make readdir fast by moving other
+   attributes out.
+
+   Corner cases:
+
+   Rename and unlink need to move file attributes from zero name.
+
+   Special case:
+
+   Using cob api for ioservice to create data objects is special
+   case. The main difference is that, parent fid (in nskey) and
+   child fid (in nsrec) are the same.
+
+   Cob iterator.
+
+   In order to iterate over all names that "dir" cob contains, cob
+   iterator is used. It is simple cursor based API, that contains
+   four methods:
+
+   - xx_cob_iterator_init() - init iterator with cob fid and file name;
+   - xx_cob_iterator_get()  - position iterator according with its properies;
+   - xx_cob_iterator_next() - move to next position;
+   - xx_cob_iterator_fini() - fini iterator.
+
+   `cob' and `name' parameters, passed to xx_cob_iterator_init(),
+   specify initial position of the iterator. Then iterator moves
+   with xx_cob_iterator_next() method over namespace table until
+   end of table is reached or a record with another parent fid is
+   found.
+
+   Once iterator is not needed, it is finalized by xx_cob_iterator_fini().
+
+   @see m0_mdstore_readdir() for example of using iterator.
+
+   Mkfs.
+
+   Cob cannot be used before xx_cob_domain_mkfs() is called. For
+   details consult with xx_cob_domain_mkfs()
+
+   This function creates the following structures [records? objects?]
+   in cob tables:
+
+   - the main root cob with fid XX_COB_ROOT_FID;
+
+   - metadata hierarchy root cob (what potentially metadata client
+   can see) with fid XX_COB_ROOT_FID and name XX_COB_ROOT_NAME;
+
+   - sessions root cob (all sessions are created below it) with fid
+   XX_COB_SESSIONS_FID and name XX_COB_SESSIONS_NAME;
+
+   - omgid terminator record with id = ~0ULL. This is used for omgid
+   allocation during xx_cob_create();
+
+   Mdstore based cobs cannot be used properly without mkfs done.
+   All unit tests that access cob and also all modules using cobs
+   should do xx_cob_domain_mkfs() on startup.
+
+   @{
+ */
+
+struct m0_cob;
+struct m0_fid;
+struct xx_cob_id;
+struct xx_cob_domain;
+struct xx_cob_domain_id;
+
+/* Namespace name for root cob (not exposed to user) */
+extern const char XX_COB_ROOT_NAME[];
+
+/* Namespace name for sessions root cob. */
+extern const char XX_COB_SESSIONS_NAME[];
+
+/* Grobal cob root fid. */
+extern const struct m0_fid XX_COB_ROOT_FID;
+
+/* Hierarchy root fid (exposed to user). */
+extern const struct m0_fid XX_COB_SLASH_FID;
+
+/* Root sessions cob fid. */
+extern const struct m0_fid XX_COB_SESSIONS_FID;
+
+/**
+   Unique cob domain identifier.
+
+   A cob_domain identifier distinguishes domains within a single
+   database environment.
+ */
+struct xx_cob_domain_id {
+        uint32_t id;
+};
+
+/**
+   cob domain
+
+   Component object metadata is stored in database tables. The
+   database in turn is stored in a metadata container. A cob_domain
+   is a grouping of cob's described by a namespace or object index.
+   The objects referenced by the tables will reside in other,
+   filedata containers.
+
+   A xx_cob_domain is an in-memory structure that identifies these
+   tables.  The list of domains will be created at metadata container
+   ingest (when a container is first "started/read/initialized/opened".)
+
+   A xx_cob_domain cannot span multiple containers.  Eventually,
+   there should be methods for combining/splitting containers and
+   therefore cob domains and databases.
+*/
+struct xx_cob_domain {
+        struct xx_cob_domain_id cd_id;
+        struct m0_be_kvs         cd_object_index;
+        struct m0_be_kvs         cd_namespace;
+        struct m0_be_kvs         cd_fileattr_basic;
+        struct m0_be_kvs         cd_fileattr_omg;
+
+        /**
+         * An ADDB context for events related to this domain.
+         */
+        struct m0_addb_ctx      cd_addb;
+};
+
+int xx_cob_domain_init(struct xx_cob_domain *dom, struct m0_be_domain *be_dom,
+		       const struct xx_cob_domain_id *id);
+
+void xx_cob_domain_fini(struct xx_cob_domain *dom);
+
+/**
+ * Prepare storage before using. Create root cob for session objects
+ * and root for files hierarchy.
+ */
+M0_INTERNAL int xx_cob_domain_mkfs(struct xx_cob_domain *dom,
+				   const struct m0_fid *rootfid,
+				   const struct m0_fid *sessfid,
+				   struct m0_be_tx *tx);
+
+/**
+ * Flags for cob attributes.
+ */
+enum xx_cob_valid_flags {
+        XX_COB_ATIME   = 1 << 0,
+        XX_COB_MTIME   = 1 << 1,
+        XX_COB_CTIME   = 1 << 2,
+        XX_COB_SIZE    = 1 << 3,
+        XX_COB_MODE    = 1 << 4,
+        XX_COB_UID     = 1 << 5,
+        XX_COB_GID     = 1 << 6,
+        XX_COB_BLOCKS  = 1 << 7,
+        XX_COB_TYPE    = 1 << 8,
+        XX_COB_FLAGS   = 1 << 9,
+        XX_COB_NLINK   = 1 << 10,
+        XX_COB_RDEV    = 1 << 11,
+        XX_COB_BLKSIZE = 1 << 12
+};
+
+#define XX_COB_ALL (XX_COB_ATIME | XX_COB_MTIME | XX_COB_CTIME |                \
+                    XX_COB_SIZE | XX_COB_MODE | XX_COB_UID | XX_COB_GID |       \
+                    XX_COB_BLOCKS | XX_COB_TYPE | XX_COB_FLAGS | XX_COB_NLINK | \
+                    XX_COB_RDEV | XX_COB_BLKSIZE)
+
+/**
+ * Attributes describing object that needs to be created or modified.
+ * This structure is filled by mdservice and used in mdstore or
+ * in cob modules for carrying in-request information to layers that
+ * should not be dealing with fop request or response.
+ */
+struct xx_cob_attr {
+        struct m0_fid       ca_pfid;    /**< parent fid */
+        struct m0_fid       ca_tfid;    /**< object fid */
+        uint16_t            ca_flags;   /**< flags (enum xx_cob_valid_flags) */
+        uint32_t            ca_mode;    /**< protection. */
+        uint32_t            ca_uid;     /**< user ID of owner. */
+        uint32_t            ca_gid;     /**< group ID of owner. */
+        uint64_t            ca_atime;   /**< time of last access. */
+        uint64_t            ca_mtime;   /**< time of last modification. */
+        uint64_t            ca_ctime;   /**< time of last status change. */
+        uint64_t            ca_rdev;    /**< devid for special devices */
+        uint32_t            ca_nlink;   /**< number of hard links. */
+        uint64_t            ca_size;    /**< total size, in bytes. */
+        uint64_t            ca_blksize; /**< blocksize for filesystem I/O. */
+        uint64_t            ca_blocks;  /**< number of blocks allocated. */
+        uint64_t            ca_version; /**< object version */
+        struct m0_buf       ca_name;    /**< object name */
+        struct m0_buf       ca_link;    /**< symlink body */
+};
+
+/**
+ * Namespace table key. For data objects, cnk_pfid = cfid and cnk_name = "".
+ */
+struct xx_cob_nskey {
+        struct m0_fid       cnk_pfid;
+        struct m0_bitstring cnk_name;
+};
+
+M0_INTERNAL size_t xx_cob_nskey_size(const struct xx_cob_nskey *nskey);
+
+/**
+ * Compare two keys. Return: k0 > k1: +1, k0 < k1: -1, 0 - otherwise.
+ */
+M0_INTERNAL int xx_cob_nskey_cmp(const struct xx_cob_nskey *k0,
+				 const struct xx_cob_nskey *k1);
+
+/**
+ * Namespace table record "value" part. For each file there may exist
+ * several xx_cob_nsrecs, given that there are several hardlinks. First
+ * of the records -- so called "zero record", aka stat data -- contains
+ * file attributes.
+ */
+struct xx_cob_nsrec {
+        struct m0_fid     cnr_fid;     /**< object fid */
+        uint32_t          cnr_linkno;  /**< number of link for the name */
+
+        /**
+         * The following fields are only important for 0-nsrec, that is,
+         * stat data. For other records, only two fields above are valid.
+         */
+        uint32_t          cnr_nlink;   /**< number of hard links */
+        uint32_t          cnr_cntr;    /**< linkno allocation counter */
+        uint64_t          cnr_omgid;   /**< uid/gid/mode slot reference */
+        uint64_t          cnr_size;    /**< total size, in bytes */
+        uint64_t          cnr_blksize; /**< blocksize for filesystem I/O */
+        uint64_t          cnr_blocks;  /**< number of blocks allocated */
+        uint64_t          cnr_atime;   /**< time of last access */
+        uint64_t          cnr_mtime;   /**< time of last modification */
+        uint64_t          cnr_ctime;   /**< time of last status change */
+};
+
+/** Object index table key. The oi table record is a struct xx_cob_nskey. */
+struct xx_cob_oikey {
+        struct m0_fid     cok_fid;
+        uint32_t          cok_linkno;  /**< hardlink ordinal index */
+};
+
+/**
+ * Fileattr_basic table, key is xx_cob_fabkey
+ *
+ * @note version should change on every namespace manipulation and data write.
+ * If version and mtime/ctime both change frequently, at the same time,
+ * it is arguably better to put version info in the namespace table instead
+ * of fileattr_basic table so that there is only 1 table write.
+ *
+ * The reasoning behind the current design is that namespace table should be
+ * as compact as possible to reduce lookup footprint. Also, readdir benefits
+ * from smaller namespace entries.
+ */
+struct xx_cob_fabkey {
+        struct m0_fid     cfb_fid;
+};
+
+struct xx_cob_fabrec {
+        struct m0_verno   cfb_version;  /**< version from last fop */
+        uint64_t          cfb_layoutid; /**< reference to layout */
+        uint16_t          cfb_linklen;  /**< symlink len if any */
+        char              cfb_link[0];  /**< symlink body */
+        /* add ACL, Besides ACL, no further metadata is needed for stat(2). */
+};
+
+/**
+ * Omg (owner/mode/group) table key
+ */
+struct xx_cob_omgkey {
+        uint64_t          cok_omgid;   /**< omg id ref */
+};
+
+/**
+ * Protection and access flags are stored in omg table.
+ */
+struct xx_cob_omgrec {
+        uint32_t          cor_uid;     /**< user ID of owner */
+        uint32_t          cor_mode;    /**< protection */
+        uint32_t          cor_gid;     /**< group ID of owner */
+};
+
+/**
+ * In-memory representation of a component object.
+ *
+ * m0_cob is an in-memory structure, populated from database tables
+ * on demand. m0_cob is not cached for long time (except for root)
+ * and is only used as a temporary handle of database structures for the
+ * sake of handiness. This means, we don't need to bother with locking
+ * as every time we pass cob to some function this is new instance of it.
+ * All the concurrency for providing data correctness is done by underlying
+ * database (db[45] or rvm).
+ *
+ * The exposed methods to get a new instance of cob are:
+ * - xx_cob_lookup() - allocate new in-memory cob and populate it with lookup
+ *                     by name.
+ * - xx_cob_locate() - allocate new in-memory cob and populate it with lookup
+ *                     by fid.
+ * - xx_cob_create() - allocate new in-memory cob, populate it with passed
+ *                     records and create database structures.
+ *
+ * The cobs returned by these methods are always populated.
+ *
+ * Not populated cob is only exposed with xx_cob_alloc() method, which is used
+ * by request handler and (possibly) others. Such a cob is used as an input
+ * parameter to functions mentioned above.
+ *
+ * Users use xx_cob_get/put to hold/release references; a cob may be destroyed
+ * on the last put, or it may be cached for some time (just like root cob is).
+ * @todo at some point, we may replace the co_ref by taking a reference on the
+ * underlying co_stob.  At that point, we will need a callback at last put.
+ * We wait to see how cob users will use these references, whether they need
+ * callbacks in turn, etc.
+ *
+ * A m0_cob serves several purposes:
+ *
+ * - it acts as a handle for the underlying metadata storage. Meta-data
+ * operations can be executed on persistent storage by calling functions on
+ * m0_cob;
+ *
+ * - it caches certain metadata attributes in memory (controlled by ->co_flags);
+ *
+ * <b>Liveness</b>
+ * A m0_cob may be freed when the reference count drops to 0.
+ *
+ * @note xx_cob_nskey is allocated separately because it is variable
+ * length. Once allocated, it can be released if M0_CA_NSKEY_FREE flag
+ * is specified in its allocation time.
+ *
+ * <b>Caching and concurrency</b>
+ * Cobs are not cached by cob domain, neither by cob API users.
+ * Rationale is the following:
+ *
+ * - we use db[45] for storing metadata and it already has cache that may work
+ * in a way that satisfies our needs;
+ *
+ * - using cache means substantial complications with locking and concurrent
+ * access. Currently these issues are completely covered by db[45].
+ */
+struct m0_cob {
+        struct xx_cob_domain  *co_dom;
+        struct m0_stob        *co_stob;     /**< underlying storage object */
+        struct m0_ref          co_ref;      /**< refcounter for caching cobs */
+        uint64_t               co_flags;    /**< @see enum xx_cob_valid_flags */
+        struct m0_fid         *co_fid;      /**< object fid, ref to nsrec fid */
+        struct xx_cob_nskey   *co_nskey;    /**< cob statdata nskey */
+        struct xx_cob_oikey    co_oikey;    /**< object fid, linkno */
+        struct xx_cob_nsrec    co_nsrec;    /**< object fid, basic stat data */
+        struct xx_cob_fabrec  *co_fabrec;   /**< fileattr_basic data (acl...) */
+        struct xx_cob_omgrec   co_omgrec;   /**< permission data */
+        struct bt_key_val     *co_oipair;   /**< used for object index access */
+        struct m0_addb_ctx     co_addb;     /**< cob private addb ctx */
+};
+
+/**
+ * This is all standard readdir related stuff. This is one readdir entry.
+ */
+struct m0_dirent {
+        uint32_t             d_namelen;
+        uint32_t             d_reclen;
+        char                 d_name[0];
+};
+
+/**
+ * Readdir page.
+ */
+struct m0_rdpg {
+        struct m0_bitstring *r_pos;
+        struct m0_buf        r_buf;
+        struct m0_bitstring *r_end;
+};
+
+/**
+ * Cob iterator. Holds current position inside a cob (used by readdir).
+ */
+struct xx_cob_iterator {
+        struct m0_cob           *ci_cob;      /**< the cob we iterate */
+        struct m0_be_kvs_cursor  ci_cursor;   /**< cob iterator cursor */
+        struct xx_cob_nskey     *ci_key;      /**< current iterator pos */
+        struct xx_cob_nsrec      ci_rec;      /**< current iterator rec */
+        struct bt_key_val        ci_pair;     /**< used for iterator cursor */
+};
+
+/**
+ * Cob flags and valid attributes.
+ */
+enum xx_cob_flags {
+        M0_CA_NSKEY      = (1 << 0),  /**< nskey in cob is up-to-date */
+        M0_CA_NSKEY_FREE = (1 << 1),  /**< cob will dealloc the nskey */
+        M0_CA_NSREC      = (1 << 2),  /**< nsrec in cob is up-to-date */
+        M0_CA_FABREC     = (1 << 3),  /**< fabrec in cob is up-to-date */
+        M0_CA_OMGREC     = (1 << 4),  /**< omgrec in cob is up-to-date */
+        M0_CA_LAYOUT     = (1 << 5),  /**< layout in cob is up-to-date */
+};
+
+/**
+ * Lookup a filename in the namespace table.
+ *
+ * Allocate a new cob and populate it with the contents of the
+ * namespace record; i.e. the stat data and fid. This function
+ * also looks up fab and omg tables, depending on "need" flag.
+ *
+ * @param dom   cob domain to use
+ * @param nskey name to lookup
+ * @param flags flags specifying what parts of cob to populate
+ * @param out   resulting cob is store here
+ * @param tx    db transaction to be used
+ *
+ * @see xx_cob_locate
+ */
+M0_INTERNAL int xx_cob_lookup(struct xx_cob_domain *dom,
+			      struct xx_cob_nskey *nskey,
+			      uint64_t flags,
+			      struct m0_cob **out, struct m0_be_tx *tx);
+
+/**
+ * Locate cob by object index key.
+ *
+ * Create a new cob and populate it with the contents of the
+ * a record; i.e. the filename. This also lookups for all attributes,
+ * that is, fab, omg, etc., according to @need flags.
+ *
+ * @param dom   cob domain to use
+ * @param oikey oikey (fid) to lookup
+ * @param flags flags specifying what parts of cob to populate
+ * @param out   resulting cob is store here
+ * @param tx    db transaction to be used
+ *
+ * @see xx_cob_lookup
+ */
+M0_INTERNAL int xx_cob_locate(struct xx_cob_domain *dom,
+			      struct xx_cob_oikey *oikey,
+			      uint64_t flags,
+			      struct m0_cob **out, struct m0_be_tx *tx);
+
+/**
+ * Add a cob to the namespace.
+ *
+ * This doesn't create a new storage object; just creates
+ * metadata table entries for it to enable namespace and oi lookup.
+ *
+ * @param cob    cob instance allocted with xx_cob_alloc()
+ * @param nskey  namespace key made with xx_cob_nskey_make()
+ * @param nsrec  namespace record with all attrbiutes set
+ * @param fabrec basic attributes record
+ * @param omgrec owner/mode/group record
+ * @param tx     transaction handle
+ */
+M0_INTERNAL int xx_cob_create(struct m0_cob *cob,
+			      struct xx_cob_nskey *nskey,
+			      struct xx_cob_nsrec *nsrec,
+			      struct xx_cob_fabrec *fabrec,
+			      struct xx_cob_omgrec *omgrec,
+			      struct m0_be_tx *tx);
+
+/**
+ * Delete name with stat data, entry in object index and all file
+ * attributes from fab, omg, etc., tables.
+ *
+ * @param cob this cob will be deleted
+ * @param tx db transaction to use
+ *
+ * Note, that xx_cob_delete() does not decrement cob's reference counter.
+ * Use xx_cob_delete_put() to have the counter decremented.
+ *
+ * @see xx_cob_delete_put()
+ */
+M0_INTERNAL int xx_cob_delete(struct m0_cob *cob, struct m0_be_tx *tx);
+
+/**
+ * Deletes and puts cob.
+ *
+ * @see xx_cob_delete(), xx_cob_put()
+ */
+M0_INTERNAL int xx_cob_delete_put(struct m0_cob *cob, struct m0_be_tx *tx);
+
+/**
+ * Update file attributes of passed cob with @nsrec, @fabrec
+ * and @omgrec fields.
+ *
+ * @param cob    cob store updates to
+ * @param nsrec  new nsrec to store to cob
+ * @param fabrec fab record to store or null
+ * @param omgrec omg record to store or null
+ * @param tx     db transaction to be used
+ */
+M0_INTERNAL int xx_cob_update(struct m0_cob *cob,
+			      struct xx_cob_nsrec *nsrec,
+			      struct xx_cob_fabrec *fabrec,
+			      struct xx_cob_omgrec *omgrec,
+			      struct m0_be_tx *tx);
+
+/**
+ * Add name to namespace and object index.
+ * @param cob   stat data (zero name) cob;
+ * @param nskey new name to add to the file;
+ * @param nsrec nsrec that will be added;
+ * @param tx    transaction handle.
+ */
+M0_INTERNAL int xx_cob_name_add(struct m0_cob *cob,
+				struct xx_cob_nskey *nskey,
+				struct xx_cob_nsrec *nsrec,
+				struct m0_be_tx *tx);
+
+/**
+ * Delete name from namespace and object index.
+ *
+ * @param cob   stat data (zero name) cob;
+ * @param nskey name to kill (may be the name of statdata);
+ * @param tx    transaction handle.
+ */
+M0_INTERNAL int xx_cob_name_del(struct m0_cob *cob,
+				struct xx_cob_nskey *nskey,
+				struct m0_be_tx *tx);
+
+/**
+ * Rename old record with new record.
+ *
+ * @param cob    stat data (zero name) cob;
+ * @param srckey source name;
+ * @param tgtkey target name;
+ * @param tx     transaction handle
+*/
+M0_INTERNAL int xx_cob_name_update(struct m0_cob *cob,
+				   struct xx_cob_nskey *srckey,
+				   struct xx_cob_nskey *tgtkey,
+				   struct m0_be_tx *tx);
+
+/**
+ * Init cob iterator on passed @cob and @name as a start position.
+ */
+M0_INTERNAL int xx_cob_iterator_init(struct m0_cob *cob,
+				     struct xx_cob_iterator *it,
+				     struct m0_bitstring *name,
+				     struct m0_be_tx *tx);
+
+/**
+ * Position to next name in a dir cob.
+ */
+M0_INTERNAL int xx_cob_iterator_next(struct xx_cob_iterator *it);
+
+/**
+ * Position in table according with @it properties.
+ */
+M0_INTERNAL int xx_cob_iterator_get(struct xx_cob_iterator *it);
+
+/**
+ * Finish cob iterator.
+ */
+M0_INTERNAL void xx_cob_iterator_fini(struct xx_cob_iterator *it);
+
+/**
+ * Allocate a new cob on passed @dom.
+ */
+M0_INTERNAL int xx_cob_alloc(struct xx_cob_domain *dom, struct m0_cob **out);
+
+/**
+ * Acquires an additional reference on the object.
+ *
+ * @see xx_cob_put()
+ */
+M0_INTERNAL void xx_cob_get(struct m0_cob *obj);
+
+/**
+ * Releases a reference on the object.
+ *
+ * When the last reference is released, the object can either return to the
+ * cache or can be immediately destroyed.
+ *
+ * @see xx_cob_get(), xx_cob_delete_put()
+ */
+M0_INTERNAL void xx_cob_put(struct m0_cob *obj);
+
+/**
+ * Create object index key that is used for operations on object index table.
+ * It consists of object fid an linkno depending on what record we want to
+ * find.
+ */
+M0_INTERNAL void xx_cob_oikey_make(struct xx_cob_oikey *oikey,
+				   const struct m0_fid *fid, int linkno);
+
+/**
+ * Create namespace table key for ns table manipulation. It contains parent fid
+ * and child name.
+ */
+M0_INTERNAL int xx_cob_nskey_make(struct xx_cob_nskey **keyh,
+				  const struct m0_fid *pfid,
+				  const char *name, size_t namelen);
+
+/**
+ * Allocate fabrec record according with @link and @linklen and setup record
+ * fields.
+ */
+M0_INTERNAL int xx_cob_fabrec_make(struct xx_cob_fabrec **rech,
+				   const char *link, size_t linklen);
+
+/**
+ * Try to allocate new omgid using omg table and terminator record. Save
+ * allocated id in @omgid if not NULL.
+ */
+M0_INTERNAL int xx_cob_alloc_omgid(struct xx_cob_domain *dom,
+				   struct m0_be_tx *tx, uint64_t * omgid);
+
+/** @} end group cob */
+
+/* __MERO_RVM_COB_COB_H__ */
+#endif
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/cob/ut/rvm_cob.c b/cob/ut/rvm_cob.c
new file mode 100644
index 0000000..c2b9390
--- /dev/null
+++ b/cob/ut/rvm_cob.c
@@ -0,0 +1,423 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Nathan Rutman <nathan_rutman@xyratex.com>
+ * Original creation date: 10/24/2010
+ */
+
+#include "lib/ut.h"
+#include "lib/ub.h"
+#include "lib/memory.h"
+#include "lib/misc.h"              /* M0_SET0 */
+#include "lib/bitstring.h"
+#include "cob/rvm_cob.h"
+
+static const char db_name[] = "ut-cob";
+static const char test_name[] = "hello_world";
+static const char add_name[] = "add_name";
+static const char wrong_name[] = "wrong_name";
+
+static struct xx_cob_domain_id id = { 42 };
+static struct m0_dbenv       db;
+static struct xx_cob_domain  dom;
+static struct m0_cob         *cob;
+static int rc;
+
+static int db_reset(void)
+{
+        rc = m0_ut_db_reset(db_name);
+        /* M0_UT_ASSERT not usable during ts_init */
+        M0_ASSERT(rc == 0);
+        return rc;
+}
+
+static void test_mkfs(void)
+{
+        struct m0_db_tx         tx;
+        int                     rc;
+
+        rc = m0_dbenv_init(&db, db_name, 0);
+        M0_UT_ASSERT(rc == 0);
+
+        rc = xx_cob_domain_init(&dom, &db, &id);
+        M0_UT_ASSERT(rc == 0);
+
+        rc = m0_db_tx_init(&tx, &db, 0);
+        M0_UT_ASSERT(rc == 0);
+
+        /* Create root and other structures */
+        rc = xx_cob_domain_mkfs(&dom, &XX_COB_SLASH_FID,
+                                &XX_COB_SESSIONS_FID, &tx);
+        M0_UT_ASSERT(rc == 0);
+        m0_db_tx_commit(&tx);
+
+        /* Fini everything */
+        xx_cob_domain_fini(&dom);
+        m0_dbenv_fini(&db);
+}
+
+static void test_init(void)
+{
+
+        rc = m0_dbenv_init(&db, db_name, 0);
+        /* test_init is called by ub_init which hates M0_UT_ASSERT */
+        M0_ASSERT(rc == 0);
+
+        rc = xx_cob_domain_init(&dom, &db, &id);
+        M0_ASSERT(rc == 0);
+}
+
+static void test_fini(void)
+{
+        xx_cob_domain_fini(&dom);
+        m0_dbenv_fini(&db);
+}
+
+static void test_create(void)
+{
+        struct xx_cob_nskey    *key;
+        struct xx_cob_nsrec    nsrec;
+        struct xx_cob_fabrec  *fabrec;
+        struct xx_cob_omgrec   omgrec;
+        struct m0_fid          pfid;
+        struct m0_db_tx        tx;
+
+        M0_SET0(&nsrec);
+        M0_SET0(&omgrec);
+
+        /* pfid, filename */
+        m0_fid_set(&pfid, 0x123, 0x456);
+        xx_cob_nskey_make(&key, &pfid, test_name, strlen(test_name));
+
+        m0_fid_set(&nsrec.cnr_fid, 0xabc, 0xdef);
+        nsrec.cnr_nlink = 0;
+
+        m0_db_tx_init(&tx, dom.cd_dbenv, 0);
+        rc = xx_cob_alloc(&dom, &cob);
+        M0_UT_ASSERT(rc == 0);
+        xx_cob_fabrec_make(&fabrec, NULL, 0);
+        rc = xx_cob_create(cob, key, &nsrec, fabrec, &omgrec, &tx);
+        M0_UT_ASSERT(rc == 0);
+
+        nsrec.cnr_nlink++;
+        rc = xx_cob_update(cob, &nsrec, NULL, NULL, &tx);
+        M0_UT_ASSERT(rc == 0);
+        xx_cob_put(cob);
+        m0_db_tx_commit(&tx);
+}
+
+/**
+   Test that add_name works.
+*/
+static void test_add_name(void)
+{
+        struct xx_cob_nskey *nskey;
+        struct m0_fid        pfid;
+        struct m0_db_tx      tx;
+
+        /* pfid, filename */
+        m0_fid_set(&pfid, 0x123, 0x456);
+
+        m0_db_tx_init(&tx, dom.cd_dbenv, 0);
+
+        /* lookup for cob created before using @test_name. */
+        xx_cob_nskey_make(&nskey, &pfid, test_name, strlen(test_name));
+        rc = xx_cob_lookup(&dom, nskey, M0_CA_NSKEY_FREE, &cob, &tx);
+        M0_UT_ASSERT(rc == 0);
+
+        /* add new name to existing cob */
+        xx_cob_nskey_make(&nskey, &pfid, add_name, strlen(add_name));
+        cob->co_nsrec.cnr_linkno = cob->co_nsrec.cnr_cntr;
+        rc = xx_cob_name_add(cob, nskey, &cob->co_nsrec, &tx);
+        M0_UT_ASSERT(rc == 0);
+        xx_cob_put(cob);
+
+        /* lookup for new name */
+        rc = xx_cob_lookup(&dom, nskey, 0, &cob, &tx);
+        M0_UT_ASSERT(rc == 0);
+        xx_cob_put(cob);
+        m0_free(nskey);
+
+        /* lookup for wrong name, should fail. */
+        xx_cob_nskey_make(&nskey, &pfid, wrong_name, strlen(wrong_name));
+        rc = xx_cob_lookup(&dom, nskey, 0, &cob, &tx);
+        M0_UT_ASSERT(rc != 0);
+        m0_free(nskey);
+
+        m0_db_tx_commit(&tx);
+}
+
+/**
+   Test that del_name works.
+*/
+static void test_del_name(void)
+{
+        struct xx_cob_nskey *nskey;
+        struct m0_fid        pfid;
+        struct m0_db_tx      tx;
+
+        /* pfid, filename */
+        m0_fid_set(&pfid, 0x123, 0x456);
+
+        m0_db_tx_init(&tx, dom.cd_dbenv, 0);
+
+        /* lookup for cob created before using @test_name. */
+        xx_cob_nskey_make(&nskey, &pfid, test_name, strlen(test_name));
+        rc = xx_cob_lookup(&dom, nskey, M0_CA_NSKEY_FREE, &cob, &tx);
+        M0_UT_ASSERT(rc == 0);
+
+        /* del name that we created in prev test */
+        xx_cob_nskey_make(&nskey, &pfid, add_name, strlen(add_name));
+        rc = xx_cob_name_del(cob, nskey, &tx);
+        M0_UT_ASSERT(rc == 0);
+        xx_cob_put(cob);
+
+        /* lookup for new name */
+        rc = xx_cob_lookup(&dom, nskey, 0, &cob, &tx);
+        M0_UT_ASSERT(rc != 0);
+        m0_free(nskey);
+
+        m0_db_tx_commit(&tx);
+}
+
+/**
+   Lookup by name, make sure cfid is right.
+*/
+static void test_lookup(void)
+{
+        struct m0_db_tx      tx;
+        struct xx_cob_nskey *nskey;
+        struct m0_fid        pfid;
+
+        m0_fid_set(&pfid, 0x123, 0x456);
+        xx_cob_nskey_make(&nskey, &pfid, test_name, strlen(test_name));
+        m0_db_tx_init(&tx, dom.cd_dbenv, 0);
+        rc = xx_cob_lookup(&dom, nskey, M0_CA_NSKEY_FREE, &cob, &tx);
+        m0_db_tx_commit(&tx);
+        M0_UT_ASSERT(rc == 0);
+        M0_UT_ASSERT(cob != NULL);
+        M0_UT_ASSERT(cob->co_dom == &dom);
+        M0_UT_ASSERT(cob->co_flags & M0_CA_NSREC);
+        M0_UT_ASSERT(cob->co_nsrec.cnr_fid.f_container == 0xabc);
+        M0_UT_ASSERT(cob->co_nsrec.cnr_fid.f_key == 0xdef);
+
+        /* We should have cached the key also, unless oom */
+        M0_UT_ASSERT(cob->co_flags & M0_CA_NSKEY);
+
+        xx_cob_put(cob);
+}
+
+static int test_locate_internal(void)
+{
+        struct m0_db_tx      tx;
+        struct m0_fid        fid;
+        struct xx_cob_oikey  oikey;
+
+        m0_fid_set(&fid, 0xabc, 0xdef);
+
+        oikey.cok_fid = fid;
+        oikey.cok_linkno = 0;
+
+        m0_db_tx_init(&tx, dom.cd_dbenv, 0);
+        rc = xx_cob_locate(&dom, &oikey, 0, &cob, &tx);
+        m0_db_tx_commit(&tx);
+
+        return rc;
+}
+
+/**
+   Lookup by fid, make sure pfid is right.
+*/
+static void test_locate(void)
+{
+        rc = test_locate_internal();
+        M0_UT_ASSERT(rc == 0);
+        M0_UT_ASSERT(cob != NULL);
+        M0_UT_ASSERT(cob->co_dom == &dom);
+
+        /* We should have saved the NSKEY */
+        M0_UT_ASSERT(cob->co_flags & M0_CA_NSKEY);
+        M0_UT_ASSERT(cob->co_nskey->cnk_pfid.f_container == 0x123);
+        M0_UT_ASSERT(cob->co_nskey->cnk_pfid.f_key == 0x456);
+
+        /* Assuming we looked up the NSREC at the same time */
+        M0_UT_ASSERT(cob->co_flags & M0_CA_NSREC);
+
+        xx_cob_put(cob);
+}
+
+/**
+   Test if delete works.
+*/
+static void test_delete(void)
+{
+        struct m0_db_tx tx;
+
+        /* gets ref */
+        rc = test_locate_internal();
+        M0_ASSERT(rc == 0);
+
+        m0_db_tx_init(&tx, dom.cd_dbenv, 0);
+        rc = xx_cob_delete_put(cob, &tx);
+        m0_db_tx_commit(&tx);
+        M0_UT_ASSERT(rc == 0);
+
+        /* should fail now */
+        rc = test_locate_internal();
+        M0_UT_ASSERT(rc != 0);
+}
+
+const struct m0_test_suite xx_cob_ut = {
+        .ts_name = "xx-cob-ut",
+        .ts_init = db_reset,
+        /* .ts_fini = db_reset, */
+        .ts_tests = {
+                { "cob-mkfs", test_mkfs },
+                { "cob-init", test_init },
+                { "cob-create", test_create },
+                { "cob-lookup", test_lookup },
+                { "cob-locate", test_locate },
+                { "cob-add-name", test_add_name },
+                { "cob-del-name", test_del_name },
+                { "cob-delete", test_delete },
+                { "cob-fini", test_fini },
+                { NULL, NULL }
+        }
+};
+
+/*
+ * UB
+ */
+
+/* CU_ASSERT doesn't work for ub tests */
+#define M0_UB_ASSERT M0_ASSERT
+
+static struct m0_db_tx cob_ub_tx;
+
+enum {
+        UB_ITER = 100000
+};
+
+static void ub_init(void)
+{
+        db_reset();
+        test_init();
+        rc = m0_db_tx_init(&cob_ub_tx, dom.cd_dbenv, 0);
+        M0_ASSERT(rc == 0);
+}
+
+static void ub_fini(void)
+{
+        rc = m0_db_tx_commit(&cob_ub_tx);
+        M0_ASSERT(rc == 0);
+        test_fini();
+        db_reset();
+}
+
+static void newtx(int i) {
+        int rc;
+
+        if (i && i % 10 == 0) {
+                rc = m0_db_tx_commit(&cob_ub_tx);
+                M0_UB_ASSERT(rc == 0);
+                rc = m0_db_tx_init(&cob_ub_tx, dom.cd_dbenv, 0);
+                M0_UB_ASSERT(rc == 0);
+        }
+}
+
+static void ub_create(int i)
+{
+        struct xx_cob_nskey   *key;
+        struct xx_cob_nsrec    nsrec;
+        struct xx_cob_fabrec  *fabrec;
+        struct xx_cob_omgrec   omgrec;
+        struct m0_fid          fid;
+
+        M0_SET0(&nsrec);
+        M0_SET0(&omgrec);
+
+        newtx(i);
+
+        /* pfid == cfid for data objects, so here we are identifying
+           uniquely in the namespace by {pfid, ""} */
+        m0_fid_set(&fid, 0xAA, i);
+        xx_cob_nskey_make(&key, &fid, "", 0);
+
+        m0_fid_set(&nsrec.cnr_fid, 0xAA, i);
+        nsrec.cnr_nlink = 1;
+
+        rc = xx_cob_alloc(&dom, &cob);
+        M0_UB_ASSERT(rc == 0);
+
+        xx_cob_fabrec_make(&fabrec, NULL, 0);
+        rc = xx_cob_create(cob, key, &nsrec, fabrec, &omgrec, &cob_ub_tx);
+        M0_UB_ASSERT(rc == 0);
+
+        xx_cob_put(cob);
+}
+
+static void ub_lookup(int i)
+{
+        struct xx_cob_nskey *key;
+        struct m0_fid        fid;
+
+        newtx(i);
+
+        /* pfid == cfid for data objects */
+        m0_fid_set(&fid, 0xAA, i);
+        xx_cob_nskey_make(&key, &fid, "", 0);
+        rc = xx_cob_lookup(&dom, key, M0_CA_NSKEY_FREE, &cob, &cob_ub_tx);
+        M0_UB_ASSERT(rc == 0);
+        M0_UB_ASSERT(cob != NULL);
+        M0_UB_ASSERT(cob->co_dom == &dom);
+
+        M0_UB_ASSERT(cob->co_flags & M0_CA_NSREC);
+        M0_UB_ASSERT(cob->co_nsrec.cnr_fid.f_container == 0xAA);
+        M0_UB_ASSERT(cob->co_nsrec.cnr_fid.f_key == i);
+
+        /* We should be holding the nskey until the final put */
+        M0_UB_ASSERT(cob->co_flags & M0_CA_NSKEY);
+
+        xx_cob_put(cob);
+}
+
+
+struct m0_ub_set xx_cob_ub = {
+        .us_name = "xx-cob-ub",
+        .us_init = ub_init,
+        .us_fini = ub_fini,
+        .us_run  = {
+                { .ut_name = "create",
+                  .ut_iter = UB_ITER,
+                  .ut_round = ub_create },
+
+                { .ut_name = "lookup",
+                  .ut_iter = UB_ITER,
+                  .ut_round = ub_lookup },
+
+                { .ut_name = NULL }
+        }
+};
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
-- 
1.8.3.2

