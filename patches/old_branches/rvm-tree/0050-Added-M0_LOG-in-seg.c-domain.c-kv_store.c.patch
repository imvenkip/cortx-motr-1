From 6852ec1fa00d97d407cac0b1ba5cb42819458cc9 Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Mon, 11 Feb 2013 05:22:21 -0800
Subject: [PATCH 50/94] Added M0_LOG in seg.c domain.c kv_store.c

---
 be/domain.c         |  2 ++
 be/helper.h         |  2 --
 be/kv_store.c       | 22 ++++++++++++++++++----
 be/kv_store.h       | 16 ++++++++--------
 be/seg.c            | 22 +++++++++++++++++-----
 be/tx.c             |  3 +++
 be/ut/kv_store.c    | 13 ++++++++-----
 be/ut/kv_store_ub.c |  6 ++++--
 8 files changed, 60 insertions(+), 26 deletions(-)

diff --git a/be/domain.c b/be/domain.c
index 378fe51..afe3e4d 100644
--- a/be/domain.c
+++ b/be/domain.c
@@ -84,6 +84,7 @@ M0_INTERNAL void m0_be_domain_init(struct m0_be_domain *dom)
          */
         m0_be_init();
         M0_POST(m0_be_domain_invariant(dom));
+        M0_LOG(M0_INFO, "Domain initialised, dom = %p", dom);
         M0_LEAVE();
 }
 
@@ -139,6 +140,7 @@ M0_INTERNAL void m0_be_domain_fini(struct m0_be_domain *dom)
         m0_stob_fini(dom->bd_impl.log_stob);
 
         M0_POST(m0_be_domain_invariant(dom));
+        M0_LOG(M0_INFO, "Domain finalised, dom = %p", dom);
         M0_LEAVE();
 }
 
diff --git a/be/helper.h b/be/helper.h
index e9def06..f39de5a 100644
--- a/be/helper.h
+++ b/be/helper.h
@@ -48,8 +48,6 @@ enum {
         /** Control operations in specific functions. */
         BE_KV_INSERT         = 555,
         BE_KV_DELETE         = 666,
-        BE_KV_IN_TX_NULL     = 777,
-        BE_KV_IN_TX_NOT_NULL = 888,
 };
 
 /**
diff --git a/be/kv_store.c b/be/kv_store.c
index d829e15..879bdb6 100644
--- a/be/kv_store.c
+++ b/be/kv_store.c
@@ -81,8 +81,10 @@ M0_INTERNAL void m0_be_ks_create_handle(struct m0_be_domain        *dom,
         M0_ALLOC_PTR(tx);
         M0_ASSERT(tx != NULL);
 
-        if (tx == NULL)
+        if (tx == NULL) {
+                M0_LOG(M0_FATAL, "Could not create tx for kv_store handle!");
                 return;
+        }
 
         /* Lookup for the kv_store segment. */
         sm_group = m0_be_domain_sm_group(dom);
@@ -134,8 +136,8 @@ M0_EXPORTED(m0_be_ks_create_handle);
 M0_INTERNAL bool m0_be_ks_init(struct m0_be_kv_store **out_handle,
                                struct m0_tl_descr     *descr,
                                struct m0_be_domain    *dom,
-                               kv_key_cmp              cmp_fp,
-                               kv_key_match            match_fp,
+                               kv_key_cmp_t            cmp_fp,
+                               kv_key_match_t          match_fp,
                                char                   *mode)
 {
         struct m0_be_kv_store      *handle = NULL;
@@ -163,6 +165,7 @@ M0_INTERNAL bool m0_be_ks_init(struct m0_be_kv_store **out_handle,
                                                    BE_KV_SEG_NAME);
                 if (recovery_status != BE_KV_SUCCESS) {
                         ret_val = false;
+                        M0_LOG(M0_FATAL, "Could not recover kv_store handle!");
                         goto exit_init;
                 }
         } else {
@@ -188,8 +191,14 @@ M0_INTERNAL bool m0_be_ks_init(struct m0_be_kv_store **out_handle,
         ret_val = m0_be_ks_deref_handle(handle, rvm_handle_seg);
 
         if (ret_val == false && recovery_status != BE_KV_SUCCESS) {
+
                 m0_be_ks_create_handle(dom, descr, &rvm_handle);
-                M0_ASSERT(rvm_handle != NULL);
+                if (rvm_handle == NULL) {
+                        M0_LOG(M0_FATAL, "Failed to create handle!");
+                        ret_val = false;
+                        goto exit_init;
+                }
+
                 handle->handle_rvm = rvm_handle;
                 ret_val = true;
         }
@@ -284,6 +293,7 @@ M0_INTERNAL int m0_be_ks_delete(struct m0_be_kv_store  *handle,
         bool                     target_found;
 
         M0_ENTRY();
+        M0_ASSERT(tx != NULL);
 
         ks_list_descr  = handle->handle_heap.ks_list_descr;
         ks_tlist       = &handle->handle_rvm->ks_tlist;
@@ -385,6 +395,7 @@ M0_INTERNAL int m0_be_ks_insert(struct m0_be_kv_store      *handle,
         int                      ret_val       = BE_KV_INVALID_REQ;
 
         M0_ENTRY("obj_ref: %p", obj_ref);
+        M0_ASSERT(tx != NULL);
 
         ks_list_descr = handle->handle_heap.ks_list_descr;
         ks_tlist      = &handle->handle_rvm->ks_tlist;
@@ -394,6 +405,7 @@ M0_INTERNAL int m0_be_ks_insert(struct m0_be_kv_store      *handle,
         /* Ensure object is allocated on same domain as that of handle */
         if (obj_ref->be_magic != dom->bd_magic) {
                 ret_val = BE_KV_OUT_OF_DOMAIN;
+                M0_LOG(M0_ERROR, "kv_insert: object out of domain!");
                 goto exit_insert;
         }
 
@@ -404,6 +416,7 @@ M0_INTERNAL int m0_be_ks_insert(struct m0_be_kv_store      *handle,
         m0_tlist_for(ks_list_descr, ks_tlist, scan) {
                 if (handle->handle_heap.ks_key_cmp(new, scan) == 0) {
                         ret_val = BE_KV_DUPLICATE;
+                        M0_LOG(M0_ERROR, "kv_insert: duplicate insertion!");
                         goto exit_insert;
                 }
         } m0_tlist_endfor;
@@ -490,6 +503,7 @@ M0_INTERNAL bool m0_be_ks_deref_handle(struct m0_be_kv_store *handle,
 
         if (kv_store->u_hi == 0) {
                 ret_val = false;
+                M0_LOG(M0_DEBUG, "Failed to restore handle from index 0!");
                 goto exit_deref;
         }
 
diff --git a/be/kv_store.h b/be/kv_store.h
index cfed3ec..62ed45a 100644
--- a/be/kv_store.h
+++ b/be/kv_store.h
@@ -70,8 +70,8 @@
        struct m0_be_kv_store *handle;
        struct m0_tl_descr    *list_descr;
        struct m0_be_domain   *dom;
-       kv_key_cmp             cmp_routine;
-       kv_key_match           match_routine;
+       kv_key_cmp_t           cmp_routine;
+       kv_key_match_t         match_routine;
        char                  *mode = "create" or "recover";
        bool                   status;
 
@@ -135,8 +135,8 @@
 /**
   Function compare routines. Used in key value store while searching for key.
  */
-typedef int     (*kv_key_cmp)(void *, void *);
-typedef int     (*kv_key_match)(void *, void *);
+typedef int     (*kv_key_cmp_t)(void *, void *);
+typedef int     (*kv_key_match_t)(void *, void *);
 
 /**
   Structure that stores the fields of the kv_store handle that neeed to be made
@@ -156,9 +156,9 @@ struct m0_be_kv_store_heap {
         /** Domain pointer. */
         struct m0_be_domain     *ks_dom;
         /** Compare function from user. */
-        kv_key_cmp               ks_key_cmp;
+        kv_key_cmp_t             ks_key_cmp;
         /** Match function from user. */
-        kv_key_match             ks_key_match;
+        kv_key_match_t           ks_key_match;
 };
 
 /**
@@ -200,8 +200,8 @@ M0_INTERNAL void m0_be_ks_create_handle(struct m0_be_domain        *dom,
 M0_INTERNAL bool m0_be_ks_init(struct m0_be_kv_store **handle,
                                struct m0_tl_descr     *descr,
                                struct m0_be_domain    *dom,
-                               kv_key_cmp              cmp_fp,
-                               kv_key_match            match_fp,
+                               kv_key_cmp_t            cmp_fp,
+                               kv_key_match_t          match_fp,
                                char                   *mode);
 
 /**
diff --git a/be/seg.c b/be/seg.c
index 5da8e24..be9aabf 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -328,8 +328,10 @@ M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
         M0_ASSERT(seg->bs_stob->so_state == CSS_UNKNOWN);
         result = m0_stob_create(seg->bs_stob, NULL);
 
-        if (result < 0)
+        if (result < 0) {
+                M0_LOG(M0_ERROR, "Failed to creat stob in m0_be_seg_create_cb");
                 goto error;
+        }
 
         lstob = stob2linux(seg->bs_stob);
 
@@ -359,8 +361,10 @@ M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
                               chunk_size,
                               &err);
 
-        if (result < 0)
+        if (result < 0) {
+                M0_LOG(M0_ERROR, "rds_zap_heap failed in m0_be_seg_create_cb");
                 goto error;
+        }
 
         /* @todo - begin transaction. */
         /* update the named segment transactionally. */
@@ -371,8 +375,10 @@ M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
                                &static_addr,
                                &err);
 
-        if (result < 0)
+        if (result < 0) {
+                M0_LOG(M0_ERROR, "rds_load_heap failed in m0_be_seg_create_cb");
                 goto error;
+        }
 
         seg->bs_static_addr = (void *)(static_addr);
 
@@ -384,6 +390,7 @@ M0_INTERNAL void m0_be_seg_create_cb(struct m0_sm_group *sm_group,
         m0_be_seg_tlist_add(&seg->bs_dom->bd_seg, seg);
 
         M0_LEAVE();
+        M0_LOG(M0_INFO, "Segment created! seg = %p", seg);
         return;
 
 error:
@@ -412,8 +419,10 @@ M0_INTERNAL void m0_be_seg_open_cb(struct m0_sm_group *sm_group,
 
         seg = (struct m0_be_seg *)sm_ast->sa_datum;
 
-        if (seg->bs_stob->so_state == CSS_UNKNOWN)
+        if (seg->bs_stob->so_state == CSS_UNKNOWN) {
+                M0_LOG(M0_ERROR, "Invalid stob state in seg_open_cb");
                 goto error;
+        }
 
         lstob = stob2linux(seg->bs_stob);
 
@@ -439,8 +448,10 @@ M0_INTERNAL void m0_be_seg_open_cb(struct m0_sm_group *sm_group,
                                &static_addr,
                                &err);
 
-        if (result < 0)
+        if (result < 0) {
+                M0_LOG(M0_ERROR, "rds_load_heap failed in m0_be_seg_open_cb");
                 goto error;
+        }
 
         seg->bs_static_addr = (void *)(static_addr);
 
@@ -449,6 +460,7 @@ M0_INTERNAL void m0_be_seg_open_cb(struct m0_sm_group *sm_group,
         m0_sm_state_set((&seg->bs_sm), M0_BESEG_ACTIVE);
 
         M0_LEAVE();
+        M0_LOG(M0_INFO, "Segment opened! seg = %p", seg);
         return;
 
 error:
diff --git a/be/tx.c b/be/tx.c
index a574af7..1c81883 100644
--- a/be/tx.c
+++ b/be/tx.c
@@ -183,6 +183,7 @@ M0_INTERNAL void m0_be_tx_start(struct m0_be_tx *tx)
         m0_be_tx_state_change(tx, M0_BETX_OPEN);
 
         M0_POST(m0_be_tx_invariant(tx));
+        M0_LOG(M0_INFO, "Transaction started. tx = %p", tx);
         M0_LEAVE();
 }
 
@@ -242,6 +243,7 @@ M0_INTERNAL void m0_be_tx_done_cb(struct m0_sm_group *sm_group,
 
         ret = rvm_end_transaction(tx->bt_impl.tx_id, flush);
         if (RVM_SUCCESS != ret) {
+                M0_LOG(M0_DEBUG, "rvm_end_transaction failed in tx_done_cb");
                 goto exit_end_tx;
         }
 
@@ -250,6 +252,7 @@ M0_INTERNAL void m0_be_tx_done_cb(struct m0_sm_group *sm_group,
         end_for_each_reg_in_tx
 
         m0_sm_state_set(&tx->bt_sm, M0_BETX_DONE);
+        M0_LOG(M0_INFO, "Transaction done tx = %p", tx);
         goto exit;
 
 exit_end_tx:
diff --git a/be/ut/kv_store.c b/be/ut/kv_store.c
index 54f18ee..5cc61dc 100644
--- a/be/ut/kv_store.c
+++ b/be/ut/kv_store.c
@@ -107,8 +107,8 @@ static int ts_kv_store_init()
         rc = system(kv_cmd);
         M0_ASSERT(rc == 0);
 
-        kv_key_cmp     cmp_routine;
-        kv_key_match   match_routine;
+        kv_key_cmp_t     cmp_routine;
+        kv_key_match_t   match_routine;
 
         cmp_routine   = &function_comp;
         match_routine = &function_match;
@@ -118,8 +118,9 @@ static int ts_kv_store_init()
 
         init_status = m0_be_ks_init(&handle, &kv_list_descr, kv_dom,
                                     cmp_routine, match_routine, "create");
-        M0_ASSERT(init_status == true);
         M0_ASSERT(handle != NULL);
+        M0_ASSERT(init_status == true);
+        M0_LOG(M0_INFO, "kv_store init status = %d", init_status);
         return 0;
 }
 
@@ -234,12 +235,14 @@ static int delete(struct m0_kv_store_obj *target)
         /* Delete this obj from kv store */
         ret_val = m0_be_ks_delete(handle, (void *)target, tx);
 
-        if (ret_val != BE_KV_FAILURE) {
+        if (ret_val == BE_KV_SUCCESS) {
                 m0_be_tx_done(tx);
                 m0_be_wait(sm_group, &tx->bt_sm,
                            M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
 
-                ret_val = BE_KV_SUCCESS;
+        } else {
+                M0_LOG(M0_ERROR, "Failed to delete object in kv_store, err %d",
+                       ret_val);
         }
 
         m0_be_tx_fini(tx);
diff --git a/be/ut/kv_store_ub.c b/be/ut/kv_store_ub.c
index e9391d7..825454b 100644
--- a/be/ut/kv_store_ub.c
+++ b/be/ut/kv_store_ub.c
@@ -324,8 +324,8 @@ static void ub_init(void)
         rc = system(kv_cmd);
         M0_ASSERT(rc == 0);
 
-        kv_key_cmp     cmp_routine;
-        kv_key_match   match_routine;
+        kv_key_cmp_t     cmp_routine;
+        kv_key_match_t   match_routine;
 
         cmp_routine   = &function_comp;
         match_routine = &function_match;
@@ -337,6 +337,7 @@ static void ub_init(void)
                                     cmp_routine, match_routine, "create");
         M0_ASSERT(init_status == true);
         M0_ASSERT(handle != NULL);
+        M0_LOG(M0_INFO, "kv_store initialised...init_status : %d", init_status);
 }
 
 static void ub_fini()
@@ -349,6 +350,7 @@ static void ub_fini()
         sprintf(kv_cmd, "rm -rf %s", stob_dir);
         rc = system(kv_cmd);
         M0_ASSERT(rc == 0);
+        M0_LOG(M0_INFO, "kv_store finilise");
 }
 
 struct m0_ub_set m0_kvstore_ub = {
-- 
1.8.3.2

