From cf78d3bc8ddbe276a10e6ae544215127353bd130 Mon Sep 17 00:00:00 2001
From: Zishan Shaikh <zishan_shaikh@xyratex.com>
Date: Wed, 20 Mar 2013 05:02:13 -0700
Subject: [PATCH 67/94] Cob integration with kv_store

---
 be/helper.c  | 237 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 be/helper.h  |  25 +++++++
 cob/cob.c    |  57 ++++++++++++++
 cob/cob.h    |  20 +++++
 cob/ut/cob.c |  70 +++++++++++++++++-
 5 files changed, 408 insertions(+), 1 deletion(-)

diff --git a/be/helper.c b/be/helper.c
index a2bf281..193300c 100644
--- a/be/helper.c
+++ b/be/helper.c
@@ -28,6 +28,9 @@
 #include "lib/trace.h"
 #include "be/helper.h"
 #include "be/seg.h"
+#include "be/kv_store.h"
+#include <stdio.h>
+#include <stdlib.h>
 
 M0_INTERNAL void m0_be_ks_init_domain(struct m0_be_domain  **out_dom)
 {
@@ -137,6 +140,240 @@ M0_INTERNAL void m0_be_wait(struct m0_sm_group *sm_group,
 }
 M0_EXPORTED(m0_be_wait);
 
+M0_INTERNAL void m0_kv_init_helper(struct m0_be_domain   **dom,
+                                   struct m0_be_kv_store **handle,
+                                   struct m0_tl_descr     *list_descr,
+                                   kv_key_cmp_t            cmp_routine,
+                                   kv_key_match_t          match_routine)
+
+{
+        struct m0_sm_group        *sm_group;
+        const char                *stob_dir;
+        const char                *stob_file;
+        const char                *log_file;
+        char                       kv_cmd[1024];
+        int                        rc;
+
+        stob_file = "0000000000000000.0000000000000001";
+        stob_dir  = "./__be/o";
+        log_file  = "/tmp/log_file";
+
+
+        M0_LOG(M0_DEBUG,"KV Store Initialization");
+        sprintf(kv_cmd, "rm -rf %s", log_file);
+        rc = system(kv_cmd);
+        M0_ASSERT(rc == 0);
+
+        sprintf(kv_cmd, "mkdir -p %s", stob_dir);
+        rc = system(kv_cmd);
+        M0_ASSERT(rc == 0);
+
+        sprintf(kv_cmd,
+                "dd if=/dev/zero of=%s/%s bs=1024 count=204800 2>/dev/null",
+                stob_dir, stob_file);
+        rc = system(kv_cmd);
+        M0_ASSERT(rc == 0);
+
+        m0_be_ks_init_domain(dom);
+        M0_ASSERT(dom != NULL);
+
+        /* Create a kv-store handle */
+        m0_be_ks_create(list_descr, *dom,
+                        cmp_routine, match_routine, handle);
+        M0_ASSERT(*handle != NULL);
+
+        sm_group = m0_be_domain_sm_group(*dom);
+
+        /* Initialise the kv-store i.e. create or recover from RVM */
+        m0_be_ks_init(*handle, NULL, "create");
+        m0_be_wait(sm_group, &(*handle)->ks_handle_heap.ksh_sm,
+                   M0_BITS(M0_BEKS_DONE));
+
+        M0_ASSERT((*handle)->ks_handle_rvm != NULL);
+        M0_LOG(M0_INFO, "kv_store initialised!");
+}
+M0_EXPORTED(m0_kv_init_helper);
+
+M0_INTERNAL int32_t m0_kv_insert_helper(struct m0_be_kv_store  *handle,
+                                        struct m0_be_reference *ref,
+                                        struct m0_be_tx        *tx)
+{
+        int32_t                    status  = -2;
+        struct m0_sm_group        *sm_group;
+        struct m0_be_domain       *dom;
+
+        M0_PRE(tx->bt_sm.sm_state == M0_BETX_OPEN);
+
+        dom = handle->ks_handle_heap.ksh_dom;
+        M0_ASSERT(dom != NULL);
+        M0_ASSERT(ref != NULL);
+
+        sm_group = m0_be_domain_sm_group(dom);
+
+        /* Insert this into the kv_store */
+        status = m0_be_ks_insert(handle, NULL, ref, tx);
+        if (status == BE_KV_FAILURE || status == BE_KV_OUT_OF_DOMAIN ||
+            status == BE_KV_DUPLICATE)
+                goto exit;
+
+        m0_be_tx_done(tx);
+        m0_be_wait(sm_group, &tx->bt_sm,
+                   M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
+        m0_be_tx_fini(tx);
+        m0_free(tx);
+
+        /* to free obj_buf */
+exit:
+        return status;
+}
+M0_EXPORTED(m0_kv_insert_helper);
+
+M0_INTERNAL int m0_kv_malloc_helper(struct m0_be_domain     *cob_be_domain,
+                                    struct m0_be_tx        **tx_out,
+                                    struct m0_cob_nsrec    **nsrec_out,
+                                    struct m0_be_reference **ref_out)
+{
+        struct m0_be_seg        *kv_seg;
+        struct m0_be_reg        *obj_reg;
+        struct m0_be_buf        *obj_buf;
+        struct m0_be_tx         *be_tx;
+        struct m0_cob_nsrec     *co_kv_nsrec;
+        struct m0_be_reference  *obj_ref;
+        bool                     ret_dom;
+        int32_t                  status;
+
+        M0_ASSERT(cob_be_domain != NULL);
+
+        /* Search for the kv_store segment */
+        ret_dom = m0_be_domain_lookup(cob_be_domain, BE_KV_SEG_NAME, &kv_seg);
+        M0_ASSERT(ret_dom);
+        M0_ASSERT(kv_seg != NULL);
+
+        M0_ALLOC_PTR(be_tx);
+        M0_ASSERT(be_tx != NULL);
+
+        m0_be_tx_init(be_tx, cob_be_domain, 0);
+
+        /* Prepare a region for the object */
+        M0_ALLOC_PTR(obj_reg);
+        M0_ASSERT(obj_reg != NULL);
+
+        M0_ALLOC_PTR(obj_buf);
+        M0_ASSERT(obj_buf != NULL);
+
+        obj_buf->b_nob = sizeof *co_kv_nsrec;
+        m0_be_reg_init(obj_reg, be_tx, kv_seg, obj_buf);
+
+        /* As nothing in credit list, so can start tx directly */
+        m0_be_tx_start(be_tx);
+
+        /* Memory alloc to the object via rvm */
+        co_kv_nsrec = (struct m0_cob_nsrec *)m0_be_ks_obj_malloc(obj_reg,
+                                                                 &obj_ref);
+        M0_ASSERT(obj_ref != NULL);
+
+        if (co_kv_nsrec == NULL) {
+                status = BE_KV_FAILURE;
+                goto exit;
+        }
+        M0_ASSERT(obj_ref != NULL);
+
+        *tx_out     = be_tx;
+        *ref_out    = obj_ref;
+        *nsrec_out  = co_kv_nsrec;
+        status      = BE_KV_SUCCESS;
+
+exit:
+        return status;
+}
+M0_EXPORTED(m0_kv_malloc_helper);
+
+M0_INTERNAL void m0_kv_find_helper(struct m0_be_kv_store *handle, void *key,
+                                   void                 (*find_cb)(void *cbdata,
+                                                                   void *result,
+                                                                   int rc))
+{
+        struct m0_be_kv_store_cb        *cb_info;
+        char                            *operation_name;
+        M0_ALLOC_PTR(cb_info);
+
+        operation_name = (char *)malloc(10);
+        strcpy(operation_name, "KS_FIND");
+
+        cb_info->ksc_cbdata     = (void *)operation_name;
+        cb_info->ksc_cb         = find_cb;
+
+        m0_be_ks_find(handle, cb_info, key);
+        m0_free(cb_info);
+}
+M0_EXPORTED(m0_kv_find_helper);
+
+M0_INTERNAL int32_t m0_kv_delete_helper(struct m0_be_kv_store *handle,
+                                        void                  *target,
+                                        uint64_t               sizeof_target)
+{
+        struct m0_be_tx           *tx = NULL;
+        struct m0_be_buf          *obj_buf;
+        struct m0_be_reg          *obj_reg = NULL;
+        struct m0_be_seg          *kv_seg  = NULL;
+        struct m0_sm_group        *sm_group;
+        struct m0_be_domain       *kv_dom;
+        int32_t                    ret_val;
+        bool                       ret_dom;
+
+        M0_ALLOC_PTR(tx);
+
+        if (tx == NULL)
+                return BE_KV_FAILURE;
+
+        kv_dom = handle->ks_handle_heap.ksh_dom;
+        M0_ASSERT(kv_dom != NULL);
+
+        /* Search for the kv_store segment */
+        ret_dom = m0_be_domain_lookup(kv_dom, BE_KV_SEG_NAME, &kv_seg);
+        M0_ASSERT(ret_dom);
+        M0_ASSERT(kv_seg != NULL);
+
+        sm_group = m0_be_domain_sm_group(kv_dom);
+
+        m0_be_tx_init(tx, kv_dom, 0);
+
+        /* Prepare a region for this object */
+        M0_ALLOC_PTR(obj_reg);
+        M0_ASSERT(obj_reg != NULL);
+
+        M0_ALLOC_PTR(obj_buf);
+        M0_ASSERT(obj_buf != NULL);
+
+        obj_buf->b_nob  = sizeof_target;
+        obj_buf->b_addr = target;
+        m0_be_reg_init(obj_reg, tx, kv_seg, obj_buf);
+        M0_ASSERT(obj_reg != NULL);
+
+        m0_be_tx_add_cred(tx, obj_reg);
+
+        m0_be_tx_prep(tx);
+        m0_be_tx_start(tx);
+
+        /* Delete this obj from kv store */
+        ret_val = m0_be_ks_delete(handle, NULL, target, tx);
+
+        if (ret_val == BE_KV_SUCCESS) {
+                m0_be_tx_done(tx);
+                m0_be_wait(sm_group, &tx->bt_sm,
+                           M0_BITS(M0_BETX_DONE, M0_BETX_FAILED));
+        } else {
+                M0_LOG(M0_ERROR, "Failed to delete object in kv_store, err %d",
+                       ret_val);
+        }
+
+        m0_be_tx_fini(tx);
+        m0_free(tx);
+        m0_free(obj_reg);
+        m0_free(obj_buf);
+        return ret_val;
+}
+M0_EXPORTED(m0_kv_delete_helper);
 #undef M0_TRACE_SUBSYSTEM
 /* @} end of helper group */
 
diff --git a/be/helper.h b/be/helper.h
index 78c3b1c..2c5b006 100644
--- a/be/helper.h
+++ b/be/helper.h
@@ -26,6 +26,8 @@
 #include "lib/memory.h"
 #include "lib/list.h"
 #include "mero/magic.h"
+#include "be/kv_store.h"
+#include "cob/cob.h"
 
 #define BE_KV_SEG_NAME "kv_store"
 
@@ -83,6 +85,29 @@ M0_INTERNAL void m0_be_ks_prep_link_reg(struct m0_be_domain    *dom,
 M0_INTERNAL void m0_be_wait(struct m0_sm_group *sm_group,
                             struct m0_sm       *sm, uint64_t allowed_states);
 
+M0_INTERNAL void m0_kv_init_helper(struct m0_be_domain   **dom,
+                                   struct m0_be_kv_store **handle,
+                                   struct m0_tl_descr     *list_descr,
+                                   kv_key_cmp_t            cmp_routine,
+                                   kv_key_match_t          match_routine);
+
+M0_INTERNAL int32_t m0_kv_malloc_helper(struct m0_be_domain     *cob_be_domain,
+                                        struct m0_be_tx        **tx_out,
+                                        struct m0_cob_nsrec    **nsrec_out,
+                                        struct m0_be_reference **ref_out);
+
+M0_INTERNAL int32_t m0_kv_insert_helper(struct m0_be_kv_store  *handle,
+                                        struct m0_be_reference *ref,
+                                        struct m0_be_tx        *tx);
+
+M0_INTERNAL void m0_kv_find_helper(struct m0_be_kv_store *handle, void *key,
+                                   void                 (*find_cb)(void *cbdata,
+                                                                   void *result,
+                                                                   int rc));
+
+M0_INTERNAL int32_t m0_kv_delete_helper(struct m0_be_kv_store *handle,
+                                        void                  *target,
+                                        uint64_t               sizeof_target);
 /** @} end of helper group */
 
 #endif /* __MERO_BE_HELPER_H__ */
diff --git a/cob/cob.c b/cob/cob.c
index 2dd1ba4..86dcc84 100644
--- a/cob/cob.c
+++ b/cob/cob.c
@@ -32,11 +32,49 @@
 
 #include "cob/cob.h"
 
+#ifndef __KERNEL__
+
+/** Declarations needed for kv_store integration. */
+#include "be/helper.h"
+#include "be/kv_store.h"
+
 /**
    @addtogroup cob
    @{
 */
 
+/* @todo: Magic values random for now,. */
+struct m0_tl_descr cob_ns_list_descr = M0_TL_DESCR("cob",
+                                                    struct m0_cob_nsrec,
+                                                    cnr_linkage,
+                                                    cnr_magic,
+                                                    0xab5ce55edba1b0a0,
+                                                    0xba1dba11adba0bab);
+
+struct m0_be_domain  *cob_be_domain = NULL;
+
+/** Compare and match routines for kv_store. */
+M0_INTERNAL int m0_cob_kv_ns_cmp(void *in_obj1, void *in_obj2)
+{
+        struct m0_cob_nsrec *obj1;
+        struct m0_cob_nsrec *obj2;
+
+        obj1 = (struct m0_cob_nsrec *)in_obj1;
+        obj2 = (struct m0_cob_nsrec *)in_obj2;
+
+        return m0_cob_nskey_cmp(obj1->cnr_nskey, obj2->cnr_nskey);
+}
+
+M0_INTERNAL int m0_cob_kv_ns_match(void *in_obj, void *key)
+{
+        struct m0_cob_nsrec *obj;
+        obj = (struct m0_cob_nsrec *)in_obj;
+
+        return m0_cob_nskey_cmp(obj->cnr_nskey, (struct m0_cob_nskey *)key);
+}
+#endif
+
+
 enum {
         M0_COB_NAME_MAX = 256
 };
@@ -309,17 +347,34 @@ int m0_cob_domain_init(struct m0_cob_domain *dom, struct m0_dbenv *env,
         char table[16];
         int rc;
 
+
         dom->cd_id = *id;
         M0_PRE(dom->cd_id.id != 0);
 
         dom->cd_dbenv = env;
 
+#ifndef __KERNEL__
+        if (cob_be_domain == NULL) {
+                kv_key_cmp_t   cmp_routine;
+                kv_key_match_t match_routine;
+
+                cmp_routine     = &m0_cob_kv_ns_cmp;
+                match_routine   = &m0_cob_kv_ns_match;
+
+                m0_kv_init_helper(&cob_be_domain, &dom->cd_kvnamespace,
+                                  &cob_ns_list_descr, cmp_routine,
+                                  match_routine);
+        }
+#endif
+
+
         /* Locate table based on domain id */
         rc = m0_table_init(&dom->cd_namespace, dom->cd_dbenv,
                            cob_dom_id_make(table, &dom->cd_id, "ns"),
                            0, &cob_ns_ops);
         if (rc != 0)
                 return rc;
+
         rc = m0_table_init(&dom->cd_object_index, dom->cd_dbenv,
                            cob_dom_id_make(table, &dom->cd_id, "oi"),
                            0, &cob_oi_ops);
@@ -344,6 +399,7 @@ int m0_cob_domain_init(struct m0_cob_domain *dom, struct m0_dbenv *env,
                 m0_table_fini(&dom->cd_object_index);
                 m0_table_fini(&dom->cd_namespace);
                 return rc;
+
         }
 
         m0_addb_ctx_init(&dom->cd_addb, &m0_cob_domain_addb, &env->d_addb);
@@ -1257,6 +1313,7 @@ M0_INTERNAL int m0_cob_name_add(struct m0_cob *cob,
         if (rc != 0)
                 goto out;
 
+        /* call ks_insert */
         m0_db_pair_setup(&pair, &cob->co_dom->cd_namespace,
                          nskey, m0_cob_nskey_size(nskey),
                          nsrec, sizeof *nsrec);
diff --git a/cob/cob.h b/cob/cob.h
index a5e21db..4a5d814 100644
--- a/cob/cob.h
+++ b/cob/cob.h
@@ -37,6 +37,10 @@
 #include "stob/stob.h"
 #include "dtm/verno.h"
 
+#ifndef __KERNEL__
+  #include "be/kv_store.h"
+#endif
+
 /* import */
 struct m0_db_tx;
 
@@ -267,7 +271,13 @@ struct m0_cob_domain {
         struct m0_cob_domain_id cd_id;
         struct m0_dbenv        *cd_dbenv;
         struct m0_table         cd_object_index;
+
         struct m0_table         cd_namespace;
+
+#ifndef __KERNEL__
+        struct m0_be_kv_store  *cd_kvnamespace;
+#endif
+
         struct m0_table         cd_fileattr_basic;
         struct m0_table         cd_fileattr_omg;
 
@@ -380,6 +390,13 @@ struct m0_cob_nsrec {
         uint64_t          cnr_atime;   /**< time of last access */
         uint64_t          cnr_mtime;   /**< time of last modification */
         uint64_t          cnr_ctime;   /**< time of last status change */
+
+#ifndef __KERNEL__
+        /** For kv_store. */
+        struct m0_tlink      cnr_linkage;
+        uint64_t             cnr_magic;
+        struct m0_cob_nskey *cnr_nskey;
+#endif
 };
 
 /** Object index table key. The oi table record is a struct m0_cob_nskey. */
@@ -494,6 +511,9 @@ struct m0_cob {
         struct m0_cob_nskey   *co_nskey;    /**< cob statdata nskey */
         struct m0_cob_oikey    co_oikey;    /**< object fid, linkno */
         struct m0_cob_nsrec    co_nsrec;    /**< object fid, basic stat data */
+
+        struct m0_cob_nsrec   *co_kv_nsrec;
+
         struct m0_cob_fabrec  *co_fabrec;   /**< fileattr_basic data (acl...) */
         struct m0_cob_omgrec   co_omgrec;   /**< permission data */
         struct m0_db_pair      co_oipair;   /**< used for object index access */
diff --git a/cob/ut/cob.c b/cob/ut/cob.c
index b41caad..4910266 100644
--- a/cob/ut/cob.c
+++ b/cob/ut/cob.c
@@ -24,6 +24,7 @@
 #include "lib/misc.h"              /* M0_SET0 */
 #include "lib/bitstring.h"
 #include "cob/cob.h"
+#include "be/helper.h"
 
 static const char db_name[] = "ut-cob";
 static const char test_name[] = "hello_world";
@@ -36,6 +37,11 @@ static struct m0_cob_domain  dom;
 static struct m0_cob         *cob;
 static int rc;
 
+
+static struct m0_cob_nsrec  *ret_kv_nsrec;
+extern struct m0_be_domain  *cob_be_domain;
+
+
 static int db_reset(void)
 {
         rc = m0_ut_db_reset(db_name);
@@ -119,6 +125,15 @@ static void test_create(void)
         m0_db_tx_commit(&tx);
 }
 
+static void test_find_callback(void *cbdata, void *result, int32_t rc)
+{
+        M0_ASSERT(rc == BE_KV_SUCCESS);
+
+        ret_kv_nsrec = (struct m0_cob_nsrec *)result;
+        m0_free(cbdata);
+}
+
+
 /**
    Test that add_name works.
 */
@@ -128,6 +143,13 @@ static void test_add_name(void)
         struct m0_fid        pfid;
         struct m0_db_tx      tx;
 
+        /* Kv_store declarations */
+        int32_t                    status  = -2;
+        struct m0_be_reference    *obj_ref;
+        struct m0_be_tx           *be_tx;
+        struct m0_cob_nsrec       *co_kv_nsrec;
+        struct m0_cob_nskey       *co_kv_nskey;
+
         /* pfid, filename */
         m0_fid_set(&pfid, 0x123, 0x456);
 
@@ -141,6 +163,53 @@ static void test_add_name(void)
         /* add new name to existing cob */
         m0_cob_nskey_make(&nskey, &pfid, add_name, strlen(add_name));
         cob->co_nsrec.cnr_linkno = cob->co_nsrec.cnr_cntr;
+
+        /* kv_store integration here */
+        co_kv_nskey = nskey;
+
+        /* Allocate memory to co_kv_ns_rec on RVM */
+        status = m0_kv_malloc_helper(cob_be_domain, &be_tx, &co_kv_nsrec,
+                                     &obj_ref);
+        M0_ASSERT(obj_ref != NULL);
+        M0_ASSERT(co_kv_nsrec != NULL);
+
+        co_kv_nsrec->cnr_nskey = co_kv_nskey;
+
+        /* Insert allocated object */
+        status = m0_kv_insert_helper(dom.cd_kvnamespace, obj_ref, be_tx);
+        M0_ASSERT(status == BE_KV_SUCCESS);
+
+        /* Find inserted object */
+        m0_kv_find_helper(dom.cd_kvnamespace, nskey, &test_find_callback);
+
+        M0_ASSERT(ret_kv_nsrec != NULL);
+        M0_ASSERT(ret_kv_nsrec == co_kv_nsrec);
+        M0_ASSERT(ret_kv_nsrec->cnr_nskey     == co_kv_nsrec->cnr_nskey);
+
+        M0_ASSERT(ret_kv_nsrec->cnr_fid.f_key == co_kv_nsrec->cnr_fid.f_key);
+        M0_ASSERT(ret_kv_nsrec->cnr_magic     == co_kv_nsrec->cnr_magic);
+        M0_ASSERT(ret_kv_nsrec->cnr_cntr      == co_kv_nsrec->cnr_cntr);
+        M0_ASSERT(ret_kv_nsrec->cnr_blocks    == co_kv_nsrec->cnr_blocks);
+        M0_ASSERT(ret_kv_nsrec->cnr_blksize   == co_kv_nsrec->cnr_blksize);
+
+        /* Delete inserted object */
+        status = m0_kv_delete_helper(dom.cd_kvnamespace, (void *)ret_kv_nsrec,
+                                     sizeof *ret_kv_nsrec);
+        M0_ASSERT(status == BE_KV_SUCCESS);
+
+        /* Try finding deleted object again, should return as NULL only.
+         * If callback if called (possible only after successful
+         * search in ks_find), ret_kv_nsrec will have some address.
+         * So setting it to NULL in order to ensure callback was never called.
+         */
+        ret_kv_nsrec = NULL;
+        m0_kv_find_helper(dom.cd_kvnamespace, nskey, &test_find_callback);
+        M0_ASSERT(ret_kv_nsrec == NULL);
+
+        printf("\nDone with all kv_store ops\n");
+        /* kv_store integration end */
+
+
         rc = m0_cob_name_add(cob, nskey, &cob->co_nsrec, &tx);
         M0_UT_ASSERT(rc == 0);
         m0_cob_put(cob);
@@ -411,7 +480,6 @@ struct m0_ub_set m0_cob_ub = {
                 { .ut_name = NULL }
         }
 };
-
 /*
  *  Local variables:
  *  c-indentation-style: "K&R"
-- 
1.8.3.2

