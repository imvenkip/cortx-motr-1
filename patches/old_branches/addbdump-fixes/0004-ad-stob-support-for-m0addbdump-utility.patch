From 4484ca8c6df3af38d9662e4e4ee9b9a367cd9fed Mon Sep 17 00:00:00 2001
From: Rohan Puri <rohan_puri@xyratex.com>
Date: Thu, 6 Feb 2014 15:45:13 +0530
Subject: [PATCH 4/5] ad stob support for m0addbdump utility

---
 addb/dump/addbdump.c            | 11 +----------
 addb/user_space/addb_stobsink.c | 44 +++++++++++++++++++++++++++++++++++++++--
 balloc/balloc.c                 |  9 +--------
 be/btree.c                      |  7 ++++++-
 be/seg.c                        | 11 ++---------
 ioservice/cob_foms.c            |  6 +++---
 ioservice/io_foms.c             |  4 ++--
 ioservice/ut/bulkio_ut.c        |  6 +++---
 mero/setup.c                    | 27 +++++++++++++++++++++----
 mero/setup.h                    |  3 ++-
 sns/cm/repair/ut/net.c          |  2 +-
 sns/cm/repair/ut/storage.c      |  2 +-
 sns/cm/repair/ut/xform.c        |  2 +-
 sns/cm/storage.c                |  2 +-
 stob/ad.c                       | 17 +++++++++-------
 stob/linux.c                    |  1 +
 stob/stob.c                     |  4 ----
 17 files changed, 100 insertions(+), 58 deletions(-)

diff --git a/addb/dump/addbdump.c b/addb/dump/addbdump.c
index 94fb981..ac7b9d8 100644
--- a/addb/dump/addbdump.c
+++ b/addb/dump/addbdump.c
@@ -169,7 +169,7 @@ static int dump_ad_stob_init(struct dump_stob *stob, uint64_t cid,
 	struct dump_ad_stob *adstob;
 	struct m0_stob_id   *bstob_id, *bestob_id;
 	struct m0_stob     **bstob, **bestob;
-//	struct m0_balloc    *cb;
+	struct m0_balloc    *cb;
 	int                  rc;
 	struct m0_stob_domain *be_stob_dom;
 	struct m0_sm_group *grp = NULL;// m0_locality0_get()->lo_grp;
@@ -201,19 +201,15 @@ static int dump_ad_stob_init(struct dump_stob *stob, uint64_t cid,
 	bstob_id->si_bits.u_hi = cid;
 	bstob_id->si_bits.u_lo = M0_AD_STOB_ID_LO;
 	rc = dump_stob_locate(stob->s_ldom, bstob_id, bstob);
-	//	rc = m0_linux_stob_domain_locate(BE_UT_H_STORAGE_DIR, &be_stob_dom);
 	M0_ASSERT(rc == 0);
 	if (rc == 0) {
-		printf("bestob: %p\n", *bestob);
 		m0_be_ut_backend_init(be);
 		m0_be_ut_backend_new_grp_lock_state_set(be, true);
 		grp = m0_be_ut_backend_sm_group_lookup(be);
 		M0_ASSERT(grp != NULL);
 		m0_sm_group_lock(grp);
 		m0_be_seg_init(be_seg, *bestob, &be->but_dom);
-		printf("ad 2\n");
 		rc = m0_be_seg_open(be_seg);
-		printf("ad 3\n");
 		M0_ASSERT(rc == 0);
 		m0_be_allocator_init(m0_be_seg_allocator(be_seg), be_seg);
 		m0_be_seg_dict_init(be_seg);
@@ -225,7 +221,6 @@ static int dump_ad_stob_init(struct dump_stob *stob, uint64_t cid,
 		rc = m0_ad_stob_domain_locate(ad_dname, be_seg, grp,
 				&adstob->as_dom, *bstob);
 		m0_sm_group_unlock(grp);
-		printf("ad 4\n");
 	}
 	if (rc != 0) {
 		if (*bestob != NULL) {
@@ -237,13 +232,11 @@ static int dump_ad_stob_init(struct dump_stob *stob, uint64_t cid,
 		M0_ASSERT(stob->s_adom == NULL);
 		stob->s_adom = adstob;
 		adstob->as_dom->sd_ops = &ad_stob_domain_op;
-#if 0
 		m0_sm_group_lock(grp);
 		rc = m0_balloc_create(cid, be_seg, NULL, &cb);
 		if (rc == 0) {
 			cb->cb_ballroom.ab_ops = &balloc_ops;
 			adstob->as_dom->sd_ops = &ad_stob_domain_op;
-			printf("stob domain name: '%s'\n", adstob->as_dom->sd_name);
 			rc = m0_ad_stob_setup(adstob->as_dom, be_seg, grp,
 					*bstob, &cb->cb_ballroom,
 					BALLOC_DEF_CONTAINER_SIZE,
@@ -252,8 +245,6 @@ static int dump_ad_stob_init(struct dump_stob *stob, uint64_t cid,
 					BALLOC_DEF_RESERVED_GROUPS);
 		}
 		m0_sm_group_unlock(grp);
-#endif
-		printf("ad 5\n");
 	}
 	return rc;
 }
diff --git a/addb/user_space/addb_stobsink.c b/addb/user_space/addb_stobsink.c
index 103d547..bab714b 100644
--- a/addb/user_space/addb_stobsink.c
+++ b/addb/user_space/addb_stobsink.c
@@ -377,6 +377,8 @@ struct stobsink_poolbuf {
 	bool                      spb_busy;
 	struct m0_bufvec          spb_buf;
 	struct m0_stob_io         spb_io;
+	/** The transaction object for spb_io */
+	struct m0_dtx             spb_tx;
 
 	/* following fields are used as size[1] arrays of spb_buf and spb_io */
 	m0_bcount_t               spb_buf_v_count;
@@ -667,6 +669,7 @@ static void stobsink_offset_search(struct stobsink *sink, uint64_t first_seq_nr)
  */
 static bool stobsink_chan_cb(struct m0_clink *link)
 {
+	struct m0_sm_group      *grp = m0_locality0_get()->lo_grp;
 	struct stobsink_poolbuf *pb =
 	    container_of(link, struct stobsink_poolbuf, spb_wait);
 	bool sync;
@@ -682,6 +685,14 @@ static bool stobsink_chan_cb(struct m0_clink *link)
 		       pb->spb_sink->ss_bshift,
 		       pb->spb_io.si_rc);
 	/** @todo alert some component if the operation fails */
+	if (pb->spb_tx.tx_state == M0_DTX_OPEN) {
+			m0_sm_group_lock(grp);
+			m0_mutex_unlock(&pb->spb_sink->ss_mutex);
+			m0_dtx_done_sync(&pb->spb_tx);
+			m0_dtx_fini(&pb->spb_tx);
+			m0_mutex_lock(&pb->spb_sink->ss_mutex);
+			m0_sm_group_unlock(grp);
+	}
 	pb->spb_busy = false;
 	m0_mutex_unlock(&pb->spb_sink->ss_mutex);
 
@@ -769,6 +780,7 @@ static void stobsink_persist(struct stobsink_poolbuf *pb,
 			     m0_bindex_t              offset,
 			     uint32_t                 record_nr)
 {
+	struct m0_sm_group        *grp = m0_locality0_get()->lo_grp;
 	struct stobsink           *sink;
 	struct m0_stob_domain     *dom;
 	struct m0_bufvec_cursor    cur;
@@ -815,9 +827,31 @@ static void stobsink_persist(struct stobsink_poolbuf *pb,
 	pb->spb_io.si_rc = 0;
 	pb->spb_io.si_count = 0;
 	m0_mutex_unlock(&sink->ss_mutex);
-	M0_ASSERT(dom->sd_bedom == NULL); /* Linux stob */
+	if (dom->sd_bedom != NULL) {
+		m0_sm_group_lock(grp);
+		m0_dtx_init(&pb->spb_tx, dom->sd_bedom, grp);
+		dom->sd_ops->sdo_write_credit(dom,
+				&pb->spb_io.si_stob,
+				&pb->spb_tx.tx_betx_cred);
+		rc = dom->sd_ops->sdo_tx_make(dom, &pb->spb_tx);
+		if (rc != 0) {
+			m0_dtx_fini(&pb->spb_tx);
+			m0_sm_group_unlock(grp);
+			m0_mutex_lock(&sink->ss_mutex);
+			pb->spb_busy = false;
+			M0_LOG(M0_ERROR, "%s: tx_make for offset=%ld "
+					 "and size=%ld failed: rc=%d",
+				dom->sd_name,
+				(long)offset,
+				(long)m0_vec_count(&pb->spb_io.si_user.ov_vec), rc);
+			/** @todo alert some component that the db/tx has failed */
+			return;
+		}
+	}
 	M0_LOG(M0_DEBUG, "pb=%p: launching stob io...", pb);
-	rc = m0_stob_io_launch(&pb->spb_io, sink->ss_stob, NULL, NULL);
+	rc = m0_stob_io_launch(&pb->spb_io, sink->ss_stob, &pb->spb_tx, NULL);
+	if (dom->sd_bedom != NULL)
+		m0_sm_group_unlock(grp);
 	m0_mutex_lock(&sink->ss_mutex);
 
 	if (rc != 0) {
@@ -825,6 +859,12 @@ static void stobsink_persist(struct stobsink_poolbuf *pb,
 		M0_LOG(M0_ERROR, "segment persist at offset %ld failed %d",
 		       (unsigned long) offset, rc);
 		/** @todo alert some component that the stob has failed */
+		if (pb->spb_tx.tx_state == M0_DTX_OPEN) {
+			m0_sm_group_lock(grp);
+			m0_dtx_done_sync(&pb->spb_tx);
+			m0_dtx_fini(&pb->spb_tx);
+			m0_sm_group_unlock(grp);
+		}
 	}
 	M0_POST(stobsink_invariant(sink));
 }
diff --git a/balloc/balloc.c b/balloc/balloc.c
index 0423d11..250d7ca 100644
--- a/balloc/balloc.c
+++ b/balloc/balloc.c
@@ -2110,7 +2110,6 @@ M0_INTERNAL int balloc_init(struct m0_ad_balloc *ballroom, struct m0_be_seg *db,
 	int			 rc;
 	M0_ENTRY();
 
-	m0_console_printf("rohan\n");
 	mero = b2m0(ballroom);
 
 	rc = balloc_init_internal(mero, db, grp, bshift, container_size,
@@ -2213,13 +2212,9 @@ M0_INTERNAL int m0_balloc_create(uint64_t            cid,
 	M0_PRE(out != NULL);
 
 	sprintf(cid_name, "%llu", (unsigned long long)cid);
-	m0_console_printf("balloc_create 1\n");
 	rc = m0_be_seg_dict_lookup(seg, cid_name, (void**)out);
-	if (rc == 0) {
-		m0_console_printf("*out: %p\n", *out);
+	if (rc == 0)
 		return rc;
-	}
-	m0_console_printf("balloc_create 2\n");
 	m0_be_tx_init(&tx, 0, seg->bs_domain,
 		      grp, NULL, NULL, NULL, NULL);
 	M0_BE_ALLOC_CREDIT_PTR(cb, seg, &cred);
@@ -2243,8 +2238,6 @@ M0_INTERNAL int m0_balloc_create(uint64_t            cid,
 			if (rc == 0) {
 				cb->cb_container_id = cid;
 				cb->cb_ballroom.ab_ops = &balloc_ops;
-				m0_console_printf("balloc ops s: %p\n", &balloc_ops);
-				m0_console_printf("balloc_init s: %p\n", balloc_ops.bo_init);
 
 				m0_be_btree_init(&cb->cb_db_group_extents, seg,
 						 &ge_btree_ops);
diff --git a/be/btree.c b/be/btree.c
index 2c1acc1..1bed54a 100644
--- a/be/btree.c
+++ b/be/btree.c
@@ -131,6 +131,10 @@ static int be_btree_compare(const struct m0_be_btree *btree,
 {
 	const struct m0_be_btree_kv_ops *ops = btree->bb_ops;
 
+	M0_PRE(ops != NULL);
+	m0_console_printf("ops: %p\n", ops);
+	m0_console_printf("ops->ko_table_ops: %p\n", ops->ko_table_ops);
+	m0_console_printf("ops->ko_table: %p\n", ops->ko_table);
 	M0_PRE(equi(ops->ko_table != NULL, ops->ko_table_ops != NULL));
 
 	return ops->ko_table_ops == NULL ?
@@ -1018,8 +1022,9 @@ M0_INTERNAL void m0_be_btree_init(struct m0_be_btree *tree,
 	tree->bb_ops = ops;
 	tree->bb_seg = seg;
 
-	if (!m0_be_seg_contains(seg, tree->bb_root))
+	if (!m0_be_seg_contains(seg, tree->bb_root)) {
 		tree->bb_root = NULL;
+	}
 }
 
 M0_INTERNAL void m0_be_btree_fini(struct m0_be_btree *tree)
diff --git a/be/seg.c b/be/seg.c
index 86dce4f..c768af8 100644
--- a/be/seg.c
+++ b/be/seg.c
@@ -54,7 +54,6 @@ M0_INTERNAL int m0_be_seg_create(struct m0_be_seg *seg,
 		.bh_addr = addr,
 		.bh_size = size,
 	};
-	m0_console_printf("addr: %p, size: %llu\n", addr,(unsigned long long)size);
 	return m0_be_io_sync(seg->bs_stob, SIO_WRITE,
 			     &hdr, M0_BE_SEG_HEADER_OFFSET, sizeof hdr);
 }
@@ -111,19 +110,14 @@ M0_INTERNAL int m0_be_seg_open(struct m0_be_seg *seg)
 	M0_PRE(M0_IN(seg->bs_state, (M0_BSS_INIT, M0_BSS_CLOSED)));
 	rc = m0_be_io_sync(seg->bs_stob, SIO_READ,
 			   &hdr, M0_BE_SEG_HEADER_OFFSET, sizeof hdr);
-	if (rc != 0) {
-		m0_console_printf("rc: m0_be_io_sync: %d\n", rc);
+	if (rc != 0)
 		return rc;
-	}
 	/* XXX check for magic */
 
 	p = mmap(hdr.bh_addr, hdr.bh_size, PROT_READ|PROT_WRITE,
 		 MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
-	if (p != hdr.bh_addr) {
-		m0_console_printf("rc: mmap: %d, addr: %p, seg_size: %llu\n", -errno,
-				  hdr.bh_addr, (unsigned long long) hdr.bh_size);
+	if (p != hdr.bh_addr)
 		return -errno;
-	}
 
 	rc = m0_be_io_sync(seg->bs_stob, SIO_READ, hdr.bh_addr, 0, hdr.bh_size);
 	if (rc == 0) {
@@ -131,7 +125,6 @@ M0_INTERNAL int m0_be_seg_open(struct m0_be_seg *seg)
 		seg->bs_addr  = hdr.bh_addr;
 		seg->bs_state = M0_BSS_OPENED;
 	} else {
-		m0_console_printf("rc: m0_be_io_sync: %d\n", rc);
 		munmap(hdr.bh_addr, hdr.bh_size);
 	}
 	return rc;
diff --git a/ioservice/cob_foms.c b/ioservice/cob_foms.c
index ce28c72..cdf02ef 100644
--- a/ioservice/cob_foms.c
+++ b/ioservice/cob_foms.c
@@ -417,7 +417,7 @@ static int cc_stob_create_credit(struct m0_fom *fom, struct m0_fom_cob_op *cc,
 	M0_PRE(cc != NULL);
 
 	reqh = m0_fom_reqh(fom);
-	sdom = m0_cs_stob_domain_find(reqh, &cc->fco_stobid);
+	sdom = m0_cs_stob_domain_find(reqh, &cc->fco_stobid, false);
 	if (sdom == NULL) {
 		M0_LOG(M0_DEBUG, "can't find domain for stob_id=["U128D_F"]",
 		       U128_P(&cc->fco_stobid.si_bits));
@@ -442,7 +442,7 @@ static int cc_stob_create(struct m0_fom *fom, struct m0_fom_cob_op *cc)
 	M0_PRE(cc != NULL);
 
 	reqh = m0_fom_reqh(fom);
-	sdom = m0_cs_stob_domain_find(reqh, &cc->fco_stobid);
+	sdom = m0_cs_stob_domain_find(reqh, &cc->fco_stobid, false);
 	if (sdom == NULL) {
 		M0_LOG(M0_DEBUG, "can't find domain for stob_id=["U128D_F"]",
 		       U128_P(&cc->fco_stobid.si_bits));
@@ -650,7 +650,7 @@ static int cd_stob_delete(struct m0_fom *fom, struct m0_fom_cob_op *cd)
 	M0_PRE(cd != NULL);
 
 	reqh = m0_fom_reqh(fom);
-	sdom = m0_cs_stob_domain_find(reqh, &cd->fco_stobid);
+	sdom = m0_cs_stob_domain_find(reqh, &cd->fco_stobid, false);
 	if (sdom == NULL) {
 		IOS_ADDB_FUNCFAIL(-EINVAL, CD_STOB_DELETE_1, &m0_ios_addb_ctx);
 		return -EINVAL;
diff --git a/ioservice/io_foms.c b/ioservice/io_foms.c
index 6d1b043..d6aa425 100644
--- a/ioservice/io_foms.c
+++ b/ioservice/io_foms.c
@@ -976,7 +976,7 @@ static int stob_object_find(struct m0_fom *fom)
 	rwfop = io_rw_get(fom->fo_fop);
 
 	io_fom_cob_rw_fid2stob_map(&rwfop->crw_fid, &stobid);
-	fom_stdom = m0_cs_stob_domain_find(m0_fom_reqh(fom), &stobid);
+	fom_stdom = m0_cs_stob_domain_find(m0_fom_reqh(fom), &stobid, false);
 	if (fom_stdom == NULL)
 		return -EINVAL;
 
@@ -1788,7 +1788,7 @@ static void stob_write_credit(struct m0_fom *fom)
 	rc = stob_object_find(fom);
 	M0_ASSERT(rc == 0);
 	fom_stdom = m0_cs_stob_domain_find(m0_fom_reqh(fom),
-			&fom_obj->fcrw_stob->so_id);
+			&fom_obj->fcrw_stob->so_id, false);
 	M0_ASSERT(fom_stdom != NULL);
 	/*
 	   Since the upper layer IO block size could differ with IO block size
diff --git a/ioservice/ut/bulkio_ut.c b/ioservice/ut/bulkio_ut.c
index 0b82cdd..e4eae4d 100644
--- a/ioservice/ut/bulkio_ut.c
+++ b/ioservice/ut/bulkio_ut.c
@@ -635,7 +635,7 @@ static int check_write_fom_tick(struct m0_fom *fom)
                 stobio_tlist_add(&fom_obj->fcrw_stio_list, saved_stobio_desc);
                 io_fom_cob_rw_fid2stob_map(&rwfop->crw_fid, &stobid);
 		reqh = m0_fom_reqh(fom);
-                fom_stdom = m0_cs_stob_domain_find(reqh, &stobid);
+                fom_stdom = m0_cs_stob_domain_find(reqh, &stobid, false);
 		M0_UT_ASSERT(fom_stdom != NULL);
 
                 rc = m0_stob_find(fom_stdom, &stobid, &fom_obj->fcrw_stob);
@@ -917,7 +917,7 @@ static int check_read_fom_tick(struct m0_fom *fom)
                 stobio_tlist_add(&fom_obj->fcrw_stio_list, saved_stobio_desc);
                 io_fom_cob_rw_fid2stob_map(&rwfop->crw_fid, &stobid);
 		reqh = m0_fom_reqh(fom);
-                fom_stdom = m0_cs_stob_domain_find(reqh, &stobid);
+                fom_stdom = m0_cs_stob_domain_find(reqh, &stobid, false);
 		M0_UT_ASSERT(fom_stdom != NULL);
 
                 rc = m0_stob_find(fom_stdom, &stobid, &fom_obj->fcrw_stob);
@@ -1070,7 +1070,7 @@ static int bulkio_stob_create_fom_tick(struct m0_fom *fom)
 	M0_UT_ASSERT(rwfop->crw_desc.id_nr == rwfop->crw_ivecs.cis_nr);
         io_fom_cob_rw_fid2stob_map(&rwfop->crw_fid, &stobid);
 	reqh = m0_fom_reqh(fom);
-        fom_stdom = m0_cs_stob_domain_find(reqh, &stobid);
+        fom_stdom = m0_cs_stob_domain_find(reqh, &stobid, false);
 	M0_UT_ASSERT(fom_stdom != NULL);
 
 	m0_stob_create_helper_credit(fom_stdom, &stobid,
diff --git a/mero/setup.c b/mero/setup.c
index a10e344..765cfa0 100644
--- a/mero/setup.c
+++ b/mero/setup.c
@@ -958,14 +958,18 @@ static void cs_linux_stob_fini(struct cs_stobs *stob)
 
 M0_INTERNAL struct m0_stob_domain *m0_cs_stob_domain_find(struct m0_reqh *reqh,
 							  const struct
-							  m0_stob_id *stob_id)
+							  m0_stob_id *stob_id,
+							  bool addb_stob)
 {
 	struct m0_reqh_context  *rqctx;
 	struct cs_stobs         *stob;
 	struct cs_ad_stob       *adstob;
 
 	rqctx = bob_of(reqh, struct m0_reqh_context, rc_reqh, &rhctx_bob);
-	stob = &rqctx->rc_stob;
+	if (addb_stob == true)
+		stob = &rqctx->rc_addb_stob.cas_stobs;
+	else
+		stob = &rqctx->rc_stob;
 
 	if (stob->s_stype == M0_LINUX_STOB)
 		return stob->s_ldom;
@@ -1291,14 +1295,17 @@ static int cs_storage_prepare(struct m0_reqh_context *rctx)
    @see m0_addb_mc_configure_stob_sink() that is used by ADDB machine
    to store the ADDB recs.
  */
+static struct m0_dtx ad_tx;
 static int cs_addb_storage_init(struct m0_reqh_context *rctx)
 {
 	int                    rc;
 	struct m0_stob_domain *sdom;
 	struct cs_addb_stob   *addb_stob = &rctx->rc_addb_stob;
 //	const char            *stype = m0_cs_stypes[M0_LINUX_STOB];
+	struct m0_sm_group   *grp =  m0_locality0_get()->lo_grp;
 
 	M0_ENTRY();
+	M0_PRE(grp != NULL);
 
 	/** @todo allow different stob type for data stobs & ADDB stobs? */
 	rc = cs_storage_init(/*stype*/ rctx->rc_stype, rctx->rc_addb_stpath,
@@ -1306,10 +1313,22 @@ static int cs_addb_storage_init(struct m0_reqh_context *rctx)
 	if (rc != 0)
 		M0_RETURN(rc);
 
-	sdom = rctx->rc_addb_stob.cas_stobs.s_ldom;
+	sdom = m0_cs_stob_domain_find(&rctx->rc_reqh, &m0_addb_stob_id, true);
+
+	M0_ASSERT(sdom != NULL);
 
-	rc = m0_stob_create_helper(sdom, NULL, &m0_addb_stob_id,
+	m0_sm_group_lock(grp);
+	m0_dtx_init(&ad_tx, rctx->rc_beseg->bs_domain, grp);
+	m0_stob_create_helper_credit(sdom, &m0_addb_stob_id,
+					&ad_tx.tx_betx_cred);
+	rc = sdom->sd_ops->sdo_tx_make(sdom, &ad_tx);
+	M0_ASSERT(rc == 0);
+	rc = m0_stob_create_helper(sdom, &ad_tx, &m0_addb_stob_id,
 				   &addb_stob->cas_stob);
+	m0_dtx_done_sync(&ad_tx);
+	m0_dtx_fini(&ad_tx);
+	m0_sm_group_unlock(grp);
+
 	M0_RETURN(rc);
 }
 
diff --git a/mero/setup.h b/mero/setup.h
index d91129a..035b9de 100644
--- a/mero/setup.h
+++ b/mero/setup.h
@@ -476,7 +476,8 @@ int m0_cs_start(struct m0_mero *cs_mero);
 M0_INTERNAL struct m0_rpc_machine *m0_mero_to_rmach(struct m0_mero *mero);
 
 M0_INTERNAL struct m0_stob_domain *m0_cs_stob_domain_find(struct m0_reqh *reqh,
-					const struct m0_stob_id *stob_id);
+					const struct m0_stob_id *stob_id,
+					bool addb_stob);
 
 /**
    Find a request handler service within a given Mero instance.
diff --git a/sns/cm/repair/ut/net.c b/sns/cm/repair/ut/net.c
index 9c8ee86..c1057dc 100644
--- a/sns/cm/repair/ut/net.c
+++ b/sns/cm/repair/ut/net.c
@@ -449,7 +449,7 @@ static void receiver_stob_create()
 	dbenv = s0_reqh->rh_dbenv;
 
 	cob_create(dbenv, cdom, 0, &gfid, 0);
-        sdom = m0_cs_stob_domain_find(s0_reqh, &sid);
+        sdom = m0_cs_stob_domain_find(s0_reqh, &sid, false);
         M0_UT_ASSERT(sdom != NULL);
 
 	m0_sm_group_lock(grp);
diff --git a/sns/cm/repair/ut/storage.c b/sns/cm/repair/ut/storage.c
index 319b01b..08ec31e 100644
--- a/sns/cm/repair/ut/storage.c
+++ b/sns/cm/repair/ut/storage.c
@@ -218,7 +218,7 @@ void write_post(void)
 	w_sag.sag_base.cag_cp_local_nr = 1;
 	w_sag.sag_fnr = 1;
 
-	sdom = m0_cs_stob_domain_find(reqh, &sid);
+	sdom = m0_cs_stob_domain_find(reqh, &sid, false);
 	M0_UT_ASSERT(sdom != NULL);
 
 	m0_sm_group_lock(grp);
diff --git a/sns/cm/repair/ut/xform.c b/sns/cm/repair/ut/xform.c
index de2200a..817da00 100644
--- a/sns/cm/repair/ut/xform.c
+++ b/sns/cm/repair/ut/xform.c
@@ -251,7 +251,7 @@ static void tgt_fid_cob_create()
         dbenv = reqh->rh_dbenv;
 
         cob_create(dbenv, cdom, 0, &gfid, 0);
-        stob_dom = m0_cs_stob_domain_find(reqh, &sid);
+        stob_dom = m0_cs_stob_domain_find(reqh, &sid, false);
         M0_ASSERT(stob_dom != NULL);
 
 	m0_sm_group_lock(grp);
diff --git a/sns/cm/storage.c b/sns/cm/storage.c
index b342ac6..065c186 100644
--- a/sns/cm/storage.c
+++ b/sns/cm/storage.c
@@ -156,7 +156,7 @@ static int cp_io(struct m0_cm_cp *cp, const enum m0_stob_io_opcode op)
 	reqh = m0_fom_reqh(cp_fom);
 	stobid = &sns_cp->sc_sid;
 	stio = &sns_cp->sc_stio;
-	dom = m0_cs_stob_domain_find(reqh, stobid);
+	dom = m0_cs_stob_domain_find(reqh, stobid, false);
 	m0_sns_cm_cp_addb_log(cp);
 
 	if (dom == NULL) {
diff --git a/stob/ad.c b/stob/ad.c
index 2952f76..ff6fef3 100644
--- a/stob/ad.c
+++ b/stob/ad.c
@@ -269,11 +269,13 @@ M0_INTERNAL void ad_domain_fini(struct m0_stob_domain *self,
 			   struct m0_sm_group *grp)
 {
 	struct ad_domain       *adom = domain2ad(self);
+#if 0
 	struct m0_be_seg       *seg  = adom->ad_be_seg;
 	struct m0_be_tx         tx = {};
 	struct m0_be_tx_credit  cred = {};
 	struct m0_be_op         op;
 	int                     rc;
+#endif
 
 	if (adom->ad_setup) {
 		adom->ad_ballroom->ab_ops->bo_fini(adom->ad_ballroom);
@@ -283,6 +285,7 @@ M0_INTERNAL void ad_domain_fini(struct m0_stob_domain *self,
 	m0_stob_cache_fini(&adom->ad_cache);
 	m0_stob_domain_fini(self);
 
+#if 0
 	if (seg == NULL)
 		return;
 
@@ -306,6 +309,7 @@ M0_INTERNAL void ad_domain_fini(struct m0_stob_domain *self,
 	}
 
 	m0_be_tx_fini(&tx);
+#endif
 }
 
 static const char prefix[] = "ad.";
@@ -333,8 +337,6 @@ static int ad_stob_type_domain_locate(struct m0_stob_type *type,
 	int                     rc;
 	char                    name[80];
 
-	M0_ENTRY("name=%s id=%lld", domain_name,
-			(unsigned long long)dom_id);
 	M0_PRE(be_seg != NULL);
 	M0_PRE(out != NULL);
 	M0_PRE(domain_name != NULL);
@@ -344,9 +346,13 @@ static int ad_stob_type_domain_locate(struct m0_stob_type *type,
 	sprintf(name, "ad_%llu", (unsigned long long)dom_id);
 	rc = m0_be_seg_dict_lookup(be_seg, name, (void **)&adom);
 	if (rc == 0) {
-		m0_console_printf("ad stob found in dict\n");
 		*out = &adom->ad_base;
-	//	adom->ad_setup = false;
+		adom->ad_setup = false;
+		m0_be_emap_init(emap, be_seg);
+		(*out)->sd_ops = &ad_stob_domain_op;
+		m0_stob_domain_init(*out, type, dom_id,
+				    be_seg->bs_domain);
+		m0_stob_cache_init(&adom->ad_cache);
 		return rc;
 	}
 
@@ -453,8 +459,6 @@ M0_INTERNAL int m0_ad_stob_setup(struct m0_stob_domain *dom,
 
 	M0_ASSERT(ballroom != NULL);
 	M0_ASSERT(ballroom->ab_ops != NULL);
-	m0_console_printf("balloc ops r: %p\n", ballroom->ab_ops);
-	m0_console_printf("balloc init r: %p\n", ballroom->ab_ops->bo_init);
 	M0_ASSERT(ballroom->ab_ops->bo_init != NULL);
 
 	result = ballroom->ab_ops->bo_init(ballroom, be_seg, grp, bshift,
@@ -583,7 +587,6 @@ static int ad_cursor(struct ad_domain *adom, struct m0_stob *obj,
 	m0_be_op_wait(&it->ec_op);
 	M0_ASSERT(m0_be_op_state(&it->ec_op) == M0_BOS_SUCCESS);
 	rc = it->ec_op.bo_u.u_emap.e_rc;
-	//emap_dump(it);
 	m0_be_op_fini(&it->ec_op);
 	if (rc != 0 && rc != -ENOENT && rc != -ESRCH)
 		M0_STOB_FUNC_FAIL(AD_CURSOR, rc);
diff --git a/stob/linux.c b/stob/linux.c
index e538c7a..5b02cb4 100644
--- a/stob/linux.c
+++ b/stob/linux.c
@@ -28,6 +28,7 @@
 #include "lib/errno.h"
 #include "lib/memory.h"
 #include "lib/assert.h"
+#include "lib/trace.h"
 #include "dtm/dtm.h"
 
 #include "stob/linux.h"
diff --git a/stob/stob.c b/stob/stob.c
index 7a225de..380d5ac 100644
--- a/stob/stob.c
+++ b/stob/stob.c
@@ -172,10 +172,6 @@ M0_INTERNAL int m0_stob_locate(struct m0_stob *obj)
 			obj->so_state = CSS_EXISTS;
 			break;
 		case -ENOENT:
-			m0_console_printf("ENOENT: Stobid_lo:%llu,"
-					  "stobid_hi:%llu\n",
-					  (unsigned long long)obj->so_id.si_bits.u_lo,
-					  (unsigned long long)obj->so_id.si_bits.u_hi);
 			obj->so_state = CSS_NOENT;
 			break;
 		}
-- 
1.8.3.2

