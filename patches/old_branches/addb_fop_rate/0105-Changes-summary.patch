From 6bdc1ef407812968f8eb5ef9b7bdebe1dac8b6cd Mon Sep 17 00:00:00 2001
From: Rohan Puri <rohan_puri@xyratex.com>
Date: Tue, 22 Oct 2013 17:12:43 +0530
Subject: [PATCH 105/159] Changes summary : - 1. Various style fixes. 2. Moved
 m0_monitor_setup in m0t1fs_setup().

These changes are part of round 1 review of addb-monitoring-infrastructure
at link http://reviewboard.clusterstor.com/r/1544/
---
 addb/addb_monitor.c         | 63 +++++++++++++++++++++++----------------------
 addb/addb_monitor.h         | 18 ++++++-------
 m0t1fs/linux_kernel/super.c | 57 +++++++++++++++++++---------------------
 mero/conf.c                 |  2 +-
 stats/stats_srv.c           |  3 ++-
 5 files changed, 71 insertions(+), 72 deletions(-)

diff --git a/addb/addb_monitor.c b/addb/addb_monitor.c
index bd5fac2..af01083 100644
--- a/addb/addb_monitor.c
+++ b/addb/addb_monitor.c
@@ -222,8 +222,8 @@ M0_INTERNAL int m0_addb_monitor_stats_svc_conn_init(struct m0_reqh *reqh)
 	/**
 	 * Need to release monitoring ctx mutex here to avoid deadlock due to
 	 * same thread acguiring this mutex twice(once above here in this
-	 * function & in m0_rpc_client_connect())  without releasing it the
-	 * first time.
+	 * function & in addb_mon_rpc_client_connect())  without releasing it
+	 * the first time.
 	 */
 	m0_mutex_unlock(&mon_ctx->amc_mutex);
 	rc = addb_mon_rpc_client_connect(mon_ctx->amc_stats_conn,
@@ -245,9 +245,9 @@ M0_INTERNAL int m0_addb_monitor_stats_svc_conn_init(struct m0_reqh *reqh)
 }
 #endif
 
-M0_INTERNAL void m0_addb_conf_process(struct m0_reqh *reqh,
-				      struct m0_rpc_conn *conn,
-				      const char *ep)
+M0_INTERNAL void m0_addb_monitor_setup(struct m0_reqh     *reqh,
+				       struct m0_rpc_conn *conn,
+				       const char         *ep)
 {
 	struct m0_addb_monitoring_ctx *mon_ctx;
 
@@ -392,15 +392,12 @@ M0_INTERNAL void m0_addb_monitors_fini(struct m0_reqh *reqh)
 {
 	struct m0_addb_monitor *mon;
 
-	m0_mutex_lock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
 	m0_tl_for(addb_mon, &reqh->rh_addb_monitoring_ctx.amc_list, mon) {
 		m0_addb_monitor_del(reqh, mon);
 		m0_addb_monitor_fini(mon);
 	} m0_tl_endfor;
 
 	addb_mon_tlist_fini(&reqh->rh_addb_monitoring_ctx.amc_list);
-	m0_mutex_unlock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
-
 	m0_mutex_fini(&reqh->rh_addb_monitoring_ctx.amc_mutex);
 }
 
@@ -425,16 +422,18 @@ enum {
 };
 
 static void addb_mon_fop_free(struct m0_stats_update_fop *fop_data,
-			      uint32_t fop_nr)
+			      uint32_t                    stats_nr)
 {
-	M0_PRE(fop_data != NULL);
+	struct m0_stats_recs *stats;
 
+	M0_PRE(fop_data != NULL);
+	stats = &fop_data->suf_stats;
 	if (fop_data->suf_stats.sf_stats != NULL) {
 		int i;
 
-		for (i = 0; i < fop_nr; ++i)
-			m0_free(fop_data->suf_stats.sf_stats[i].ss_data.au64s_data);
-		m0_free(fop_data->suf_stats.sf_stats);
+		for (i = 0; i < stats_nr; ++i)
+			m0_free(stats->sf_stats[i].ss_data.au64s_data);
+		m0_free(stats->sf_stats);
 	}
 	m0_free(fop_data);
 	fop_data = NULL;
@@ -449,7 +448,7 @@ static void addb_monitor_stats_fop_release(struct m0_ref *ref)
 }
 
 static int addb_monitor_stats_fop_send(struct m0_stats_update_fop *fop_data,
-				       struct m0_rpc_conn      *conn)
+				       struct m0_rpc_conn         *conn)
 {
 	struct m0_fop      *stats_update_fop;
 	struct m0_rpc_item *item;
@@ -478,14 +477,15 @@ M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh       *reqh,
 	struct m0_tl                  *mon_list;
 	struct m0_addb_monitoring_ctx *mon_ctx;
 	/* Continue scanning from the place we left last time */
-	struct m0_addb_monitor        *mon     = fom->pf_mon;
-	struct m0_stats_update_fop    *fop     =  NULL;
-	uint32_t                       fop_nr  =  0;
-	uint32_t                       used    = 0;
-	uint32_t                       scanned = 0;
-	uint32_t                       sent    = 0;
-	uint32_t                       result  = 0;
-	struct m0_addb_ctx            *cv[] = {&m0_addb_monitors_mod_ctx, NULL};
+	struct m0_addb_monitor        *mon       = fom->pf_mon;
+	struct m0_stats_update_fop    *fop       =  NULL;
+	uint32_t                       stats_nr  =  0;
+	uint32_t                       used      = 0;
+	uint32_t                       scanned   = 0;
+	uint32_t                       sent      = 0;
+	uint32_t                       result    = 0;
+	struct m0_addb_ctx            *cv[]      = {&m0_addb_monitors_mod_ctx,
+						    NULL};
 
 	M0_PRE(reqh != NULL);
 
@@ -513,7 +513,7 @@ M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh       *reqh,
 		mon = addb_mon_tlist_next(mon_list, mon);
 		if (sum == NULL || !sum->asr_dirty)
 			continue;
-		++fop_nr;
+		++stats_nr;
 		if (fop == NULL) {
 			M0_ALLOC_PTR(fop);
 			if (fop != NULL)
@@ -523,7 +523,7 @@ M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh       *reqh,
 		if (fop == NULL || fop->suf_stats.sf_stats == NULL ||
 		    data == NULL) {
 			result = -ENOMEM;
-			addb_mon_fop_free(fop, fop_nr);
+			addb_mon_fop_free(fop, stats_nr);
 			break;
 		}
 		rec = &fop->suf_stats.sf_stats[used++];
@@ -534,6 +534,7 @@ M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh       *reqh,
 		memcpy(rec->ss_data.au64s_data,
 		       sum->asr_rec.ss_data.au64s_data, SUM_SIZE(sum));
 		sum->asr_dirty = false;
+		m0_mutex_unlock(&sum->asr_mutex);
 		m0_mutex_unlock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
 		/**
 		 * Post summary record on global machine too.
@@ -542,21 +543,21 @@ M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh       *reqh,
 					   m0_addb_rec_type_lookup(rec->ss_id),
 					   cv, rec);
 		m0_mutex_lock(&reqh->rh_addb_monitoring_ctx.amc_mutex);
-		m0_mutex_unlock(&sum->asr_mutex);
 		if (used == BATCH) {
 			fop->suf_stats.sf_nr = BATCH;
-			result = addb_monitor_stats_fop_send(fop,
-						             mon_ctx->amc_stats_conn);
+			result =
+			addb_monitor_stats_fop_send(fop,
+					            mon_ctx->amc_stats_conn);
 			if (result != 0)
 				goto out;
-			used   = 0;
-			fop    = NULL;
-			fop_nr = 0;
+			used     = 0;
+			fop      = NULL;
+			stats_nr = 0;
 			++sent;
 		}
 	}
 	if (fop != NULL) {
-		fop->suf_stats.sf_nr = fop_nr;
+		fop->suf_stats.sf_nr = stats_nr;
 		result = addb_monitor_stats_fop_send(fop,
 					             mon_ctx->amc_stats_conn);
 		if (result != 0)
diff --git a/addb/addb_monitor.h b/addb/addb_monitor.h
index 4871874..b649d55 100644
--- a/addb/addb_monitor.h
+++ b/addb/addb_monitor.h
@@ -107,8 +107,8 @@
 	should be maintained while defining the structure).
 
 	// 4. Define monitor operation amo_sum_rec
-	struct m0_addb_sum_rec *xyz_amo_sum_rec(const struct m0_addb_monitor *mon,
-					       struct m0_reqh             *reqh)
+	struct m0_addb_sum_rec *xyz_amo_sum_rec(const struct m0_addb_monitor *m,
+					       struct m0_reqh             *rqh)
 	{
 		struct m0_addb_sum_rec *sum_rec;
 
@@ -182,8 +182,8 @@
 		//1. Delete monitor from reqh's list of monitors for this node.
 		//2. Remove (lockers_clear)  monitor specific data from reqh's
 		//   locker data structure (obviously do lockers_get before this
-		//   to get the pointer to m0_addb_sum_rec structure for following
-		//   steps, NOTE: shown in below code snippet).
+		//   to get the pointer to m0_addb_sum_rec structure for
+		//   following steps, NOTE: shown in below code snippet).
 		//3. Finalize summary record (m0_addb_sum_rec).
 		//4. Free summary record (m0_addb_sum_rec).
 		//5. Finalize monitor.
@@ -192,7 +192,7 @@
 
 		struct m0_addb_sum_rec *rec =
 			&xyz_module_var.xms_mon->am_ops->amo_sum_rec(reqh,
-								     xyz_module_var.xms_mon);
+							xyz_module_var.xms_mon);
 		M0_PRE(rec != NULL);
 
 		m0_addb_monitor_del(&xyz_module_var.xms_mon);
@@ -214,7 +214,7 @@ struct addb_post_fom;
 
 enum {
 	ADDB_STATS_MAX_RPCS_IN_FLIGHT = 1,
-	ADDB_STATS_MAX_RPC_SLOTS_NR = 1
+	ADDB_STATS_MAX_RPC_SLOTS_NR   = 1
 };
 
 M0_TL_DESCR_DECLARE(addb_mon, M0_EXTERN);
@@ -357,9 +357,9 @@ M0_INTERNAL int m0_addb_monitor_summaries_post(struct m0_reqh       *reqh,
  * @param conn rpc connection object of stats service
  * @param ep stats service endpoint
  */
-M0_INTERNAL void m0_addb_conf_process(struct m0_reqh *reqh,
-				      struct m0_rpc_conn *conn,
-				      const char *ep);
+M0_INTERNAL void m0_addb_monitor_setup(struct m0_reqh     *reqh,
+				       struct m0_rpc_conn *conn,
+				       const char         *ep);
 
 /**
  * Macro to post ADDB monitor stats summary records as ADDB records
diff --git a/m0t1fs/linux_kernel/super.c b/m0t1fs/linux_kernel/super.c
index 982a5dd..31b8a82 100644
--- a/m0t1fs/linux_kernel/super.c
+++ b/m0t1fs/linux_kernel/super.c
@@ -36,6 +36,7 @@
 #include "conf/confc.h"    /* m0_confc */
 #include "rpc/rpclib.h"    /* m0_rcp_client_connect */
 #include "addb/addb.h"
+#include "rpc/rpc_internal.h"
 
 static int m0t1fs_layout_build(const uint64_t         layout_id,
 			       const uint32_t         N,
@@ -506,9 +507,6 @@ static int connect_to_service(const char *addr, enum m0_conf_service_type type,
 				   M0T1FS_MAX_NR_RPC_IN_FLIGHT,
 				   M0T1FS_NR_SLOTS_PER_SESSION);
 	if (rc == 0) {
-		if (type == M0_CST_SS)
-			m0_addb_conf_process(&m0t1fs_globals.g_reqh,
-					     &ctx->sc_conn, addr);
 		svc_ctx_tlist_add_tail(&csb->csb_service_contexts, ctx);
 		M0_CNT_INC(csb->csb_nr_active_contexts);
 		M0_LOG(M0_INFO, "Connected to service `%s'. %d active contexts",
@@ -555,7 +553,6 @@ static int connect_to_services(struct m0t1fs_sb *csb, struct m0_conf_obj *fs,
 	int                 rc;
 	bool                mds_is_provided       = false;
 	bool                dlm_is_provided       = false;
-	bool                stats_svc_is_provided = false;
 
 	M0_ENTRY();
 	M0_PRE(svc_ctx_tlist_is_empty(&csb->csb_service_contexts));
@@ -577,38 +574,21 @@ static int connect_to_services(struct m0t1fs_sb *csb, struct m0_conf_obj *fs,
 			dlm_is_provided = true;
 		else if (svc->cs_type == M0_CST_IOS)
 			++*nr_ios;
-		else if (svc->cs_type == M0_CST_SS)
-			stats_svc_is_provided = true;
 
 		for (pstr = svc->cs_endpoints; *pstr != NULL; ++pstr) {
 			M0_LOG(M0_DEBUG, "svc type=%d, ep=%s",
 			       svc->cs_type, *pstr);
 			rc = connect_to_service(*pstr, svc->cs_type, csb);
-			if (rc != 0) {
-				if (svc->cs_type == M0_CST_SS) {
-					/** @todo: User ADDB here */
-					M0_LOG(M0_WARN,
-					       "Stats service conn failed");
-					/**
-					 * If stats service is the last entry,
-					 * then we want to return success & log
-					 * the error
-					 */
-					rc = 0;
-					continue;
-				}
-				else
-					goto out;
-			}
+			if (rc != 0)
+				goto out;
 		}
 	}
 out:
 	m0_confc_close(entry);
 	m0_confc_close(dir);
 
-	if (rc == 0 && mds_is_provided && dlm_is_provided &&
-	    stats_svc_is_provided && *nr_ios > 0)
-		M0_LOG(M0_DEBUG, "Connected to SS, IOS, MDS and RMS");
+	if (rc == 0 && mds_is_provided && dlm_is_provided && *nr_ios > 0)
+		M0_LOG(M0_DEBUG, "Connected to IOS, MDS and RMS");
 	else {
 		M0_LOG(M0_FATAL, "Error connecting to the services. "
 		       "(Please check whether IOS, MDS and RMS are provided)");
@@ -968,11 +948,15 @@ static void m0t1fs_sb_layout_fini(struct m0t1fs_sb *csb)
 
 static int m0t1fs_setup(struct m0t1fs_sb *csb, const struct mount_opts *mops)
 {
-	struct m0_confc     confc;
-	struct m0_conf_obj *fs;
-	uint32_t            nr_ios;
-	int                 rc;
-	struct fs_params    fs_params = {0};
+	struct m0t1fs_service_context *ctx;
+	struct m0_confc                confc;
+	struct m0_conf_obj            *fs;
+	struct m0_reqh                *reqh = &m0t1fs_globals.g_reqh;
+	const char                    *ep_addr;
+	uint32_t                       nr_ios = 0;
+	int                            rc;
+	struct fs_params               fs_params = {0};
+	bool                           stats_svc_is_provided = false;
 
 	M0_ENTRY();
 	M0_PRE(csb->csb_astthread.t_state == TS_RUNNING);
@@ -993,6 +977,19 @@ static int m0t1fs_setup(struct m0t1fs_sb *csb, const struct mount_opts *mops)
 	rc = fs_params_parse(&fs_params,
 			     M0_CONF_CAST(fs, m0_conf_filesystem)->cf_params) ?:
 		connect_to_services(csb, fs, &nr_ios);
+
+	m0_tl_for(svc_ctx, &csb->csb_service_contexts, ctx) {
+		if (ctx->sc_type == M0_CST_SS) {
+			stats_svc_is_provided = true;
+			break;
+		}
+	} m0_tlist_endfor;
+	if (stats_svc_is_provided) {
+		ep_addr = ctx->sc_conn.c_rpcchan->rc_destep->nep_addr;
+		m0_addb_monitor_setup(reqh, &ctx->sc_conn, ep_addr);
+		M0_LOG(M0_DEBUG, "Stats service connected");
+	} else
+		M0_LOG(M0_WARN, "Stats service ep not specified");
 	m0_confc_close(fs);
 	if (rc != 0)
 		goto end;
diff --git a/mero/conf.c b/mero/conf.c
index 8bd0734..cf0d1dd 100644
--- a/mero/conf.c
+++ b/mero/conf.c
@@ -62,7 +62,7 @@ static const char *service_name[] = {
 	[M0_CST_IOS] = "ioservice",  /* IO/data service. */
 	[M0_CST_MGS] = "confd",      /* Management service (confd). */
 	[M0_CST_DLM] = "dlm",        /* DLM service. */
-	[M0_CST_SS]  = "stats"       /* @todo replace with symbolic const used by stats service */
+	[M0_CST_SS]  = "stats"       /* Stats service */
 };
 
 static char *service_name_dup(const struct m0_conf_service *svc)
diff --git a/stats/stats_srv.c b/stats/stats_srv.c
index 6095cbd..2a1c692 100644
--- a/stats/stats_srv.c
+++ b/stats/stats_srv.c
@@ -610,7 +610,8 @@ static int read_stats(struct m0_fom *fom)
 	for (i = 0; i < qfop->sqf_ids.au64s_nr; ++i) {
 		struct m0_addb_uint64_seq *sum_data;
 		struct m0_stats           *stats_obj =
-			m0_stats_get(&svc->ss_stats, qfop->sqf_ids.au64s_data[i]);
+			m0_stats_get(&svc->ss_stats,
+				     qfop->sqf_ids.au64s_data[i]);
 
 		/* Continue getting stats for next id */
 		if (stats_obj == NULL) {
-- 
1.8.3.2

