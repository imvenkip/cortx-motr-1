From b44704fcb14368af1335bb6f1fc6310dae61be4b Mon Sep 17 00:00:00 2001
From: Rajanikant Chirmade <rajanikant_chirmade@xyratex.com>
Date: Mon, 18 Nov 2013 14:19:28 +0530
Subject: [PATCH 150/159]  - Fixed some of review commets.

---
 fop/fom.c               | 17 +++++++++--------
 fop/fom.h               |  9 ++++-----
 stats/util/stats_util.c |  6 ++++--
 3 files changed, 17 insertions(+), 15 deletions(-)

diff --git a/fop/fom.c b/fop/fom.c
index fa5f254..22bfc98 100644
--- a/fop/fom.c
+++ b/fop/fom.c
@@ -187,7 +187,7 @@ static struct m0_fom_domain_ops m0_fom_dom_ops = {
 };
 
 static struct fop_rate_stats_sum_rec {
-	uint64_t frssr_fop_rate;
+	uint64_t ssr_fop_rate;
 } fop_rate_stats_sum;
 
 static struct m0_addb_sum_rec *
@@ -220,10 +220,10 @@ static void fop_rate_monitor_watch(const struct m0_addb_monitor *monitor,
 
 	M0_PRE(reqh != NULL);
 
-	if (m0_addb_rec_rid_to_id(rec->ar_rid) == M0_ADDB_RECID_FOP_RATE_CNTR) {
-		m0_rwlock_read_lock(&reqh->rh_rwlock);
-		sum_rec = m0_reqh_lockers_get(reqh, FOM_RATE_KEY(reqh));
-		m0_rwlock_read_unlock(&reqh->rh_rwlock);
+	if (m0_addb_rec_rid_make(M0_ADDB_BRT_CNTR,
+			         M0_ADDB_RECID_FOP_RATE_CNTR) == rec->ar_rid) {
+
+		sum_rec = monitor->am_ops->amo_sum_rec(monitor, reqh);
 		M0_ASSERT(sum_rec != NULL);
 
 		m0_mutex_lock(&sum_rec->asr_mutex);
@@ -236,7 +236,7 @@ static void fop_rate_monitor_watch(const struct m0_addb_monitor *monitor,
 		 * rec->ar_data.au64s_data[1] is number of samples
 		 * rec->ar_data.au64s_data[2] is sum_samples
 		 */
-		f_rate->frssr_fop_rate =
+		f_rate->ssr_fop_rate =
 		rec->ar_data.au64s_data[2] / rec->ar_data.au64s_data[1];
 		sum_rec->asr_dirty = true;
 		m0_mutex_unlock(&sum_rec->asr_mutex);
@@ -668,8 +668,7 @@ static void fom_exec(struct m0_fom *fom)
 		 * Don't touch the fom after this point.
 		 */
 		++loc->fl_fop_rate_count;
-		if (now >= loc->fl_fop_rate_next_update ||
-		    loc->fl_fop_rate_next_update == 0) {
+		if (now >= loc->fl_fop_rate_next_update) {
 			m0_addb_counter_update(&loc->fl_stat_fop_rate,
 					       loc->fl_fop_rate_count);
 			loc->fl_fop_rate_next_update =
@@ -937,6 +936,7 @@ static int loc_init(struct m0_fom_locality *loc, size_t cpu, size_t cpu_max)
 	if (result != 0)
 		goto err2;
 
+	loc->fl_fop_rate_next_update = 0;
 	result = m0_addb_counter_init(&loc->fl_stat_fop_rate,
 				      &m0_addb_rt_fop_rate_cntr);
 	if (result != 0)
@@ -1554,6 +1554,7 @@ M0_INTERNAL int m0_fom_fol_rec_add(struct m0_fom *fom)
 }
 
 /** @} endgroup fom */
+#undef FOM_RATE_KEY
 /*
  *  Local variables:
  *  c-indentation-style: "K&R"
diff --git a/fop/fom.h b/fop/fom.h
index ddfbf16..a422ee3 100644
--- a/fop/fom.h
+++ b/fop/fom.h
@@ -260,10 +260,6 @@ struct m0_fom_locality {
 	 */
 	unsigned                     fl_foms;
 
-	/** fop rate stats */
-	uint64_t                     fl_fop_rate_count;
-	m0_time_t		     fl_fop_rate_next_update;
-
 	/** State Machine (SM) group for AST call-backs */
 	struct m0_sm_group	     fl_group;
 
@@ -300,7 +296,10 @@ struct m0_fom_locality {
 	   fom_dequeue() counting by m0_fom::fo_sched_epoch.
 	 */
 	struct m0_addb_counter       fl_stat_sched_wait_times;
-	/** FOP rate conter. It is fop execution per sec. */
+
+	/** FOP rate counter. It is fop executed per sec. */
+	uint64_t                     fl_fop_rate_count;
+	m0_time_t		     fl_fop_rate_next_update;
 	struct m0_addb_counter       fl_stat_fop_rate;
 
 	/** AST which triggers the posting of statistics */
diff --git a/stats/util/stats_util.c b/stats/util/stats_util.c
index 0663cb7..f47915d 100644
--- a/stats/util/stats_util.c
+++ b/stats/util/stats_util.c
@@ -191,9 +191,11 @@ static void stats_print_values(FILE *out,
 		if (rt == NULL)
 			continue;
 
-		/* @todo Summary record fields mismatch. Skip OR error ? */
-		if (stats_recs->sf_stats[i].ss_data.au64s_nr != rt->art_rf_nr)
+		if (stats_recs->sf_stats[i].ss_data.au64s_nr != rt->art_rf_nr) {
+			fprintf(stderr, "%s stats fields mismatch.\n",
+				rt->art_name);
 			continue;
+		}
 
 		for (j = 0; j < stats_recs->sf_stats[i].ss_data.au64s_nr; ++j)
 			fprintf(out, "%*lu",
-- 
1.8.3.2

