From 54ebcacbfa206f2512a5f80c02e8af5893110b89 Mon Sep 17 00:00:00 2001
From: Rajanikant Chirmade <rajanikant_chirmade@xyratex.com>
Date: Thu, 4 Jul 2013 15:17:02 +0530
Subject: [PATCH 059/159] Stats Service DLD - moved files to stats directory. -
 defined stats fop - defined stats fom phases

---
 addb/stats_srv.c       | 412 ------------------------
 addb/stats_srv.h       | 159 ---------
 stats/stats_fops.h     |   1 +
 stats/stats_srv.c      | 852 -------------------------------------------------
 stats/stats_srv.c~HEAD | 852 +++++++++++++++++++++++++++++++++++++++++++++++++
 stats/stats_srv.h      | 156 ---------
 stats/stats_srv.h~HEAD | 156 +++++++++
 7 files changed, 1009 insertions(+), 1579 deletions(-)
 delete mode 100644 addb/stats_srv.c
 delete mode 100644 addb/stats_srv.h
 delete mode 100644 stats/stats_srv.c
 create mode 100644 stats/stats_srv.c~HEAD
 delete mode 100644 stats/stats_srv.h
 create mode 100644 stats/stats_srv.h~HEAD

diff --git a/addb/stats_srv.c b/addb/stats_srv.c
deleted file mode 100644
index 6f6639b..0000000
--- a/addb/stats_srv.c
+++ /dev/null
@@ -1,412 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Rajanikant Chirmade <rajanikant_chirmade@xyratex.com>
- * Original creation date: 06/14/2013
- */
-
-/**
-   @page DLD-stats-svc  Stats Service
-
-   - @ref DLD-stats-svc-ovw
-   - @ref DLD-stats-svc-def
-   - @ref DLD-stats-svc-req
-   - @subpage DLD-stats-svc-fspecs
-   - @ref DLD-stats-svc-lspecs
-      - @ref DLD-stats-svc-lspecs-stats_list
-      - @ref DLD-stats-svc-lspec-state
-      - @ref DLD-stats-svc-lspec-thread
-      - @ref DLD-stats-svc-lspec-service-registration
-      - @ref DLD-stats-svc-lspec-numa
-      - @ref DLD-stats-svc-lspec-depends
-      - @ref DLD-stats-svc-lspec-conformance
-   - @ref DLD-stats-svc-ut
-   - @ref DLD-stats-svc-it
-   - @ref DLD-stats-svc-st
-   - @ref DLD-stats-svc-O
-   - @ref DLD-stats-svc-ref
-
-   <hr>
-   @section DLD-stats-svc-ovw Overview
-   This design related to stats service. Stats service provides the follwoing
-   functionality:
-   - Updates of in-memory stats objects on requests from mero nodes
-   - Provides stats information from in-memroy stats objects to cluster
-     administrations utilities/console on their query.
-
-   <hr>
-   @section DLD-stats-svc-def Definitions
-   - <b>Stats Service</b> Stats service which processes mero statistics
-     update/query requests.
-   - <b>Stats Object</b> Stats in-memory object which represents a statitics
-     matrix.
-   - <b>Stats Update</b> Stats update request which updates Stats object values.
-   - <b>Stats Query</b> Stats query request which returns latest updated
-     stats objects values.
-
-   <hr>
-   @section DLD-stats-svc-req Requirements
-   - <b>r.stats_service.in_memory_objects</b> Maintains in-memory statistic
-     objects up to date from stats update got from mero nodes.
-   - <b>r.stats_service.update</b> It updates Stats Objects values.
-   - <b>r.stats_service.query</b> It returns Stats Object values to mero
-      monitoring console, utilities etc.
-
-   <hr>
-   @section DLD-stats-svc-lspecs Logical Specification
-
-   @subsection DLD-stats-svc-lspecs-stats_list Stats Object List
-   In memory stats object list does not contains any object initially. When the
-   first update request comes for respective stats, stats update FOM creates it
-   update its stats values. If stats object already allocated stats update FOM
-   update respective object direcly.
-
-   @subsection DLD-stats-svc-lspec-state State Transitions
-   State diagram for stats_update FOM:
-   @dot
-   digraph {
-	size = "5,10"
-	node [shape=record, fontsize=10]
-	S0 [label="Init Update FOM"]
-        S1 [label="Create stats object"]
-	S2 [label="Update Stats object"]
-	S3 [label="Finliase FOM"]
-	S0 -> S1 [label="FOM initialised"]
-	S0 -> S2 [label="Stats object found"]
-	S1 -> S2 [label="Stats object created"]
-	S2 -> S3 [label="Stats object updated"]
-   }
-   @enddot
-
-   State diagram for stats_query FOM:
-   @dot
-   digraph {
-	size = "5,10"
-	node [shape=record, fontsize=10]
-	S0 [label="Init Query FOM"]
-	S1 [label="Read stats object and set reply FOP"]
-	S2 [label="Finliase FOM"]
-	S0 -> S1 [label="FOM initialised"]
-	S1 -> S2 [label="Stats object read"]
-   }
-   @enddot
-
-   @subsection DLD-stats-svc-lspec-thread Threading and Concurrency Model
-   Since stats service runs by request handler and all stats service FOMs
-   locality is same, all the stats services requests (updates/query) executes
-   by same thread. All stats service operation executes serially.
-
-   @subsection DLD-stats-svc-lspec-service-registration Service Registration
-   Stats service type defination :
-
-   M0_REQH_SERVICE_TYPE_DEFINE(m0_stats_svc_type, &stats_service_type_ops,
-                            M0_STATS_SVC_NAME, &m0_addb_ct_stats_service);
-
-   Stats service type registration/unregistration :
-
-   Stats service registers/unregistrs its service type with request handler
-   using interfaces m0_stats_svc_register()/ m0_stats_svc_unregister() during
-   Mero system initialization and finalization (m0_init()/ m0_fini()).
-
-   @subsection DLD-stats-svc-lspec-numa NUMA optimizations
-   Update FOM and query FOM puts in same locality thread.
-
-   @subsection DLD-stats-svc-lspec-depends Dependencies
-   - <b>r.reqh</b> : Request handler to execute stats service FOMs.
-   - <b>r.addb</b> : ADDB subsystem is the dependancy for stats service since
-     these stats object are in the form of ADDB records. And ADDB subsystem
-     required to recognise that objects.
-
-   @subsection DLD-stats-svc-lspec-conformance Conformance
-   - <b>i.stats_service.in_memory_objects</b> It implements list of ADDB records
-     to keep stats run time.
-   - <b>i.stats_service.update</b> It implements stats_update FOM.
-   - <b>i.stats_service.query</b> It implements stats_query FOM.
-
-   <hr>
-   @section DLD-stats-svc-ut Unit Tests
-   -# Test stats update with single stats parameter
-   -# Test stats update with multiple stats parameters
-   -# Test stats query with single stats parameter
-   -# Test stats query with multiple stats parameters
-
-   <hr>
-   @section DLD-stats-svc-it Integration Test
-   Mero nodes sends stats (differnet 2-3 type stats) to stats service,
-   verification of stats sent by Mero node with respective stats object.
-
-   <hr>
-   @section DLD-stats-svc-st System Test
-   This tests whole monitoring infrastructure by running some sample IOs on
-   on Mero and verify statistics collected by querying statistic service using
-   client/monitoring utility.
-
-   <hr>
-   @section DLD-stats-svc-O Analysis
-   - Keeping stats info as ADDB record provide generic way to for all types
-     of stats objects. It also helpful to send it over network.
-
-   <hr>
-   @section DLD-stats-svc-ref References
-   - <a href="https://docs.google.com/a/xyratex.com/document/d/
-14uPeE0mNkRu3oF32Ys_EnpvSZtGWbf8hviPHTBTOXso/edit">
-   HLD of ADDB Monitoring</a>
-   - <a href="https://docs.google.com/a/xyratex.com/document/d/
-1lBgPht18RYX7s9XL-FcfUBKZ0zvo6JzqAEsXpTWs_4Q/edit">
-   Mero Stats Service</a>
- */
-
-M0_TL_DESCR_DEFINE(stats, "statistic objects", M0_INTERNAL, struct m0_stats,
-		   s_linkage, s_magic, M0_STATS_MAGIC, M0_STATS_HEAD_MAGIC);
-M0_TL_DEFINE(stats, M0_INTERNAL, struct m0_stats);
-
-static const struct m0_bob_type stats_svc_bob = {
-	.bt_name         = "stats svc",
-	.bt_magix_offset = M0_MAGIX_OFFSET(struct stats_svc, ss_magic),
-	.bt_magix        = M0_STATS_SVC_MAGIC,
-	.bt_check        = NULL
-};
-
-M0_BOB_DEFINE(static, &stats_svc_bob, stats_svc);
-
-/**
- * List of statistic objects.
- * Initially this list not contains any stats. As stats_update request recieved
- * stats_update FOM creates new entry for respetive stats otherwise update
- * existing stats object.
- */
-static struct m0_tl stats_list;
-
-/*
- * Stats Service
- */
-
-/**
- * The rso_start methos to start Stats service.
- */
-static int stats_svc_rso_start(struct m0_reqh_service *service)
-{
-	M0_PRE(service != NULL);
-
-	return 0;
-}
-
-/**
- * The rso_stop method to stop Stats service.
- */
-static int stats_svc_rso_stop(struct m0_reqh_service *service)
-{
-	M0_PRE(service != NULL);
-
-	return 0;
-}
-
-/**
- * The rso_fini method to finalize the Stats service.
- */
-static void stats_svc_rso_fini(struct m0_reqh_service *service)
-{
-	M0_PRE(service != NULL);
-}
-
-static const struct m0_reqh_service_ops stats_svc_ops = {
-	.rso_start = stats_svc_rso_start,
-	.rso_stop  = stats_svc_rso_stop,
-	.rso_fini  = stats_svc_rso_fini
-};
-
-/*
- * Stats Service Type
- */
-
-static int stats_svc_rsto_service_allocate(struct m0_reqh_service      **srv,
-					   struct m0_reqh_service_type   stype,
-					   struct m0_reqh_context       *rctx)
-{
-}
-
-static struct m0_reqh_service_type_ops stats_service_type_ops = {
-	.rsto_service_allocate = stats_svc_rsto_service_allocate,
-};
-
-M0_REQH_SERVICE_TYPE_DEFINE(m0_stats_svc_type, &stats_service_type_ops,
-			    M0_STATS_SVC_NAME, &m0_addb_ct_stats_svc);
-
-/*
- * Public interfaces
- */
-
-/**
- * It register Stats service.
- */
-M0_INTERNAL int m0_stats_svc_register(void)
-{
-	return m0_reqh_service_type_register(&m0_stats_svc_type);
-}
-
-/**
- * Deregister Stats service
- */
-M0_INTERNAL int m0_stats_svc_unregister(void)
-{
-	m0_reqh_service_type_unregister(&m0_stats_svc_type);
-
-	return 0;
-}
-
-/*
- * Stats Update FOM.
- */
-
-/**
- * Create and initiate stats update FOM.
- */
-static int stats_update_fom_create(struct m0_fop  *fop, struct m0_fom **out,
-				   struct m0_reqh *reqh)
-{
-	M0_PRE(fop != NULL);
-	M0_PRE(out != NULL);
-
-	return 0;
-}
-
-/**
- * State transition function for stats update FOM.
- */
-static int stats_update_fom_tick(struct m0_fom *fom)
-{
-	M0_PRE(fom != NULL);
-
-	return 0;
-}
-
-/**
- * Finalize stats update FOM.
- */
-static void stats_update_fom_fini(struct m0_fom *fom)
-{
-	M0_PRE(fom != NULL);
-}
-
-/**
- * Get stats update FOM locality.
- */
-static size_t stats_update_fom_home_locality(const struct m0_fom *fom)
-{
-	return 1; /* all stats update FOM run in same locality */
-}
-
-/**
- * Initialize addb context of stats update FOM.
- */
-static void stats_update_fom_addb_init(struct m0_fom     *fom,
-				       struct m0_addb_mc *mc)
-{
-}
-
-/**
- * Stats update FOM operation vector.
- */
-static const struct m0_fom_ops stats_update_fom_ops = {
-	.fo_tick          = stats_update_fom_tick,
-	.fo_home_locality = stats_update_fom_home_locality,
-	.fo_addb_init     = stats_update_fom_addb_init,
-	.fo_fini          = stats_update_fom_fini
-};
-
-/**
- * Stats update FOP type operation vector.
- */
-const struct m0_fom_type_ops stats_update_fom_type_ops {
-	.fto_create = stats_update_fom_create,
-};
-
-/*
- * Stats Query FOM
- */
-
-/**
- * Create and initiate stats query FOM.
- */
-static int stats_query_fom_create(struct m0_fop  *fop, struct m0_fom **out,
-				  struct m0_reqh *reqh)
-{
-	M0_PRE(fop != NULL);
-	M0_PRE(out != NULL);
-
-	return 0;
-}
-
-/**
- * State transition function for stats query FOM.
- */
-static int stats_query_fom_tick(struct m0_fom *fom)
-{
-	M0_PRE(fom != NULL);
-
-	return 0;
-}
-
-/**
- * Finalize stats query FOM.
- */
-static void stats_query_fom_fini(struct m0_fom *fom)
-{
-	M0_PRE(fom != NULL);
-}
-
-/**
- * Get stats query FOM locality.
- */
-static size_t stats_query_fom_home_locality(const struct m0_fom *fom)
-{
-	return 1; /* all stats query FOM run in same locality */
-}
-
-/**
- * Initialize addb context of stats query FOM.
- */
-static void stats_query_fom_addb_init(struct m0_fom     *fom,
-				      struct m0_addb_mc *mc)
-{
-}
-
-/**
- * Stats update FOM operation vector.
- */
-static const struct m0_fom_ops stats_query_fom_ops = {
-	.fo_tick          = stats_query_fom_tick,
-	.fo_home_locality = stats_query_fom_home_locality,
-	.fo_addb_init     = stats_query_fom_addb_init,
-	.fo_fini          = stats_query_fom_fini
-};
-
-/**
- * Stats update FOP type operation vector.
- */
-const struct m0_fom_type_ops stats_query_fom_type_ops {
-	.fto_create = stats_query_fom_create,
-};
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/addb/stats_srv.h b/addb/stats_srv.h
deleted file mode 100644
index 9a755ee..0000000
--- a/addb/stats_srv.h
+++ /dev/null
@@ -1,159 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Rajanikant Chirmade <rajanikant_chirmade@xyratex.com>
- * Original creation date: 06/14/2013
- */
-
-#pragma once
-
-#ifndef __MERO_ADDB_STATS_SVC_H__
-#define __MERO_ADDB_STATS_SVC_H__
-#ifndef __KERNEL__
-
-#include "reqh/reqh.h"
-#include "reqh/reqh_service.h"
-
-/**
-   @page DLD-stats-svc-fspecs Functional Specification
-
-   - @ref DLD-stats-svc-fspecs-ds
-   - @ref DLD-stats-svc-fspecs-int-if
-   - @ref DLD-stats-svc-fspecs-ext-if
-
-   <hr>
-   @section DLD-stats-svc-fspecs-ds Data Structures
-   - m0_mon_stats
-   - stats_svc
-   - stats_list
-   - stats_update_fom
-   - stats_query_fom
-
-   @section DLD-stats-svc-fspecs-int-if Internal Interfaces
-   - stats_svc_rso_start()
-   - stats_svc_rso_stop()
-   - stats_svc_rso_fini()
-   - stats_svc_rsto_service_allocate()
-
-   - stats_update_fom_create()
-   - stats_update_fom_tick()
-   - stats_update_fom_home_locality()
-   - stats_update_fom_addb_init()
-   - stats_update_fom_fini()
-
-   - stats_query_fom_create()
-   - stats_query_fom_tick()
-   - stats_query_fom_home_locality()
-   - stats_query_fom_addb_init()
-   - stats_query_fom_fini()
-
-   @section DLD-stats-svc-fspecs-ext-if External Interfaces
-   - m0_stats_svc_register()
-   - m0_stats_svc_unregister()
-*/
-
-/**
- * @defgroup stats_svc Stats Service
- * @{
- */
-#define M0_STATS_SVC_NAME "stats"
-extern struct m0_reqh_service_type m0_stats_svc_type;
-
-/**
- * @todo Need to define stuffs which can be removed on stats fops code merge.
- *       Mero nodes sends sequence of m0_addb_stats_sum.
- */
-struct m0_addb_stats_sum_data {
-	uint64_t  ssd_nr;
-	uint64_t *ssd_fields;
-} M0_XCA_SEQUENCE;
-
-struct m0_addb_stats_sum {
-	/** stats id */
-	uint64_t		      ss_id;
-	struct m0_addb_stats_sum_data ss_data;
-} M0_XCA_RECORD;
-
-struct m0_addb_stats_fop {
-	uint64_t		  sf_nr;
-	struct m0_addb_stats_sum *sf_stats;
-} M0_XCA_SEQUENCE;
-/** stuff ends */
-
-/**
- * In-memory representation of Statistic information
- * @todo This should goto mon.h
- */
-struct m0_stats {
-	uint64_t		  s_magic;
-	/** stats name (instead can put uint64_t stats_id ???) */
-	char			 *s_name;
-	/** Linkage to global stats objects */
-	struct m0_tlink		 *s_linkage;
-	/** ADDB records which represent statitics */
-	struct m0_addb_stats_sum *s_data;
-};
-
-/**
- * Stats request handler service.
- */
-struct stats_svc {
-	uint64_t	       ss_magic;
-	/** List of m0_stats in-momory objects */
-	struct m0_tl           ss_stats;
-	/** Embedded request handler service object. */
-	struct m0_reqh_service ss_reqhs;
-};
-
-/**
- * Stats update request FOM
- */
-struct stats_update_fom {
-	uint64_t      suf_magic;
-	struct m0_fom suf_fom;
-};
-
-/**
- * Stats query FOM
- */
-struct stats_query_fom {
-	uint64_t      sqf_magic;
-	struct m0_fom sqf_fom;
-};
-
-/**
- * Registers stats service.
- */
-M0_INTERNAL int m0_stats_svc_register(void);
-
-/**
- * Un-registers stats service.
- */
-M0_INTERNAL int m0_stats_svc_unregister(void);
-
-/** @} end group stats_service */
-
-#endif /* __KERNEL__ */
-#endif /* __MERO_ADDB_STATS_SVC_H_ */
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/stats/stats_fops.h b/stats/stats_fops.h
index 303db74..3888798 100644
--- a/stats/stats_fops.h
+++ b/stats/stats_fops.h
@@ -28,6 +28,7 @@
 #include "addb/addb.h"
 #include "addb/addb_wire.h"
 #include "addb/addb_wire_xc.h"
+
 /**
  * @defgroup stats_fop Stats FOP
  * @{
diff --git a/stats/stats_srv.c b/stats/stats_srv.c
deleted file mode 100644
index 806ce58..0000000
--- a/stats/stats_srv.c
+++ /dev/null
@@ -1,852 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Rajanikant Chirmade <rajanikant_chirmade@xyratex.com>
- * Original creation date: 06/14/2013
- */
-
-/**
-   @page DLD-stats-svc  Stats Service
-
-   - @ref DLD-stats-svc-ovw
-   - @ref DLD-stats-svc-def
-   - @ref DLD-stats-svc-req
-   - @subpage DLD-stats-svc-fspecs
-   - @ref DLD-stats-svc-lspecs
-      - @ref DLD-stats-svc-lspecs-stats_list
-      - @ref DLD-stats-svc-lspec-state
-      - @ref DLD-stats-svc-lspec-thread
-      - @ref DLD-stats-svc-lspec-service-registration
-      - @ref DLD-stats-svc-lspec-numa
-      - @ref DLD-stats-svc-lspec-depends
-      - @ref DLD-stats-svc-lspec-conformance
-   - @ref DLD-stats-svc-ut
-   - @ref DLD-stats-svc-it
-   - @ref DLD-stats-svc-st
-   - @ref DLD-stats-svc-O
-   - @ref DLD-stats-svc-ref
-
-   <hr>
-   @section DLD-stats-svc-ovw Overview
-   Stats service provides the following functionality:
-   - Updates of in-memory stats objects on requests from mero nodes
-   - Provides stats information from in-memory stats objects to cluster
-     administrative utilities/console on their query.
-
-   <hr>
-   @section DLD-stats-svc-def Definitions
-   - <b>Stats Service</b> Stats service which processes mero statistics
-     update/query requests.
-   - <b>Stats Object</b> Stats in-memory object which represents a statistics
-     matrix.
-   - <b>Stats Update</b> Stats update request which updates stats object values.
-   - <b>Stats Query</b> Stats query request which returns latest updated
-     stats objects value.
-   - <b>Stats Clients</b> Mero administrative console/utilities.
-
-   <hr>
-   @section DLD-stats-svc-req Requirements
-   - <b>r.stats_service.in_memory_objects</b> Maintains in-memory statistic
-     objects. It is list of stats object.
-   - <b>r.stats_service.update</b> It updates requested stats object values.
-   - <b>r.stats_service.query</b> It returns requested stats object values to
-     stats clients.
-
-   <hr>
-   @section DLD-stats-svc-lspecs Logical Specification
-
-   @subsection DLD-stats-svc-lspecs-stats_list Stats Object List
-   In memory stats object list does not contain any object initially. Stats
-   FOM update respective stats object. object is created if not found in
-   stats list.
-
-   @subsection DLD-stats-svc-lspec-state State Transitions
-   State diagram for stats_update FOM:
-   @dot
-   digraph {
-	size = "5,10"
-	node [shape=record, fontsize=10]
-	S0 [label="Init Update FOM"]
-	S1 [label="Update Stats object"]
-	S2 [label="Finalise FOM"]
-	S0 -> S1 [label="Stats Update fom initiaized"]
-	S1 -> S2 [label="Stats object updated"]
-   }
-   @enddot
-
-   State diagram for stats_query FOM:
-   @dot
-   digraph {
-	size = "5,10"
-	node [shape=record, fontsize=10]
-	S0 [label="Init Query FOM"]
-	S1 [label="Read stats objects and set reply FOP"]
-	S2 [label="Finalise FOM"]
-	S0 -> S1 [label="Stats object found"]
-	S1 -> S2 [label="Set reply FOP"]
-   }
-   @enddot
-
-   @subsection DLD-stats-svc-lspec-thread Threading and Concurrency Model
-   Stats service FOMs(updates/query) are executed by request handler's
-   locality thread. Since same locality is assigned to all these FOMs, no
-   other serialization is required for stats service.
-
-   @subsection DLD-stats-svc-lspec-service-registration Service Registration
-   Stats service type definition :
-
-   M0_REQH_SERVICE_TYPE_DEFINE(m0_stats_svc_type, &stats_service_type_ops,
-                            M0_STATS_SVC_NAME, &m0_addb_ct_stats_service);
-
-   Stats service type initialization/finalization :
-
-   Stats service registers/unregisters its service type with request handler
-   using interfaces m0_stats_svc_init()/ m0_stats_svc_fini() during
-   Mero system initialization and finalization (m0_init()/ m0_fini()).
-
-   @subsection DLD-stats-svc-lspec-numa NUMA optimizations
-   Update FOMs and query FOMs are executed in the same locality. Update/Query
-   FOMs access in-memory list of statistic objects. Since both type of FOMs
-   executed by same localiy threads it gets benifis of locality.
-
-   @subsection DLD-stats-svc-lspec-depends Dependencies
-   - <b>r.reqh</b> : Request handler's locality thread execute stats service
-   FOMs(update/query).
-
-   @subsection DLD-stats-svc-lspec-conformance Conformance
-   - <b>i.stats_service.in_memory_objects</b> It implements list of stats
-     object to keep stats run time.
-   - <b>i.stats_service.update</b> It implements stats_update FOM.
-   - <b>i.stats_service.query</b> It implements stats_query FOM.
-
-   <hr>
-   @section DLD-stats-svc-ut Unit Tests
-   -# Test update request for stats object not present with stats service
-      stats list with single stats parameter
-   -# Test update request for stats object present with stats service stats
-      list with single stats parameter
-   -# Test update request for stats object with multiple stats parameters
-   -# Test query for stats object with single stats parameter
-   -# Test query for stats object with multiple stats parameters
-
-   <hr>
-   @section DLD-stats-svc-it Integration Test
-   Mero nodes send stats (different 2-3 types) to stats service,
-   verification of stats sent by Mero node with respective stats object.
-
-   <hr>
-   @section DLD-stats-svc-st System Test
-   This tests whole monitoring infrastructure by running some sample IOs on
-   on Mero and verify statistics collected by querying statistic service using
-   client/monitoring utility.
-
-   <hr>
-   @section DLD-stats-svc-O Analysis
-   - Since all the stats objects are in-memory objects, query and update are
-     fast.
-   - Since stats service is just a book keeping of stats information into
-     in-memory object list. Since it does not do any computations of stats
-     values, it does not creates CPU usage overhead for mero nodes.
-
-   <hr>
-   @section DLD-stats-svc-ref References
-   - <a href="https://docs.google.com/a/xyratex.com/document/d/
-14uPeE0mNkRu3oF32Ys_EnpvSZtGWbf8hviPHTBTOXso/edit">
-   HLD of ADDB Monitoring</a>
-   - <a href="https://docs.google.com/a/xyratex.com/document/d/
-1lBgPht18RYX7s9XL-FcfUBKZ0zvo6JzqAEsXpTWs_4Q/edit">
-   Mero Stats Service</a>
- */
-#undef M0_ADDB_CT_CREATE_DEFINITION
-#define M0_ADDB_CT_CREATE_DEFINITION
-#undef M0_ADDB_RT_CREATE_DEFINITION
-#define M0_ADDB_RT_CREATE_DEFINITION
-#include "stats/stats_addb.h"
-
-#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_STATS
-#include "lib/trace.h"
-#include "lib/tlist.h"
-#include "lib/assert.h"
-#include "lib/misc.h"
-#include "lib/memory.h"
-#include "rpc/item.h"
-#include "fop/fop_item_type.h"
-#include "rpc/rpc_opcodes.h"
-#include "stats/stats_srv.h"
-#include "fop/fop.h"
-#include "fop/fom_generic.h"
-#include "reqh/reqh_service.h"
-#include "stats/stats_fops.h"
-#include "stats/stats_fops_xc.h"
-
-M0_TL_DESCR_DEFINE(stats, "statistic objects", M0_INTERNAL, struct m0_stats,
-		   s_linkage, s_magic, M0_STATS_MAGIC, M0_STATS_HEAD_MAGIC);
-M0_TL_DEFINE(stats, M0_INTERNAL, struct m0_stats);
-
-static const struct m0_bob_type stats_svc_bob = {
-	.bt_name         = "stats svc",
-	.bt_magix_offset = M0_MAGIX_OFFSET(struct stats_svc, ss_magic),
-	.bt_magix        = M0_STATS_SVC_MAGIC,
-	.bt_check        = NULL
-};
-
-M0_BOB_DEFINE(static, &stats_svc_bob, stats_svc);
-
-struct m0_addb_ctx stats_svc_addb_ctx;
-const struct m0_fom_type_ops stats_update_fom_type_ops;
-const struct m0_fom_type_ops stats_query_fom_type_ops;
-struct m0_sm_conf stats_update_fom_sm_conf;
-struct m0_sm_conf stats_query_fom_sm_conf;
-
-static int stats_add(struct m0_tl *stats_list, struct m0_stats_sum *sum);
-
-/**
- * @todo stuff These are stuffs and need to remove when actual stats defined.
- *             These are added just to test stats utility.
- *             This should be removed when actual Monitoring infra and
- *             some monitors code come in.
- *
- */
-static void define_stats()
-{
-	/** No provision to pass seperate name for rec type to M0_ADDB_RT_DP */
-	m0_addb_rt_stats_fop_rate.art_name = "fop_rate";
-	m0_addb_rec_type_register(&m0_addb_rt_stats_fop_rate);
-	m0_addb_rt_stats_read_size.art_name = "read_size";
-	m0_addb_rec_type_register(&m0_addb_rt_stats_read_size);
-	m0_addb_rt_stats_disk_stats.art_name = "disk_stats";
-	m0_addb_rec_type_register(&m0_addb_rt_stats_disk_stats);
-}
-
-static void add_dummy_stats(struct m0_tl *stats_list)
-{
-	struct m0_stats_sum stats_sum;
-	static struct fop_rate {
-		uint64_t fr_rate;
-		uint64_t fr_avg_turnaround_time_ns;
-	} f_rate;
-	static struct read_size {
-		uint64_t rs_avg_size;
-	} r_size;
-	static struct disk_stats {
-		uint64_t ds_total;
-		uint64_t ds_free;
-		uint64_t ds_used;
-	} d_stats;
-
-        f_rate.fr_rate = 3000;
-        f_rate.fr_avg_turnaround_time_ns = 98765;
-        stats_sum.ss_id = M0_ADDB_RECID_STATS_FOP_RATE;
-        stats_sum.ss_data.au64s_nr = 2;
-        stats_sum.ss_data.au64s_data = (uint64_t *)&f_rate;
-	stats_add(stats_list, &stats_sum);
-
-        r_size.rs_avg_size = 8196;
-        stats_sum.ss_id = M0_ADDB_RECID_STATS_READ_SIZE;
-        stats_sum.ss_data.au64s_nr = 1;
-        stats_sum.ss_data.au64s_data = (uint64_t *)&r_size;
-	stats_add(stats_list, &stats_sum);
-
-        d_stats.ds_free  = 2678901234;
-        d_stats.ds_used  = 3578901234;
-        d_stats.ds_total = 6257802468;
-        stats_sum.ss_id = M0_ADDB_RECID_STATS_DISK_STATS;
-        stats_sum.ss_data.au64s_nr = 3;
-        stats_sum.ss_data.au64s_data = (uint64_t *)&d_stats;
-	stats_add(stats_list, &stats_sum);
-}
-/** end stuff */
-
-
-/*
- * Stats Service
- */
-static bool stats_svc_invariant(const struct stats_svc *svc)
-{
-	return stats_svc_bob_check(svc);
-}
-
-/**
- * The rso_start methods to start stats service.
- */
-static int stats_svc_rso_start(struct m0_reqh_service *service)
-{
-	M0_PRE(m0_reqh_service_state_get(service) == M0_RST_STARTING);
-
-	return 0;
-}
-
-/**
- * The rso_stop method to stop Stats service.
- */
-static void stats_svc_rso_stop(struct m0_reqh_service *service)
-{
-        M0_PRE(m0_reqh_service_state_get(service) == M0_RST_STOPPED);
-}
-
-/**
- * The rso_fini method to finalise the Stats service.
- */
-static void stats_svc_rso_fini(struct m0_reqh_service *service)
-{
-	struct stats_svc *svc;
-	struct m0_stats  *stats_obj;
-
-	M0_PRE(M0_IN(m0_reqh_service_state_get(service), (M0_RST_STOPPED,
-							  M0_RST_FAILED)));
-	svc = bob_of(service, struct stats_svc, ss_reqhs, &stats_svc_bob);
-
-	m0_tl_for(stats, &svc->ss_stats, stats_obj) {
-		M0_ASSERT(stats_obj != NULL);
-
-		stats_tlink_del_fini(stats_obj);
-		m0_free(stats_obj->s_sum.ss_data.au64s_data);
-		m0_free(stats_obj);
-	} m0_tl_endfor;
-
-	stats_svc_bob_fini(svc);
-	m0_free(svc);
-}
-
-static const struct m0_reqh_service_ops stats_svc_ops = {
-	.rso_start = stats_svc_rso_start,
-	.rso_stop  = stats_svc_rso_stop,
-	.rso_fini  = stats_svc_rso_fini
-};
-
-static int stats_svc_rsto_service_allocate(struct m0_reqh_service      **srv,
-					   struct m0_reqh_service_type  *stype,
-					   struct m0_reqh_context       *rctx)
-{
-	struct stats_svc *svc;
-
-	M0_PRE(srv != NULL && stype != NULL);
-
-	M0_ALLOC_PTR(svc);
-	if (svc == NULL)
-		M0_RETERR(-ENOMEM, "Failed to allocate memory.");
-
-	*srv = &svc->ss_reqhs;
-	(*srv)->rs_type = stype;
-	(*srv)->rs_ops = &stats_svc_ops;
-
-	stats_svc_bob_init(svc);
-	stats_tlist_init(&svc->ss_stats);
-
-	M0_POST(stats_svc_invariant(svc));
-
-	// stuff. check @todo stuff
-	add_dummy_stats(&svc->ss_stats);
-
-	return 0;
-}
-
-static struct m0_reqh_service_type_ops stats_service_type_ops = {
-	.rsto_service_allocate = stats_svc_rsto_service_allocate,
-};
-
-M0_REQH_SERVICE_TYPE_DEFINE(m0_stats_svc_type, &stats_service_type_ops,
-			    M0_STATS_SVC_NAME, &m0_addb_ct_stats_svc);
-
-/*
- * Public interfaces
- */
-M0_INTERNAL int m0_stats_svc_init(void)
-{
-	int rc;
-
-	m0_addb_ctx_type_register(&m0_addb_ct_stats_svc);
-	m0_addb_ctx_type_register(&m0_addb_ct_stats_update_fom);
-	m0_addb_ctx_type_register(&m0_addb_ct_stats_query_fom);
-
-	rc = m0_reqh_service_type_register(&m0_stats_svc_type);
-	if (rc != 0)
-		return rc;
-
-	rc = m0_stats_fops_init();
-	if (rc != 0)
-		m0_reqh_service_type_unregister(&m0_stats_svc_type);
-
-	// stuff. check @todo stuff
-	define_stats();
-
-	return rc;
-}
-
-M0_INTERNAL void m0_stats_svc_fini(void)
-{
-	m0_reqh_service_type_unregister(&m0_stats_svc_type);
-	m0_stats_fops_fini();
-}
-
-/*
- * Stats Update FOM.
- */
-static int stats_update_fom_create(struct m0_fop  *fop, struct m0_fom **out,
-				   struct m0_reqh *reqh);
-static int stats_update_fom_tick(struct m0_fom *fom);
-static void stats_update_fom_fini(struct m0_fom *fom);
-static size_t stats_fom_home_locality(const struct m0_fom *fom);
-static void stats_update_fom_addb_init(struct m0_fom     *fom,
-				       struct m0_addb_mc *mc);
-
-/**
- * Stats update FOM operation vector.
- */
-static const struct m0_fom_ops stats_update_fom_ops = {
-	.fo_tick          = stats_update_fom_tick,
-	.fo_home_locality = stats_fom_home_locality,
-	.fo_addb_init     = stats_update_fom_addb_init,
-	.fo_fini          = stats_update_fom_fini
-};
-
-/**
- * Stats update FOP type operation vector.
- */
-const struct m0_fom_type_ops stats_update_fom_type_ops = {
-	.fto_create = stats_update_fom_create,
-};
-
-struct m0_sm_state_descr stats_update_phases[] = {
-	[STATS_UPDATE_FOM_INIT] = {
-		.sd_flags = M0_SDF_INITIAL,
-		.sd_name = "Init",
-		.sd_allowed = M0_BITS(STATS_UPDATE_FOM_UPDATE_OBJECT)
-	},
-	[STATS_UPDATE_FOM_UPDATE_OBJECT] = {
-		.sd_name = "Update",
-		.sd_allowed = M0_BITS(STATS_UPDATE_FOM_FINISH)
-	},
-	[STATS_UPDATE_FOM_FINISH] = {
-		.sd_flags = M0_SDF_TERMINAL,
-		.sd_name = "Finish",
-		.sd_allowed = 0
-	},
-};
-
-struct m0_sm_conf stats_update_fom_sm_conf = {
-	.scf_name      = "stats-update-fom-sm",
-	.scf_nr_states = ARRAY_SIZE(stats_update_phases),
-	.scf_state     = stats_update_phases
-};
-
-static bool stats_invariant(const struct m0_stats *stats)
-{
-	return stats->s_magic == M0_STATS_MAGIC;
-}
-
-/**
- * @todo This def may come in monitor infra. Need to take care while merging.
- */
-#define SUM_SIZE(sum_data) (sum_data->ss_data.au64s_nr * sizeof(uint64_t))
-
-static struct m0_stats *stats_get(struct m0_tl *stats_list, uint64_t id)
-{
-	struct m0_stats *stats_obj = NULL;
-
-	M0_PRE(stats_list != NULL);
-
-	m0_tl_for(stats, stats_list, stats_obj) {
-		M0_ASSERT(stats_invariant(stats_obj));
-		if (stats_obj->s_sum.ss_id == id)
-			break;
-	} m0_tl_endfor;
-
-	return stats_obj;
-}
-
-static int stats_sum_copy(struct m0_stats_sum *s, struct m0_stats_sum *d)
-{
-	M0_PRE(s != NULL && d != NULL);
-	if (d->ss_data.au64s_nr == 0) {
-		M0_ALLOC_ARR(d->ss_data.au64s_data, s->ss_data.au64s_nr);
-		if (d->ss_data.au64s_data == NULL)
-			M0_RETERR(-ENOMEM, "Failed to allocate memory.");
-	}
-
-	d->ss_id = s->ss_id;
-	d->ss_data.au64s_nr = s->ss_data.au64s_nr;
-	memcpy(d->ss_data.au64s_data, s->ss_data.au64s_data, SUM_SIZE(d));
-	return 0;
-}
-
-static int stats_add(struct m0_tl *stats_list, struct m0_stats_sum *sum)
-{
-	struct m0_stats *new_stats;
-	int              rc;
-
-	M0_PRE(stats_list != NULL);
-	M0_PRE(sum != NULL);
-
-	/**
-          * @todo
-          * Is it required to check valid m0_stats_sum::ss_id from some
-          * some list? How ? need some global stats id list.
-          */
-
-	M0_ALLOC_PTR(new_stats);
-	if (new_stats == NULL)
-		M0_RETERR(-ENOMEM, "Failed to allocate memory.");
-
-	new_stats->s_magic = M0_STATS_MAGIC;
-	rc = stats_sum_copy(sum, &new_stats->s_sum);
-	if (rc != 0) {
-		m0_free(new_stats);
-		return rc;
-	}
-
-	stats_tlink_init(new_stats);
-	stats_tlist_add_tail(stats_list, new_stats);
-
-	return 0;
-}
-
-static int stats_update(struct m0_fom *fom)
-{
-	struct m0_stats_update_fop *ufop;
-	struct stats_svc           *svc;
-	int			    i;
-
-	M0_PRE(fom != NULL);
-
-	ufop = m0_stats_update_fop_get(fom->fo_fop);
-
-	svc = container_of(fom->fo_service, struct stats_svc, ss_reqhs);
-	stats_svc_invariant(svc);
-
-	for (i = 0; i < ufop->suf_stats.sf_nr; ++i) {
-		struct m0_stats_sum *sum = &(ufop->suf_stats.sf_stats[i]);
-		struct m0_stats     *stats_obj = stats_get(&svc->ss_stats,
-							   sum->ss_id);
-
-		if (stats_obj != NULL) {
-			stats_sum_copy(sum, &stats_obj->s_sum);
-		} else {
-			int rc = stats_add(&svc->ss_stats, sum);
-			if (rc != 0)
-				return rc;
-		}
-	}
-
-	return 0;
-}
-
-/**
- * Create and initiate stats update FOM.
- */
-static int stats_update_fom_create(struct m0_fop  *fop, struct m0_fom **out,
-				   struct m0_reqh *reqh)
-{
-	struct stats_update_fom *stats_ufom;
-	struct m0_fom           *fom;
-
-	M0_PRE(fop != NULL);
-	M0_PRE(out != NULL);
-
-	M0_ALLOC_PTR(stats_ufom);
-	if (stats_ufom == NULL)
-		M0_RETERR(-ENOMEM, "Failed to allocate memory.");
-
-	fom = &stats_ufom->suf_fom;
-	m0_fom_init(fom, &(fop->f_type->ft_fom_type), &stats_update_fom_ops,
-		    fop, NULL, reqh, &m0_stats_svc_type);
-
-	stats_ufom->suf_magic = M0_STATS_UPDATE_FOM_MAGIC;
-
-	*out = fom;
-
-	return 0;
-}
-
-/**
- * State transition function for stats update FOM.
- */
-static int stats_update_fom_tick(struct m0_fom *fom)
-{
-	int rc = 0;
-
-	M0_PRE(fom != NULL);
-
-	switch(m0_fom_phase(fom)) {
-	case STATS_UPDATE_FOM_INIT:
-		m0_fom_phase_set(fom, STATS_UPDATE_FOM_UPDATE_OBJECT);
-		rc = M0_FSO_AGAIN;
-		break;
-	case STATS_UPDATE_FOM_UPDATE_OBJECT:
-		rc = stats_update(fom);
-		m0_fom_phase_set(fom, STATS_UPDATE_FOM_FINISH);
-		/* No need to execute generic phases. */
-		rc = M0_FSO_WAIT;
-		break;
-	default:
-		M0_IMPOSSIBLE("Phase not defined.");
-	}
-
-	return rc;
-}
-
-/**
- * Finalise stats update FOM.
- */
-static void stats_update_fom_fini(struct m0_fom *fom)
-{
-	struct stats_update_fom *ufom;
-
-	M0_PRE(fom != NULL);
-	ufom = container_of(fom, struct stats_update_fom, suf_fom);
-
-	m0_fom_fini(fom);
-	m0_free(ufom);
-}
-
-/**
- * Get stats update FOM locality.
- */
-static size_t stats_fom_home_locality(const struct m0_fom *fom)
-{
-	return 1; /* all stats update FOM run in same locality */
-}
-
-/**
- * Initialize addb context of stats update FOM.
- */
-static void stats_update_fom_addb_init(struct m0_fom     *fom,
-				       struct m0_addb_mc *mc)
-{
-        M0_ADDB_CTX_INIT(mc, &fom->fo_addb_ctx, &m0_addb_ct_stats_update_fom,
-                         &fom->fo_service->rs_addb_ctx);
-}
-
-/*
- * Stats Query FOM
- */
-static int    stats_query_fom_create(struct m0_fop  *fop, struct m0_fom **out,
-				     struct m0_reqh *reqh);
-static int    stats_query_fom_tick(struct m0_fom *fom);
-static void   stats_query_fom_fini(struct m0_fom *fom);
-static void   stats_query_fom_addb_init(struct m0_fom     *fom,
-				        struct m0_addb_mc *mc);
-/**
- * Stats update FOM operation vector.
- */
-static const struct m0_fom_ops stats_query_fom_ops = {
-	.fo_tick          = stats_query_fom_tick,
-	.fo_home_locality = stats_fom_home_locality,
-	.fo_addb_init     = stats_query_fom_addb_init,
-	.fo_fini          = stats_query_fom_fini
-};
-
-/**
- * Stats update FOP type operation vector.
- */
-const struct m0_fom_type_ops stats_query_fom_type_ops = {
-	.fto_create = stats_query_fom_create,
-};
-
-struct m0_sm_state_descr stats_query_phases[] = {
-	[STATS_QUERY_FOM_READ_OBJECT] = {
-		.sd_name    = "Read",
-		.sd_allowed = M0_BITS(M0_FOPH_SUCCESS, M0_FOPH_FAILURE)
-	}
-};
-
-struct m0_sm_conf stats_query_fom_sm_conf = {
-	.scf_name      = "stats-query-fom-sm",
-	.scf_nr_states = ARRAY_SIZE(stats_query_phases),
-	.scf_state     = stats_query_phases
-};
-
-static int read_stats(struct m0_fom *fom)
-{
-	struct m0_stats_query_fop     *qfop;
-	struct stats_svc              *svc;
-	struct m0_stats_query_rep_fop *rep_fop;
-	int			       i;
-	int			       rc = 0;
-
-	M0_PRE(fom != NULL);
-
-	qfop = m0_stats_query_fop_get(fom->fo_fop);
-	M0_ASSERT(qfop->sqf_ids.au64s_nr != 0);
-
-	svc = container_of(fom->fo_service, struct stats_svc, ss_reqhs);
-	stats_svc_invariant(svc);
-
-	rep_fop = m0_stats_query_rep_fop_get(fom->fo_rep_fop);
-	rep_fop->sqrf_stats.sf_nr = qfop->sqf_ids.au64s_nr;
-
-	for (i = 0; i < qfop->sqf_ids.au64s_nr; ++i) {
-		struct m0_addb_uint64_seq *sum_data;
-		struct m0_stats           *stats_obj =
-			stats_get(&svc->ss_stats, qfop->sqf_ids.au64s_data[i]);
-
-		/* Continue getting stats for next id */
-		if (stats_obj == NULL) {
-			rep_fop->sqrf_stats.sf_stats[i].ss_id =
-				M0_STATS_ID_UNDEFINED;
-			rep_fop->sqrf_stats.sf_stats[i].ss_data.au64s_nr = 0;
-			continue;
-		}
-
-		sum_data = &(rep_fop->sqrf_stats.sf_stats[i].ss_data);
-		rc = stats_sum_copy(&stats_obj->s_sum,
-				    &rep_fop->sqrf_stats.sf_stats[i]);
-		if (rc != 0) {
-			struct m0_stats_sum *sums;
-
-			sums = rep_fop->sqrf_stats.sf_stats;
-
-#undef REP_STATS_SUM_DATA
-#define REP_STATS_SUM_DATA(rep_fop, i) \
-	(rep_fop->sqrf_stats.sf_stats[i].ss_data.au64s_data)
-
-			for (;i >= 0; --i)
-				m0_free(REP_STATS_SUM_DATA(rep_fop, i));
-			m0_free(rep_fop->sqrf_stats.sf_stats);
-			break;
-		}
-	}
-
-	return rc;
-}
-
-/**
- * Create and initialize stats query FOM.
- */
-static int stats_query_fom_create(struct m0_fop  *fop, struct m0_fom **out,
-				  struct m0_reqh *reqh)
-{
-	struct stats_query_fom	      *stats_qfom;
-	struct m0_fom		      *fom;
-	struct m0_fop		      *reply_fop;
-	struct m0_stats_query_rep_fop *qrep_fop;
-	struct m0_stats_query_fop     *q_fop;
-	int			       rc = 0;
-
-	M0_PRE(fop != NULL);
-	M0_PRE(out != NULL);
-
-	M0_ALLOC_PTR(stats_qfom);
-	if (stats_qfom == NULL)
-		M0_RETERR(-ENOMEM, "Failed to allocate memory.");
-
-	M0_ALLOC_PTR(qrep_fop);
-	if (qrep_fop == NULL) {
-		rc = -ENOMEM;
-		goto free_qfom;
-	}
-
-	q_fop = m0_stats_query_fop_get(fop);
-	qrep_fop->sqrf_stats.sf_nr = q_fop->sqf_ids.au64s_nr;
-
-	M0_ALLOC_ARR(qrep_fop->sqrf_stats.sf_stats, q_fop->sqf_ids.au64s_nr);
-	if (qrep_fop->sqrf_stats.sf_stats == NULL) {
-		rc = -ENOMEM;
-		goto free_qrep_fop;
-	}
-
-	reply_fop = m0_fop_alloc(&m0_fop_stats_query_rep_fopt, qrep_fop);
-	if (reply_fop == NULL) {
-		rc = -ENOMEM;
-		goto free_qrep_fop_stats;
-	}
-
-	fom = &stats_qfom->sqf_fom;
-	m0_fom_init(fom, &fop->f_type->ft_fom_type, &stats_query_fom_ops, fop,
-		    reply_fop, reqh, &m0_stats_svc_type);
-	m0_fop_put(reply_fop);
-
-	stats_qfom->sqf_magic = M0_STATS_QUERY_FOM_MAGIC;
-
-	*out = fom;
-
-	return 0;
-
-free_qrep_fop_stats:
-	m0_free(qrep_fop->sqrf_stats.sf_stats);
-free_qrep_fop:
-	m0_free(qrep_fop);
-free_qfom:
-	m0_free(stats_qfom);
-
-	M0_RETERR(rc, "Failed to create query FOM");
-}
-
-/**
- * State transition function for stats query FOM.
- */
-static int stats_query_fom_tick(struct m0_fom *fom)
-{
-	int rc = 0;
-
-	M0_PRE(fom != NULL);
-
-	/**
-	 * @note only M0_FOPH_QUEUE_REPLY & M0_FOPH_QUEUE_REPLY_WAIT are
-	 * required.
-	 */
-	if (m0_fom_phase(fom) < M0_FOPH_NR)
-		return m0_fom_tick_generic(fom);
-
-	switch(m0_fom_phase(fom)) {
-	case STATS_QUERY_FOM_READ_OBJECT:
-		rc = read_stats(fom);
-		fom->fo_sm_phase.sm_rc = rc;
-		m0_fom_phase_moveif(fom, rc, M0_FOPH_SUCCESS, M0_FOPH_FAILURE);
-		rc = M0_FSO_AGAIN;
-		break;
-	default:
-		M0_IMPOSSIBLE("Phase not defined.");
-	}
-
-	return rc;
-}
-
-/**
- * Finalise stats query FOM.
- */
-static void stats_query_fom_fini(struct m0_fom *fom)
-{
-	struct stats_query_fom *qfom;
-
-	M0_PRE(fom != NULL);
-	qfom = container_of(fom, struct stats_query_fom, sqf_fom);
-
-	m0_fom_fini(fom);
-	m0_free(qfom);
-}
-
-/**
- * Initialize addb context of stats query FOM.
- */
-static void stats_query_fom_addb_init(struct m0_fom     *fom,
-				      struct m0_addb_mc *mc)
-{
-        M0_ADDB_CTX_INIT(mc, &fom->fo_addb_ctx, &m0_addb_ct_stats_update_fom,
-                         &fom->fo_service->rs_addb_ctx);
-}
-
-#undef M0_TRACE_SUBSYSTEM
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/stats/stats_srv.c~HEAD b/stats/stats_srv.c~HEAD
new file mode 100644
index 0000000..806ce58
--- /dev/null
+++ b/stats/stats_srv.c~HEAD
@@ -0,0 +1,852 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Rajanikant Chirmade <rajanikant_chirmade@xyratex.com>
+ * Original creation date: 06/14/2013
+ */
+
+/**
+   @page DLD-stats-svc  Stats Service
+
+   - @ref DLD-stats-svc-ovw
+   - @ref DLD-stats-svc-def
+   - @ref DLD-stats-svc-req
+   - @subpage DLD-stats-svc-fspecs
+   - @ref DLD-stats-svc-lspecs
+      - @ref DLD-stats-svc-lspecs-stats_list
+      - @ref DLD-stats-svc-lspec-state
+      - @ref DLD-stats-svc-lspec-thread
+      - @ref DLD-stats-svc-lspec-service-registration
+      - @ref DLD-stats-svc-lspec-numa
+      - @ref DLD-stats-svc-lspec-depends
+      - @ref DLD-stats-svc-lspec-conformance
+   - @ref DLD-stats-svc-ut
+   - @ref DLD-stats-svc-it
+   - @ref DLD-stats-svc-st
+   - @ref DLD-stats-svc-O
+   - @ref DLD-stats-svc-ref
+
+   <hr>
+   @section DLD-stats-svc-ovw Overview
+   Stats service provides the following functionality:
+   - Updates of in-memory stats objects on requests from mero nodes
+   - Provides stats information from in-memory stats objects to cluster
+     administrative utilities/console on their query.
+
+   <hr>
+   @section DLD-stats-svc-def Definitions
+   - <b>Stats Service</b> Stats service which processes mero statistics
+     update/query requests.
+   - <b>Stats Object</b> Stats in-memory object which represents a statistics
+     matrix.
+   - <b>Stats Update</b> Stats update request which updates stats object values.
+   - <b>Stats Query</b> Stats query request which returns latest updated
+     stats objects value.
+   - <b>Stats Clients</b> Mero administrative console/utilities.
+
+   <hr>
+   @section DLD-stats-svc-req Requirements
+   - <b>r.stats_service.in_memory_objects</b> Maintains in-memory statistic
+     objects. It is list of stats object.
+   - <b>r.stats_service.update</b> It updates requested stats object values.
+   - <b>r.stats_service.query</b> It returns requested stats object values to
+     stats clients.
+
+   <hr>
+   @section DLD-stats-svc-lspecs Logical Specification
+
+   @subsection DLD-stats-svc-lspecs-stats_list Stats Object List
+   In memory stats object list does not contain any object initially. Stats
+   FOM update respective stats object. object is created if not found in
+   stats list.
+
+   @subsection DLD-stats-svc-lspec-state State Transitions
+   State diagram for stats_update FOM:
+   @dot
+   digraph {
+	size = "5,10"
+	node [shape=record, fontsize=10]
+	S0 [label="Init Update FOM"]
+	S1 [label="Update Stats object"]
+	S2 [label="Finalise FOM"]
+	S0 -> S1 [label="Stats Update fom initiaized"]
+	S1 -> S2 [label="Stats object updated"]
+   }
+   @enddot
+
+   State diagram for stats_query FOM:
+   @dot
+   digraph {
+	size = "5,10"
+	node [shape=record, fontsize=10]
+	S0 [label="Init Query FOM"]
+	S1 [label="Read stats objects and set reply FOP"]
+	S2 [label="Finalise FOM"]
+	S0 -> S1 [label="Stats object found"]
+	S1 -> S2 [label="Set reply FOP"]
+   }
+   @enddot
+
+   @subsection DLD-stats-svc-lspec-thread Threading and Concurrency Model
+   Stats service FOMs(updates/query) are executed by request handler's
+   locality thread. Since same locality is assigned to all these FOMs, no
+   other serialization is required for stats service.
+
+   @subsection DLD-stats-svc-lspec-service-registration Service Registration
+   Stats service type definition :
+
+   M0_REQH_SERVICE_TYPE_DEFINE(m0_stats_svc_type, &stats_service_type_ops,
+                            M0_STATS_SVC_NAME, &m0_addb_ct_stats_service);
+
+   Stats service type initialization/finalization :
+
+   Stats service registers/unregisters its service type with request handler
+   using interfaces m0_stats_svc_init()/ m0_stats_svc_fini() during
+   Mero system initialization and finalization (m0_init()/ m0_fini()).
+
+   @subsection DLD-stats-svc-lspec-numa NUMA optimizations
+   Update FOMs and query FOMs are executed in the same locality. Update/Query
+   FOMs access in-memory list of statistic objects. Since both type of FOMs
+   executed by same localiy threads it gets benifis of locality.
+
+   @subsection DLD-stats-svc-lspec-depends Dependencies
+   - <b>r.reqh</b> : Request handler's locality thread execute stats service
+   FOMs(update/query).
+
+   @subsection DLD-stats-svc-lspec-conformance Conformance
+   - <b>i.stats_service.in_memory_objects</b> It implements list of stats
+     object to keep stats run time.
+   - <b>i.stats_service.update</b> It implements stats_update FOM.
+   - <b>i.stats_service.query</b> It implements stats_query FOM.
+
+   <hr>
+   @section DLD-stats-svc-ut Unit Tests
+   -# Test update request for stats object not present with stats service
+      stats list with single stats parameter
+   -# Test update request for stats object present with stats service stats
+      list with single stats parameter
+   -# Test update request for stats object with multiple stats parameters
+   -# Test query for stats object with single stats parameter
+   -# Test query for stats object with multiple stats parameters
+
+   <hr>
+   @section DLD-stats-svc-it Integration Test
+   Mero nodes send stats (different 2-3 types) to stats service,
+   verification of stats sent by Mero node with respective stats object.
+
+   <hr>
+   @section DLD-stats-svc-st System Test
+   This tests whole monitoring infrastructure by running some sample IOs on
+   on Mero and verify statistics collected by querying statistic service using
+   client/monitoring utility.
+
+   <hr>
+   @section DLD-stats-svc-O Analysis
+   - Since all the stats objects are in-memory objects, query and update are
+     fast.
+   - Since stats service is just a book keeping of stats information into
+     in-memory object list. Since it does not do any computations of stats
+     values, it does not creates CPU usage overhead for mero nodes.
+
+   <hr>
+   @section DLD-stats-svc-ref References
+   - <a href="https://docs.google.com/a/xyratex.com/document/d/
+14uPeE0mNkRu3oF32Ys_EnpvSZtGWbf8hviPHTBTOXso/edit">
+   HLD of ADDB Monitoring</a>
+   - <a href="https://docs.google.com/a/xyratex.com/document/d/
+1lBgPht18RYX7s9XL-FcfUBKZ0zvo6JzqAEsXpTWs_4Q/edit">
+   Mero Stats Service</a>
+ */
+#undef M0_ADDB_CT_CREATE_DEFINITION
+#define M0_ADDB_CT_CREATE_DEFINITION
+#undef M0_ADDB_RT_CREATE_DEFINITION
+#define M0_ADDB_RT_CREATE_DEFINITION
+#include "stats/stats_addb.h"
+
+#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_STATS
+#include "lib/trace.h"
+#include "lib/tlist.h"
+#include "lib/assert.h"
+#include "lib/misc.h"
+#include "lib/memory.h"
+#include "rpc/item.h"
+#include "fop/fop_item_type.h"
+#include "rpc/rpc_opcodes.h"
+#include "stats/stats_srv.h"
+#include "fop/fop.h"
+#include "fop/fom_generic.h"
+#include "reqh/reqh_service.h"
+#include "stats/stats_fops.h"
+#include "stats/stats_fops_xc.h"
+
+M0_TL_DESCR_DEFINE(stats, "statistic objects", M0_INTERNAL, struct m0_stats,
+		   s_linkage, s_magic, M0_STATS_MAGIC, M0_STATS_HEAD_MAGIC);
+M0_TL_DEFINE(stats, M0_INTERNAL, struct m0_stats);
+
+static const struct m0_bob_type stats_svc_bob = {
+	.bt_name         = "stats svc",
+	.bt_magix_offset = M0_MAGIX_OFFSET(struct stats_svc, ss_magic),
+	.bt_magix        = M0_STATS_SVC_MAGIC,
+	.bt_check        = NULL
+};
+
+M0_BOB_DEFINE(static, &stats_svc_bob, stats_svc);
+
+struct m0_addb_ctx stats_svc_addb_ctx;
+const struct m0_fom_type_ops stats_update_fom_type_ops;
+const struct m0_fom_type_ops stats_query_fom_type_ops;
+struct m0_sm_conf stats_update_fom_sm_conf;
+struct m0_sm_conf stats_query_fom_sm_conf;
+
+static int stats_add(struct m0_tl *stats_list, struct m0_stats_sum *sum);
+
+/**
+ * @todo stuff These are stuffs and need to remove when actual stats defined.
+ *             These are added just to test stats utility.
+ *             This should be removed when actual Monitoring infra and
+ *             some monitors code come in.
+ *
+ */
+static void define_stats()
+{
+	/** No provision to pass seperate name for rec type to M0_ADDB_RT_DP */
+	m0_addb_rt_stats_fop_rate.art_name = "fop_rate";
+	m0_addb_rec_type_register(&m0_addb_rt_stats_fop_rate);
+	m0_addb_rt_stats_read_size.art_name = "read_size";
+	m0_addb_rec_type_register(&m0_addb_rt_stats_read_size);
+	m0_addb_rt_stats_disk_stats.art_name = "disk_stats";
+	m0_addb_rec_type_register(&m0_addb_rt_stats_disk_stats);
+}
+
+static void add_dummy_stats(struct m0_tl *stats_list)
+{
+	struct m0_stats_sum stats_sum;
+	static struct fop_rate {
+		uint64_t fr_rate;
+		uint64_t fr_avg_turnaround_time_ns;
+	} f_rate;
+	static struct read_size {
+		uint64_t rs_avg_size;
+	} r_size;
+	static struct disk_stats {
+		uint64_t ds_total;
+		uint64_t ds_free;
+		uint64_t ds_used;
+	} d_stats;
+
+        f_rate.fr_rate = 3000;
+        f_rate.fr_avg_turnaround_time_ns = 98765;
+        stats_sum.ss_id = M0_ADDB_RECID_STATS_FOP_RATE;
+        stats_sum.ss_data.au64s_nr = 2;
+        stats_sum.ss_data.au64s_data = (uint64_t *)&f_rate;
+	stats_add(stats_list, &stats_sum);
+
+        r_size.rs_avg_size = 8196;
+        stats_sum.ss_id = M0_ADDB_RECID_STATS_READ_SIZE;
+        stats_sum.ss_data.au64s_nr = 1;
+        stats_sum.ss_data.au64s_data = (uint64_t *)&r_size;
+	stats_add(stats_list, &stats_sum);
+
+        d_stats.ds_free  = 2678901234;
+        d_stats.ds_used  = 3578901234;
+        d_stats.ds_total = 6257802468;
+        stats_sum.ss_id = M0_ADDB_RECID_STATS_DISK_STATS;
+        stats_sum.ss_data.au64s_nr = 3;
+        stats_sum.ss_data.au64s_data = (uint64_t *)&d_stats;
+	stats_add(stats_list, &stats_sum);
+}
+/** end stuff */
+
+
+/*
+ * Stats Service
+ */
+static bool stats_svc_invariant(const struct stats_svc *svc)
+{
+	return stats_svc_bob_check(svc);
+}
+
+/**
+ * The rso_start methods to start stats service.
+ */
+static int stats_svc_rso_start(struct m0_reqh_service *service)
+{
+	M0_PRE(m0_reqh_service_state_get(service) == M0_RST_STARTING);
+
+	return 0;
+}
+
+/**
+ * The rso_stop method to stop Stats service.
+ */
+static void stats_svc_rso_stop(struct m0_reqh_service *service)
+{
+        M0_PRE(m0_reqh_service_state_get(service) == M0_RST_STOPPED);
+}
+
+/**
+ * The rso_fini method to finalise the Stats service.
+ */
+static void stats_svc_rso_fini(struct m0_reqh_service *service)
+{
+	struct stats_svc *svc;
+	struct m0_stats  *stats_obj;
+
+	M0_PRE(M0_IN(m0_reqh_service_state_get(service), (M0_RST_STOPPED,
+							  M0_RST_FAILED)));
+	svc = bob_of(service, struct stats_svc, ss_reqhs, &stats_svc_bob);
+
+	m0_tl_for(stats, &svc->ss_stats, stats_obj) {
+		M0_ASSERT(stats_obj != NULL);
+
+		stats_tlink_del_fini(stats_obj);
+		m0_free(stats_obj->s_sum.ss_data.au64s_data);
+		m0_free(stats_obj);
+	} m0_tl_endfor;
+
+	stats_svc_bob_fini(svc);
+	m0_free(svc);
+}
+
+static const struct m0_reqh_service_ops stats_svc_ops = {
+	.rso_start = stats_svc_rso_start,
+	.rso_stop  = stats_svc_rso_stop,
+	.rso_fini  = stats_svc_rso_fini
+};
+
+static int stats_svc_rsto_service_allocate(struct m0_reqh_service      **srv,
+					   struct m0_reqh_service_type  *stype,
+					   struct m0_reqh_context       *rctx)
+{
+	struct stats_svc *svc;
+
+	M0_PRE(srv != NULL && stype != NULL);
+
+	M0_ALLOC_PTR(svc);
+	if (svc == NULL)
+		M0_RETERR(-ENOMEM, "Failed to allocate memory.");
+
+	*srv = &svc->ss_reqhs;
+	(*srv)->rs_type = stype;
+	(*srv)->rs_ops = &stats_svc_ops;
+
+	stats_svc_bob_init(svc);
+	stats_tlist_init(&svc->ss_stats);
+
+	M0_POST(stats_svc_invariant(svc));
+
+	// stuff. check @todo stuff
+	add_dummy_stats(&svc->ss_stats);
+
+	return 0;
+}
+
+static struct m0_reqh_service_type_ops stats_service_type_ops = {
+	.rsto_service_allocate = stats_svc_rsto_service_allocate,
+};
+
+M0_REQH_SERVICE_TYPE_DEFINE(m0_stats_svc_type, &stats_service_type_ops,
+			    M0_STATS_SVC_NAME, &m0_addb_ct_stats_svc);
+
+/*
+ * Public interfaces
+ */
+M0_INTERNAL int m0_stats_svc_init(void)
+{
+	int rc;
+
+	m0_addb_ctx_type_register(&m0_addb_ct_stats_svc);
+	m0_addb_ctx_type_register(&m0_addb_ct_stats_update_fom);
+	m0_addb_ctx_type_register(&m0_addb_ct_stats_query_fom);
+
+	rc = m0_reqh_service_type_register(&m0_stats_svc_type);
+	if (rc != 0)
+		return rc;
+
+	rc = m0_stats_fops_init();
+	if (rc != 0)
+		m0_reqh_service_type_unregister(&m0_stats_svc_type);
+
+	// stuff. check @todo stuff
+	define_stats();
+
+	return rc;
+}
+
+M0_INTERNAL void m0_stats_svc_fini(void)
+{
+	m0_reqh_service_type_unregister(&m0_stats_svc_type);
+	m0_stats_fops_fini();
+}
+
+/*
+ * Stats Update FOM.
+ */
+static int stats_update_fom_create(struct m0_fop  *fop, struct m0_fom **out,
+				   struct m0_reqh *reqh);
+static int stats_update_fom_tick(struct m0_fom *fom);
+static void stats_update_fom_fini(struct m0_fom *fom);
+static size_t stats_fom_home_locality(const struct m0_fom *fom);
+static void stats_update_fom_addb_init(struct m0_fom     *fom,
+				       struct m0_addb_mc *mc);
+
+/**
+ * Stats update FOM operation vector.
+ */
+static const struct m0_fom_ops stats_update_fom_ops = {
+	.fo_tick          = stats_update_fom_tick,
+	.fo_home_locality = stats_fom_home_locality,
+	.fo_addb_init     = stats_update_fom_addb_init,
+	.fo_fini          = stats_update_fom_fini
+};
+
+/**
+ * Stats update FOP type operation vector.
+ */
+const struct m0_fom_type_ops stats_update_fom_type_ops = {
+	.fto_create = stats_update_fom_create,
+};
+
+struct m0_sm_state_descr stats_update_phases[] = {
+	[STATS_UPDATE_FOM_INIT] = {
+		.sd_flags = M0_SDF_INITIAL,
+		.sd_name = "Init",
+		.sd_allowed = M0_BITS(STATS_UPDATE_FOM_UPDATE_OBJECT)
+	},
+	[STATS_UPDATE_FOM_UPDATE_OBJECT] = {
+		.sd_name = "Update",
+		.sd_allowed = M0_BITS(STATS_UPDATE_FOM_FINISH)
+	},
+	[STATS_UPDATE_FOM_FINISH] = {
+		.sd_flags = M0_SDF_TERMINAL,
+		.sd_name = "Finish",
+		.sd_allowed = 0
+	},
+};
+
+struct m0_sm_conf stats_update_fom_sm_conf = {
+	.scf_name      = "stats-update-fom-sm",
+	.scf_nr_states = ARRAY_SIZE(stats_update_phases),
+	.scf_state     = stats_update_phases
+};
+
+static bool stats_invariant(const struct m0_stats *stats)
+{
+	return stats->s_magic == M0_STATS_MAGIC;
+}
+
+/**
+ * @todo This def may come in monitor infra. Need to take care while merging.
+ */
+#define SUM_SIZE(sum_data) (sum_data->ss_data.au64s_nr * sizeof(uint64_t))
+
+static struct m0_stats *stats_get(struct m0_tl *stats_list, uint64_t id)
+{
+	struct m0_stats *stats_obj = NULL;
+
+	M0_PRE(stats_list != NULL);
+
+	m0_tl_for(stats, stats_list, stats_obj) {
+		M0_ASSERT(stats_invariant(stats_obj));
+		if (stats_obj->s_sum.ss_id == id)
+			break;
+	} m0_tl_endfor;
+
+	return stats_obj;
+}
+
+static int stats_sum_copy(struct m0_stats_sum *s, struct m0_stats_sum *d)
+{
+	M0_PRE(s != NULL && d != NULL);
+	if (d->ss_data.au64s_nr == 0) {
+		M0_ALLOC_ARR(d->ss_data.au64s_data, s->ss_data.au64s_nr);
+		if (d->ss_data.au64s_data == NULL)
+			M0_RETERR(-ENOMEM, "Failed to allocate memory.");
+	}
+
+	d->ss_id = s->ss_id;
+	d->ss_data.au64s_nr = s->ss_data.au64s_nr;
+	memcpy(d->ss_data.au64s_data, s->ss_data.au64s_data, SUM_SIZE(d));
+	return 0;
+}
+
+static int stats_add(struct m0_tl *stats_list, struct m0_stats_sum *sum)
+{
+	struct m0_stats *new_stats;
+	int              rc;
+
+	M0_PRE(stats_list != NULL);
+	M0_PRE(sum != NULL);
+
+	/**
+          * @todo
+          * Is it required to check valid m0_stats_sum::ss_id from some
+          * some list? How ? need some global stats id list.
+          */
+
+	M0_ALLOC_PTR(new_stats);
+	if (new_stats == NULL)
+		M0_RETERR(-ENOMEM, "Failed to allocate memory.");
+
+	new_stats->s_magic = M0_STATS_MAGIC;
+	rc = stats_sum_copy(sum, &new_stats->s_sum);
+	if (rc != 0) {
+		m0_free(new_stats);
+		return rc;
+	}
+
+	stats_tlink_init(new_stats);
+	stats_tlist_add_tail(stats_list, new_stats);
+
+	return 0;
+}
+
+static int stats_update(struct m0_fom *fom)
+{
+	struct m0_stats_update_fop *ufop;
+	struct stats_svc           *svc;
+	int			    i;
+
+	M0_PRE(fom != NULL);
+
+	ufop = m0_stats_update_fop_get(fom->fo_fop);
+
+	svc = container_of(fom->fo_service, struct stats_svc, ss_reqhs);
+	stats_svc_invariant(svc);
+
+	for (i = 0; i < ufop->suf_stats.sf_nr; ++i) {
+		struct m0_stats_sum *sum = &(ufop->suf_stats.sf_stats[i]);
+		struct m0_stats     *stats_obj = stats_get(&svc->ss_stats,
+							   sum->ss_id);
+
+		if (stats_obj != NULL) {
+			stats_sum_copy(sum, &stats_obj->s_sum);
+		} else {
+			int rc = stats_add(&svc->ss_stats, sum);
+			if (rc != 0)
+				return rc;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * Create and initiate stats update FOM.
+ */
+static int stats_update_fom_create(struct m0_fop  *fop, struct m0_fom **out,
+				   struct m0_reqh *reqh)
+{
+	struct stats_update_fom *stats_ufom;
+	struct m0_fom           *fom;
+
+	M0_PRE(fop != NULL);
+	M0_PRE(out != NULL);
+
+	M0_ALLOC_PTR(stats_ufom);
+	if (stats_ufom == NULL)
+		M0_RETERR(-ENOMEM, "Failed to allocate memory.");
+
+	fom = &stats_ufom->suf_fom;
+	m0_fom_init(fom, &(fop->f_type->ft_fom_type), &stats_update_fom_ops,
+		    fop, NULL, reqh, &m0_stats_svc_type);
+
+	stats_ufom->suf_magic = M0_STATS_UPDATE_FOM_MAGIC;
+
+	*out = fom;
+
+	return 0;
+}
+
+/**
+ * State transition function for stats update FOM.
+ */
+static int stats_update_fom_tick(struct m0_fom *fom)
+{
+	int rc = 0;
+
+	M0_PRE(fom != NULL);
+
+	switch(m0_fom_phase(fom)) {
+	case STATS_UPDATE_FOM_INIT:
+		m0_fom_phase_set(fom, STATS_UPDATE_FOM_UPDATE_OBJECT);
+		rc = M0_FSO_AGAIN;
+		break;
+	case STATS_UPDATE_FOM_UPDATE_OBJECT:
+		rc = stats_update(fom);
+		m0_fom_phase_set(fom, STATS_UPDATE_FOM_FINISH);
+		/* No need to execute generic phases. */
+		rc = M0_FSO_WAIT;
+		break;
+	default:
+		M0_IMPOSSIBLE("Phase not defined.");
+	}
+
+	return rc;
+}
+
+/**
+ * Finalise stats update FOM.
+ */
+static void stats_update_fom_fini(struct m0_fom *fom)
+{
+	struct stats_update_fom *ufom;
+
+	M0_PRE(fom != NULL);
+	ufom = container_of(fom, struct stats_update_fom, suf_fom);
+
+	m0_fom_fini(fom);
+	m0_free(ufom);
+}
+
+/**
+ * Get stats update FOM locality.
+ */
+static size_t stats_fom_home_locality(const struct m0_fom *fom)
+{
+	return 1; /* all stats update FOM run in same locality */
+}
+
+/**
+ * Initialize addb context of stats update FOM.
+ */
+static void stats_update_fom_addb_init(struct m0_fom     *fom,
+				       struct m0_addb_mc *mc)
+{
+        M0_ADDB_CTX_INIT(mc, &fom->fo_addb_ctx, &m0_addb_ct_stats_update_fom,
+                         &fom->fo_service->rs_addb_ctx);
+}
+
+/*
+ * Stats Query FOM
+ */
+static int    stats_query_fom_create(struct m0_fop  *fop, struct m0_fom **out,
+				     struct m0_reqh *reqh);
+static int    stats_query_fom_tick(struct m0_fom *fom);
+static void   stats_query_fom_fini(struct m0_fom *fom);
+static void   stats_query_fom_addb_init(struct m0_fom     *fom,
+				        struct m0_addb_mc *mc);
+/**
+ * Stats update FOM operation vector.
+ */
+static const struct m0_fom_ops stats_query_fom_ops = {
+	.fo_tick          = stats_query_fom_tick,
+	.fo_home_locality = stats_fom_home_locality,
+	.fo_addb_init     = stats_query_fom_addb_init,
+	.fo_fini          = stats_query_fom_fini
+};
+
+/**
+ * Stats update FOP type operation vector.
+ */
+const struct m0_fom_type_ops stats_query_fom_type_ops = {
+	.fto_create = stats_query_fom_create,
+};
+
+struct m0_sm_state_descr stats_query_phases[] = {
+	[STATS_QUERY_FOM_READ_OBJECT] = {
+		.sd_name    = "Read",
+		.sd_allowed = M0_BITS(M0_FOPH_SUCCESS, M0_FOPH_FAILURE)
+	}
+};
+
+struct m0_sm_conf stats_query_fom_sm_conf = {
+	.scf_name      = "stats-query-fom-sm",
+	.scf_nr_states = ARRAY_SIZE(stats_query_phases),
+	.scf_state     = stats_query_phases
+};
+
+static int read_stats(struct m0_fom *fom)
+{
+	struct m0_stats_query_fop     *qfop;
+	struct stats_svc              *svc;
+	struct m0_stats_query_rep_fop *rep_fop;
+	int			       i;
+	int			       rc = 0;
+
+	M0_PRE(fom != NULL);
+
+	qfop = m0_stats_query_fop_get(fom->fo_fop);
+	M0_ASSERT(qfop->sqf_ids.au64s_nr != 0);
+
+	svc = container_of(fom->fo_service, struct stats_svc, ss_reqhs);
+	stats_svc_invariant(svc);
+
+	rep_fop = m0_stats_query_rep_fop_get(fom->fo_rep_fop);
+	rep_fop->sqrf_stats.sf_nr = qfop->sqf_ids.au64s_nr;
+
+	for (i = 0; i < qfop->sqf_ids.au64s_nr; ++i) {
+		struct m0_addb_uint64_seq *sum_data;
+		struct m0_stats           *stats_obj =
+			stats_get(&svc->ss_stats, qfop->sqf_ids.au64s_data[i]);
+
+		/* Continue getting stats for next id */
+		if (stats_obj == NULL) {
+			rep_fop->sqrf_stats.sf_stats[i].ss_id =
+				M0_STATS_ID_UNDEFINED;
+			rep_fop->sqrf_stats.sf_stats[i].ss_data.au64s_nr = 0;
+			continue;
+		}
+
+		sum_data = &(rep_fop->sqrf_stats.sf_stats[i].ss_data);
+		rc = stats_sum_copy(&stats_obj->s_sum,
+				    &rep_fop->sqrf_stats.sf_stats[i]);
+		if (rc != 0) {
+			struct m0_stats_sum *sums;
+
+			sums = rep_fop->sqrf_stats.sf_stats;
+
+#undef REP_STATS_SUM_DATA
+#define REP_STATS_SUM_DATA(rep_fop, i) \
+	(rep_fop->sqrf_stats.sf_stats[i].ss_data.au64s_data)
+
+			for (;i >= 0; --i)
+				m0_free(REP_STATS_SUM_DATA(rep_fop, i));
+			m0_free(rep_fop->sqrf_stats.sf_stats);
+			break;
+		}
+	}
+
+	return rc;
+}
+
+/**
+ * Create and initialize stats query FOM.
+ */
+static int stats_query_fom_create(struct m0_fop  *fop, struct m0_fom **out,
+				  struct m0_reqh *reqh)
+{
+	struct stats_query_fom	      *stats_qfom;
+	struct m0_fom		      *fom;
+	struct m0_fop		      *reply_fop;
+	struct m0_stats_query_rep_fop *qrep_fop;
+	struct m0_stats_query_fop     *q_fop;
+	int			       rc = 0;
+
+	M0_PRE(fop != NULL);
+	M0_PRE(out != NULL);
+
+	M0_ALLOC_PTR(stats_qfom);
+	if (stats_qfom == NULL)
+		M0_RETERR(-ENOMEM, "Failed to allocate memory.");
+
+	M0_ALLOC_PTR(qrep_fop);
+	if (qrep_fop == NULL) {
+		rc = -ENOMEM;
+		goto free_qfom;
+	}
+
+	q_fop = m0_stats_query_fop_get(fop);
+	qrep_fop->sqrf_stats.sf_nr = q_fop->sqf_ids.au64s_nr;
+
+	M0_ALLOC_ARR(qrep_fop->sqrf_stats.sf_stats, q_fop->sqf_ids.au64s_nr);
+	if (qrep_fop->sqrf_stats.sf_stats == NULL) {
+		rc = -ENOMEM;
+		goto free_qrep_fop;
+	}
+
+	reply_fop = m0_fop_alloc(&m0_fop_stats_query_rep_fopt, qrep_fop);
+	if (reply_fop == NULL) {
+		rc = -ENOMEM;
+		goto free_qrep_fop_stats;
+	}
+
+	fom = &stats_qfom->sqf_fom;
+	m0_fom_init(fom, &fop->f_type->ft_fom_type, &stats_query_fom_ops, fop,
+		    reply_fop, reqh, &m0_stats_svc_type);
+	m0_fop_put(reply_fop);
+
+	stats_qfom->sqf_magic = M0_STATS_QUERY_FOM_MAGIC;
+
+	*out = fom;
+
+	return 0;
+
+free_qrep_fop_stats:
+	m0_free(qrep_fop->sqrf_stats.sf_stats);
+free_qrep_fop:
+	m0_free(qrep_fop);
+free_qfom:
+	m0_free(stats_qfom);
+
+	M0_RETERR(rc, "Failed to create query FOM");
+}
+
+/**
+ * State transition function for stats query FOM.
+ */
+static int stats_query_fom_tick(struct m0_fom *fom)
+{
+	int rc = 0;
+
+	M0_PRE(fom != NULL);
+
+	/**
+	 * @note only M0_FOPH_QUEUE_REPLY & M0_FOPH_QUEUE_REPLY_WAIT are
+	 * required.
+	 */
+	if (m0_fom_phase(fom) < M0_FOPH_NR)
+		return m0_fom_tick_generic(fom);
+
+	switch(m0_fom_phase(fom)) {
+	case STATS_QUERY_FOM_READ_OBJECT:
+		rc = read_stats(fom);
+		fom->fo_sm_phase.sm_rc = rc;
+		m0_fom_phase_moveif(fom, rc, M0_FOPH_SUCCESS, M0_FOPH_FAILURE);
+		rc = M0_FSO_AGAIN;
+		break;
+	default:
+		M0_IMPOSSIBLE("Phase not defined.");
+	}
+
+	return rc;
+}
+
+/**
+ * Finalise stats query FOM.
+ */
+static void stats_query_fom_fini(struct m0_fom *fom)
+{
+	struct stats_query_fom *qfom;
+
+	M0_PRE(fom != NULL);
+	qfom = container_of(fom, struct stats_query_fom, sqf_fom);
+
+	m0_fom_fini(fom);
+	m0_free(qfom);
+}
+
+/**
+ * Initialize addb context of stats query FOM.
+ */
+static void stats_query_fom_addb_init(struct m0_fom     *fom,
+				      struct m0_addb_mc *mc)
+{
+        M0_ADDB_CTX_INIT(mc, &fom->fo_addb_ctx, &m0_addb_ct_stats_update_fom,
+                         &fom->fo_service->rs_addb_ctx);
+}
+
+#undef M0_TRACE_SUBSYSTEM
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/stats/stats_srv.h b/stats/stats_srv.h
deleted file mode 100644
index 136e00e..0000000
--- a/stats/stats_srv.h
+++ /dev/null
@@ -1,156 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Rajanikant Chirmade <rajanikant_chirmade@xyratex.com>
- * Original creation date: 06/14/2013
- */
-
-#pragma once
-
-#ifndef __MERO_STATS_STATS_SVC_H__
-#define __MERO_STATS_STATS_SVC_H__
-#ifndef __KERNEL__
-
-/**
-   @page DLD-stats-svc-fspecs Functional Specification
-
-   - @ref DLD-stats-svc-fspecs-ds
-   - @ref DLD-stats-svc-fspecs-int-if
-   - @ref DLD-stats-svc-fspecs-ext-if
-
-   <hr>
-   @section DLD-stats-svc-fspecs-ds Data Structures
-   - m0_stats
-   - stats_svc
-   - stats_list
-   - stats_update_fom
-   - stats_query_fom
-
-   @section DLD-stats-svc-fspecs-int-if Internal Interfaces
-   - stats_svc_rso_start()
-   - stats_svc_rso_stop()
-   - stats_svc_rso_fini()
-   - stats_svc_rsto_service_allocate()
-
-   - stats_update_fom_create()
-   - stats_update_fom_tick()
-   - stats_update_fom_home_locality()
-   - stats_update_fom_addb_init()
-   - stats_update_fom_fini()
-
-   - stats_query_fom_create()
-   - stats_query_fom_tick()
-   - stats_query_fom_home_locality()
-   - stats_query_fom_addb_init()
-   - stats_query_fom_fini()
-
-   @section DLD-stats-svc-fspecs-ext-if External Interfaces
-   - m0_stats_svc_init()
-   - m0_stats_svc_fini()
-*/
-
-#include "stats/stats_fops.h"
-#include "reqh/reqh.h"
-#include "reqh/reqh_service.h"
-#include "fop/fom_generic.h"
-
-/**
- * @defgroup stats_svc Stats Service
- * @{
- */
-#define M0_STATS_SVC_NAME "stats"
-
-extern struct m0_reqh_service_type m0_stats_svc_type;
-
-/**
- * In-memory representation of statistical information
- */
-struct m0_stats {
-	uint64_t	    s_magic;
-	/** Linkage to list of global stats object */
-	struct m0_tlink     s_linkage;
-	/** Summary record represent statistics */
-	struct m0_stats_sum s_sum;
-};
-
-/**
- * Stats service.
- */
-struct stats_svc {
-	uint64_t	       ss_magic;
-	/**
-	 * List of statistic objects.
-	 * Initially this list does not contains any stats object. As
-	 * stats_update request is recieved, stats_update FOM creates new entry
-	 * for respective stats otherwise update existing stats object.
-	 */
-	struct m0_tl           ss_stats;
-	/** Embedded request handler service object. */
-	struct m0_reqh_service ss_reqhs;
-};
-
-/**
- * Stats update fom.
- */
-struct stats_update_fom {
-	uint64_t      suf_magic;
-	struct m0_fom suf_fom;
-};
-
-enum stats_update_fom_phases {
-	STATS_UPDATE_FOM_INIT = M0_FOPH_INIT,
-	STATS_UPDATE_FOM_FINISH = M0_FOPH_FINISH,
-	STATS_UPDATE_FOM_UPDATE_OBJECT = M0_FOPH_NR + 1,
-};
-
-/*
- * Stats query fom.
- */
-struct stats_query_fom {
-	uint64_t      sqf_magic;
-	struct m0_fom sqf_fom;
-};
-
-enum stats_query_fom_phases {
-	STATS_QUERY_FOM_READ_OBJECT = M0_FOPH_NR + 1,
-};
-
-/**
- * Initialize stats service.
- */
-M0_INTERNAL int m0_stats_svc_init(void);
-
-/**
- * Finalize stats service.
- */
-M0_INTERNAL void m0_stats_svc_fini(void);
-
-#define STATS_SVC_ALLOC_PTR(ptr, loc, ctx)				      \
-	M0_ALLOC_PTR_ADDB(ptr, &m0_addb_gmc, M0_STATS_SVC_ADDB_LOC_##loc, ctx)
-
-/** @} end group stats_service */
-
-#endif /* __KERNEL__ */
-#endif /* __MERO_STATS_STATS_SVC_H_ */
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/stats/stats_srv.h~HEAD b/stats/stats_srv.h~HEAD
new file mode 100644
index 0000000..136e00e
--- /dev/null
+++ b/stats/stats_srv.h~HEAD
@@ -0,0 +1,156 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Rajanikant Chirmade <rajanikant_chirmade@xyratex.com>
+ * Original creation date: 06/14/2013
+ */
+
+#pragma once
+
+#ifndef __MERO_STATS_STATS_SVC_H__
+#define __MERO_STATS_STATS_SVC_H__
+#ifndef __KERNEL__
+
+/**
+   @page DLD-stats-svc-fspecs Functional Specification
+
+   - @ref DLD-stats-svc-fspecs-ds
+   - @ref DLD-stats-svc-fspecs-int-if
+   - @ref DLD-stats-svc-fspecs-ext-if
+
+   <hr>
+   @section DLD-stats-svc-fspecs-ds Data Structures
+   - m0_stats
+   - stats_svc
+   - stats_list
+   - stats_update_fom
+   - stats_query_fom
+
+   @section DLD-stats-svc-fspecs-int-if Internal Interfaces
+   - stats_svc_rso_start()
+   - stats_svc_rso_stop()
+   - stats_svc_rso_fini()
+   - stats_svc_rsto_service_allocate()
+
+   - stats_update_fom_create()
+   - stats_update_fom_tick()
+   - stats_update_fom_home_locality()
+   - stats_update_fom_addb_init()
+   - stats_update_fom_fini()
+
+   - stats_query_fom_create()
+   - stats_query_fom_tick()
+   - stats_query_fom_home_locality()
+   - stats_query_fom_addb_init()
+   - stats_query_fom_fini()
+
+   @section DLD-stats-svc-fspecs-ext-if External Interfaces
+   - m0_stats_svc_init()
+   - m0_stats_svc_fini()
+*/
+
+#include "stats/stats_fops.h"
+#include "reqh/reqh.h"
+#include "reqh/reqh_service.h"
+#include "fop/fom_generic.h"
+
+/**
+ * @defgroup stats_svc Stats Service
+ * @{
+ */
+#define M0_STATS_SVC_NAME "stats"
+
+extern struct m0_reqh_service_type m0_stats_svc_type;
+
+/**
+ * In-memory representation of statistical information
+ */
+struct m0_stats {
+	uint64_t	    s_magic;
+	/** Linkage to list of global stats object */
+	struct m0_tlink     s_linkage;
+	/** Summary record represent statistics */
+	struct m0_stats_sum s_sum;
+};
+
+/**
+ * Stats service.
+ */
+struct stats_svc {
+	uint64_t	       ss_magic;
+	/**
+	 * List of statistic objects.
+	 * Initially this list does not contains any stats object. As
+	 * stats_update request is recieved, stats_update FOM creates new entry
+	 * for respective stats otherwise update existing stats object.
+	 */
+	struct m0_tl           ss_stats;
+	/** Embedded request handler service object. */
+	struct m0_reqh_service ss_reqhs;
+};
+
+/**
+ * Stats update fom.
+ */
+struct stats_update_fom {
+	uint64_t      suf_magic;
+	struct m0_fom suf_fom;
+};
+
+enum stats_update_fom_phases {
+	STATS_UPDATE_FOM_INIT = M0_FOPH_INIT,
+	STATS_UPDATE_FOM_FINISH = M0_FOPH_FINISH,
+	STATS_UPDATE_FOM_UPDATE_OBJECT = M0_FOPH_NR + 1,
+};
+
+/*
+ * Stats query fom.
+ */
+struct stats_query_fom {
+	uint64_t      sqf_magic;
+	struct m0_fom sqf_fom;
+};
+
+enum stats_query_fom_phases {
+	STATS_QUERY_FOM_READ_OBJECT = M0_FOPH_NR + 1,
+};
+
+/**
+ * Initialize stats service.
+ */
+M0_INTERNAL int m0_stats_svc_init(void);
+
+/**
+ * Finalize stats service.
+ */
+M0_INTERNAL void m0_stats_svc_fini(void);
+
+#define STATS_SVC_ALLOC_PTR(ptr, loc, ctx)				      \
+	M0_ALLOC_PTR_ADDB(ptr, &m0_addb_gmc, M0_STATS_SVC_ADDB_LOC_##loc, ctx)
+
+/** @} end group stats_service */
+
+#endif /* __KERNEL__ */
+#endif /* __MERO_STATS_STATS_SVC_H_ */
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
-- 
1.8.3.2

