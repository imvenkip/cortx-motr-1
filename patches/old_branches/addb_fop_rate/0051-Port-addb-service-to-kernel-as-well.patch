From 119e51be603a181044b24df3d9fa39febd250d5e Mon Sep 17 00:00:00 2001
From: Rohan Puri <rohan_puri@xyratex.com>
Date: Mon, 2 Sep 2013 13:36:30 +0530
Subject: [PATCH 051/159] Port addb service to kernel as well.

---
 addb/Makefile.sub            |   6 +-
 addb/addb.c                  |   6 +-
 addb/addb.h                  |   9 +-
 addb/addb_monitor.c          |   4 -
 addb/addb_pfom.c             | 413 +++++++++++++++++++++++++++++++++++++++++++
 addb/addb_svc.c              | 231 ++++++++++++++++++++++++
 addb/addb_svc.h              | 106 +++++++++++
 addb/user_space/addb_pfom.c  | 413 -------------------------------------------
 addb/user_space/addb_svc.c   | 231 ------------------------
 addb/user_space/addb_svc.h   | 108 -----------
 addb/ut/addb_ut_svc.c        |   2 +-
 m0t1fs/linux_kernel/m0t1fs.c |  13 +-
 mero/init.c                  |   1 -
 13 files changed, 772 insertions(+), 771 deletions(-)
 create mode 100644 addb/addb_pfom.c
 create mode 100644 addb/addb_svc.c
 create mode 100644 addb/addb_svc.h
 delete mode 100644 addb/user_space/addb_pfom.c
 delete mode 100644 addb/user_space/addb_svc.c
 delete mode 100644 addb/user_space/addb_svc.h

diff --git a/addb/Makefile.sub b/addb/Makefile.sub
index 57383b1..c059894 100644
--- a/addb/Makefile.sub
+++ b/addb/Makefile.sub
@@ -8,7 +8,7 @@ nobase_mero_include_HEADERS += addb/addb.h \
                                addb/addb_pvt.h \
                                addb/addb_wire.h \
                                addb/addb_wire_xc.h \
-                               addb/user_space/addb_svc.h \
+                               addb/addb_svc.h \
                                addb/user_space/uctx.h
 
 mero_libmero_la_SOURCES  += addb/addb.c \
@@ -35,10 +35,10 @@ EXTRA_DIST += addb/addb_counter.c \
 	      addb/addb_ts.c \
               addb/linux_kernel/kctx.c \
               addb/user_space/addb_fom.c \
-              addb/user_space/addb_pfom.c \
+              addb/addb_pfom.c \
               addb/user_space/addb_retrieval.c \
               addb/user_space/addb_stobsink.c \
-              addb/user_space/addb_svc.c \
+              addb/addb_svc.c \
               addb/user_space/uctx.c
 
 CLEANFILES += addb/addb_fops_xc.c \
diff --git a/addb/addb.c b/addb/addb.c
index feaa937..96d0140 100644
--- a/addb/addb.c
+++ b/addb/addb.c
@@ -699,9 +699,7 @@ Plan</a> for details.
 #include "lib/misc.h"
 #include "lib/rwlock.h"
 #include "lib/time.h"
-#ifndef __KERNEL__
 #include "fop/fom_generic.h"
-#endif
 #define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_ADDB
 #include "lib/trace.h"  /* M0_LOG() */
 
@@ -769,12 +767,12 @@ static int addb_node_uuid_init(void)
 #include "addb/addb_counter.c"
 #include "addb/addb_ts.c"
 #include "addb/addb_rpcsink.c"
+#include "addb/addb_svc.c"
+#include "addb/addb_pfom.c"
 #ifdef __KERNEL__
 #include "addb/linux_kernel/kctx.c"
 #else
-#include "addb/user_space/addb_svc.c"
 #include "addb/user_space/addb_fom.c"
-#include "addb/user_space/addb_pfom.c"
 #include "addb/user_space/uctx.c"
 #include "addb/user_space/addb_stobsink.c"
 #include "addb/user_space/addb_retrieval.c"
diff --git a/addb/addb.h b/addb/addb.h
index 269e0ac..0e66318 100644
--- a/addb/addb.h
+++ b/addb/addb.h
@@ -74,6 +74,8 @@ struct m0_sm_conf;
    @{
 */
 
+#define M0_ADDB_SVC_NAME  "addb"
+
 /**
    ADDB module initializer.
  */
@@ -1590,18 +1592,15 @@ M0_INTERNAL uint32_t m0_addb_rec_rid_to_id(uint64_t rid);
    @{
  */
 
-#ifndef __KERNEL__
 /**
    ADDB service module initializer
  */
-M0_INTERNAL int m0_addb_svc_mod_init();
+M0_INTERNAL int m0_addb_svc_mod_init(void);
 
 /**
    ADDB service module finalizer
  */
-M0_INTERNAL void m0_addb_svc_mod_fini();
-
-#endif /* __KERNEL__ */
+M0_INTERNAL void m0_addb_svc_mod_fini(void);
 
 /** @} end of addb_svc group */
 
diff --git a/addb/addb_monitor.c b/addb/addb_monitor.c
index 300755b..f72dbb2 100644
--- a/addb/addb_monitor.c
+++ b/addb/addb_monitor.c
@@ -152,10 +152,6 @@
 
 #include "addb/addb_monitor.h"
 
-/**
- * @todo: Start addb service in m0tl1fs(kernel) so that addb pfom
- * can be made use of to post stats summary records periodically.
- */
 M0_TL_DESCR_DEFINE(addb_mon, "addb monitors list", M0_INTERNAL,
 		   struct m0_addb_monitor, am_linkage, am_magic,
 		   M0_ADDB_MONITOR_LIST_LINK_MAGIC,
diff --git a/addb/addb_pfom.c b/addb/addb_pfom.c
new file mode 100644
index 0000000..60c50a2
--- /dev/null
+++ b/addb/addb_pfom.c
@@ -0,0 +1,413 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Carl Braganza <carl_braganza@xyratex.com>
+ * Original creation date: 12/09/2012
+ */
+
+/**
+   @page ADDB-DLD-SVC-pstats Periodic Posting of Statistics
+   Periodic posting of statistics is done by means of a dedicated @ref fom "FOM"
+   represented by the ::addb_post_fom structure.
+   The FOM is created by the addb_pfom_start() subroutine invoked by the
+   addb_service_start() service operation.
+
+   The FOM transitions through the following phases:
+   @dot
+   digraph pstats {
+       S0 [label="Init"]
+       S1 [label="ComputeTimeout"]
+       S2 [label="Sleep"]
+       S3 [label="Post" ]
+       S4 [label="Fini" ]
+       S0 -> S1 [label="*"];
+       S1 -> S2 [label="*"];
+       S2 -> S2 [label="NotReady"];
+       S2 -> S3 [label="Ready"];
+       S2 -> S4 [label="Stopped"];
+       S3 -> S1 [label="*"];
+   }
+   @enddot
+   - The FOM starts in the Init phase then transitions to the ComputeTimeout
+   phase.  It forces the next phase to compute the next posting epoch based
+   on the current time.
+   - In the ComputeTimeout phase the FOM calculates the absolute time of the
+   next posting epoch.  The next epoch is computed relative to the previous
+   epoch so as to reduce the impact of the actual time it takes to post the
+   statistics.  However, if the current time has already advanced significantly
+   toward the next epoch, then it will compute the next epoch against current
+   time.  The latter computation is forced on the first iteration, but could
+   conceivably happen at run time because a ready FOM is subject to scheduling
+   delays.  The FOM transitions to the Sleep phase next.
+   - In the Sleep phase, it checks to see if the FOM has been shutdown, and
+   if so, will transition to the Fini phase.  If not shutdown, it checks to
+   see if the current time exceeds the next posting epoch, and if so will
+   transition to the Post phase.  Otherwise it will block the FOM until
+   the next posting epoch.
+   - The Post phase will invoke m0_reqh_stats_post_addb() to post pending
+   statistics.  It will then transition to the ComputeTimeout phase to repeat
+   the cycle.
+
+   The period of the posting fom is set on creation from the value of
+   the ::addb_pfom_period global variable.
+
+   The posting fom is launched only if the ::addb_svc_start_pfom global
+   permits.  This control is provided for unit testing.
+
+   The FOM is terminated by invoking addb_pfom_stop().  The subroutine
+   posts an AST to cancel its timer and force it to stop itself.
+ */
+
+/* This file is designed to be included by addb/addb.c */
+
+/**
+   @ingroup addb_svc_pvt
+   @{
+ */
+
+static const struct m0_bob_type addb_pfom_bob = {
+	.bt_name = "addb pfom",
+	.bt_magix_offset = M0_MAGIX_OFFSET(struct addb_post_fom, pf_magic),
+	.bt_magix = M0_ADDB_PFOM_MAGIC,
+	.bt_check = NULL
+};
+
+M0_BOB_DEFINE(static, &addb_pfom_bob, addb_post_fom);
+
+/*
+ ******************************************************************************
+ * ADDB Statistics Posting FOM Type
+ ******************************************************************************
+ */
+enum addb_pfom_phase {
+	ADDB_PFOM_PHASE_INIT  = M0_FOM_PHASE_INIT,
+	ADDB_PFOM_PHASE_FINI  = M0_FOM_PHASE_FINISH,
+	ADDB_PFOM_PHASE_CTO   = M0_FOM_PHASE_NR,
+	ADDB_PFOM_PHASE_SLEEP,
+	ADDB_PFOM_PHASE_POST,
+};
+
+static struct m0_sm_state_descr addb_pfom_state_descr[] = {
+        [ADDB_PFOM_PHASE_INIT] = {
+                .sd_flags       = M0_SDF_INITIAL,
+                .sd_name        = "Init",
+                .sd_allowed     = M0_BITS(ADDB_PFOM_PHASE_CTO)
+        },
+        [ADDB_PFOM_PHASE_CTO] = {
+                .sd_flags       = 0,
+                .sd_name        = "ComputeTimeOut",
+                .sd_allowed     = M0_BITS(ADDB_PFOM_PHASE_SLEEP)
+        },
+        [ADDB_PFOM_PHASE_SLEEP] = {
+                .sd_flags       = 0,
+                .sd_name        = "Sleep",
+                .sd_allowed     = M0_BITS(ADDB_PFOM_PHASE_POST,
+					  ADDB_PFOM_PHASE_SLEEP,
+					  ADDB_PFOM_PHASE_FINI)
+        },
+        [ADDB_PFOM_PHASE_POST] = {
+                .sd_flags       = 0,
+                .sd_name        = "Post",
+                .sd_allowed     = M0_BITS(ADDB_PFOM_PHASE_CTO)
+        },
+        [ADDB_PFOM_PHASE_FINI] = {
+                .sd_flags       = M0_SDF_TERMINAL,
+                .sd_name        = "Fini",
+                .sd_allowed     = 0
+        },
+};
+
+static struct m0_sm_conf addb_pfom_sm_conf = {
+	.scf_name = "addb-pfom-sm",
+	.scf_nr_states = ARRAY_SIZE(addb_pfom_state_descr),
+	.scf_state = addb_pfom_state_descr
+};
+
+static const struct m0_fom_type_ops addb_pfom_type_ops = {
+        .fto_create = NULL
+};
+
+static struct m0_fom_type addb_pfom_type;
+
+/*
+ ******************************************************************************
+ * ADDB Statistics Posting FOM
+ ******************************************************************************
+ */
+
+/** UT hook to track a singleton FOM */
+static bool the_addb_pfom_started;
+
+enum {
+	/**
+	   Tolerance on the posting epoch when re-computing the next epoch.
+	   The number is expressed as a fraction of the posting period.  The
+	   greater the number the narrower the tolerance.
+	 */
+	M0_ADDB_PFOM_PERIOD_FRAC_TOLERANCE = 10,
+};
+
+static bool addb_pfom_invariant(const struct addb_post_fom *pfom)
+{
+	return addb_post_fom_bob_check(pfom);
+}
+
+static void addb_pfom_fo_fini(struct m0_fom *fom)
+{
+        struct addb_post_fom   *pfom = bob_of(fom, struct addb_post_fom, pf_fom,
+					      &addb_pfom_bob);
+	struct addb_svc        *svc = container_of(pfom, struct addb_svc,
+						   as_pfom);
+	struct m0_reqh_service *rsvc = &svc->as_reqhs;
+
+	M0_ENTRY();
+
+	m0_fom_fini(fom);
+	m0_fom_timeout_fini(&pfom->pf_timeout);
+	addb_post_fom_bob_fini(pfom);
+
+	/*
+	 * Mustn't free as the fom is embedded in the service object, but
+	 * notify UT waiters.
+	 */
+	m0_mutex_lock(&rsvc->rs_mutex);
+	pfom->pf_running = false;
+	m0_cond_broadcast(&svc->as_cond);
+	the_addb_pfom_started = false;
+	M0_LOG(M0_DEBUG, "done");
+	m0_mutex_unlock(&rsvc->rs_mutex);
+}
+
+static size_t addb_pfom_fo_locality(const struct m0_fom *fom)
+{
+	return 1; // well, why not?
+}
+
+static int addb_pfom_fo_tick(struct m0_fom *fom)
+{
+        struct addb_post_fom   *pfom = bob_of(fom, struct addb_post_fom, pf_fom,
+					      &addb_pfom_bob);
+	struct addb_svc        *svc = container_of(pfom, struct addb_svc,
+						   as_pfom);
+	struct m0_reqh         *reqh = svc->as_reqhs.rs_reqh;
+	struct m0_reqh_service *rsvc = &svc->as_reqhs;
+	int                     rc = M0_FSO_AGAIN;
+	m0_time_t               now;
+	int                     err;
+	M0_ENTRY();
+
+	switch (m0_fom_phase(fom)) {
+	case ADDB_PFOM_PHASE_INIT:
+		M0_LOG(M0_DEBUG, "init");
+		m0_mutex_lock(&rsvc->rs_mutex);
+		the_addb_pfom_started = true;
+		m0_cond_broadcast(&svc->as_cond); /* for UT */
+		m0_mutex_unlock(&rsvc->rs_mutex);
+		m0_fom_phase_set(fom, ADDB_PFOM_PHASE_CTO);
+		break;
+	case ADDB_PFOM_PHASE_CTO:
+		M0_LOG(M0_DEBUG, "cto");
+		now = m0_time_now();
+		if (now < pfom->pf_next_post + pfom->pf_tolerance)
+			pfom->pf_next_post += pfom->pf_period;
+		else
+			pfom->pf_next_post = now + pfom->pf_period;
+		m0_fom_phase_set(fom, ADDB_PFOM_PHASE_SLEEP);
+		break;
+	case ADDB_PFOM_PHASE_SLEEP:
+		if (pfom->pf_shutdown) {
+			M0_LOG(M0_DEBUG, "fini");
+			m0_fom_phase_set(fom, ADDB_PFOM_PHASE_FINI);
+			rc = M0_FSO_WAIT;
+			break;
+		}
+		now = m0_time_now();
+		if (now >= pfom->pf_next_post) {
+			m0_fom_phase_set(fom, ADDB_PFOM_PHASE_POST);
+			break;
+		}
+		m0_fom_timeout_fini(&pfom->pf_timeout);
+		m0_fom_timeout_init(&pfom->pf_timeout);
+		m0_fom_timeout_wait_on(&pfom->pf_timeout, &pfom->pf_fom,
+				       pfom->pf_next_post);
+		M0_LOG(M0_DEBUG, "wait");
+		rc = M0_FSO_WAIT;
+		break;
+	case ADDB_PFOM_PHASE_POST:
+		M0_LOG(M0_DEBUG, "post");
+		m0_reqh_stats_post_addb(reqh);
+
+		err = m0_addb_monitor_summaries_post(svc->as_reqhs.rs_reqh);
+
+		/**
+		 * In case of summaries posting failure, just log error.
+		 * We do not terminate the fom.
+		 */
+		if (err != 0)
+			M0_LOG(M0_ERROR, "addb summary posting failed");
+
+		if (reqh->rh_addb_mc.am_sink->rs_skulk != NULL)
+			(*reqh->rh_addb_mc.am_sink->rs_skulk)
+				(&reqh->rh_addb_mc);
+		m0_fom_phase_set(fom, ADDB_PFOM_PHASE_CTO);
+		break;
+	default:
+		M0_IMPOSSIBLE("Phasors were not on stun!");
+	}
+
+	M0_RETURN(rc);
+}
+
+static void addb_pfom_fo_addb_init(struct m0_fom *fom, struct m0_addb_mc *mc)
+{
+        struct addb_post_fom *pfom = bob_of(fom, struct addb_post_fom, pf_fom,
+					    &addb_pfom_bob);
+	struct addb_svc      *svc = container_of(pfom, struct addb_svc,
+						 as_pfom);
+
+	M0_ADDB_CTX_INIT(mc, &fom->fo_addb_ctx, &m0_addb_ct_addb_pfom,
+			 &svc->as_reqhs.rs_addb_ctx);
+}
+
+static const struct m0_fom_ops addb_pfom_ops = {
+        .fo_fini          = addb_pfom_fo_fini,
+        .fo_tick          = addb_pfom_fo_tick,
+        .fo_home_locality = addb_pfom_fo_locality,
+	.fo_addb_init     = addb_pfom_fo_addb_init
+};
+
+/*
+ ******************************************************************************
+ * Interfaces
+ ******************************************************************************
+ */
+
+/**
+   The periodicity set at creation.
+   Mainly for UT usage but could eventually be set via config parameters.
+ */
+static m0_time_t addb_pfom_period = M0_MKTIME(M0_ADDB_DEF_STAT_PERIOD_S, 0);
+
+/**
+   Starts the statistics posting FOM.
+   @param svc The ADDB service structure. The embedded as_pfom field is the FOM.
+ */
+static void addb_pfom_start(struct addb_svc *svc)
+{
+	struct addb_post_fom *pfom = &svc->as_pfom;
+	struct m0_fom        *fom = &pfom->pf_fom;
+	struct m0_reqh       *reqh = svc->as_reqhs.rs_reqh;
+
+	M0_ENTRY();
+	M0_PRE(addb_svc_invariant(svc));
+
+	m0_rwlock_read_lock(&reqh->rh_rwlock);
+
+	addb_post_fom_bob_init(pfom);
+	M0_POST(addb_pfom_invariant(pfom));
+
+	m0_fom_init(fom, &addb_pfom_type, &addb_pfom_ops, NULL, NULL,
+		    reqh, svc->as_reqhs.rs_type);
+	m0_fom_timeout_init(&pfom->pf_timeout);
+	pfom->pf_period = addb_pfom_period;
+	pfom->pf_tolerance = pfom->pf_period
+		/ M0_ADDB_PFOM_PERIOD_FRAC_TOLERANCE;
+	pfom->pf_next_post = 0; /* force the first timeout calculation */
+	pfom->pf_running = true;
+
+        M0_PRE(m0_fom_phase(fom) == ADDB_PFOM_PHASE_INIT);
+	m0_fom_queue(fom, reqh);
+
+	m0_rwlock_read_unlock(&reqh->rh_rwlock);
+}
+
+/**
+   AST callback to safely stop the FOM.
+ */
+static void addb_pfom_stop_cb(struct m0_sm_group *grp, struct m0_sm_ast *ast)
+{
+        struct addb_post_fom *pfom = bob_of(ast, struct addb_post_fom,
+					    pf_ast, &addb_pfom_bob);
+
+	M0_LOG(M0_DEBUG, "pfom_stop_cb: %d\n", (int)pfom->pf_running);
+	if (pfom->pf_running) {
+		if (pfom->pf_timeout.to_cb.fc_fom != NULL)
+			m0_fom_timeout_cancel(&pfom->pf_timeout);
+		if (m0_fom_is_waiting(&pfom->pf_fom))
+			m0_fom_ready(&pfom->pf_fom);
+		pfom->pf_shutdown = true;
+	}
+}
+
+/**
+   Initiates the termination of the statistics posting FOM.
+   Uses the service mutex internally.
+   Blocks until the FOM terminates.
+ */
+static void addb_pfom_stop(struct addb_svc *svc)
+{
+        struct addb_post_fom   *pfom = &svc->as_pfom;
+	struct m0_fom          *fom  = &pfom->pf_fom;
+	struct m0_reqh_service *rsvc = &svc->as_reqhs;
+
+	M0_ENTRY();
+
+	M0_PRE(addb_svc_invariant(svc));
+	M0_PRE(m0_mutex_is_not_locked(&rsvc->rs_mutex));
+
+	m0_mutex_lock(&rsvc->rs_mutex);
+	if (pfom->pf_running) {
+		M0_ASSERT(addb_pfom_invariant(pfom));
+
+		M0_LOG(M0_DEBUG, "posting pfom stop ast");
+		pfom->pf_ast.sa_cb = addb_pfom_stop_cb;
+		m0_sm_ast_post(&fom->fo_loc->fl_group, &pfom->pf_ast);
+
+		M0_LOG(M0_DEBUG, "waiting for pfom to stop");
+		while (pfom->pf_running)
+			m0_cond_wait(&svc->as_cond);
+	}
+	m0_mutex_unlock(&rsvc->rs_mutex);
+}
+
+/**
+   Initializes the statistics posting FOM module.
+ */
+M0_INTERNAL int addb_pfom_mod_init(void)
+{
+	m0_fom_type_init(&addb_pfom_type, &addb_pfom_type_ops, NULL,
+			 &addb_pfom_sm_conf);
+	return 0;
+}
+
+/**
+   Finalizes the statistics posting FOM module.
+ */
+static void addb_pfom_mod_fini(void)
+{
+}
+
+/** @} end group addb_pvt */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/addb/addb_svc.c b/addb/addb_svc.c
new file mode 100644
index 0000000..9c4af4b
--- /dev/null
+++ b/addb/addb_svc.c
@@ -0,0 +1,231 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Carl Braganza <carl_braganza@xyratex.com>
+ * Original creation date: 12/09/2012
+ */
+
+/**
+   @page ADDB-DLD-SVC Service
+
+   This design relates to the ADDB service. The ADDB service provides the
+   following functionality:
+   - Periodic posting of request handler related statistical data
+   - Receipt of remote ADDB data (FUTURE)
+
+   - @ref ADDB-DLD-SVC-fspec
+   - @ref ADDB-DLD-SVC-lspec
+     - @ref ADDB-DLD-SVC-pstats "Periodic Posting of Statistics"
+
+   <hr>
+   @section ADDB-DLD-SVC-fspec Functional Specification
+   The primary data structures involved are:
+   - addb_svc
+   - addb_post_fom
+
+   The interfaces involved are:
+   - addb_pfom_mod_fini()
+   - addb_pfom_mod_init()
+   - addb_pfom_start()
+   - addb_pfom_stop()
+   - m0_addb_svc_mod_fini()
+   - m0_addb_svc_mod_init()
+
+   <hr>
+   @section ADDB-DLD-SVC-lspec Logical Specification
+   The following subsections are present:
+   - @subpage ADDB-DLD-SVC-pstats "Periodic Posting of Statistics"
+
+ */
+
+/* This file is designed to be included by addb/addb.c */
+
+#include "addb/addb_svc.h"
+
+/**
+   @ingroup addb_svc_pvt
+   @{
+ */
+
+static const struct m0_bob_type addb_svc_bob = {
+	.bt_name = "addb svc",
+	.bt_magix_offset = M0_MAGIX_OFFSET(struct addb_svc, as_magic),
+	.bt_magix = M0_ADDB_SVC_MAGIC,
+	.bt_check = NULL
+};
+
+M0_BOB_DEFINE(static, &addb_svc_bob, addb_svc);
+
+/**
+   Hook to control the launch of the statistics posting thread.
+   Mainly for UT usage but could eventually be set via config parameters.
+ */
+static bool addb_svc_start_pfom = true;
+
+/**
+   UT handle to a started singleton service.  Every instance started will
+   overwrite this without serialization.
+ */
+static struct addb_svc *the_addb_svc;
+
+/*
+ ******************************************************************************
+ * ADDB service
+ ******************************************************************************
+ */
+static bool addb_svc_invariant(const struct addb_svc *svc)
+{
+	return addb_svc_bob_check(svc);
+}
+
+/**
+   The rso_start method to start the ADDB service and launch startup time
+   FOMs.
+ */
+static int addb_svc_rso_start(struct m0_reqh_service *service)
+{
+	struct addb_svc *svc;
+
+	M0_LOG(M0_DEBUG, "starting");
+	M0_PRE(m0_reqh_service_state_get(service) == M0_RST_STARTING);
+
+	svc = bob_of(service, struct addb_svc, as_reqhs, &addb_svc_bob);
+	if (addb_svc_start_pfom)
+		addb_pfom_start(svc);
+	the_addb_svc = svc;
+	return 0;
+}
+
+/**
+   The rso_prepare_to_stop method terminates the persistent FOMs.
+ */
+static void addb_svc_rso_prepare_to_stop(struct m0_reqh_service *service)
+{
+	struct addb_svc *svc;
+
+	M0_LOG(M0_DEBUG, "preparing to stop");
+	M0_PRE(m0_reqh_service_state_get(service) == M0_RST_STOPPING);
+	svc = bob_of(service, struct addb_svc, as_reqhs, &addb_svc_bob);
+	if (addb_svc_start_pfom)
+		addb_pfom_stop(svc);
+}
+
+/**
+   The rso_stop method to stop the ADDB service.
+ */
+static void addb_svc_rso_stop(struct m0_reqh_service *service)
+{
+	M0_LOG(M0_DEBUG, "stopping");
+	M0_PRE(m0_reqh_service_state_get(service) == M0_RST_STOPPED);
+}
+
+/**
+   The rso_fini method to finalize the ADDB service.
+ */
+static void addb_svc_rso_fini(struct m0_reqh_service *service)
+{
+	struct addb_svc *svc;
+
+	M0_LOG(M0_DEBUG, "done");
+	M0_PRE(M0_IN(m0_reqh_service_state_get(service), (M0_RST_STOPPED,
+	                                                  M0_RST_FAILED)));
+	svc = bob_of(service, struct addb_svc, as_reqhs, &addb_svc_bob);
+	m0_cond_fini(&svc->as_cond);
+	addb_svc_bob_fini(svc);
+	the_addb_svc = NULL;
+	m0_free(svc);
+}
+
+static const struct m0_reqh_service_ops addb_service_ops = {
+	.rso_start           = addb_svc_rso_start,
+	.rso_prepare_to_stop = addb_svc_rso_prepare_to_stop,
+	.rso_stop            = addb_svc_rso_stop,
+	.rso_fini            = addb_svc_rso_fini
+};
+
+/*
+ ******************************************************************************
+ * ADDB service type
+ ******************************************************************************
+ */
+
+/**
+   The rsto_service_allocate method to allocate an ADDB service instance.
+ */
+static int addb_svc_rsto_service_allocate(struct m0_reqh_service **service,
+					  struct m0_reqh_service_type *stype,
+					  struct m0_reqh_context *rctx)
+{
+	struct addb_svc *svc;
+
+	M0_ALLOC_PTR(svc);
+	if (svc == NULL) {
+		M0_LOG(M0_ERROR, "Unable to allocate memory for ADDB service");
+		return -ENOMEM;
+	}
+	*service = &svc->as_reqhs;
+	(*service)->rs_type = stype;
+	(*service)->rs_ops = &addb_service_ops;
+	m0_cond_init(&svc->as_cond, &(*service)->rs_mutex);
+	addb_svc_bob_init(svc);
+
+	M0_POST(addb_svc_invariant(svc));
+
+	return 0;
+}
+
+static struct m0_reqh_service_type_ops addb_service_type_ops = {
+	.rsto_service_allocate = addb_svc_rsto_service_allocate,
+};
+
+M0_REQH_SERVICE_TYPE_DEFINE(m0_addb_svc_type, &addb_service_type_ops,
+                            M0_ADDB_SVC_NAME, &m0_addb_ct_addb_service);
+
+/** @} end group addb_svc_pvt */
+
+/*
+ ******************************************************************************
+ * Public interfaces
+ ******************************************************************************
+ */
+
+M0_INTERNAL int m0_addb_svc_mod_init(void)
+{
+	int rc;
+	rc = m0_reqh_service_type_register(&m0_addb_svc_type);
+	if (rc == 0) {
+		rc = addb_pfom_mod_init();
+		if (rc != 0)
+			m0_reqh_service_type_unregister(&m0_addb_svc_type);
+	}
+	return rc;
+}
+
+M0_INTERNAL void m0_addb_svc_mod_fini(void)
+{
+	addb_pfom_mod_fini();
+        m0_reqh_service_type_unregister(&m0_addb_svc_type);
+}
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/addb/addb_svc.h b/addb/addb_svc.h
new file mode 100644
index 0000000..11acb9e
--- /dev/null
+++ b/addb/addb_svc.h
@@ -0,0 +1,106 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Carl Braganza <carl_braganza@xyratex.com>
+ * Original creation date: 12/09/2012
+ */
+
+#pragma once
+
+#ifndef __MERO_ADDB_ADDB_SVC_H__
+#define __MERO_ADDB_ADDB_SVC_H__
+
+#include "reqh/reqh.h"
+#include "reqh/reqh_service.h"
+#ifndef __KERNEL__
+#include "mero/setup.h"
+#endif
+/**
+   @defgroup addb_svc_pvt ADDB Service Internal Interfaces
+   @ingroup addb_svc
+   @{
+ */
+
+extern struct m0_reqh_service_type m0_addb_svc_type;
+
+/**
+   ADDB statistics posting FOM
+ */
+struct addb_post_fom {
+	uint64_t              pf_magic;
+	/** Periodicity of the statistics post. */
+	m0_time_t             pf_period;
+	/** Tolerance limit in epoch calculation */
+	m0_time_t             pf_tolerance;
+	/** Next post time. */
+	m0_time_t             pf_next_post;
+	/** Shutdown request flag. */
+	bool                  pf_shutdown;
+	/** Running flag.  Used to synchronize termination. */
+	bool                  pf_running;
+	/** trap used to get into the locality to interact with the fom */
+	struct m0_sm_ast      pf_ast;
+	/** The FOM timer */
+	struct m0_fom_timeout pf_timeout;
+	/** Embedded FOM object. */
+	struct m0_fom         pf_fom;
+};
+
+/**
+ * ADDB fom created for ADDB fop
+ */
+struct addb_fom {
+	uint64_t       af_magic;
+	struct m0_fom  af_fom;
+};
+
+/**
+   ADDB request handler service
+ */
+struct addb_svc {
+	uint64_t               as_magic;
+	/**
+	   The statistics posting FOM.
+	 */
+        struct addb_post_fom   as_pfom;
+	/**
+	   Service condition variable
+	 */
+	struct m0_cond         as_cond;
+	/**
+	   Embedded request handler service object.
+	 */
+	struct m0_reqh_service as_reqhs;
+};
+
+static void addb_pfom_mod_fini(void);
+static int  addb_pfom_mod_init(void);
+static void addb_pfom_start(struct addb_svc *svc);
+static void addb_pfom_stop(struct addb_svc *svc);
+
+/** @} end group addb_svc_pvt */
+
+#endif /* __MERO_ADDB_ADDB_SVC_H__ */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/addb/user_space/addb_pfom.c b/addb/user_space/addb_pfom.c
deleted file mode 100644
index 60c50a2..0000000
--- a/addb/user_space/addb_pfom.c
+++ /dev/null
@@ -1,413 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Carl Braganza <carl_braganza@xyratex.com>
- * Original creation date: 12/09/2012
- */
-
-/**
-   @page ADDB-DLD-SVC-pstats Periodic Posting of Statistics
-   Periodic posting of statistics is done by means of a dedicated @ref fom "FOM"
-   represented by the ::addb_post_fom structure.
-   The FOM is created by the addb_pfom_start() subroutine invoked by the
-   addb_service_start() service operation.
-
-   The FOM transitions through the following phases:
-   @dot
-   digraph pstats {
-       S0 [label="Init"]
-       S1 [label="ComputeTimeout"]
-       S2 [label="Sleep"]
-       S3 [label="Post" ]
-       S4 [label="Fini" ]
-       S0 -> S1 [label="*"];
-       S1 -> S2 [label="*"];
-       S2 -> S2 [label="NotReady"];
-       S2 -> S3 [label="Ready"];
-       S2 -> S4 [label="Stopped"];
-       S3 -> S1 [label="*"];
-   }
-   @enddot
-   - The FOM starts in the Init phase then transitions to the ComputeTimeout
-   phase.  It forces the next phase to compute the next posting epoch based
-   on the current time.
-   - In the ComputeTimeout phase the FOM calculates the absolute time of the
-   next posting epoch.  The next epoch is computed relative to the previous
-   epoch so as to reduce the impact of the actual time it takes to post the
-   statistics.  However, if the current time has already advanced significantly
-   toward the next epoch, then it will compute the next epoch against current
-   time.  The latter computation is forced on the first iteration, but could
-   conceivably happen at run time because a ready FOM is subject to scheduling
-   delays.  The FOM transitions to the Sleep phase next.
-   - In the Sleep phase, it checks to see if the FOM has been shutdown, and
-   if so, will transition to the Fini phase.  If not shutdown, it checks to
-   see if the current time exceeds the next posting epoch, and if so will
-   transition to the Post phase.  Otherwise it will block the FOM until
-   the next posting epoch.
-   - The Post phase will invoke m0_reqh_stats_post_addb() to post pending
-   statistics.  It will then transition to the ComputeTimeout phase to repeat
-   the cycle.
-
-   The period of the posting fom is set on creation from the value of
-   the ::addb_pfom_period global variable.
-
-   The posting fom is launched only if the ::addb_svc_start_pfom global
-   permits.  This control is provided for unit testing.
-
-   The FOM is terminated by invoking addb_pfom_stop().  The subroutine
-   posts an AST to cancel its timer and force it to stop itself.
- */
-
-/* This file is designed to be included by addb/addb.c */
-
-/**
-   @ingroup addb_svc_pvt
-   @{
- */
-
-static const struct m0_bob_type addb_pfom_bob = {
-	.bt_name = "addb pfom",
-	.bt_magix_offset = M0_MAGIX_OFFSET(struct addb_post_fom, pf_magic),
-	.bt_magix = M0_ADDB_PFOM_MAGIC,
-	.bt_check = NULL
-};
-
-M0_BOB_DEFINE(static, &addb_pfom_bob, addb_post_fom);
-
-/*
- ******************************************************************************
- * ADDB Statistics Posting FOM Type
- ******************************************************************************
- */
-enum addb_pfom_phase {
-	ADDB_PFOM_PHASE_INIT  = M0_FOM_PHASE_INIT,
-	ADDB_PFOM_PHASE_FINI  = M0_FOM_PHASE_FINISH,
-	ADDB_PFOM_PHASE_CTO   = M0_FOM_PHASE_NR,
-	ADDB_PFOM_PHASE_SLEEP,
-	ADDB_PFOM_PHASE_POST,
-};
-
-static struct m0_sm_state_descr addb_pfom_state_descr[] = {
-        [ADDB_PFOM_PHASE_INIT] = {
-                .sd_flags       = M0_SDF_INITIAL,
-                .sd_name        = "Init",
-                .sd_allowed     = M0_BITS(ADDB_PFOM_PHASE_CTO)
-        },
-        [ADDB_PFOM_PHASE_CTO] = {
-                .sd_flags       = 0,
-                .sd_name        = "ComputeTimeOut",
-                .sd_allowed     = M0_BITS(ADDB_PFOM_PHASE_SLEEP)
-        },
-        [ADDB_PFOM_PHASE_SLEEP] = {
-                .sd_flags       = 0,
-                .sd_name        = "Sleep",
-                .sd_allowed     = M0_BITS(ADDB_PFOM_PHASE_POST,
-					  ADDB_PFOM_PHASE_SLEEP,
-					  ADDB_PFOM_PHASE_FINI)
-        },
-        [ADDB_PFOM_PHASE_POST] = {
-                .sd_flags       = 0,
-                .sd_name        = "Post",
-                .sd_allowed     = M0_BITS(ADDB_PFOM_PHASE_CTO)
-        },
-        [ADDB_PFOM_PHASE_FINI] = {
-                .sd_flags       = M0_SDF_TERMINAL,
-                .sd_name        = "Fini",
-                .sd_allowed     = 0
-        },
-};
-
-static struct m0_sm_conf addb_pfom_sm_conf = {
-	.scf_name = "addb-pfom-sm",
-	.scf_nr_states = ARRAY_SIZE(addb_pfom_state_descr),
-	.scf_state = addb_pfom_state_descr
-};
-
-static const struct m0_fom_type_ops addb_pfom_type_ops = {
-        .fto_create = NULL
-};
-
-static struct m0_fom_type addb_pfom_type;
-
-/*
- ******************************************************************************
- * ADDB Statistics Posting FOM
- ******************************************************************************
- */
-
-/** UT hook to track a singleton FOM */
-static bool the_addb_pfom_started;
-
-enum {
-	/**
-	   Tolerance on the posting epoch when re-computing the next epoch.
-	   The number is expressed as a fraction of the posting period.  The
-	   greater the number the narrower the tolerance.
-	 */
-	M0_ADDB_PFOM_PERIOD_FRAC_TOLERANCE = 10,
-};
-
-static bool addb_pfom_invariant(const struct addb_post_fom *pfom)
-{
-	return addb_post_fom_bob_check(pfom);
-}
-
-static void addb_pfom_fo_fini(struct m0_fom *fom)
-{
-        struct addb_post_fom   *pfom = bob_of(fom, struct addb_post_fom, pf_fom,
-					      &addb_pfom_bob);
-	struct addb_svc        *svc = container_of(pfom, struct addb_svc,
-						   as_pfom);
-	struct m0_reqh_service *rsvc = &svc->as_reqhs;
-
-	M0_ENTRY();
-
-	m0_fom_fini(fom);
-	m0_fom_timeout_fini(&pfom->pf_timeout);
-	addb_post_fom_bob_fini(pfom);
-
-	/*
-	 * Mustn't free as the fom is embedded in the service object, but
-	 * notify UT waiters.
-	 */
-	m0_mutex_lock(&rsvc->rs_mutex);
-	pfom->pf_running = false;
-	m0_cond_broadcast(&svc->as_cond);
-	the_addb_pfom_started = false;
-	M0_LOG(M0_DEBUG, "done");
-	m0_mutex_unlock(&rsvc->rs_mutex);
-}
-
-static size_t addb_pfom_fo_locality(const struct m0_fom *fom)
-{
-	return 1; // well, why not?
-}
-
-static int addb_pfom_fo_tick(struct m0_fom *fom)
-{
-        struct addb_post_fom   *pfom = bob_of(fom, struct addb_post_fom, pf_fom,
-					      &addb_pfom_bob);
-	struct addb_svc        *svc = container_of(pfom, struct addb_svc,
-						   as_pfom);
-	struct m0_reqh         *reqh = svc->as_reqhs.rs_reqh;
-	struct m0_reqh_service *rsvc = &svc->as_reqhs;
-	int                     rc = M0_FSO_AGAIN;
-	m0_time_t               now;
-	int                     err;
-	M0_ENTRY();
-
-	switch (m0_fom_phase(fom)) {
-	case ADDB_PFOM_PHASE_INIT:
-		M0_LOG(M0_DEBUG, "init");
-		m0_mutex_lock(&rsvc->rs_mutex);
-		the_addb_pfom_started = true;
-		m0_cond_broadcast(&svc->as_cond); /* for UT */
-		m0_mutex_unlock(&rsvc->rs_mutex);
-		m0_fom_phase_set(fom, ADDB_PFOM_PHASE_CTO);
-		break;
-	case ADDB_PFOM_PHASE_CTO:
-		M0_LOG(M0_DEBUG, "cto");
-		now = m0_time_now();
-		if (now < pfom->pf_next_post + pfom->pf_tolerance)
-			pfom->pf_next_post += pfom->pf_period;
-		else
-			pfom->pf_next_post = now + pfom->pf_period;
-		m0_fom_phase_set(fom, ADDB_PFOM_PHASE_SLEEP);
-		break;
-	case ADDB_PFOM_PHASE_SLEEP:
-		if (pfom->pf_shutdown) {
-			M0_LOG(M0_DEBUG, "fini");
-			m0_fom_phase_set(fom, ADDB_PFOM_PHASE_FINI);
-			rc = M0_FSO_WAIT;
-			break;
-		}
-		now = m0_time_now();
-		if (now >= pfom->pf_next_post) {
-			m0_fom_phase_set(fom, ADDB_PFOM_PHASE_POST);
-			break;
-		}
-		m0_fom_timeout_fini(&pfom->pf_timeout);
-		m0_fom_timeout_init(&pfom->pf_timeout);
-		m0_fom_timeout_wait_on(&pfom->pf_timeout, &pfom->pf_fom,
-				       pfom->pf_next_post);
-		M0_LOG(M0_DEBUG, "wait");
-		rc = M0_FSO_WAIT;
-		break;
-	case ADDB_PFOM_PHASE_POST:
-		M0_LOG(M0_DEBUG, "post");
-		m0_reqh_stats_post_addb(reqh);
-
-		err = m0_addb_monitor_summaries_post(svc->as_reqhs.rs_reqh);
-
-		/**
-		 * In case of summaries posting failure, just log error.
-		 * We do not terminate the fom.
-		 */
-		if (err != 0)
-			M0_LOG(M0_ERROR, "addb summary posting failed");
-
-		if (reqh->rh_addb_mc.am_sink->rs_skulk != NULL)
-			(*reqh->rh_addb_mc.am_sink->rs_skulk)
-				(&reqh->rh_addb_mc);
-		m0_fom_phase_set(fom, ADDB_PFOM_PHASE_CTO);
-		break;
-	default:
-		M0_IMPOSSIBLE("Phasors were not on stun!");
-	}
-
-	M0_RETURN(rc);
-}
-
-static void addb_pfom_fo_addb_init(struct m0_fom *fom, struct m0_addb_mc *mc)
-{
-        struct addb_post_fom *pfom = bob_of(fom, struct addb_post_fom, pf_fom,
-					    &addb_pfom_bob);
-	struct addb_svc      *svc = container_of(pfom, struct addb_svc,
-						 as_pfom);
-
-	M0_ADDB_CTX_INIT(mc, &fom->fo_addb_ctx, &m0_addb_ct_addb_pfom,
-			 &svc->as_reqhs.rs_addb_ctx);
-}
-
-static const struct m0_fom_ops addb_pfom_ops = {
-        .fo_fini          = addb_pfom_fo_fini,
-        .fo_tick          = addb_pfom_fo_tick,
-        .fo_home_locality = addb_pfom_fo_locality,
-	.fo_addb_init     = addb_pfom_fo_addb_init
-};
-
-/*
- ******************************************************************************
- * Interfaces
- ******************************************************************************
- */
-
-/**
-   The periodicity set at creation.
-   Mainly for UT usage but could eventually be set via config parameters.
- */
-static m0_time_t addb_pfom_period = M0_MKTIME(M0_ADDB_DEF_STAT_PERIOD_S, 0);
-
-/**
-   Starts the statistics posting FOM.
-   @param svc The ADDB service structure. The embedded as_pfom field is the FOM.
- */
-static void addb_pfom_start(struct addb_svc *svc)
-{
-	struct addb_post_fom *pfom = &svc->as_pfom;
-	struct m0_fom        *fom = &pfom->pf_fom;
-	struct m0_reqh       *reqh = svc->as_reqhs.rs_reqh;
-
-	M0_ENTRY();
-	M0_PRE(addb_svc_invariant(svc));
-
-	m0_rwlock_read_lock(&reqh->rh_rwlock);
-
-	addb_post_fom_bob_init(pfom);
-	M0_POST(addb_pfom_invariant(pfom));
-
-	m0_fom_init(fom, &addb_pfom_type, &addb_pfom_ops, NULL, NULL,
-		    reqh, svc->as_reqhs.rs_type);
-	m0_fom_timeout_init(&pfom->pf_timeout);
-	pfom->pf_period = addb_pfom_period;
-	pfom->pf_tolerance = pfom->pf_period
-		/ M0_ADDB_PFOM_PERIOD_FRAC_TOLERANCE;
-	pfom->pf_next_post = 0; /* force the first timeout calculation */
-	pfom->pf_running = true;
-
-        M0_PRE(m0_fom_phase(fom) == ADDB_PFOM_PHASE_INIT);
-	m0_fom_queue(fom, reqh);
-
-	m0_rwlock_read_unlock(&reqh->rh_rwlock);
-}
-
-/**
-   AST callback to safely stop the FOM.
- */
-static void addb_pfom_stop_cb(struct m0_sm_group *grp, struct m0_sm_ast *ast)
-{
-        struct addb_post_fom *pfom = bob_of(ast, struct addb_post_fom,
-					    pf_ast, &addb_pfom_bob);
-
-	M0_LOG(M0_DEBUG, "pfom_stop_cb: %d\n", (int)pfom->pf_running);
-	if (pfom->pf_running) {
-		if (pfom->pf_timeout.to_cb.fc_fom != NULL)
-			m0_fom_timeout_cancel(&pfom->pf_timeout);
-		if (m0_fom_is_waiting(&pfom->pf_fom))
-			m0_fom_ready(&pfom->pf_fom);
-		pfom->pf_shutdown = true;
-	}
-}
-
-/**
-   Initiates the termination of the statistics posting FOM.
-   Uses the service mutex internally.
-   Blocks until the FOM terminates.
- */
-static void addb_pfom_stop(struct addb_svc *svc)
-{
-        struct addb_post_fom   *pfom = &svc->as_pfom;
-	struct m0_fom          *fom  = &pfom->pf_fom;
-	struct m0_reqh_service *rsvc = &svc->as_reqhs;
-
-	M0_ENTRY();
-
-	M0_PRE(addb_svc_invariant(svc));
-	M0_PRE(m0_mutex_is_not_locked(&rsvc->rs_mutex));
-
-	m0_mutex_lock(&rsvc->rs_mutex);
-	if (pfom->pf_running) {
-		M0_ASSERT(addb_pfom_invariant(pfom));
-
-		M0_LOG(M0_DEBUG, "posting pfom stop ast");
-		pfom->pf_ast.sa_cb = addb_pfom_stop_cb;
-		m0_sm_ast_post(&fom->fo_loc->fl_group, &pfom->pf_ast);
-
-		M0_LOG(M0_DEBUG, "waiting for pfom to stop");
-		while (pfom->pf_running)
-			m0_cond_wait(&svc->as_cond);
-	}
-	m0_mutex_unlock(&rsvc->rs_mutex);
-}
-
-/**
-   Initializes the statistics posting FOM module.
- */
-M0_INTERNAL int addb_pfom_mod_init(void)
-{
-	m0_fom_type_init(&addb_pfom_type, &addb_pfom_type_ops, NULL,
-			 &addb_pfom_sm_conf);
-	return 0;
-}
-
-/**
-   Finalizes the statistics posting FOM module.
- */
-static void addb_pfom_mod_fini(void)
-{
-}
-
-/** @} end group addb_pvt */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/addb/user_space/addb_svc.c b/addb/user_space/addb_svc.c
deleted file mode 100644
index b79ca38..0000000
--- a/addb/user_space/addb_svc.c
+++ /dev/null
@@ -1,231 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Carl Braganza <carl_braganza@xyratex.com>
- * Original creation date: 12/09/2012
- */
-
-/**
-   @page ADDB-DLD-SVC Service
-
-   This design relates to the ADDB service. The ADDB service provides the
-   following functionality:
-   - Periodic posting of request handler related statistical data
-   - Receipt of remote ADDB data (FUTURE)
-
-   - @ref ADDB-DLD-SVC-fspec
-   - @ref ADDB-DLD-SVC-lspec
-     - @ref ADDB-DLD-SVC-pstats "Periodic Posting of Statistics"
-
-   <hr>
-   @section ADDB-DLD-SVC-fspec Functional Specification
-   The primary data structures involved are:
-   - addb_svc
-   - addb_post_fom
-
-   The interfaces involved are:
-   - addb_pfom_mod_fini()
-   - addb_pfom_mod_init()
-   - addb_pfom_start()
-   - addb_pfom_stop()
-   - m0_addb_svc_mod_fini()
-   - m0_addb_svc_mod_init()
-
-   <hr>
-   @section ADDB-DLD-SVC-lspec Logical Specification
-   The following subsections are present:
-   - @subpage ADDB-DLD-SVC-pstats "Periodic Posting of Statistics"
-
- */
-
-/* This file is designed to be included by addb/addb.c */
-
-#include "addb/user_space/addb_svc.h"
-
-/**
-   @ingroup addb_svc_pvt
-   @{
- */
-
-static const struct m0_bob_type addb_svc_bob = {
-	.bt_name = "addb svc",
-	.bt_magix_offset = M0_MAGIX_OFFSET(struct addb_svc, as_magic),
-	.bt_magix = M0_ADDB_SVC_MAGIC,
-	.bt_check = NULL
-};
-
-M0_BOB_DEFINE(static, &addb_svc_bob, addb_svc);
-
-/**
-   Hook to control the launch of the statistics posting thread.
-   Mainly for UT usage but could eventually be set via config parameters.
- */
-static bool addb_svc_start_pfom = true;
-
-/**
-   UT handle to a started singleton service.  Every instance started will
-   overwrite this without serialization.
- */
-static struct addb_svc *the_addb_svc;
-
-/*
- ******************************************************************************
- * ADDB service
- ******************************************************************************
- */
-static bool addb_svc_invariant(const struct addb_svc *svc)
-{
-	return addb_svc_bob_check(svc);
-}
-
-/**
-   The rso_start method to start the ADDB service and launch startup time
-   FOMs.
- */
-static int addb_svc_rso_start(struct m0_reqh_service *service)
-{
-	struct addb_svc *svc;
-
-	M0_LOG(M0_DEBUG, "starting");
-	M0_PRE(m0_reqh_service_state_get(service) == M0_RST_STARTING);
-
-	svc = bob_of(service, struct addb_svc, as_reqhs, &addb_svc_bob);
-	if (addb_svc_start_pfom)
-		addb_pfom_start(svc);
-	the_addb_svc = svc;
-	return 0;
-}
-
-/**
-   The rso_prepare_to_stop method terminates the persistent FOMs.
- */
-static void addb_svc_rso_prepare_to_stop(struct m0_reqh_service *service)
-{
-	struct addb_svc *svc;
-
-	M0_LOG(M0_DEBUG, "preparing to stop");
-	M0_PRE(m0_reqh_service_state_get(service) == M0_RST_STOPPING);
-	svc = bob_of(service, struct addb_svc, as_reqhs, &addb_svc_bob);
-	if (addb_svc_start_pfom)
-		addb_pfom_stop(svc);
-}
-
-/**
-   The rso_stop method to stop the ADDB service.
- */
-static void addb_svc_rso_stop(struct m0_reqh_service *service)
-{
-	M0_LOG(M0_DEBUG, "stopping");
-	M0_PRE(m0_reqh_service_state_get(service) == M0_RST_STOPPED);
-}
-
-/**
-   The rso_fini method to finalize the ADDB service.
- */
-static void addb_svc_rso_fini(struct m0_reqh_service *service)
-{
-	struct addb_svc *svc;
-
-	M0_LOG(M0_DEBUG, "done");
-	M0_PRE(M0_IN(m0_reqh_service_state_get(service), (M0_RST_STOPPED,
-	                                                  M0_RST_FAILED)));
-	svc = bob_of(service, struct addb_svc, as_reqhs, &addb_svc_bob);
-	m0_cond_fini(&svc->as_cond);
-	addb_svc_bob_fini(svc);
-	the_addb_svc = NULL;
-	m0_free(svc);
-}
-
-static const struct m0_reqh_service_ops addb_service_ops = {
-	.rso_start           = addb_svc_rso_start,
-	.rso_prepare_to_stop = addb_svc_rso_prepare_to_stop,
-	.rso_stop            = addb_svc_rso_stop,
-	.rso_fini            = addb_svc_rso_fini
-};
-
-/*
- ******************************************************************************
- * ADDB service type
- ******************************************************************************
- */
-
-/**
-   The rsto_service_allocate method to allocate an ADDB service instance.
- */
-static int addb_svc_rsto_service_allocate(struct m0_reqh_service **service,
-					  struct m0_reqh_service_type *stype,
-					  struct m0_reqh_context *rctx)
-{
-	struct addb_svc *svc;
-
-	M0_ALLOC_PTR(svc);
-	if (svc == NULL) {
-		M0_LOG(M0_ERROR, "Unable to allocate memory for ADDB service");
-		return -ENOMEM;
-	}
-	*service = &svc->as_reqhs;
-	(*service)->rs_type = stype;
-	(*service)->rs_ops = &addb_service_ops;
-	m0_cond_init(&svc->as_cond, &(*service)->rs_mutex);
-	addb_svc_bob_init(svc);
-
-	M0_POST(addb_svc_invariant(svc));
-
-	return 0;
-}
-
-static struct m0_reqh_service_type_ops addb_service_type_ops = {
-	.rsto_service_allocate = addb_svc_rsto_service_allocate,
-};
-
-M0_REQH_SERVICE_TYPE_DEFINE(m0_addb_svc_type, &addb_service_type_ops,
-                            M0_ADDB_SVC_NAME, &m0_addb_ct_addb_service);
-
-/** @} end group addb_svc_pvt */
-
-/*
- ******************************************************************************
- * Public interfaces
- ******************************************************************************
- */
-
-M0_INTERNAL int m0_addb_svc_mod_init()
-{
-	int rc;
-	rc = m0_reqh_service_type_register(&m0_addb_svc_type);
-	if (rc == 0) {
-		rc = addb_pfom_mod_init();
-		if (rc != 0)
-			m0_reqh_service_type_unregister(&m0_addb_svc_type);
-	}
-	return rc;
-}
-
-M0_INTERNAL void m0_addb_svc_mod_fini()
-{
-	addb_pfom_mod_fini();
-        m0_reqh_service_type_unregister(&m0_addb_svc_type);
-}
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/addb/user_space/addb_svc.h b/addb/user_space/addb_svc.h
deleted file mode 100644
index 3c2ff76..0000000
--- a/addb/user_space/addb_svc.h
+++ /dev/null
@@ -1,108 +0,0 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Carl Braganza <carl_braganza@xyratex.com>
- * Original creation date: 12/09/2012
- */
-
-#pragma once
-
-#ifndef __MERO_ADDB_ADDB_SVC_H__
-#define __MERO_ADDB_ADDB_SVC_H__
-#ifndef __KERNEL__
-
-#include "reqh/reqh.h"
-#include "reqh/reqh_service.h"
-#include "mero/setup.h"
-
-/**
-   @defgroup addb_svc_pvt ADDB Service Internal Interfaces
-   @ingroup addb_svc
-   @{
- */
-
-#define M0_ADDB_SVC_NAME  "addb"
-extern struct m0_reqh_service_type m0_addb_svc_type;
-
-/**
-   ADDB statistics posting FOM
- */
-struct addb_post_fom {
-	uint64_t              pf_magic;
-	/** Periodicity of the statistics post. */
-	m0_time_t             pf_period;
-	/** Tolerance limit in epoch calculation */
-	m0_time_t             pf_tolerance;
-	/** Next post time. */
-	m0_time_t             pf_next_post;
-	/** Shutdown request flag. */
-	bool                  pf_shutdown;
-	/** Running flag.  Used to synchronize termination. */
-	bool                  pf_running;
-	/** trap used to get into the locality to interact with the fom */
-	struct m0_sm_ast      pf_ast;
-	/** The FOM timer */
-	struct m0_fom_timeout pf_timeout;
-	/** Embedded FOM object. */
-	struct m0_fom         pf_fom;
-};
-
-/**
- * ADDB fom created for ADDB fop
- */
-struct addb_fom {
-	uint64_t       af_magic;
-	struct m0_fom  af_fom;
-};
-
-/**
-   ADDB request handler service
- */
-struct addb_svc {
-	uint64_t               as_magic;
-	/**
-	   The statistics posting FOM.
-	 */
-        struct addb_post_fom   as_pfom;
-	/**
-	   Service condition variable
-	 */
-	struct m0_cond         as_cond;
-	/**
-	   Embedded request handler service object.
-	 */
-	struct m0_reqh_service as_reqhs;
-};
-
-static void addb_pfom_mod_fini(void);
-static int  addb_pfom_mod_init(void);
-static void addb_pfom_start(struct addb_svc *svc);
-static void addb_pfom_stop(struct addb_svc *svc);
-
-/** @} end group addb_svc_pvt */
-
-#endif /* __KERNEL__ */
-#endif /* __MERO_ADDB_ADDB_SVC_H__ */
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/addb/ut/addb_ut_svc.c b/addb/ut/addb_ut_svc.c
index 03d0645..a7edb0c 100644
--- a/addb/ut/addb_ut_svc.c
+++ b/addb/ut/addb_ut_svc.c
@@ -22,7 +22,7 @@
 
 /* This file is designed to be included by addb/ut/addb_ut.c */
 
-#include "addb/user_space/addb_svc.h"
+#include "addb/addb_svc.h"
 
 #include "mero/setup.h"
 #include "net/lnet/lnet.h"
diff --git a/m0t1fs/linux_kernel/m0t1fs.c b/m0t1fs/linux_kernel/m0t1fs.c
index 94090b5..ee1b57f 100644
--- a/m0t1fs/linux_kernel/m0t1fs.c
+++ b/m0t1fs/linux_kernel/m0t1fs.c
@@ -360,7 +360,18 @@ static int m0t1fs_service_start(const char *sname)
 
 static int m0t1fs_reqh_services_start(void)
 {
-	return m0t1fs_service_start("rmservice");
+	int rc;
+
+	rc = m0t1fs_service_start(M0_ADDB_SVC_NAME);
+	if (rc)
+		goto err;
+	rc = m0t1fs_service_start("rmservice");
+	if (rc)
+		goto err;
+	M0_RETURN(rc);
+err:
+	m0t1fs_reqh_services_stop();
+	M0_RETURN(rc);
 }
 
 static void m0t1fs_reqh_services_stop(void)
diff --git a/mero/init.c b/mero/init.c
index 010d1e5..cba07c2 100644
--- a/mero/init.c
+++ b/mero/init.c
@@ -143,7 +143,6 @@ struct init_fini_call subsystem[] = {
 	{ &m0_ad_stobs_init,    &m0_ad_stobs_fini,    "ad-stob" },
 	{ &sim_global_init,     &sim_global_fini,     "desim" },
 	{ &m0_addb_svc_mod_init, &m0_addb_svc_mod_fini, "addbsvc" },
-#endif
 	{ &m0_confx_types_init, &m0_confx_types_fini, "conf-xtypes" },
 	{ &m0_conf_fops_init,   &m0_conf_fops_fini,   "conf-fops" },
 	{ &m0_addb_service_fop_init, &m0_addb_service_fop_fini, "addb_fops" },
-- 
1.8.3.2

