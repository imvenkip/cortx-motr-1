From cf42eac4f9d2db7e3006e9d8485718d42e298374 Mon Sep 17 00:00:00 2001
From: Rohan Puri <rohan_puri@xyratex.com>
Date: Thu, 17 Oct 2013 16:44:28 +0530
Subject: [PATCH 104/159] Changes summary : - 1. ADDB monitor infrastructure UT
 added. 2. Made stats_get() api non-static. 3. Fixed style issue in
 stats/stats_srv.c file.

---
 addb/ut/addb_ut.c           |   1 +
 addb/ut/addb_ut_mon_infra.c | 325 +++++++++++++++++++++++++++++++++++++++++---
 stats/stats_srv.c           |  10 +-
 stats/stats_srv.h           |   2 +
 stats/ut/stats_ut_svc.c     |   2 +-
 5 files changed, 314 insertions(+), 26 deletions(-)

diff --git a/addb/ut/addb_ut.c b/addb/ut/addb_ut.c
index a6e28de..7d23fc3 100644
--- a/addb/ut/addb_ut.c
+++ b/addb/ut/addb_ut.c
@@ -29,6 +29,7 @@
 #include "lib/semaphore.h"
 #include "lib/thread.h"
 #include "ut/ut.h"
+#include "reqh/reqh.h"
 
 /* control symbol exposure by including .c files */
 #include "addb/addb.c" /* directly pick up internal static symbols */
diff --git a/addb/ut/addb_ut_mon_infra.c b/addb/ut/addb_ut_mon_infra.c
index 49afe62..b9cfaeb 100644
--- a/addb/ut/addb_ut_mon_infra.c
+++ b/addb/ut/addb_ut_mon_infra.c
@@ -18,49 +18,312 @@
  * Original creation date: 09/30/2013
  */
 
+#include "stats/stats_srv.h"
+
 enum {
-	UT_ADDB_MON_INFRA_TS_INIT_PAGES = 16,
-	UT_ADDB_MON_INFRA_TS_MAX_PAGES  = 36,
-	UT_ADDB_MON_INFRA_TS_PAGE_SIZE  = 4096, /* bytes */
-	UT_ADDB_MON_INFRA_REC_NR = 100,
+	UT_ADDB_MON_TS_INIT_PAGES  = 16,
+	UT_ADDB_MON_TS_MAX_PAGES   = 36,
+	UT_ADDB_MON_TS_PAGE_SIZE  = 4096, /* bytes */
+	UT_ADDB_MONS_NR            = 10,
 };
 
 static char *addb_mon_infra_server_argv[] = {
 	"addb_mon_infra_ut", "-r", "-p", "-T", "linux", "-D", SERVER_DB_NAME,
 	"-S", SERVER_STOB_NAME, "-A", SERVER_ADDB_STOB_NAME,
-	"-e", SERVER_ENDPOINT, "-R", "lnet:0@lo:12345:34:1", "-s", "addb",
+	"-e", SERVER_ENDPOINT, "-R", SERVER_ENDPOINT, "-s", "addb",
 	"-s", "stats", "-w", "10"
 };
 
+struct m0_addb_monitor  ut_mon[UT_ADDB_MONS_NR];
+uint32_t                ut_mon_data_key[UT_ADDB_MONS_NR];
+struct m0_reqh         *ut_srv_reqh;
+uint32_t                stats_id[UT_ADDB_MONS_NR];
+
+struct ut_monitor_sum_data1 {
+	uint64_t umsd_field1;
+}ut_mon_sum_data1;
+
+
+struct ut_monitor_sum_data2 {
+	uint64_t umsd_field1;
+	uint64_t umsd_field2;
+}ut_mon_sum_data2;
+
+struct ut_monitor_sum_data3 {
+	uint64_t umsd_field1;
+	uint64_t umsd_field2;
+	uint64_t umsd_field3;
+}ut_mon_sum_data3;
+
+struct ut_monitor_sum_data4 {
+	uint64_t umsd_field1;
+	uint64_t umsd_field2;
+	uint64_t umsd_field3;
+	uint64_t umsd_field4;
+}ut_mon_sum_data4;
+
+struct ut_monitor_sum_data5 {
+	uint64_t umsd_field1;
+	uint64_t umsd_field2;
+	uint64_t umsd_field3;
+	uint64_t umsd_field4;
+	uint64_t umsd_field5;
+}ut_mon_sum_data5;
+
+struct ut_monitor_sum_data6 {
+	uint64_t umsd_field1;
+	uint64_t umsd_field2;
+	uint64_t umsd_field3;
+	uint64_t umsd_field4;
+	uint64_t umsd_field5;
+	uint64_t umsd_field6;
+}ut_mon_sum_data6;
+
+struct ut_monitor_sum_data7 {
+	uint64_t umsd_field1;
+	uint64_t umsd_field2;
+	uint64_t umsd_field3;
+	uint64_t umsd_field4;
+	uint64_t umsd_field5;
+	uint64_t umsd_field6;
+	uint64_t umsd_field7;
+}ut_mon_sum_data7;
+
+struct ut_monitor_sum_data8 {
+	uint64_t umsd_field1;
+	uint64_t umsd_field2;
+	uint64_t umsd_field3;
+	uint64_t umsd_field4;
+	uint64_t umsd_field5;
+	uint64_t umsd_field6;
+	uint64_t umsd_field7;
+	uint64_t umsd_field8;
+}ut_mon_sum_data8;
+
+struct ut_monitor_sum_data9 {
+	uint64_t umsd_field1;
+	uint64_t umsd_field2;
+	uint64_t umsd_field3;
+	uint64_t umsd_field4;
+	uint64_t umsd_field5;
+	uint64_t umsd_field6;
+	uint64_t umsd_field7;
+	uint64_t umsd_field8;
+	uint64_t umsd_field9;
+}ut_mon_sum_data9;
+
+
+void *mon_sum_data_arrp[] = { NULL,
+			    &ut_mon_sum_data1,
+			    &ut_mon_sum_data2,
+			    &ut_mon_sum_data3,
+			    &ut_mon_sum_data4,
+			    &ut_mon_sum_data5,
+			    &ut_mon_sum_data6,
+			    &ut_mon_sum_data7,
+			    &ut_mon_sum_data8,
+			    &ut_mon_sum_data9
+			  };
+#undef MON_DATA
+#define MON_DATA(n) mon_sum_data_arrp[n]
+
+void *dprt_arrp[] = { NULL,
+		      &m0__addb_ut_rt_dp1,
+		      &m0__addb_ut_rt_dp2,
+		      &m0__addb_ut_rt_dp3,
+		      &m0__addb_ut_rt_dp4,
+		      &m0__addb_ut_rt_dp5,
+		      &m0__addb_ut_rt_dp6,
+		      &m0__addb_ut_rt_dp7,
+		      &m0__addb_ut_rt_dp8,
+		      &m0__addb_ut_rt_dp9,
+		    };
+#undef DPRT_P
+#define DPRT_P(n) dprt_arrp[n]
+
+#undef DPRTP
+#define DPRTP(n) &m0__addb_ut_rt_dp ## n
+
+static struct m0_addb_sum_rec *ut_mon_sum_rec(const struct m0_addb_monitor *mon,
+				              struct m0_reqh               *reqh)
+{
+	struct m0_addb_sum_rec *sum_rec;
+	int                     idx;
+
+	for (idx = 1; idx < UT_ADDB_MONS_NR; ++idx) {
+		if (mon == &ut_mon[idx])
+			break;
+	}
+	sum_rec = m0_reqh_lockers_get(reqh, ut_mon_data_key[idx]);
+	M0_ASSERT(sum_rec != NULL);
+
+	return sum_rec;
+}
+
+void ut_mon_watch(const struct m0_addb_monitor *monitor,
+		  const struct m0_addb_rec     *rec,
+		  struct m0_reqh               *reqh)
+{
+	struct m0_addb_sum_rec *sum_rec;
+	int                     idx;
+
+	/* Get the index */
+	for (idx = 1; idx < UT_ADDB_MONS_NR; ++idx) {
+		if (monitor == &ut_mon[idx])
+			break;
+	}
+	M0_UT_ASSERT(idx < 10);
+
+	if (m0_addb_rec_rid_to_id(rec->ar_rid) == stats_id[idx]) {
+		m0_rwlock_read_lock(&reqh->rh_rwlock);
+		sum_rec = m0_reqh_lockers_get(reqh, ut_mon_data_key[idx]);
+		m0_rwlock_read_unlock(&reqh->rh_rwlock);
+		M0_ASSERT(sum_rec != NULL);
+		if (((struct ut_monitor_sum_data1 *)MON_DATA(idx))->umsd_field1
+		    == 0) {
+			m0_mutex_lock(&sum_rec->asr_mutex);
+			memcpy(MON_DATA(idx), rec->ar_data.au64s_data,
+			       idx * sizeof(uint64_t));
+			sum_rec->asr_dirty = true;
+			m0_mutex_unlock(&sum_rec->asr_mutex);
+		}
+	}
+}
+
+const struct m0_addb_monitor_ops ut_mon_ops = {
+	.amo_watch   = ut_mon_watch,
+	.amo_sum_rec = ut_mon_sum_rec
+};
+
+static void addb_ut_mon_init(struct m0_addb_rec_type *rtype, int idx)
+{
+	struct m0_addb_sum_rec *sum_rec;
+
+	M0_ALLOC_PTR(sum_rec);
+	M0_ASSERT(ut_srv_reqh != NULL);
+
+	M0_ASSERT(sum_rec != NULL);
+	m0_addb_monitor_init(&ut_mon[idx], &ut_mon_ops);
+	m0_addb_monitor_sum_rec_init(sum_rec, rtype,
+				     (uint64_t *)MON_DATA(idx), idx);
+	ut_mon_data_key[idx] = m0_reqh_lockers_allot();
+	m0_rwlock_write_lock(&ut_srv_reqh->rh_rwlock);
+	m0_reqh_lockers_set(ut_srv_reqh, ut_mon_data_key[idx], sum_rec);
+	m0_rwlock_write_unlock(&ut_srv_reqh->rh_rwlock);
+	m0_addb_monitor_add(ut_srv_reqh, &ut_mon[idx]);
+}
+
+static void addb_ut_mon_fini(int idx)
+{
+	struct m0_addb_sum_rec *sum_rec;
+
+	M0_ASSERT(ut_srv_reqh != NULL);
+	sum_rec = ut_mon[idx].am_ops->amo_sum_rec(&ut_mon[idx], ut_srv_reqh);
+	M0_ASSERT(sum_rec != NULL);
+
+	m0_addb_monitor_del(ut_srv_reqh, &ut_mon[idx]);
+	m0_rwlock_write_lock(&ut_srv_reqh->rh_rwlock);
+	m0_reqh_lockers_clear(ut_srv_reqh, ut_mon_data_key[idx]);
+	m0_rwlock_write_unlock(&ut_srv_reqh->rh_rwlock);
+	m0_addb_monitor_sum_rec_fini(sum_rec);
+	m0_free(sum_rec);
+	m0_addb_monitor_fini(&ut_mon[idx]);
+}
+
+static void addb_post_record(struct m0_addb_mc *mc, int idx,
+			     struct m0_addb_ctx *cv[])
+{
+	switch (idx) {
+	case 1:
+		M0_ADDB_POST(&ut_srv_reqh->rh_addb_mc, DPRTP(1), cv, 10);
+		break;
+	case 2:
+		M0_ADDB_POST(&ut_srv_reqh->rh_addb_mc, DPRTP(2), cv, 10, 20);
+		break;
+	case 3:
+		M0_ADDB_POST(&ut_srv_reqh->rh_addb_mc, DPRTP(3), cv, 10, 20,
+			     30);
+		break;
+	case 4:
+		M0_ADDB_POST(&ut_srv_reqh->rh_addb_mc, DPRTP(4), cv, 10, 20, 30,
+			     40);
+		break;
+	case 5:
+		M0_ADDB_POST(&ut_srv_reqh->rh_addb_mc, DPRTP(5), cv, 10, 20, 30,
+			     40, 50);
+		break;
+	case 6:
+		M0_ADDB_POST(&ut_srv_reqh->rh_addb_mc, DPRTP(6), cv, 10, 20, 30,
+			     40, 50, 60);
+		break;
+	case 7:
+		M0_ADDB_POST(&ut_srv_reqh->rh_addb_mc, DPRTP(7), cv, 10, 20, 30,
+			     40, 50, 60, 70);
+		break;
+	case 8:
+		M0_ADDB_POST(&ut_srv_reqh->rh_addb_mc, DPRTP(8), cv, 10, 20, 30,
+			     40, 50, 60, 70, 80);
+		break;
+	case 9:
+		M0_ADDB_POST(&ut_srv_reqh->rh_addb_mc, DPRTP(9), cv, 10, 20, 30,
+			     40, 50, 60, 70, 80, 90);
+		break;
+	default:
+		M0_UT_ASSERT(0);
+	}
+}
+
+static void addb_ut_mon_verify_stats_data(struct stats_svc * stats_srv, int idx)
+{
+	struct m0_stats *stats;
+	int              i;
+
+	stats = m0_stats_get(&stats_srv->ss_stats, stats_id[idx]);
+	M0_UT_ASSERT(stats != NULL);
+	for (i = 0; i < idx; ++i)
+		M0_UT_ASSERT(stats->s_sum.ss_data.au64s_data[i]
+			     == ((i + 1) * 10));
+}
+
 static void addb_ut_mon_infra_test(void)
 {
-	struct m0_addb_rec_type   *dp = &m0__addb_ut_rt_dp1;
+	struct m0_addb_rec_type   *dp;
 	struct m0_addb_ctx        *cv[4] = { NULL, &m0_addb_proc_ctx,
 					     &m0_addb_node_ctx, NULL };
-	struct addb_ut_fom_data    ut_data;
+	struct m0_reqh_service    *reqh_srv;
+	struct stats_svc          *stats_srv;
 	struct rpcsink            *rsink;
+	m0_time_t                  temp_time;
 	uint32_t		   rec_count;
 	int                        rc;
+	int                        i;
 
+	temp_time = addb_pfom_period;
+	addb_pfom_period = M0_MKTIME(0, 1 * 1000 * 1000 * 100);
 	sctx.rsx_argv = addb_mon_infra_server_argv;
 	start_rpc_client_and_server();
-	m0_addb_mc_init(&mc);
+	ut_srv_reqh = m0_cs_reqh_get(&sctx.rsx_mero_ctx, "stats");
 
+	reqh_srv = m0_reqh_service_find(&m0_stats_svc_type, ut_srv_reqh);
+	M0_UT_ASSERT(reqh_srv != NULL);
+	stats_srv = container_of(reqh_srv, struct stats_svc, ss_reqhs);
+
+	m0_addb_mc_init(&mc);
 	rc = m0_addb_mc_configure_rpc_sink(&mc, &cctx.rcx_rpc_machine, NULL,
-					   UT_ADDB_MON_INFRA_TS_INIT_PAGES,
-					   UT_ADDB_MON_INFRA_TS_MAX_PAGES,
-					   UT_ADDB_MON_INFRA_TS_PAGE_SIZE);
+					   UT_ADDB_MON_TS_INIT_PAGES,
+					   UT_ADDB_MON_TS_MAX_PAGES,
+					   UT_ADDB_MON_TS_PAGE_SIZE);
 	M0_UT_ASSERT(rc == 0);
 	M0_UT_ASSERT(m0_addb_mc_has_rpc_sink(&mc));
 
 	rsink = rpcsink_from_mc(&mc);
 	M0_UT_ASSERT(rsink != NULL);
 	M0_UT_ASSERT(rsink->rs_ts.at_pages.ov_vec.v_nr ==
-		     UT_ADDB_MON_INFRA_TS_INIT_PAGES);
+		     UT_ADDB_MON_TS_INIT_PAGES);
 	M0_UT_ASSERT(rsink->rs_ts.at_max_pages ==
-		     UT_ADDB_MON_INFRA_TS_MAX_PAGES);
+		     UT_ADDB_MON_TS_MAX_PAGES);
 	M0_UT_ASSERT(rsink->rs_ts.at_page_size ==
-		     UT_ADDB_MON_INFRA_TS_PAGE_SIZE);
+		     UT_ADDB_MON_TS_PAGE_SIZE);
 
 	rec_count = rec_queue_tlist_length(&rsink->rs_ts.at_rec_queue);
 	M0_UT_ASSERT(rec_count == 0);
@@ -69,22 +332,44 @@ static void addb_ut_mon_infra_test(void)
 	m0__addb_ut_ct0.act_magic = 0;
 	m0__addb_ut_ct0.act_id = addb_ct_max_id + 1;
 	m0_addb_ctx_type_register(&m0__addb_ut_ct0);
-	dp->art_magic = 0;
-	dp->art_id = addb_rt_max_id + 1;
-	m0_addb_rec_type_register(dp);
+
 	M0_ADDB_CTX_INIT(&mc, &ctx, &m0__addb_ut_ct0, &m0_addb_proc_ctx);
 	cv[0] = &ctx;
 
+	/* Register addb record types & initialize addb monitors for them */
+	for (i = 1; i < 10; ++i) {
+		dp = DPRT_P(i);
+		dp->art_magic = 0;
+		stats_id[i] = dp->art_id = addb_rt_max_id + i;
+
+		/* Register ADDB summary record type */
+		m0_addb_rec_type_register(dp);
+		(void) addb_ut_mon_init(DPRT_P(i), i);
+	}
+
+	for (i = 1; i < UT_ADDB_MONS_NR; ++i)
+		addb_post_record(&ut_srv_reqh->rh_addb_mc, i, cv);
+	m0_nanosleep(m0_time(0, 2 * 1000 * 1000 * 100), NULL);
+	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
+		addb_ut_mon_verify_stats_data(stats_srv, i);
+		addb_ut_mon_fini(i);
+	}
+
 	m0_addb_mc_fini(&mc);
 	stop_rpc_client_and_server();
 
-	M0_SET0(&ut_data);
+	/* Reset to default */
+	addb_pfom_period = temp_time;
 
 	addb_ct_tlist_del(&m0__addb_ut_ct0);
 	m0__addb_ut_ct0.act_magic = 0;
-	addb_rt_tlist_del(&m0__addb_ut_rt_dp1);
-	m0__addb_ut_rt_dp1.art_magic = 0;
+	for (i = 1; i < UT_ADDB_MONS_NR; ++i) {
+		addb_rt_tlist_del((struct m0_addb_rec_type *)DPRT_P(i));
+		((struct m0_addb_rec_type *)DPRT_P(i))->art_magic = 0;
+	}
 }
+#undef DPRTP
+#undef MON_DATA
 
 /*
  *  Local variables:
diff --git a/stats/stats_srv.c b/stats/stats_srv.c
index 00b1f25..6095cbd 100644
--- a/stats/stats_srv.c
+++ b/stats/stats_srv.c
@@ -372,7 +372,7 @@ static bool stats_invariant(const struct m0_stats *stats)
  */
 #define STATS_SUM_SIZE(sum_data) (sum_data->ss_data.au64s_nr * sizeof(uint64_t))
 
-static struct m0_stats *stats_get(struct m0_tl *stats_list, uint64_t id)
+M0_INTERNAL struct m0_stats *m0_stats_get(struct m0_tl *stats_list, uint64_t id)
 {
 	struct m0_stats *stats_obj = NULL;
 
@@ -448,8 +448,8 @@ static int stats_update(struct m0_fom *fom)
 
 	for (i = 0; i < ufop->suf_stats.sf_nr; ++i) {
 		struct m0_stats_sum *sum = &(ufop->suf_stats.sf_stats[i]);
-		struct m0_stats     *stats_obj = stats_get(&svc->ss_stats,
-							   sum->ss_id);
+		struct m0_stats     *stats_obj = m0_stats_get(&svc->ss_stats,
+							      sum->ss_id);
 
 		if (stats_obj != NULL) {
 			stats_sum_copy(sum, &stats_obj->s_sum);
@@ -499,7 +499,7 @@ static int stats_update_fom_tick(struct m0_fom *fom)
 
 	M0_PRE(fom != NULL);
 
-	switch(m0_fom_phase(fom)) {
+	switch (m0_fom_phase(fom)) {
 	case STATS_UPDATE_FOM_INIT:
 		m0_fom_phase_set(fom, STATS_UPDATE_FOM_UPDATE_OBJECT);
 		rc = M0_FSO_AGAIN;
@@ -610,7 +610,7 @@ static int read_stats(struct m0_fom *fom)
 	for (i = 0; i < qfop->sqf_ids.au64s_nr; ++i) {
 		struct m0_addb_uint64_seq *sum_data;
 		struct m0_stats           *stats_obj =
-			stats_get(&svc->ss_stats, qfop->sqf_ids.au64s_data[i]);
+			m0_stats_get(&svc->ss_stats, qfop->sqf_ids.au64s_data[i]);
 
 		/* Continue getting stats for next id */
 		if (stats_obj == NULL) {
diff --git a/stats/stats_srv.h b/stats/stats_srv.h
index 136e00e..0e347a0 100644
--- a/stats/stats_srv.h
+++ b/stats/stats_srv.h
@@ -138,6 +138,8 @@ M0_INTERNAL int m0_stats_svc_init(void);
  */
 M0_INTERNAL void m0_stats_svc_fini(void);
 
+M0_INTERNAL struct m0_stats *m0_stats_get(struct m0_tl *stats_list, uint64_t id);
+
 #define STATS_SVC_ALLOC_PTR(ptr, loc, ctx)				      \
 	M0_ALLOC_PTR_ADDB(ptr, &m0_addb_gmc, M0_STATS_SVC_ADDB_LOC_##loc, ctx)
 
diff --git a/stats/ut/stats_ut_svc.c b/stats/ut/stats_ut_svc.c
index 3dcd885..9b0ffc4 100644
--- a/stats/ut/stats_ut_svc.c
+++ b/stats/ut/stats_ut_svc.c
@@ -112,7 +112,7 @@ void check_stats(struct m0_tl *stats_list, int count)
 	int id;
 
 	for (i = 0, id = 1; i < count; ++i, ++id) {
-		struct m0_stats *stats = stats_get(stats_list, id);
+		struct m0_stats *stats = m0_stats_get(stats_list, id);
 		M0_UT_ASSERT(stats != NULL);
 
 		check_summary_data(&stats_sum[i].ss_data,
-- 
1.8.3.2

