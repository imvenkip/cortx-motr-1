From 2dfa4033b71f50357c461db8557e3743a8589861 Mon Sep 17 00:00:00 2001
From: Yuriy Umanets <yuriy_umanets@xyratex.com>
Date: Wed, 23 Feb 2011 06:50:32 -0700
Subject: [PATCH 09/91] - killed "mds" module. As Nikita said we will have the
 same service for mds and io; - fixes in c2_cob_nsrec (comments and remove
 uid/gid/mode fields); - generated files md_u.c md_u.h should be at the
 beginning of sources list. They may be needed by some sources in local dir; -
 basic implementation of c2_md_store_{create|unlink|open|close}(), more stabs
 for the rest.

---
 Makefile.am         |   3 +-
 cob/cob.h           |  41 ++++++-----
 configure.ac        |   1 -
 mds/Makefile.am     |   6 --
 mds/mds.c           |  12 ----
 mdstore/Makefile.am |   2 +-
 mdstore/md.c        |   5 --
 mdstore/mdstore.c   | 197 ++++++++++++++++++++++++++++++++--------------------
 8 files changed, 150 insertions(+), 117 deletions(-)
 delete mode 100644 mds/Makefile.am
 delete mode 100644 mds/mds.c

diff --git a/Makefile.am b/Makefile.am
index a32276f..9ac7df8 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -6,12 +6,11 @@ SUBDIRS_LIBS = lib addb fol db fid fop sm stob net fid dtm nrs sns mw reqh \
                layout pool balloc desim cob capa udb site mdstore datastore # rpc
 
 SUBDIR_KERNEL = build_kernel_modules
-SUBDIR_BINARIES = mds utils
 SUBDIR_UT = fop/ut lib/ut stob/ut layout/ut balloc/ut db/ut \
             fol/ut sns/ut desim/ut cob/ut net/ut net/st udb/ut capa/ut #rpc/ut
 SUBDIR_ST = 
 SUBDIR_UB = 
-SUBDIR_BIN = utils mds
+SUBDIR_BIN = utils
 
 SUBDIRS    = $(SUBDIRS_BASE) $(SUBDIRS_LIBS) colibri $(SUBDIR_KERNEL) \
              $(SUBDIR_UT) $(SUBDIR_ST) $(SUBDIR_UB) $(SUBDIR_BIN)
diff --git a/cob/cob.h b/cob/cob.h
index 0f5fc06..3d1bb2e 100644
--- a/cob/cob.h
+++ b/cob/cob.h
@@ -98,23 +98,32 @@ int c2_cob_nskey_size(const struct c2_cob_nskey *);
 
 struct c2_cob_nsrec {
         struct c2_stob_id cnr_stobid;
-        uint32_t          cnr_dev;     /** ID of device containing file. */
-        uint64_t          cnr_ino;     /** inode number. */
-        uint32_t          cnr_mode;    /** protection. */
-        uint32_t          cnr_nlink;   /** number of hard links. */
-        uint32_t          cnr_uid;     /** user ID of owner. */
-        uint32_t          cnr_gid;     /** group ID of owner. */
-        uint32_t          cnr_sid;     /** stream id performed modification. */
-        uint32_t          cnr_nid;     /** node id performed modification. */
-        uint32_t          cnr_rdev;    /** device ID (if special file). */
-        uint64_t          cnr_size;    /** total size, in bytes. */
-        uint32_t          cnr_blksize; /** blocksize for filesystem I/O. */
-        uint32_t          cnr_blocks;  /** number of blocks allocated. */
-        uint32_t          cnr_atime;   /** time of last access. */
-        uint32_t          cnr_mtime;   /** time of last modification. */
-        uint32_t          cnr_ctime;   /** time of last status change. */
-};
+        uint32_t          cnr_dev;     /*< ID of device containing file. */
+        uint64_t          cnr_ino;     /*< inode number. */
+        uint32_t          cnr_nlink;   /*< number of hard links. */
+        uint32_t          cnr_omgid;   /*< uid/gid/mode reference */
+
+        /** 
+           @todo: these are to be migrated to another struct as 
+           described by metadata scheme.
+        */
+#if 0
+        uint32_t          cnr_mode;    /*< protection. */
+        uint32_t          cnr_uid;     /*< user ID of owner. */
+        uint32_t          cnr_gid;     /*< group ID of owner. */
+#endif
 
+        uint32_t          cnr_sid;     /*< stream id performed modification. */
+        uint32_t          cnr_nid;     /*< node id performed modification. */
+
+        uint32_t          cnr_rdev;    /*< device ID (if special file). */
+        uint64_t          cnr_size;    /*< total size, in bytes. */
+        uint32_t          cnr_blksize; /*< blocksize for filesystem I/O. */
+        uint32_t          cnr_blocks;  /*< number of blocks allocated. */
+        uint32_t          cnr_atime;   /*< time of last access. */
+        uint32_t          cnr_mtime;   /*< time of last modification. */
+        uint32_t          cnr_ctime;   /*< time of last status change. */
+};
 
 /** Object index table */
 struct c2_cob_oikey {
diff --git a/configure.ac b/configure.ac
index f86131a..4c86f69 100755
--- a/configure.ac
+++ b/configure.ac
@@ -508,7 +508,6 @@ AC_CONFIG_FILES([
                  lib/ut/Makefile
                  m4/Makefile
                  man/Makefile
-                 mds/Makefile
                  mw/Makefile
                  net/Makefile
                  net/ksunrpc/Makefile
diff --git a/mds/Makefile.am b/mds/Makefile.am
deleted file mode 100644
index 6dd9753..0000000
--- a/mds/Makefile.am
+++ /dev/null
@@ -1,6 +0,0 @@
-sbin_PROGRAMS = mds
-
-mds_SOURCES   = mds.c
-mds_LDADD     = $(top_builddir)/colibri/libcolibri.la
-
-INCLUDES      = -I. -I$(top_srcdir) -I$(top_srcdir)/include
diff --git a/mds/mds.c b/mds/mds.c
deleted file mode 100644
index 91e882d..0000000
--- a/mds/mds.c
+++ /dev/null
@@ -1,12 +0,0 @@
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include "lib/cdefs.h"
-#include "dtm/dtm.h"
-
-int main(int argc, char *argv[])
-{
-	return 0;
-}
-
diff --git a/mdstore/Makefile.am b/mdstore/Makefile.am
index 00714e3..379ef67 100644
--- a/mdstore/Makefile.am
+++ b/mdstore/Makefile.am
@@ -10,7 +10,7 @@ md_u.h md_u.c: md.ff \
 
 
 noinst_LTLIBRARIES             = libcolibri-mdstore.la
-libcolibri_mdstore_la_SOURCES  = mdstore.c mdstore.h md_u.c md_u.h md.h md.c
+libcolibri_mdstore_la_SOURCES  = md_u.c md_u.h mdstore.c mdstore.h md.h md.c
 INCLUDES                       = -I. -I$(top_srcdir) -I$(top_srcdir)/include
 
 EXTRA_DIST                     = md.ff
diff --git a/mdstore/md.c b/mdstore/md.c
index 45bc469..6beed11 100644
--- a/mdstore/md.c
+++ b/mdstore/md.c
@@ -31,11 +31,6 @@ static struct c2_fop_type_ops c2_md_store_ops = {
 	.fto_free    = c2_md_store_fop_free
 };
 
-/**
-   Free some fop fields according to fop type and free fop itself.
-   We use ->fto_free for this, which may be not right but so far
-   it looks best way.
- */
 static void c2_md_store_fop_free(struct c2_fop *fop)
 {
         struct c2_fop_create *create;
diff --git a/mdstore/mdstore.c b/mdstore/mdstore.c
index 7a67cd4..4cd09ba 100644
--- a/mdstore/mdstore.c
+++ b/mdstore/mdstore.c
@@ -16,6 +16,8 @@
 #include "fop/fop.h"
 #include "cob/cob.h"
 
+#include "mdstore/md_u.h"
+
 #include "mdstore.h"
 
 int c2_md_store_init(struct c2_md_store *md, struct c2_cob_domain_id *id,
@@ -33,8 +35,7 @@ void c2_md_store_fini(struct c2_md_store *md)
         c2_cob_domain_fini(&md->md_cob);
 }
 
-#if 0
-static void c2_fop_fid2stobid(struct c2_stob_id *id, struct c2_fop_fid *fid)
+static void fid2stobid(struct c2_stob_id *id, struct c2_fop_fid *fid)
 {
         id->si_bits.u_hi = fid->f_seq;
         id->si_bits.u_lo = fid->f_oid;
@@ -46,48 +47,61 @@ static void make_nskey(struct c2_cob_nskey **keyh, struct c2_fop_fid *fid,
         struct c2_cob_nskey *key;
 
         key = c2_alloc(sizeof(*key) + name->n_count);
-        lustre_fid2stobid(&key->cnk_pfid, fid);
+        fid2stobid(&key->cnk_pfid, fid);
         memcpy(c2_bitstring_buf_get(&key->cnk_name), 
                name->n_name, name->n_count);
         c2_bitstring_len_set(&key->cnk_name, name->n_count);
         *keyh = key;
 }
 
-static int cob_create(struct c2_cob_domain *dom, struct c2_fop_create *cr,
-                      struct c2_db_tx *tx)
+static int c2_md_store_check_perm(struct c2_md_store *md, struct c2_fop *fop, 
+                                  struct c2_fop_ctx *ctx)
 {
-        struct c2_fop_body    *body = &cr->c_body;
+        /** 
+           @todo: this to check permissions for operation described by 
+           fop and ctx.
+        */
+        return 0;
+}
+
+int c2_md_store_create(struct c2_md_store *md, struct c2_fop *fop,
+                       struct c2_fop_ctx *ctx)
+{
+        struct c2_fop_create  *create = c2_fop_data(fop);
+        struct c2_fop_body    *body = &create->c_body;
         struct c2_cob         *cob;
         struct c2_cob_nskey   *key;
         struct c2_cob_nsrec    nsrec;
         struct c2_cob_fabrec   fabrec;
         int                    rc;
+        
+        rc = c2_md_store_check_perm(md, fop, ctx);
+        if (rc)
+                return rc;
 
-        make_nskey(&key, &body->b_pfid, &cr->c_name);
-        c2_fop_fid2stobid(&nsrec.cnr_stobid, &body->b_tfid);
+        make_nskey(&key, &body->b_pfid, &create->c_name);
+        fid2stobid(&nsrec.cnr_stobid, &body->b_tfid);
 
+        nsrec.cnr_dev = md->md_cob.cd_id.id;
+        nsrec.cnr_nlink = 1;
+        nsrec.cnr_ino = 0;
+        
         /** 
-           @todo: Let it be domain id so far, may be useful. 
+           @todo: to be later handled in another way according to
+           metadata scheme. Apparently omgid should be allocated
+           here and set to ->cnr_omgid for reference.
         */
-        nsrec.cnr_dev = dom->cd_id.id;
-
-        /**
-           @todo: do we need ino?
-        */
-        nsrec.cnr_ino = 0;
+        nsrec.cnr_omgid = 0;
 
-        nsrec.cnr_nlink = 1;
+#if 0
         nsrec.cnr_uid = body->b_uid;
         nsrec.cnr_gid = body->b_gid;
+        nsrec.cnr_mode = body->b_mode;
+#endif
+        
         nsrec.cnr_sid = body->b_sid;
         nsrec.cnr_nid = body->b_nid;
 
-        /**
-           Will be used for replicating. Others are not enoguh
-           to create objects right.
-        */
-        nsrec.cnr_mode = body->b_mode;
-        
         /** 
            @todo: do we need rdev support for specil files in
            replicator? 
@@ -95,7 +109,7 @@ static int cob_create(struct c2_cob_domain *dom, struct c2_fop_create *cr,
         nsrec.cnr_rdev = 0;
         
         /** 
-           @todo: needs to be fixed. Before data replication
+           @todo: these need to be fixed. Before data replication
            we don't need them.
         */
         nsrec.cnr_size = 0;
@@ -103,91 +117,121 @@ static int cob_create(struct c2_cob_domain *dom, struct c2_fop_create *cr,
         nsrec.cnr_blocks = 0;
 
         /** 
-           @todo: needs to be fixed. We do have 64 bit time stamp
-           in changelog rec and can use it. Still it may be not
-           needed as on target fs these fields may be updated in
-           create time.
+           @todo: these need to be fixed. We do have 64 bit time
+           stamp in changelog rec and can use it. Still it may be
+           not needed as on target fs these fields may be updated
+           in create time.
         */
         nsrec.cnr_atime = 0;
         nsrec.cnr_mtime = 0;
         nsrec.cnr_ctime = 0;
 
-        rc = c2_cob_create(dom, key, &nsrec, &fabrec, 0, &cob, tx);
+        rc = c2_cob_create(&md->md_cob, key, &nsrec, &fabrec, 0, &cob, 
+                           ctx->ft_tx);
         c2_cob_put(cob);
         c2_free(key);
 
         return rc;
 }
 
-static int cob_unlink(struct c2_cob_domai *dom, struct c2_fop_unlink *ul,
-                      struct c2_db_tx *tx)
+int c2_md_store_unlink(struct c2_md_store *md, struct c2_fop *fop,
+                       struct c2_fop_ctx *ctx)
 {
-        struct c2_stob_id  sid;
-        struct c2_cob     *cob;
-        int                rc;
+        struct c2_fop_unlink *unlink = c2_fop_data(fop);
+        struct c2_fop_body   *body = &unlink->u_body;
+        struct c2_stob_id     stobid;
+        struct c2_cob        *cob;
+        int                   rc;
+    
+        /** @todo: handle hardlinks */    
+        rc = c2_md_store_check_perm(md, fop, ctx);
+        if (rc)
+                return rc;
         
-        c2_fop_fid2stobid(&sid, &ul->u_body.b_tfid);
-        rc = c2_cob_locate(dom, &sid, &cob, tx);
+        fid2stobid(&stobid, &body->b_tfid);
+        rc = c2_cob_locate(&md->md_cob, &stobid, &cob, ctx->ft_tx);
         if (rc)
                 return rc;
-        cob->cnr_nlink--;
-        rc = c2_cob_delete(cob, tx);
-        c2_cob_put(cob);
+
+        rc = c2_cob_delete(cob, ctx->ft_tx);
         return rc;
 }
-#endif
 
-int c2_md_store_link(struct c2_md_store *md, struct c2_fop *fop, 
+int c2_md_store_open(struct c2_md_store *md, struct c2_fop *fop,
                      struct c2_fop_ctx *ctx)
 {
-        struct c2_fop_link *link;
+        struct c2_fop_open   *open = c2_fop_data(fop);
+        struct c2_fop_body   *body = &open->o_body;
+        struct c2_stob_id     stobid;
+        struct c2_cob        *cob;
+        int                   rc;
         
-        link = c2_fop_data(fop);
-        return 0;
-}
-
-int c2_md_store_unlink(struct c2_md_store *md, struct c2_fop *fop,
-                       struct c2_fop_ctx *ctx)
-{
-        struct c2_fop_unlink *unlink;
-
-        unlink = c2_fop_data(fop);
-        return 0;
-}
-
-int c2_md_store_rename(struct c2_md_store *md, struct c2_fop *fop,
-                       struct c2_fop_ctx *ctx)
-{
-        struct c2_fop_rename *rename;
-
-        rename = c2_fop_data(fop);
-        return 0;
+        rc = c2_md_store_check_perm(md, fop, ctx);
+        if (rc)
+                return rc;
+        
+        fid2stobid(&stobid, &body->b_tfid);
+        rc = c2_cob_locate(&md->md_cob, &stobid, &cob, ctx->ft_tx);
+        if (rc)
+                return rc;
+        
+        c2_cob_put(cob);
+        return rc;
 }
 
-int c2_md_store_create(struct c2_md_store *md, struct c2_fop *fop,
-                       struct c2_fop_ctx *ctx)
+int c2_md_store_close(struct c2_md_store *md, struct c2_fop *fop,
+                      struct c2_fop_ctx *ctx)
 {
-        struct c2_fop_create *create;
-
-        create = c2_fop_data(fop);
-        return 0;
+        struct c2_fop_close  *close = c2_fop_data(fop);
+        struct c2_fop_body   *body = &close->c_body;
+        struct c2_stob_id     stobid;
+        struct c2_cob        *cob;
+        int                   rc;
+        
+        rc = c2_md_store_check_perm(md, fop, ctx);
+        if (rc)
+                return rc;
+        
+        fid2stobid(&stobid, &body->b_tfid);
+        rc = c2_cob_locate(&md->md_cob, &stobid, &cob, ctx->ft_tx);
+        if (rc)
+                return rc;
+    
+        /**
+           @todo:
+           - orphans handling?
+           - quota handling?
+        */
+        
+        c2_cob_put(cob);
+        return rc;
 }
 
-int c2_md_store_open(struct c2_md_store *md, struct c2_fop *fop,
+int c2_md_store_link(struct c2_md_store *md, struct c2_fop *fop, 
                      struct c2_fop_ctx *ctx)
 {
-        struct c2_fop_open *open;
+        struct c2_fop_link *link;
+        int rc;
+        
+        rc = c2_md_store_check_perm(md, fop, ctx);
+        if (rc)
+                return rc;
         
-        open = c2_fop_data(fop);
+        link = c2_fop_data(fop);
         return 0;
 }
 
-int c2_md_store_close(struct c2_md_store *md, struct c2_fop *fop,
-                      struct c2_fop_ctx *ctx)
+int c2_md_store_rename(struct c2_md_store *md, struct c2_fop *fop,
+                       struct c2_fop_ctx *ctx)
 {
-        struct c2_fop_close *close;
+        struct c2_fop_rename *rename;
+        int rc;
         
-        close = c2_fop_data(fop);
+        rc = c2_md_store_check_perm(md, fop, ctx);
+        if (rc)
+                return rc;
+
+        rename = c2_fop_data(fop);
         return 0;
 }
 
@@ -195,6 +239,11 @@ int c2_md_store_setattr(struct c2_md_store *md, struct c2_fop *fop,
                         struct c2_fop_ctx *ctx)
 {
         struct c2_fop_setattr *setattr;
+        int rc;
+        
+        rc = c2_md_store_check_perm(md, fop, ctx);
+        if (rc)
+                return rc;
         
         setattr = c2_fop_data(fop);
         return 0;
-- 
1.8.3.2

