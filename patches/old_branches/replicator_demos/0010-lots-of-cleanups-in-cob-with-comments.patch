From 850bf806dc3e9f60f667bd57c723b6bc7944108a Mon Sep 17 00:00:00 2001
From: Yuriy Umanets <yuriy_umanets@xyratex.com>
Date: Thu, 24 Feb 2011 09:31:03 -0700
Subject: [PATCH 10/91] - lots of cleanups in cob with comments; - fixed missed
 c2_free(key) in cob/ut/cob.c; - fixed error paths in cob where it tried to
 c2_cob_put(*out) for cases that out was not set; - re-written c2_cob_create()
 to use c2_cob_link() and support hardlinks; - implemented c2_cob_link() that
 supports hardlinks; - implemented c2_cob_unlink() that supports hardlinks and
 handles all the cases with statdata migtation, etc; - kill file attrbutes for
 last link; - added sid and nid to file attributes; - killed c2_cob_delete()
 it is now part of c2_cob_unlink(); - fixed description of c2_table_update();
 - rename test_delete() to test_unlink() in cobd/ut; - use new cob APIs in
 mdstore for implementing link, unlink, create; - move C2_FOP_ md operations
 to mdstore.h.

---
 cob/cob.c         | 435 ++++++++++++++++++++++++++++++++++++++++++------------
 cob/cob.h         |  67 +++++----
 cob/ut/cob.c      |  10 +-
 db/db.h           |   3 +-
 fop/fop.h         |  12 --
 mdstore/mdstore.c |  90 ++++++-----
 mdstore/mdstore.h |  12 ++
 7 files changed, 462 insertions(+), 167 deletions(-)

diff --git a/cob/cob.c b/cob/cob.c
index 96b3c28..54358ac 100644
--- a/cob/cob.c
+++ b/cob/cob.c
@@ -226,22 +226,21 @@ static int cob_alloc(struct c2_cob_domain *dom, struct c2_cob **out)
 }
 
 static int cob_ns_lookup(struct c2_cob *cob, struct c2_db_tx *tx);
-
 static int cob_oi_lookup(struct c2_cob *cob, struct c2_db_tx *tx);
-
 static int cob_fab_lookup(struct c2_cob *cob, struct c2_db_tx *tx);
 
-/** Search for a record in the namespace table
+/** 
+   Search for a record in the namespace table
 
-    If the lookup fails, we return error and co_valid accurately reflects
-    the missing fields.
+   If the lookup fails, we return error and co_valid accurately reflects
+   the missing fields.
 
-    @see cob_oi_lookup
+   @see cob_oi_lookup
  */
 static int cob_ns_lookup(struct c2_cob *cob, struct c2_db_tx *tx)
 {
         struct c2_db_pair pair;
-        int rc;
+        int               rc;
 
         c2_db_pair_setup(&pair, &cob->co_dom->cd_namespace,
 			 cob->co_nskey, c2_cob_nskey_size(cob->co_nskey),
@@ -260,29 +259,30 @@ static int cob_ns_lookup(struct c2_cob *cob, struct c2_db_tx *tx)
 }
 
 /**
- Search for a record in the object index table.
- Most likely we want stat data for a given fid, so let's do that as well.
+   Search for a record in the object index table.
+   Most likely we want stat data for a given fid, so let's do that as well.
 
- @see cob_ns_lookup
+   @see cob_ns_lookup
  */
 static int cob_oi_lookup(struct c2_cob *cob, struct c2_db_tx *tx)
 {
         struct c2_cob_oikey oikey;
         int rc;
 
+        /** Don't need to lookup anything if nskey is already here. */
         if (cob->co_valid & CA_NSKEY)
-                /* Don't need to lookup anything if nskey is already here */
                 return 0;
 
         oikey.cok_stobid = cob->co_stobid;
         oikey.cok_linkno = 0;
 
-        /* Find the name from the object index table.
-           Note the key buffer is out of scope outside of this function,
-           but the record is good until c2_db_pair_fini. */
+        /** 
+           Find the name from the object index table. Note the key buffer
+           is out of scope outside of this function, but the record is good
+           until c2_db_pair_fini. 
+        */
         c2_db_pair_setup(&cob->co_oipair, &cob->co_dom->cd_object_index,
-			 &oikey, sizeof oikey,
-                         NULL, 0);
+			 &oikey, sizeof oikey, NULL, 0);
         rc = c2_table_lookup(tx, &cob->co_oipair);
         c2_db_pair_release(&cob->co_oipair);
         if (rc) {
@@ -297,9 +297,11 @@ static int cob_oi_lookup(struct c2_cob *cob, struct c2_db_tx *tx)
         return 0;
 }
 
-/** Search for a record in the fileattr_basic table
-  @see cob_ns_lookup
-  @see cob_oi_lookup
+/** 
+   Search for a record in the fileattr_basic table.
+
+   @see cob_ns_lookup
+   @see cob_oi_lookup
  */
 static int cob_fab_lookup(struct c2_cob *cob, struct c2_db_tx *tx)
 {
@@ -334,13 +336,15 @@ static int cob_cache_nscheck(struct c2_cob_domain *dom,
                              const struct c2_cob_nskey *nskey,
                              struct c2_cob **out)
 {
-        /* @todo implement a cache for cobs and check if the cob with this
-         nskey is in the cache */
+        /** 
+           @todo implement a cache for cobs and check if the cob with
+           this nskey is in the cache. 
+        */
         return -ENOENT;
 }
 
 /**
-   Lookup a filename in the namespace table
+   Lookup a filename in the namespace table.
 
    Check if cached first; otherwise create a new cob and populate it with
    the contents of the namespace record; i.e. the stat data and fid.
@@ -360,14 +364,15 @@ int c2_cob_lookup(struct c2_cob_domain *dom, struct c2_cob_nskey *nskey,
 
         rc = cob_cache_nscheck(dom, nskey, out);
         if (rc == 0) {
-                /* Cached, we took ref above. But we do need to free nskey
-                 if they asked */
+                /** 
+                   Cached, we took ref above. But we do need to free nskey
+                   if they asked. 
+                */
                 if (need & CA_NSKEY_FREE)
                         c2_free(nskey);
                 return 0;
         }
 
-        /* Get cob memory */
         rc = cob_alloc(dom, &cob);
         if (rc)
                 return rc;
@@ -379,12 +384,14 @@ int c2_cob_lookup(struct c2_cob_domain *dom, struct c2_cob_nskey *nskey,
                 return rc;
         }
 
+        /** Otherwise we can't assume NSKEY will stick around */
         if (need & CA_NSKEY_FREE)
-        /* Otherwise we can't assume NSKEY will stick around */
                 cob->co_valid |= CA_NSKEY | CA_NSKEY_FREE;
 
-        /* Get the fabrec here too if needed.  co_valid will be set
-         correctly inside the call so we can ignore the return code */
+        /** 
+           Get the fabrec here too if needed.  co_valid will be set
+           correctly inside the call so we can ignore the return code. 
+        */
         if (need & CA_FABREC)
                 cob_fab_lookup(cob, tx);
 
@@ -401,8 +408,10 @@ int c2_cob_lookup(struct c2_cob_domain *dom, struct c2_cob_nskey *nskey,
 static int cob_cache_oicheck(struct c2_cob_domain *dom,
                              const struct c2_stob_id *id, struct c2_cob **out)
 {
-        /* @todo implement a cache for cobs and check if the cob with this
-         oi is in the cache */
+        /** 
+           @todo: implement a cache for cobs and check if the cob with this
+           oi is in the cache. 
+        */
         return -ENOENT;
 }
 
@@ -426,7 +435,7 @@ int c2_cob_locate(struct c2_cob_domain *dom, const struct c2_stob_id *id,
         if (rc == 0) /* cached, took ref */
                 return 0;
 
-        /* Get cob memory */
+        /** Get cob memory. */
         rc = cob_alloc(dom, &cob);
         if (rc)
                 return rc;
@@ -438,7 +447,7 @@ int c2_cob_locate(struct c2_cob_domain *dom, const struct c2_stob_id *id,
                 return rc;
         }
 
-        /* Let's assume we want to lookup these up as well */
+        /** Let's assume we want to lookup these up as well. */
         cob_ns_lookup(cob, tx);
         cob_fab_lookup(cob, tx);
 
@@ -449,53 +458,106 @@ int c2_cob_locate(struct c2_cob_domain *dom, const struct c2_stob_id *id,
 C2_ADDB_EV_DEFINE(cob_eexist, "md_exists", 0x1, C2_ADDB_INVAL);
 
 /**
-   Add a new cob to the namespace.
-
-   This doesn't create a new stob; just creates metadata table entries
-   for it.
-
-   This takes a reference on the cob in-memory struct.
- */
-int c2_cob_create(struct c2_cob_domain *dom,
-                  struct c2_cob_nskey  *nskey,
-                  struct c2_cob_nsrec  *nsrec,
-                  struct c2_cob_fabrec *fabrec,
-                  uint64_t              need,
-                  struct c2_cob       **out,
-                  struct c2_db_tx      *tx)
+   Add a new cob name to the namespace. This takes a reference on 
+   the cob in-memory struct.
+   
+   @todo: Update {a|c|m}time in pfid and tfid
+*/
+int c2_cob_link(struct c2_cob_domain *dom,
+                struct c2_cob_nskey  *nskey,
+                struct c2_cob_nsrec  *nsrec,
+                uint64_t              need,
+                struct c2_cob       **out,
+                struct c2_db_tx      *tx)
 {
         struct c2_cob      *cob;
+        struct c2_cob      *cob0;
         struct c2_cob_oikey oikey;
         struct c2_db_pair   pair;
-	int rc;
+        int                 nlink;
+	int                 rc;
 
         C2_PRE(nskey != NULL);
         C2_PRE(nsrec != NULL);
-        C2_PRE(fabrec != NULL);
 	C2_PRE(c2_stob_id_is_set(&nsrec->cnr_stobid));
         C2_PRE(c2_stob_id_is_set(&nskey->cnk_pfid));
-        C2_PRE(nsrec->cnr_nlink == 1);
 
-        /* Get cob memory */
         rc = cob_alloc(dom, &cob);
         if (rc)
                 return rc;
 
-        /* Populate the cob */
-
         cob->co_nskey = nskey;
-        /* Take over nskey memory management from caller */
+
+        /** Take over nskey memory management from caller. */
         if (need & CA_NSKEY_FREE)
                 cob->co_valid |= CA_NSKEY | CA_NSKEY_FREE;
 
-        /* Add to object index table.  Table insert should fail if
-           already exists. */
-        /* Fid in object index key is the child fid of nsrec */
+        /** 
+           Check if this create case (no "zero" statdaat cob exists) 
+        */
+        if (nsrec->cnr_nlink > 0) {
+                /** 
+                   Let's find zero statdata, we will need it. 
+                */
+                rc = c2_cob_locate(dom, &nsrec->cnr_stobid, &cob0, tx);
+                if (rc)
+                        goto out_free;
+
+                /** 
+                   This is one more name for an existing file, its linkno
+                   is the same as number of links before bumping it. 
+                */
+                nsrec->cnr_linkno = cob0->co_nsrec.cnr_nlink;
+
+                /** 
+                   Bump ->cnr_nlink and use _old_ value for the key in object
+                   index later.
+                */
+                nlink = cob0->co_nsrec.cnr_nlink++;
+                
+                /** 
+                   Now let's update cob0 stat data on storage with new nlink
+                   value.
+                */
+                c2_db_pair_setup(&pair, &cob0->co_dom->cd_namespace,
+			         cob0->co_nskey, c2_cob_nskey_size(cob0->co_nskey),
+			         &cob0->co_nsrec, sizeof cob0->co_nsrec);
+                rc = c2_table_update(tx, &pair);
+	        c2_db_pair_release(&pair);
+	        c2_db_pair_fini(&pair);
+                c2_cob_put(cob0);
+	        if (rc)
+	                goto out_free;
+	} else {
+	        /** 
+	           Zero nlink for zero statdata key and +1 nlink for 
+	           statdata itself.
+	        */
+	        nlink = nsrec->cnr_nlink++;
+
+                /**
+                   This is first name, its linkno == 0. 
+                */
+                nsrec->cnr_linkno = 0;
+	}
+
+        /** 
+           We use child stobid for a key. 
+        */
         oikey.cok_stobid = nsrec->cnr_stobid;
-        oikey.cok_linkno = 0;
+        
+        /** 
+           Use new nlink value for the key in object index. 
+        */
+        oikey.cok_linkno = nlink;
+
+        /** 
+           Add to object index table. Table insert should fail if
+           already exists. 
+        */
         c2_db_pair_setup(&pair, &dom->cd_object_index,
-			 &oikey, sizeof oikey,
-			 cob->co_nskey, c2_cob_nskey_size(cob->co_nskey));
+			 &oikey, sizeof oikey, cob->co_nskey, 
+			 c2_cob_nskey_size(cob->co_nskey));
 
         rc = c2_table_insert(tx, &pair);
         c2_db_pair_release(&pair);
@@ -503,11 +565,15 @@ int c2_cob_create(struct c2_cob_domain *dom,
 	if (rc)
                 goto out_free;
 
-        /* Cache the nsrec */
+        /** Cache the nsrec. */
         cob->co_nsrec = *nsrec;
         cob->co_valid |= CA_NSREC;
 
-        /* Add to namespace table */
+        /** 
+           Add to namespace table. Content of ->co_nsrec is not important
+           with only exception for stobid. Meaningful statdata is stored
+           in "zero" namespace entry.
+        */
         c2_db_pair_setup(&pair, &dom->cd_namespace,
 			 cob->co_nskey, c2_cob_nskey_size(cob->co_nskey),
 			 &cob->co_nsrec, sizeof cob->co_nsrec);
@@ -517,12 +583,57 @@ int c2_cob_create(struct c2_cob_domain *dom,
 	c2_db_pair_fini(&pair);
 	if (rc)
                 goto out_free;
+                
+        *out = cob;
+	return 0;
+
+out_free:
+        c2_cob_put(cob);
+        C2_ADDB_ADD(&dom->cd_addb, &cob_addb_loc, cob_eexist, rc);
+        return rc;
+}
+
+/**
+   Add a new cob to the namespace.
+
+   This doesn't create a new stob; just creates metadata table entries
+   for it.
 
-        /* Cache the fabrec */
+   This takes a reference on the cob in-memory struct.
+ */
+int c2_cob_create(struct c2_cob_domain *dom,
+                  struct c2_cob_nskey  *nskey,
+                  struct c2_cob_nsrec  *nsrec,
+                  struct c2_cob_fabrec *fabrec,
+                  uint64_t              need,
+                  struct c2_cob       **out,
+                  struct c2_db_tx      *tx)
+{
+        struct c2_cob      *cob;
+        struct c2_db_pair   pair;
+	int                 rc;
+
+        C2_PRE(fabrec != NULL);
+        
+        /** 
+           No first statdata exists, nlink should be 0! 
+        */
+        C2_PRE(nsrec->cnr_nlink == 0);
+
+        /**
+           Let's create name, statdata and object index.
+        */
+        rc = c2_cob_link(dom, nskey, nsrec, need, &cob, tx);
+        if (rc)
+                return rc;
+
+        /** 
+           Now let's update file attributes. Cache the fabrec. 
+        */
         cob->co_fabrec = *fabrec;
         cob->co_valid |= CA_FABREC;
 
-        /* Add to filattr-basic table */
+        /** Add to filattr-basic table. */
         c2_db_pair_setup(&pair, &dom->cd_fileattr_basic,
 			 &cob->co_stobid, sizeof cob->co_stobid,
 			 &cob->co_fabrec, sizeof cob->co_fabrec);
@@ -537,7 +648,7 @@ int c2_cob_create(struct c2_cob_domain *dom,
 	return 0;
 
 out_free:
-        c2_cob_put(*out);
+        c2_cob_put(cob);
         C2_ADDB_ADD(&dom->cd_addb, &cob_addb_loc, cob_eexist, rc);
         return rc;
 }
@@ -551,30 +662,20 @@ static bool c2_cob_is_valid(struct c2_cob *cob)
 C2_ADDB_EV_DEFINE(cob_delete, "md_delete", 0x2, C2_ADDB_FLAG);
 
 /**
-   Delete the metadata for this cob.
-
-   Caller must be holding a reference on this cob, which
-   will be released here.
-
-   @todo right now we don't handle hardlinks
+   Unlink last link, kill statdata, file attrs, etc.
  */
-int c2_cob_delete(struct c2_cob *cob, struct c2_db_tx *tx)
+static int c2_cob_unlink_last(struct c2_cob *cob, struct c2_db_tx *tx)
 {
         struct c2_cob_oikey oikey;
-        struct c2_db_pair pair;
-        int rc;
-
-        C2_PRE(c2_cob_is_valid(cob));
-
-        /* We need the name key */
-        rc = cob_oi_lookup(cob, tx);
-        if (rc)
-                goto out;
-        C2_POST(cob->co_valid & CA_NSKEY);
+        struct c2_db_pair   pair;
+        int                  rc;
 
-        /* Remove from the object index table */
+        /** 
+           Remove from the object index table. 
+        */
         oikey.cok_stobid = cob->co_stobid;
         oikey.cok_linkno = 0;
+        
         c2_db_pair_setup(&pair, &cob->co_dom->cd_object_index,
 			 &oikey, sizeof oikey,
 			 NULL, 0);
@@ -582,35 +683,187 @@ int c2_cob_delete(struct c2_cob *cob, struct c2_db_tx *tx)
         c2_db_pair_release(&pair);
 	c2_db_pair_fini(&pair);
         if (rc)
-                goto out;
+                return rc;
 
-        /* Remove from the namespace table */
+        /** 
+           Remove from the namespace table. 
+        */
         c2_db_pair_setup(&pair, &cob->co_dom->cd_namespace,
 			 cob->co_nskey, c2_cob_nskey_size(cob->co_nskey),
 			 NULL, 0);
         rc = c2_table_delete(tx, &pair);
         c2_db_pair_release(&pair);
 	c2_db_pair_fini(&pair);
-#if 0
-        /* Remove from the fileattr_basic table */
+
+        /** 
+           Remove from the fileattr_basic table. 
+        */
         c2_db_pair_setup(&pair, &cob->co_dom->cd_fileattr_basic,
 			 &cob->co_stobid, sizeof cob->co_stobid,
 			 NULL, 0);
-        /* ignore errors; it's a dangling table entry but causes no harm */
+        
+        /** 
+           Ignore errors; it's a dangling table entry but causes no harm. 
+        */
         c2_table_delete(tx, &pair);
         c2_db_pair_release(&pair);
 	c2_db_pair_fini(&pair);
-#endif
+        return rc;
+}
 
+/**
+   Delete name, update nlink and kill statdata if last nlink.
+   
+   cob   - stat data (zero name) cob;
+   nskey - name to kill (may be the name of statdata)
+   tx    - transcation handle
+*/
+int c2_cob_unlink(struct c2_cob        *cob, 
+                  struct c2_cob_nskey  *nskey,
+                  struct c2_db_tx      *tx)
+{
+        struct c2_db_cursor cursor;
+        struct c2_cob_nsrec nsrec;
+        struct c2_cob_nskey nkey;
+        struct c2_cob_oikey oikey;
+        struct c2_db_pair   pair;
+        int                 nlink;
+        int                 rc;
+
+        C2_PRE(c2_cob_is_valid(cob));
+
+        /** 
+           We need the name key. 
+        */
+        rc = cob_oi_lookup(cob, tx);
+        if (rc)
+                goto out;
+        C2_POST(cob->co_valid & CA_NSKEY);
+
+        /**
+           Passed cob is zero name holding statdata one. Let's check 
+           its nlink.
+        */
+        C2_PRE(cob->co_nsrec.cnr_nlink > 0);
+        nlink = cob->co_nsrec.cnr_nlink--;
+
+        /** 
+           Last nlink, let's all everything. 
+        */
+        if (nlink == 0) {
+                rc = c2_cob_unlink_last(cob, tx);
+                goto out;
+        }
+                
+        /**
+           Lookup name that will be killed in namespace to check if 
+           this is statdata one or not. 
+        */
+        c2_db_pair_setup(&pair, &cob->co_dom->cd_namespace,
+	                 nskey, c2_cob_nskey_size(nskey),
+		         &nsrec, sizeof nsrec);
+        rc = c2_table_lookup(tx, &pair);
+        c2_db_pair_release(&pair);
+        c2_db_pair_fini(&pair);
+        if (rc)
+                goto out;
+
+        /** 
+           Statdata name should always have linkno == 0. Other names
+           have linkno > 0.
+        */
+        if (nsrec.cnr_linkno == 0) {
+                /** 
+                   This is first enrty, let's move statdata to next 
+                   existing name. Let's find a name. 
+                */
+                rc = c2_db_cursor_init(&cursor, 
+                                       &cob->co_dom->cd_object_index, tx);
+                if (rc)
+                        goto out;
+
+                oikey.cok_stobid = cob->co_stobid;
+                        
+                /** 
+                   We want to move statdata to next name, this is 
+                   something with linkno > 0. Let's put 1 and cursor
+                   will find closest one.
+                */
+                oikey.cok_linkno = 1;
+
+                c2_db_pair_setup(&pair, &cob->co_dom->cd_object_index,
+	                         &oikey, sizeof oikey, &nkey, sizeof nkey);
+
+                rc = c2_db_cursor_get(&cursor, &pair);
+                if (rc)
+                        goto out;
+
+                c2_db_cursor_fini(&cursor);
+
+                /**
+                   Now let's move statdata itself using found namespace
+                   key and nsrec from cob. Note that nlink-- is realdy
+                   done above.
+                */
+                c2_db_pair_setup(&pair, &cob->co_dom->cd_namespace,
+		                 &nkey, sizeof nkey, &cob->co_nsrec, 
+		                 sizeof cob->co_nsrec);
+                rc = c2_table_update(tx, &pair);
+                c2_db_pair_release(&pair);
+                c2_db_pair_fini(&pair);
+                if (rc)
+                        goto out;
+
+                /**
+                   Time to kill the name whatever it was.
+                */
+                c2_db_pair_setup(&pair, &cob->co_dom->cd_namespace,
+	                         nskey, c2_cob_nskey_size(nskey),
+		                 NULL, 0);
+                rc = c2_table_delete(tx, &pair);
+                c2_db_pair_release(&pair);
+                c2_db_pair_fini(&pair);
+                if (rc)
+                        goto out;
+
+                /** 
+                   Let's also kill object index entry. Note that we use
+                   nsrec.linkno from nsrec found by name key. This allows
+                   to kill object index entry without a loop.
+                */
+                oikey.cok_stobid = cob->co_stobid;
+                oikey.cok_linkno = nsrec.cnr_linkno;
+
+                c2_db_pair_setup(&pair, &cob->co_dom->cd_object_index,
+	                         &oikey, sizeof oikey, NULL, 0);
+                rc = c2_table_delete(tx, &pair);
+                c2_db_pair_release(&pair);
+                c2_db_pair_fini(&pair);
+        } else {
+                /**
+                   Let's update statdata on storage to make sure that
+                   nlink-- is there.
+                */
+                c2_db_pair_setup(&pair, &cob->co_dom->cd_namespace,
+	                         cob->co_nskey, c2_cob_nskey_size(cob->co_nskey),
+	                         &cob->co_nsrec, sizeof cob->co_nsrec);
+                rc = c2_table_update(tx, &pair);
+                c2_db_pair_release(&pair);
+                c2_db_pair_fini(&pair);
+                if (rc)
+                        goto out;
+        }
+                
 out:
-        /* If the op failed, assume we're not going to do anything else about
-           it, so log and drop in all cases. */
+        /** 
+           If the op failed, assume we're not going to do anything else about
+           it, so log and drop in all cases. 
+        */
         C2_ADDB_ADD(&cob->co_dom->cd_addb, &cob_addb_loc, cob_delete, rc == 0);
         c2_cob_put(cob);
         return rc;
 }
 
-
 /** @} end group cob */
 
 /*
diff --git a/cob/cob.h b/cob/cob.h
index 3d1bb2e..6ce8215 100644
--- a/cob/cob.h
+++ b/cob/cob.h
@@ -86,7 +86,8 @@ int c2_cob_domain_init(struct c2_cob_domain *dom, struct c2_dbenv *env,
 void c2_cob_domain_fini(struct c2_cob_domain *dom);
 
 
-/** Namespace table
+/** 
+   Namespace table.
    For data objects, pfid = cfid and name = ""
  */
 struct c2_cob_nskey {
@@ -98,31 +99,29 @@ int c2_cob_nskey_size(const struct c2_cob_nskey *);
 
 struct c2_cob_nsrec {
         struct c2_stob_id cnr_stobid;
-        uint32_t          cnr_dev;     /*< ID of device containing file. */
-        uint64_t          cnr_ino;     /*< inode number. */
-        uint32_t          cnr_nlink;   /*< number of hard links. */
-        uint32_t          cnr_omgid;   /*< uid/gid/mode reference */
+        uint32_t          cnr_linkno;  /**< number of link for the name */
+
+        uint64_t          cnr_ino;     /**< inode number. */
+        uint32_t          cnr_nlink;   /**< number of hard links. */
+        uint64_t          cnr_omgid;   /**< uid/gid/mode slot reference */
 
         /** 
            @todo: these are to be migrated to another struct as 
            described by metadata scheme.
         */
 #if 0
-        uint32_t          cnr_mode;    /*< protection. */
-        uint32_t          cnr_uid;     /*< user ID of owner. */
-        uint32_t          cnr_gid;     /*< group ID of owner. */
+        uint32_t          cnr_mode;    /**< protection. */
+        uint32_t          cnr_uid;     /**< user ID of owner. */
+        uint32_t          cnr_gid;     /**< group ID of owner. */
 #endif
 
-        uint32_t          cnr_sid;     /*< stream id performed modification. */
-        uint32_t          cnr_nid;     /*< node id performed modification. */
-
-        uint32_t          cnr_rdev;    /*< device ID (if special file). */
-        uint64_t          cnr_size;    /*< total size, in bytes. */
-        uint32_t          cnr_blksize; /*< blocksize for filesystem I/O. */
-        uint32_t          cnr_blocks;  /*< number of blocks allocated. */
-        uint32_t          cnr_atime;   /*< time of last access. */
-        uint32_t          cnr_mtime;   /*< time of last modification. */
-        uint32_t          cnr_ctime;   /*< time of last status change. */
+        uint32_t          cnr_rdev;    /**< device ID (if special file). */
+        uint64_t          cnr_size;    /**< total size, in bytes. */
+        uint32_t          cnr_blksize; /**< blocksize for filesystem I/O. */
+        uint32_t          cnr_blocks;  /**< number of blocks allocated. */
+        uint32_t          cnr_atime;   /**< time of last access. */
+        uint32_t          cnr_mtime;   /**< time of last modification. */
+        uint32_t          cnr_ctime;   /**< time of last status change. */
 };
 
 /** Object index table */
@@ -147,7 +146,9 @@ struct c2_cob_oikey {
     from smaller name-space entries.
  */
 struct c2_cob_fabrec {
-        struct c2_verno cfb_version; /**< version from last fop */
+        struct c2_verno   cfb_version; /**< version from last fop */
+        uint32_t          cfb_sid;     /**< stream id performed modification. */
+        uint32_t          cfb_nid;     /**< node id performed modification. */
         /* add ACL, layout_ref, any other md not needed for stat(2) */
 };
 
@@ -256,14 +257,26 @@ int c2_cob_create(struct c2_cob_domain *dom,
                   struct c2_db_tx      *tx);
 
 /**
-   Delete the metadata for this cob.
-
-   Caller must be holding a reference on this cob, which
-   will be released here.
-
-   This does not affect the underlying stob.
- */
-int c2_cob_delete(struct c2_cob *cob, struct c2_db_tx *tx);
+   Create name, object index and update nlink in "zero" statdata. Outcome
+   is the same as for c2_cob_create().
+*/
+int c2_cob_link(struct c2_cob_domain *dom,
+                struct c2_cob_nskey  *nskey,
+                struct c2_cob_nsrec  *nsrec,
+                uint64_t              need,
+                struct c2_cob       **out,
+                struct c2_db_tx      *tx);
+                
+/**
+   Delete name, update nlink and kill statdata if last nlink.
+   
+   cob   - stat data (zero name) cob;
+   nskey - name to kill (may be the name of statdata)
+   tx    - transcation handle
+*/
+int c2_cob_unlink(struct c2_cob       *cob, 
+                  struct c2_cob_nskey *nskey,
+                  struct c2_db_tx     *tx);
 
 /**
    Acquires an additional reference on the object.
diff --git a/cob/ut/cob.c b/cob/ut/cob.c
index 45bff57..ebeea3f 100644
--- a/cob/ut/cob.c
+++ b/cob/ut/cob.c
@@ -109,6 +109,7 @@ static void test_lookup(void)
         C2_UT_ASSERT(cob->co_valid & CA_NSKEY);
 
         c2_cob_put(cob);
+        c2_free(key);
 }
 
 static int test_locate_internal(void)
@@ -146,9 +147,10 @@ static void test_locate(void)
         c2_cob_put(cob);
 }
 
-static void test_delete(void)
+static void test_unlink(void)
 {
         struct c2_db_tx      tx;
+        struct c2_cob_nskey *key;
 
         /* gets ref */
         rc = test_locate_internal();
@@ -156,9 +158,11 @@ static void test_delete(void)
 
         c2_db_tx_init(&tx, dom.cd_dbenv, 0);
         /* drops ref */
-        rc = c2_cob_delete(cob, &tx);
+        make_nskey(&key, 0x123, 0x456, "hello world");
+        rc = c2_cob_unlink(cob, key, &tx);
         c2_db_tx_commit(&tx);
 	C2_UT_ASSERT(rc == 0);
+        c2_free(key);
 
         /* should fail now */
         rc = test_locate_internal();
@@ -174,7 +178,7 @@ const struct c2_test_suite cob_ut = {
                 { "cob-create", test_create },
                 { "cob-lookup", test_lookup },
                 { "cob-locate", test_locate },
-                { "cob-delete", test_delete },
+                { "cob-unlink", test_unlink },
 		{ "cob-fini", test_fini },
 		{ NULL, NULL }
 	}
diff --git a/db/db.h b/db/db.h
index c789f74..a6dd1c6 100644
--- a/db/db.h
+++ b/db/db.h
@@ -319,7 +319,8 @@ void c2_db_tx_waiter_add(struct c2_db_tx *tx, struct c2_db_tx_waiter *w);
 int c2_table_insert(struct c2_db_tx *tx, struct c2_db_pair *pair);
 
 /**
-   Updates (key, rec) pair into table as part of transaction tx.
+   Updates record to rec from pair for (key, rec) pair into table 
+   as part of transaction tx.
  */
 int c2_table_update(struct c2_db_tx *tx, struct c2_db_pair *pair);
 
diff --git a/fop/fop.h b/fop/fop.h
index 32399f3..8a1764d 100644
--- a/fop/fop.h
+++ b/fop/fop.h
@@ -82,18 +82,6 @@ void c2_fop_type_fini(struct c2_fop_type *fopt);
 int  c2_fop_type_build_nr(struct c2_fop_type **fopt, int nr);
 void c2_fop_type_fini_nr(struct c2_fop_type **fopt, int nr);
 
-enum c2_fop_metadata_code {
-        C2_FOP_FIRST,
-        C2_FOP_CREATE = C2_FOP_FIRST,
-        C2_FOP_LINK,
-        C2_FOP_UNLINK,
-        C2_FOP_RENAME,
-        C2_FOP_OPEN,
-        C2_FOP_CLOSE,
-        C2_FOP_SETATTR,
-        C2_FOP_LAST
-};
-
 /**
    Per-fop environment.
 */
diff --git a/mdstore/mdstore.c b/mdstore/mdstore.c
index 4cd09ba..d055f57 100644
--- a/mdstore/mdstore.c
+++ b/mdstore/mdstore.c
@@ -82,9 +82,12 @@ int c2_md_store_create(struct c2_md_store *md, struct c2_fop *fop,
         make_nskey(&key, &body->b_pfid, &create->c_name);
         fid2stobid(&nsrec.cnr_stobid, &body->b_tfid);
 
-        nsrec.cnr_dev = md->md_cob.cd_id.id;
-        nsrec.cnr_nlink = 1;
-        nsrec.cnr_ino = 0;
+        /**
+           Create case, nlink == 0, will be bumped by c2_cob_create()
+           where needed.
+        */
+        nsrec.cnr_nlink = 0;
+        nsrec.cnr_ino = 0;//c2_fid_flatten(&body->b_tfid);
         
         /** 
            @todo: to be later handled in another way according to
@@ -93,14 +96,9 @@ int c2_md_store_create(struct c2_md_store *md, struct c2_fop *fop,
         */
         nsrec.cnr_omgid = 0;
 
-#if 0
-        nsrec.cnr_uid = body->b_uid;
+        /*nsrec.cnr_uid = body->b_uid;
         nsrec.cnr_gid = body->b_gid;
-        nsrec.cnr_mode = body->b_mode;
-#endif
-        
-        nsrec.cnr_sid = body->b_sid;
-        nsrec.cnr_nid = body->b_nid;
+        nsrec.cnr_mode = body->b_mode;*/
 
         /** 
            @todo: do we need rdev support for specil files in
@@ -126,6 +124,12 @@ int c2_md_store_create(struct c2_md_store *md, struct c2_fop *fop,
         nsrec.cnr_mtime = 0;
         nsrec.cnr_ctime = 0;
 
+        C2_SET0(&fabrec);
+        
+        /** @todo: Update fabrec version. */
+        fabrec.cfb_sid = body->b_sid;
+        fabrec.cfb_nid = body->b_nid;
+
         rc = c2_cob_create(&md->md_cob, key, &nsrec, &fabrec, 0, &cob, 
                            ctx->ft_tx);
         c2_cob_put(cob);
@@ -134,26 +138,60 @@ int c2_md_store_create(struct c2_md_store *md, struct c2_fop *fop,
         return rc;
 }
 
+int c2_md_store_link(struct c2_md_store *md, struct c2_fop *fop, 
+                     struct c2_fop_ctx *ctx)
+{
+        struct c2_fop_link    *link = c2_fop_data(fop);
+        struct c2_fop_body    *body = &link->l_body;
+        struct c2_cob         *cob;
+        struct c2_cob_nskey   *key;
+        struct c2_cob_nsrec    nsrec;
+        int                    rc;
+        
+        rc = c2_md_store_check_perm(md, fop, ctx);
+        if (rc)
+                return rc;
+
+        /**
+           Let's zero out statdata. We don't need it, moreover,
+           ->nlink should be 0 for links, this is how unlink
+           can understand if it tries to kill link or statdata
+           itself. In latter case it needs to be move statdata
+           to en existing name of the file.
+        */
+        C2_SET0(&nsrec);
+        make_nskey(&key, &body->b_pfid, &link->l_name);
+        fid2stobid(&nsrec.cnr_stobid, &body->b_tfid);
+        
+        rc = c2_cob_link(&md->md_cob, key, &nsrec, 0, &cob, 
+                         ctx->ft_tx);
+        c2_cob_put(cob);
+        c2_free(key);
+        return rc;
+}
+
 int c2_md_store_unlink(struct c2_md_store *md, struct c2_fop *fop,
                        struct c2_fop_ctx *ctx)
 {
-        struct c2_fop_unlink *unlink = c2_fop_data(fop);
-        struct c2_fop_body   *body = &unlink->u_body;
-        struct c2_stob_id     stobid;
-        struct c2_cob        *cob;
-        int                   rc;
+        struct c2_fop_unlink  *unlink = c2_fop_data(fop);
+        struct c2_fop_body    *body = &unlink->u_body;
+        struct c2_stob_id      stobid;
+        struct c2_cob_nskey   *key;
+        struct c2_cob         *cob;
+        int                    rc;
     
-        /** @todo: handle hardlinks */    
         rc = c2_md_store_check_perm(md, fop, ctx);
         if (rc)
                 return rc;
         
+        make_nskey(&key, &body->b_pfid, &unlink->u_name);
         fid2stobid(&stobid, &body->b_tfid);
         rc = c2_cob_locate(&md->md_cob, &stobid, &cob, ctx->ft_tx);
         if (rc)
                 return rc;
 
-        rc = c2_cob_delete(cob, ctx->ft_tx);
+        rc = c2_cob_unlink(cob, key, ctx->ft_tx);
+        c2_free(key);
         return rc;
 }
 
@@ -199,28 +237,14 @@ int c2_md_store_close(struct c2_md_store *md, struct c2_fop *fop,
     
         /**
            @todo:
-           - orphans handling?
-           - quota handling?
+             - orphans handling?
+             - quota handling?
         */
         
         c2_cob_put(cob);
         return rc;
 }
 
-int c2_md_store_link(struct c2_md_store *md, struct c2_fop *fop, 
-                     struct c2_fop_ctx *ctx)
-{
-        struct c2_fop_link *link;
-        int rc;
-        
-        rc = c2_md_store_check_perm(md, fop, ctx);
-        if (rc)
-                return rc;
-        
-        link = c2_fop_data(fop);
-        return 0;
-}
-
 int c2_md_store_rename(struct c2_md_store *md, struct c2_fop *fop,
                        struct c2_fop_ctx *ctx)
 {
diff --git a/mdstore/mdstore.h b/mdstore/mdstore.h
index adc63b4..c7d78fb 100644
--- a/mdstore/mdstore.h
+++ b/mdstore/mdstore.h
@@ -42,6 +42,18 @@ int c2_md_store_setattr(struct c2_md_store *md, struct c2_fop *fop,
 void c2_md_store_fop_fini(void);
 int c2_md_store_fop_init(void);
 
+enum c2_fop_metadata_code {
+        C2_FOP_FIRST,
+        C2_FOP_CREATE = C2_FOP_FIRST,
+        C2_FOP_LINK,
+        C2_FOP_UNLINK,
+        C2_FOP_RENAME,
+        C2_FOP_OPEN,
+        C2_FOP_CLOSE,
+        C2_FOP_SETATTR,
+        C2_FOP_LAST
+};
+
 extern struct c2_fop_type c2_fop_create_fopt;
 extern struct c2_fop_type c2_fop_link_fopt;
 extern struct c2_fop_type c2_fop_unlink_fopt;
-- 
1.8.3.2

