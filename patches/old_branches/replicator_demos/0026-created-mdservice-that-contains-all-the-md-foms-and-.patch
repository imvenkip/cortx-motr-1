From 3627fd82f9d0e42eb4a655b74bb419d409b2d9f0 Mon Sep 17 00:00:00 2001
From: Yuriy Umanets <yuriy_umanets@xyratex.com>
Date: Tue, 29 Mar 2011 06:13:58 -0600
Subject: [PATCH 26/91] - created mdservice that contains all the md foms and
 fops; - some changes in mdstore.c - all the fops things are moved from
 mdstore to mdservice.

---
 Makefile.am           |   4 +-
 cob/cob.h             |   2 +-
 colibri/Makefile.am   |   3 +-
 configure.ac          |   3 +-
 fop/fom.h             |   6 +-
 ioservice/io_foms.c   |  12 +-
 mdservice/Makefile.am |  21 ++
 mdservice/md_foms.c   | 698 ++++++++++++++++++++++++++++++++++++++++++++++++++
 mdservice/md_foms.h   |  60 +++++
 mdservice/md_fops.c   |  61 +++++
 mdservice/md_fops.ff  | 111 ++++++++
 mdservice/md_fops.h   |  38 +++
 mdstore/Makefile.am   |  14 +-
 mdstore/md.c          | 240 -----------------
 mdstore/md.ff         | 111 --------
 mdstore/mdstore.c     | 163 +++---------
 mdstore/mdstore.h     |  40 ---
 reqh/reqh.c           |  47 +---
 site/site.c           |   4 +-
 site/site.h           |   4 +-
 20 files changed, 1051 insertions(+), 591 deletions(-)
 create mode 100644 mdservice/Makefile.am
 create mode 100644 mdservice/md_foms.c
 create mode 100644 mdservice/md_foms.h
 create mode 100644 mdservice/md_fops.c
 create mode 100644 mdservice/md_fops.ff
 create mode 100644 mdservice/md_fops.h
 delete mode 100644 mdstore/md.ff

diff --git a/Makefile.am b/Makefile.am
index 13a0632..f990c6a 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -3,8 +3,8 @@ SUBDIRS_BASE = m4 doc man patches
 # Order is important until fop is reached. Fop needs all libs before it in the 
 # list be build in order to use fop2c
 SUBDIRS_LIBS = lib addb fol db fid fop sm stob net dtm nrs sns mw reqh \
-               layout pool balloc desim cob capa udb ioservice site mdstore \
-               datastore # rpc
+               layout pool balloc desim cob capa udb site ioservice mdservice \
+               mdstore datastore  # rpc
 
 SUBDIR_KERNEL = build_kernel_modules
 SUBDIR_UT = fop/ut lib/ut stob/ut layout/ut balloc/ut db/ut \
diff --git a/cob/cob.h b/cob/cob.h
index 2c3eb7e..5bb3380 100644
--- a/cob/cob.h
+++ b/cob/cob.h
@@ -284,7 +284,7 @@ int c2_cob_locate(struct c2_cob_domain    *dom,
    
    @note first argument cob is allocated with c2_cob_alloc()
  */
-int c2_cob_create(struct c2_cob_cob    *cob,
+int c2_cob_create(struct c2_cob        *cob,
                   struct c2_cob_nskey  *nskey,
                   struct c2_cob_nsrec  *nsrec,
                   struct c2_cob_fabrec *fabrec,
diff --git a/colibri/Makefile.am b/colibri/Makefile.am
index 88c1733..14c65d2 100644
--- a/colibri/Makefile.am
+++ b/colibri/Makefile.am
@@ -30,6 +30,7 @@ libcolibri_la_LIBADD      = @AIO_LIBS@ @PTHREAD_LIBS@ @DB_LIBS@ @GALOIS_LIBS@ @C
                             $(top_builddir)/site/libcolibri-site.la \
                             $(top_builddir)/mdstore/libcolibri-mdstore.la \
                             $(top_builddir)/datastore/libcolibri-datastore.la \
-                            $(top_builddir)/ioservice/libcolibri-ioservice.la
+                            $(top_builddir)/ioservice/libcolibri-ioservice.la \
+                            $(top_builddir)/ioservice/libcolibri-mdservice.la
 
 #                            $(top_builddir)/rpc/libcolibri-rpc.la
diff --git a/configure.ac b/configure.ac
index ce78f55..b5f5fbc 100755
--- a/configure.ac
+++ b/configure.ac
@@ -533,12 +533,13 @@ AC_CONFIG_FILES([
                  site/Makefile
                  mdstore/Makefile
                  datastore/Makefile
+		 ioservice/Makefile
+		 mdservice/Makefile
                  udb/Makefile
                  udb/ut/Makefile
                  utils/Makefile
                  utils/linux_kernel/Makefile
 		 utils/ploss/Makefile
-		 ioservice/Makefile
 		 sns/linux_kernel/Makefile
 		 galois/linux_kernel/Makefile
 		 layout/linux_kernel/Makefile
diff --git a/fop/fom.h b/fop/fom.h
index c47ad3c..b88b372 100644
--- a/fop/fom.h
+++ b/fop/fom.h
@@ -196,12 +196,8 @@ struct c2_fom {
 	struct c2_fom_type      *fo_type;
 	const struct c2_fom_ops *fo_ops;
 	struct c2_clink          fo_clink;
-	/** FOP ctx sent by the network service. */
+	/** FOP ctx prepared by reqh. It has we need to handle fop. */
 	struct c2_fop_ctx	*fo_fop_ctx;
-	/** FOL object to make transactions of update operations. */
-	struct c2_fol		*fo_fol;
-	/** Stob domain in which this FOM is operating. */
-	struct c2_stob_domain	*fo_domain;
 };
 
 void c2_fom_init(struct c2_fom *fom);
diff --git a/ioservice/io_foms.c b/ioservice/io_foms.c
index 674738d..7994dd9 100644
--- a/ioservice/io_foms.c
+++ b/ioservice/io_foms.c
@@ -132,7 +132,7 @@ int c2_fom_cob_rwv_state(struct c2_fom *fom)
 	struct c2_fid 			 fid;
 	struct c2_fom_cob_rwv 		*fom_obj;
 	struct c2_stob_id		 stobid;
-	struct c2_dtx			 tx;
+	struct c2_db_tx                 *tx;
 	uint32_t			 bshift;
 	uint64_t			 bmask;
 	int 				 result;
@@ -199,16 +199,15 @@ int c2_fom_cob_rwv_state(struct c2_fom *fom)
 	 * This is a transaction IO and should be a separate phase 
 	 * with full fledged FOM. 
 	 */
-	result = fom->fo_domain->sd_ops->sdo_tx_make(fom->fo_domain, &tx);
-	C2_ASSERT(result == 0);
+	C2_ASSERT(fom->fo_fop_ctx != NULL && fom->fo_fop_ctx->ft_tx);
+	tx = fom->fo_fop_ctx->ft_tx;
 
-	if(fom_obj->fcrw_fop->f_type->ft_code == c2_io_service_writev_opcode)
-	{
+	if(fom_obj->fcrw_fop->f_type->ft_code == c2_io_service_writev_opcode) {
 		/* 
 		 * Make an FOL transaction record.
 		 */
 		result = c2_fop_fol_rec_add(fom_obj->fcrw_fop, 
-				fom->fo_fol, &tx.tx_dbtx);
+				            fom->fo_fop_ctx->ft_fol, tx);
 		C2_ASSERT(result == 0);
 	}
 
@@ -386,7 +385,6 @@ int c2_dummy_req_handler(struct c2_service *s, struct c2_fop *fop,
 
 	fom->fo_domain = dom;
 	fom->fo_fop_ctx = &ctx;
-	fom->fo_fol = fol;
 
 	/* 
 	 * Start the FOM.
diff --git a/mdservice/Makefile.am b/mdservice/Makefile.am
new file mode 100644
index 0000000..4ea8802
--- /dev/null
+++ b/mdservice/Makefile.am
@@ -0,0 +1,21 @@
+MDSVC_SRCDIR                     = @SRCDIR@/mdservice
+
+mdservicedir                     = $(includedir)/mdservice
+mdservice_HEADERS                = md_foms.h md_fops.h
+
+md_fops_u.h md_fops_u.c: md_fops.ff \
+                  $(top_builddir)/fop/libc2rt.la \
+                  $(top_builddir)/fop/fop2c 
+	$(top_builddir)/fop/fop2c -u $<
+
+
+noinst_LTLIBRARIES               = libcolibri-mdservice.la
+libcolibri_mdservice_la_SOURCES  = md_fops_u.c md_fops_u.h \
+				   md_foms.c md_foms.h md_fops.c md_fops.h
+INCLUDES                         = -I. -I$(top_srcdir) -I$(top_srcdir)/include
+
+EXTRA_DIST                       = md_fops.ff
+
+clean-local:
+	cd $(MDSVC_SRCDIR) ; \
+	rm -fr md_fops_u.[ch]
diff --git a/mdservice/md_foms.c b/mdservice/md_foms.c
new file mode 100644
index 0000000..30fc654
--- /dev/null
+++ b/mdservice/md_foms.c
@@ -0,0 +1,698 @@
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include "lib/misc.h"   /* C2_SET0 */
+#include "lib/cdefs.h"
+#include "lib/arith.h"   /* C2_3WAY */
+#include "lib/errno.h"
+#include "lib/assert.h"
+#include "lib/memory.h"
+#include "lib/bitstring.h"
+#include "lib/rwlock.h"
+
+#include "fop/fop.h"
+#include "cob/cob.h"
+#include "site/site.h"
+#include "mdstore/mdstore.h"
+
+#include "md_fops_u.h"
+#include "fop/fop_format_def.h"
+#include "md_fops.ff"
+
+/**
+   Make in-memory fid from fop fid.
+*/
+void c2_md_make_fid(struct c2_fid *fid, struct c2_fop_fid *ffid)
+{
+        fid->f_container = ffid->f_seq;
+        fid->f_key = ffid->f_oid;
+}
+
+/**
+   Make nskey from passed parent fid and child name.
+*/
+void c2_md_make_nskey(struct c2_cob_nskey **keyh, struct c2_fop_fid *fid,
+                      struct c2_fop_name *name)
+{
+        struct c2_cob_nskey *key;
+
+        key = c2_alloc(sizeof(*key) + name->n_count);
+        c2_md_make_fid(&key->cnk_pfid, fid);
+        memcpy(c2_bitstring_buf_get(&key->cnk_name), 
+               name->n_name, name->n_count);
+        c2_bitstring_len_set(&key->cnk_name, name->n_count);
+        *keyh = key;
+}
+
+/**
+   Make oikey from passed child fid and liunk number.
+*/
+void c2_md_make_oikey(struct c2_cob_oikey *oikey, struct c2_fop_fid *fid,
+                      int linkno)
+{
+        c2_md_make_fid(&oikey->cok_fid, fid);
+        oikey->cok_linkno = 0;
+}
+
+static int c2_md_create_permissions(struct c2_fop_create *req, 
+                                    struct c2_fop_ctx *ctx)
+{
+        return 0;
+}
+
+static int c2_md_fom_create_state(struct c2_fom *fom)
+{
+        struct c2_site           *site;
+        struct c2_cob            *cob;
+        struct c2_fop_create     *req;
+        struct c2_fop_create_rep *rep;
+        struct c2_fom_md         *fom_obj;
+        struct c2_fop            *fop;
+        struct c2_fop            *fop_rep;
+        struct c2_fop_ctx        *ctx;
+        int                       rc;
+
+        fom_obj = container_of(fom, struct c2_fom_md, fm_fom);
+
+        fop = fom_obj->fm_fop;
+        C2_ASSERT(fop != NULL);
+
+        fop_rep = fom_obj->fm_fop_rep;
+        C2_ASSERT(fop_rep != NULL);
+	
+        ctx = fom->fo_fop_ctx;
+        C2_ASSERT(ctx != NULL);
+
+        site = ctx->ft_site;
+        C2_ASSERT(site != NULL);
+
+        rc = c2_fop_fol_rec_add(fop, ctx->ft_fol, ctx->ft_tx);
+        if (rc == 0) {
+                rc = c2_cob_alloc(md->md_cob, &cob);
+                if (rc)
+                        goto out;
+
+                req = c2_fop_data(fop);
+                rep = c2_fop_data(fop_rep);
+
+                rc = c2_md_create_permissions(req, ctx);
+                if (rc) {
+                        c2_cob_put(cob);
+                        goto out;
+                }
+                rc = c2_md_store_create(site->s_mdstore, cob, req, rep, ctx);
+                c2_cob_put(cob);
+        }
+out:
+	fom->fo_phase = rc ? FOPH_FAILED : FOPH_DONE;
+        return FSO_AGAIN;
+}
+
+static int c2_md_link_permissions(struct c2_fop_link *req, 
+                                  struct c2_fop_ctx *ctx)
+{
+        return 0;
+}
+
+static int c2_md_fom_link_state(struct c2_fom *fom)
+{
+        struct c2_fop_cob        *body;
+        struct c2_site           *site;
+        struct c2_cob            *cob;
+        struct c2_fop_link       *req;
+        struct c2_fop_link_rep   *rep;
+        struct c2_fom_md         *fom_obj;
+        struct c2_fop            *fop;
+        struct c2_fop            *fop_rep;
+        struct c2_fop_ctx        *ctx;
+        struct c2_cob_oikey       oikey;
+        int                       rc;
+
+        fom_obj = container_of(fom, struct c2_fom_md, fm_fom);
+
+        fop = fom_obj->fm_fop;
+        C2_ASSERT(fop != NULL);
+
+        fop_rep = fom_obj->fm_fop_rep;
+        C2_ASSERT(fop_rep != NULL);
+	
+        ctx = fom->fo_fop_ctx;
+        C2_ASSERT(ctx != NULL);
+
+        site = ctx->ft_site;
+        C2_ASSERT(site != NULL);
+
+        rc = c2_fop_fol_rec_add(fop, ctx->ft_fol, ctx->ft_tx);
+        if (rc == 0) {
+                req = c2_fop_data(fop);
+                body = &req->l_body;
+
+                rc = c2_md_link_permissions(req, ctx);
+                if (rc)
+                        goto out;
+
+                c2_md_make_oikey(&oikey, &body->b_tfid, 0);
+
+                rc = c2_cob_locate(&site->s_mdstore->md_cob, &oikey, 
+                                   &cob, ctx->ft_tx);
+                if (rc)
+                        goto out;
+
+                rep = c2_fop_data(fop_rep);
+
+                rc = c2_md_store_link(site->s_mdstore, cob, req, rep, ctx);
+                c2_cob_put(cob);
+        }
+out:
+	fom->fo_phase = rc ? FOPH_FAILED : FOPH_DONE;
+        return FSO_AGAIN;
+}
+
+static int c2_md_unlink_permissions(struct c2_fop_unlink *req, 
+                                    struct c2_fop_ctx *ctx)
+{
+        return 0;
+}
+
+static int c2_md_fom_unlink_state(struct c2_fom *fom)
+{
+        struct c2_fop_cob        *body;
+        struct c2_site           *site;
+        struct c2_cob            *cob;
+        struct c2_fop_unlink     *req;
+        struct c2_fop_unlink_rep *rep;
+        struct c2_fom_md         *fom_obj;
+        struct c2_fop            *fop;
+        struct c2_fop            *fop_rep;
+        struct c2_fop_ctx        *ctx;
+        struct c2_cob_oikey       oikey;
+        int                       rc;
+
+        fom_obj = container_of(fom, struct c2_fom_md, fm_fom);
+
+        fop = fom_obj->fm_fop;
+        C2_ASSERT(fop != NULL);
+
+        fop_rep = fom_obj->fm_fop_rep;
+        C2_ASSERT(fop_rep != NULL);
+	
+        ctx = fom->fo_fop_ctx;
+        C2_ASSERT(ctx != NULL);
+
+        site = ctx->ft_site;
+        C2_ASSERT(site != NULL);
+
+        rc = c2_fop_fol_rec_add(fop, ctx->ft_fol, ctx->ft_tx);
+        if (rc == 0) {
+                req = c2_fop_data(fop);
+                body = &req->u_body;
+
+                rc = c2_md_unlink_permissions(req, ctx);
+                if (rc)
+                        goto out;
+
+                c2_md_make_oikey(&oikey, &body->b_tfid, 0);
+
+                rc = c2_cob_locate(&site->s_mdstore->md_cob, &oikey, 
+                                   &cob, ctx->ft_tx);
+                if (rc)
+                        goto out;
+
+                rep = c2_fop_data(fop_rep);
+
+                rc = c2_md_store_unlink(site->s_mdstore, cob, req, rep, ctx);
+                c2_cob_put(cob);
+        }
+out:
+	fom->fo_phase = rc ? FOPH_FAILED : FOPH_DONE;
+        return FSO_AGAIN;
+}
+
+static int c2_md_rename_permissions(struct c2_fop_rename *req, 
+                                    struct c2_fop_ctx *ctx)
+{
+        return 0;
+}
+
+static int c2_md_fom_rename_state(struct c2_fom *fom)
+{
+        struct c2_fop_cob        *body;
+        struct c2_site           *site;
+        struct c2_cob            *cob;
+        struct c2_fop_rename     *req;
+        struct c2_fop_reanme_rep *rep;
+        struct c2_fom_md         *fom_obj;
+        struct c2_fop            *fop;
+        struct c2_fop            *fop_rep;
+        struct c2_fop_ctx        *ctx;
+        struct c2_cob_oikey       oikey;
+        int                       rc;
+
+        fom_obj = container_of(fom, struct c2_fom_md, fm_fom);
+
+        fop = fom_obj->fm_fop;
+        C2_ASSERT(fop != NULL);
+
+        fop_rep = fom_obj->fm_fop_rep;
+        C2_ASSERT(fop_rep != NULL);
+	
+        ctx = fom->fo_fop_ctx;
+        C2_ASSERT(ctx != NULL);
+
+        site = ctx->ft_site;
+        C2_ASSERT(site != NULL);
+
+        rc = c2_fop_fol_rec_add(fop, ctx->ft_fol, ctx->ft_tx);
+        if (rc == 0) {
+                req = c2_fop_data(fop);
+                body = &req->r_sbody;
+
+                rc = c2_md_rename_permissions(req, ctx);
+                if (rc)
+                        goto out;
+
+                c2_md_make_oikey(&oikey, &body->b_tfid, 0);
+
+                rc = c2_cob_locate(&site->s_mdstore->md_cob, &oikey, 
+                                   &cob, ctx->ft_tx);
+                if (rc)
+                        goto out;
+
+                rep = c2_fop_data(fop_rep);
+
+                rc = c2_md_store_rename(site->s_mdstore, cob, req, rep, ctx);
+                c2_cob_put(cob);
+        }
+out:
+	fom->fo_phase = rc ? FOPH_FAILED : FOPH_DONE;
+        return FSO_AGAIN;
+}
+
+static int c2_md_open_permissions(struct c2_fop_open *req, 
+                                  struct c2_fop_ctx *ctx)
+{
+        return 0;
+}
+
+static int c2_md_fom_open_state(struct c2_fom *fom)
+{
+        struct c2_fop_cob        *body;
+        struct c2_site           *site;
+        struct c2_cob            *cob;
+        struct c2_fop_open       *req;
+        struct c2_fop_open_rep   *rep;
+        struct c2_fom_md         *fom_obj;
+        struct c2_fop            *fop;
+        struct c2_fop            *fop_rep;
+        struct c2_fop_ctx        *ctx;
+        struct c2_cob_oikey       oikey;
+        int                       rc;
+
+        fom_obj = container_of(fom, struct c2_fom_md, fm_fom);
+
+        fop = fom_obj->fm_fop;
+        C2_ASSERT(fop != NULL);
+
+        fop_rep = fom_obj->fm_fop_rep;
+        C2_ASSERT(fop_rep != NULL);
+	
+        ctx = fom->fo_fop_ctx;
+        C2_ASSERT(ctx != NULL);
+
+        site = ctx->ft_site;
+        C2_ASSERT(site != NULL);
+
+        rc = c2_fop_fol_rec_add(fop, ctx->ft_fol, ctx->ft_tx);
+        if (rc == 0) {
+                req = c2_fop_data(fop);
+                body = &req->o_body;
+
+                rc = c2_md_open_permissions(req, ctx);
+                if (rc)
+                        goto out;
+
+                c2_md_make_oikey(&oikey, &body->b_tfid, 0);
+
+                rc = c2_cob_locate(&site->s_mdstore->md_cob, &oikey, 
+                                   &cob, ctx->ft_tx);
+                if (rc == -ENOENT) {
+                        /*
+                         * @todo: create file if open mode says so.
+                         */
+                } else if (rc) {
+                        goto out;
+                }
+
+                rep = c2_fop_data(fop_rep);
+
+                rc = c2_md_store_open(site->s_mdstore, cob, req, rep, ctx);
+                c2_cob_put(cob);
+        }
+out:
+	fom->fo_phase = rc ? FOPH_FAILED : FOPH_DONE;
+        return FSO_AGAIN;
+}
+
+static int c2_md_fom_close_state(struct c2_fom *fom)
+{
+        struct c2_fop_cob        *body;
+        struct c2_site           *site;
+        struct c2_cob            *cob;
+        struct c2_fop_close      *req;
+        struct c2_fop_close_rep  *rep;
+        struct c2_fom_md         *fom_obj;
+        struct c2_fop            *fop;
+        struct c2_fop            *fop_rep;
+        struct c2_fop_ctx        *ctx;
+        struct c2_cob_oikey       oikey;
+        int                       rc;
+
+        fom_obj = container_of(fom, struct c2_fom_md, fm_fom);
+
+        fop = fom_obj->fm_fop;
+        C2_ASSERT(fop != NULL);
+
+        fop_rep = fom_obj->fm_fop_rep;
+        C2_ASSERT(fop_rep != NULL);
+	
+        ctx = fom->fo_fop_ctx;
+        C2_ASSERT(ctx != NULL);
+
+        site = ctx->ft_site;
+        C2_ASSERT(site != NULL);
+
+        rc = c2_fop_fol_rec_add(fop, ctx->ft_fol, ctx->ft_tx);
+        if (rc == 0) {
+                req = c2_fop_data(fop);
+                body = &req->c_body;
+
+                c2_md_make_oikey(&oikey, &body->b_tfid, 0);
+
+#if 0
+                /** @todo: Find a cob in open files table. */
+                rc = c2_cob_open_locate(&site->s_mdstore->md_cob, &oikey, 
+                                        &cob, ctx->ft_tx);
+                if (rc)
+                        goto out;
+#endif
+                rep = c2_fop_data(fop_rep);
+
+                rc = c2_md_store_close(site->s_mdstore, cob, req, rep, ctx);
+                c2_cob_put(cob);
+        }
+out:
+	fom->fo_phase = rc ? FOPH_FAILED : FOPH_DONE;
+        return FSO_AGAIN;
+}
+
+static int c2_md_setattr_permissions(struct c2_fop_setattr *req, 
+                                     struct c2_fop_ctx *ctx)
+{
+        return 0;
+}
+
+static int c2_md_fom_setattr_state(struct c2_fom *fom)
+{
+        struct c2_fop_cob        *body;
+        struct c2_site           *site;
+        struct c2_cob            *cob;
+        struct c2_fop_setattr    *req;
+        struct c2_fop_setattr_rep *rep;
+        struct c2_fom_md         *fom_obj;
+        struct c2_fop            *fop;
+        struct c2_fop            *fop_rep;
+        struct c2_fop_ctx        *ctx;
+        struct c2_cob_oikey       oikey;
+        int                       rc;
+
+        fom_obj = container_of(fom, struct c2_fom_md, fm_fom);
+
+        fop = fom_obj->fm_fop;
+        C2_ASSERT(fop != NULL);
+
+        fop_rep = fom_obj->fm_fop_rep;
+        C2_ASSERT(fop_rep != NULL);
+	
+        ctx = fom->fo_fop_ctx;
+        C2_ASSERT(ctx != NULL);
+
+        site = ctx->ft_site;
+        C2_ASSERT(site != NULL);
+
+        rc = c2_fop_fol_rec_add(fop, ctx->ft_fol, ctx->ft_tx);
+        if (rc == 0) {
+                req = c2_fop_data(fop);
+                body = &req->s_body;
+
+                rc = c2_md_setattr_permissions(req, ctx);
+                if (rc)
+                        goto out;
+
+                c2_md_make_oikey(&oikey, &body->b_tfid, 0);
+
+                rc = c2_cob_locate(&site->s_mdstore->md_cob, &oikey, 
+                                   &cob, ctx->ft_tx);
+                if (rc)
+                        goto out;
+
+                rep = c2_fop_data(fop_rep);
+
+                rc = c2_md_store_setattr(site->s_mdstore, cob, req, rep, ctx);
+                c2_cob_put(cob);
+        }
+out:
+	fom->fo_phase = rc ? FOPH_FAILED : FOPH_DONE;
+        return FSO_AGAIN;
+}
+
+static int c2_md_getattr_permissions(struct c2_fop_getattr *req, 
+                                     struct c2_fop_ctx *ctx)
+{
+        return 0;
+}
+
+static int c2_md_fom_getattr_state(struct c2_fom *fom)
+{
+        struct c2_fop_cob        *body;
+        struct c2_site           *site;
+        struct c2_cob            *cob;
+        struct c2_fop_getattr    *req;
+        struct c2_fop_getattr_rep *rep;
+        struct c2_fom_md         *fom_obj;
+        struct c2_fop            *fop;
+        struct c2_fop            *fop_rep;
+        struct c2_fop_ctx        *ctx;
+        struct c2_cob_oikey       oikey;
+        int                       rc;
+
+        fom_obj = container_of(fom, struct c2_fom_md, fm_fom);
+
+        fop = fom_obj->fm_fop;
+        C2_ASSERT(fop != NULL);
+
+        fop_rep = fom_obj->fm_fop_rep;
+        C2_ASSERT(fop_rep != NULL);
+	
+        ctx = fom->fo_fop_ctx;
+        C2_ASSERT(ctx != NULL);
+
+        site = ctx->ft_site;
+        C2_ASSERT(site != NULL);
+
+        rc = c2_fop_fol_rec_add(fop, ctx->ft_fol, ctx->ft_tx);
+        if (rc == 0) {
+                req = c2_fop_data(fop);
+                body = &req->g_body;
+
+                rc = c2_md_getattr_permissions(req, ctx);
+                if (rc)
+                        goto out;
+
+                c2_md_make_oikey(&oikey, &body->b_tfid, 0);
+
+                rc = c2_cob_locate(&site->s_mdstore->md_cob, &oikey, 
+                                   &cob, ctx->ft_tx);
+                if (rc)
+                        goto out;
+
+                rep = c2_fop_data(fop_rep);
+
+                rc = c2_md_store_getattr(site->s_mdstore, cob, req, rep, ctx);
+                c2_cob_put(cob);
+        }
+out:
+	fom->fo_phase = rc ? FOPH_FAILED : FOPH_DONE;
+        return FSO_AGAIN;
+}
+
+static int c2_md_readdir_permissions(struct c2_fop_readdir *req, 
+                                     struct c2_fop_ctx *ctx)
+{
+        return 0;
+}
+
+static int c2_md_fom_readdir_state(struct c2_fom *fom)
+{
+        struct c2_fop_cob        *body;
+        struct c2_site           *site;
+        struct c2_cob            *cob;
+        struct c2_fop_readdir    *req;
+        struct c2_fop_readdir_rep *rep;
+        struct c2_fom_md         *fom_obj;
+        struct c2_fop            *fop;
+        struct c2_fop            *fop_rep;
+        struct c2_fop_ctx        *ctx;
+        struct c2_cob_oikey       oikey;
+        int                       rc;
+
+        fom_obj = container_of(fom, struct c2_fom_md, fm_fom);
+
+        fop = fom_obj->fm_fop;
+        C2_ASSERT(fop != NULL);
+
+        fop_rep = fom_obj->fm_fop_rep;
+        C2_ASSERT(fop_rep != NULL);
+	
+        ctx = fom->fo_fop_ctx;
+        C2_ASSERT(ctx != NULL);
+
+        site = ctx->ft_site;
+        C2_ASSERT(site != NULL);
+
+        rc = c2_fop_fol_rec_add(fop, ctx->ft_fol, ctx->ft_tx);
+        if (rc == 0) {
+                req = c2_fop_data(fop);
+                body = &req->r_body;
+
+                rc = c2_md_readdir_permissions(req, ctx);
+                if (rc)
+                        goto out;
+
+                c2_md_make_oikey(&oikey, &body->b_tfid, 0);
+
+                rc = c2_cob_locate(&site->s_mdstore->md_cob, &oikey, 
+                                   &cob, ctx->ft_tx);
+                if (rc)
+                        goto out;
+
+                rep = c2_fop_data(fop_rep);
+
+                rc = c2_md_store_readdir(site->s_mdstore, cob, req, rep, ctx);
+                c2_cob_put(cob);
+        }
+out:
+	fom->fo_phase = rc ? FOPH_FAILED : FOPH_DONE;
+        return FSO_AGAIN;
+}
+
+struct c2_fom_ops c2_md_fom_create_ops = {
+	.fo_state = c2_md_fom_create_state
+};
+
+struct c2_fom_ops c2_md_fom_link_ops = {
+	.fo_state = c2_md_fom_link_state
+};
+
+struct c2_fom_ops c2_md_fom_unlink_ops = {
+	.fo_state = c2_md_fom_unlink_state
+};
+
+struct c2_fom_ops c2_md_fom_rename_ops = {
+	.fo_state = c2_md_fom_rename_state
+};
+
+struct c2_fom_ops c2_md_fom_open_ops = {
+	.fo_state = c2_md_fom_open_state
+};
+
+struct c2_fom_ops c2_md_fom_close_ops = {
+	.fo_state = c2_md_fom_close_state
+};
+
+struct c2_fom_ops c2_md_fom_setattr_ops = {
+	.fo_state = c2_md_fom_setattr_state
+};
+
+struct c2_fom_ops c2_md_fom_readdir_ops = {
+	.fo_state = c2_md_fom_readdir_state
+};
+
+struct c2_fom_ops c2_md_fom_rep_ops = {0,};
+struct c2_fom_type c2_md_fom_type_pch = {0,};
+
+int c2_md_rep_fom_init(struct c2_fop *fop, struct c2_fom **m)
+{
+        return 0;
+}
+
+int c2_md_req_fom_init(struct c2_fop *fop, struct c2_fom **m)
+{
+	struct c2_fom           *fom;
+	struct c2_fom_md        *fom_obj;
+	struct c2_fom_type      *fom_type;
+
+	C2_PRE(fop != NULL);
+	C2_PRE(m != NULL);
+
+	fom_obj= c2_alloc(sizeof(struct c2_fom_md));
+	if (fom_obj == NULL)
+	        return -ENOMEM;
+        
+        /* To cheat a bit on foms generic code. */    
+	fom_type = &c2_md_fom_type_pch;
+	fop->f_type->ft_fom_type = *fom_type;
+	fom = &fom_obj->fm_fom;
+	fom->fo_type = fom_type;
+	fom->fo_phase = FOPH_INIT;
+
+        switch (fop->f_type->ft_code) {
+        case C2_FOP_CREATE:
+		fom->fo_ops = &c2_md_fom_create_ops;
+	        break;
+        case C2_FOP_LINK:
+		fom->fo_ops = &c2_md_fom_link_ops;
+	        break;
+        case C2_FOP_UNLINK:
+		fom->fo_ops = &c2_md_fom_unlink_ops;
+	        break;
+        case C2_FOP_RENAME:
+		fom->fo_ops = &c2_md_fom_rename_ops;
+	        break;
+        case C2_FOP_OPEN:
+		fom->fo_ops = &c2_md_fom_open_ops;
+	        break;
+        case C2_FOP_CLOSE:
+		fom->fo_ops = &c2_md_fom_close_ops;
+	        break;
+        case C2_FOP_SETATTR:
+		fom->fo_ops = &c2_md_fom_setattr_ops;
+	        break;
+        case C2_FOP_READDIR:
+		fom->fo_ops = &c2_md_fom_readdir_ops;
+	        break;
+        default:
+                c2_free(fom_obj);
+                return -EINVAL;
+        }
+
+        fom_obj->fm_fop_rep = c2_fop_alloc(&c2_md_rep_fopt, NULL);
+	if (fom_obj->fm_fop_rep == NULL) {
+                c2_free(fom_obj);
+	        return -ENOMEM;
+	}
+
+	fom_obj->fm_fop = fop;
+	*m = &fom_obj->fm_fom;
+	return 0;
+}
+
+/* 
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/mdservice/md_foms.h b/mdservice/md_foms.h
new file mode 100644
index 0000000..68f4a16
--- /dev/null
+++ b/mdservice/md_foms.h
@@ -0,0 +1,60 @@
+/* -*- C -*- */
+
+#ifndef __COLIBRI_MDSERVICE_MD_FOMS_H__
+#define __COLIBRI_MDSERVICE_MD_FOMS_H__
+
+struct c2_fom;
+struct c2_fop;
+struct c2_fid;
+
+struct c2_fop_fid;
+struct c2_cob_nskey;
+struct c2_cob_oikey;
+
+struct c2_fom_md {
+	/** Generic c2_fom object. */
+        struct c2_fom                    fm_fom;
+	/** FOP associated with this FOM. */
+        struct c2_fop			*fm_fop;
+	/** Reply FOP associated with request FOP above. */
+	struct c2_fop			*fm_fop_rep;
+};
+
+/**
+   Init request fom for all types of requests.
+*/
+int c2_md_req_fom_init(struct c2_fop *fop, struct c2_fom **m);
+
+/**
+   Init reply fom.
+*/
+int c2_md_rep_fom_init(struct c2_fop *fop, struct c2_fom **m);
+
+/**
+   Make in-memory fid from fop fid.
+*/
+void c2_md_make_fid(struct c2_fid *fid, struct c2_fop_fid *ffid);
+
+/**
+   Make nskey from passed parent fid and child name.
+*/
+void c2_md_make_nskey(struct c2_cob_nskey **keyh, struct c2_fop_fid *fid, 
+                      struct c2_fop_name *name);
+
+/**
+   Make oikey from passed child fid and liunk number.
+*/
+void c2_md_make_oikey(struct c2_cob_oikey *oikey, struct c2_fop_fid *fid,
+                      int linkno);
+
+#endif /* __COLIBRI_MDSERVICE_MD_FOMS_H__ */
+
+/* 
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/mdservice/md_fops.c b/mdservice/md_fops.c
new file mode 100644
index 0000000..030bb8f
--- /dev/null
+++ b/mdservice/md_fops.c
@@ -0,0 +1,61 @@
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+static struct c2_fop_type_ops c2_md_req_ops = {
+        .fto_fom_init = c2_md_req_fom_init
+};
+
+static struct c2_fop_type_ops c2_md_rep_ops = {
+        .fto_fom_init = c2_md_rep_fom_init
+};
+
+/** Request fops. */
+C2_FOP_TYPE_DECLARE(c2_fop_create,  "Create request",    
+                    C2_FOP_CREATE,  &c2_md_req_ops);
+C2_FOP_TYPE_DECLARE(c2_fop_link,    "Hardlink request",  
+                    C2_FOP_LINK,    &c2_md_req_ops);
+C2_FOP_TYPE_DECLARE(c2_fop_unlink,  "Unlink request",
+                    C2_FOP_UNLINK,  &c2_md_req_ops);
+C2_FOP_TYPE_DECLARE(c2_fop_open,    "Open request",
+                    C2_FOP_OPEN,    &c2_md_req_ops);
+C2_FOP_TYPE_DECLARE(c2_fop_close,   "Close request",     
+                    C2_FOP_CLOSE,   &c2_md_req_ops);
+C2_FOP_TYPE_DECLARE(c2_fop_setattr, "Setattr request",   
+                    C2_FOP_SETATTR, &c2_md_req_ops);
+C2_FOP_TYPE_DECLARE(c2_fop_getattr, "Getattr request",   
+                    C2_FOP_GETATTR, &c2_md_req_ops);
+C2_FOP_TYPE_DECLARE(c2_fop_rename,  "Rename request",
+                    C2_FOP_RENAME,  &c2_md_req_ops);
+C2_FOP_TYPE_DECLARE(c2_fop_rename,  "Readdir request",   
+                    C2_FOP_READDIR, &c2_md_req_ops);
+
+/** Reply fops. */
+C2_FOP_TYPE_DECLARE(c2_fop_create_rep,  "Create reply",    
+                    C2_FOP_CREATE_REP,  &md_rep_ops);
+C2_FOP_TYPE_DECLARE(c2_fop_link_rep,    "Hardlink reply",  
+                    C2_FOP_LINK_REP,    &md_rep_ops);
+C2_FOP_TYPE_DECLARE(c2_fop_unlink_rep,  "Unlink reply",
+                    C2_FOP_UNLINK_REP,  &md_rep_ops);
+C2_FOP_TYPE_DECLARE(c2_fop_open_rep,    "Open reply",
+                    C2_FOP_OPEN_REP,    &md_rep_ops);
+C2_FOP_TYPE_DECLARE(c2_fop_close_rep,   "Close reply",     
+                    C2_FOP_CLOSE_REP,   &md_rep_ops);
+C2_FOP_TYPE_DECLARE(c2_fop_setattr_rep, "Setattr reply",   
+                    C2_FOP_SETATTR_REP, &md_rep_ops);
+C2_FOP_TYPE_DECLARE(c2_fop_getattr_rep, "Getattr reply",   
+                    C2_FOP_GETATTR_REP, &md_rep_ops);
+C2_FOP_TYPE_DECLARE(c2_fop_rename_rep,  "Rename reply",
+                    C2_FOP_RENAME_REP,  &md_rep_ops);
+C2_FOP_TYPE_DECLARE(c2_fop_rename_rep,  "Readdir reply",   
+                    C2_FOP_READDIR_REP, &md_rep_ops);
+
+/* 
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/mdservice/md_fops.ff b/mdservice/md_fops.ff
new file mode 100644
index 0000000..7aa90ec
--- /dev/null
+++ b/mdservice/md_fops.ff
@@ -0,0 +1,111 @@
+/* -*- C -*- */
+
+/**
+   @addtogroup fop
+   @{
+ */
+
+/** @file md.ff
+ *
+ * <b>Colibri metatadata fop formats</b>
+ *
+ */
+
+DEF(c2_fop_fid, RECORD,
+    _(f_seq, U64),
+    _(f_oid, U64));
+
+DEF(c2_fop_name, SEQUENCE,
+    _(n_count, U32),
+    _(n_name, BYTE));
+
+DEF(c2_fop_cob, RECORD,
+    _(b_index, U64),
+    _(b_flags, U32),
+    _(b_mode, U32),
+    _(b_uid, U32),
+    _(b_gid, U32),
+    _(b_sid, U32),
+    _(b_nid, U64),
+    _(b_atime, U32),
+    _(b_mtime, U32),
+    _(b_ctime, U32),
+    _(b_pfid, c2_fop_fid),
+    _(b_tfid, c2_fop_fid));
+
+DEF(c2_fop_create, RECORD,
+    _(c_body, c2_fop_cob),
+    _(c_name, c2_fop_name));
+
+DEF(c2_fop_create_rep, RECORD,
+    _(c_body, c2_fop_cob));
+
+DEF(c2_fop_link, RECORD,
+    _(l_body, c2_fop_cob),
+    _(l_name, c2_fop_name));
+
+DEF(c2_fop_link_rep, RECORD,
+    _(l_body, c2_fop_cob));
+
+DEF(c2_fop_unlink, RECORD,
+    _(u_body, c2_fop_cob),
+    _(u_name, c2_fop_name));
+
+DEF(c2_fop_unlink_rep, RECORD,
+    _(u_body, c2_fop_cob));
+
+DEF(c2_fop_rename, RECORD,
+    _(r_sbody, c2_fop_cob),
+    _(r_tbody, c2_fop_cob),
+    _(r_sname, c2_fop_name),
+    _(r_tname, c2_fop_name));
+
+DEF(c2_fop_rename_rep, RECORD,
+    _(r_body, c2_fop_cob));
+
+DEF(c2_fop_open, RECORD,
+    _(o_body, c2_fop_cob));
+
+DEF(c2_fop_open_rep, RECORD,
+    _(o_body, c2_fop_cob));
+
+DEF(c2_fop_close, RECORD,
+    _(c_body, c2_fop_cob));
+
+DEF(c2_fop_close_rep, RECORD,
+    _(c_body, c2_fop_cob));
+
+DEF(c2_fop_setattr, RECORD,
+    _(s_body, c2_fop_cob));
+
+DEF(c2_fop_setattr_rep, RECORD,
+    _(s_body, c2_fop_cob));
+
+DEF(c2_fop_getattr, RECORD,
+    _(g_body, c2_fop_cob));
+
+DEF(c2_fop_getattr_rep, RECORD,
+    _(g_body, c2_fop_cob));
+
+DEF(c2_fop_readdir, RECORD,
+    _(r_body, c2_fop_cob));
+
+DEF(c2_fop_dirent, RECORD,
+    _(d_body, c2_fop_cob),
+    _(d_name, c2_fop_name));
+
+DEF(c2_fop_readdir_rep, RECORD,
+    _(r_count, U32),
+    _(r_entry, c2_fop_dirent));
+
+/** @} end of fop group */
+
+/* 
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/mdservice/md_fops.h b/mdservice/md_fops.h
new file mode 100644
index 0000000..bb5c314
--- /dev/null
+++ b/mdservice/md_fops.h
@@ -0,0 +1,38 @@
+/* -*- C -*- */
+
+#ifndef __COLIBRI_MDSERVICE_MD_FOPS_H__
+#define __COLIBRI_MDSERVICE_MD_FOPS_H__
+
+enum c2_fop_metadata_code {
+        C2_FOP_FIRST,
+        C2_FOP_CREATE = C2_FOP_FIRST,
+        C2_FOP_LINK,
+        C2_FOP_UNLINK,
+        C2_FOP_RENAME,
+        C2_FOP_OPEN,
+        C2_FOP_CLOSE,
+        C2_FOP_SETATTR,
+        C2_FOP_GETATTR,
+        C2_FOP_READDIR,
+        C2_FOP_CREATE_REP,
+        C2_FOP_LINK_REP,
+        C2_FOP_UNLINK_REP,
+        C2_FOP_RENAME_REP,
+        C2_FOP_OPEN_REP,
+        C2_FOP_CLOSE_REP,
+        C2_FOP_SETATTR_REP,
+        C2_FOP_GETATTR_REP,
+        C2_FOP_READDIR_REP,
+        C2_FOP_LAST
+};
+
+#endif /* __COLIBRI_MDSERVICE_MD_FOMS_H__ */
+/* 
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/mdstore/Makefile.am b/mdstore/Makefile.am
index 3809e61..dc2b78d 100644
--- a/mdstore/Makefile.am
+++ b/mdstore/Makefile.am
@@ -3,18 +3,6 @@ MDSTORE_SRCDIR                 = @SRCDIR@/mdstore
 mdstoredir                     = $(includedir)/mdstore
 mdstore_HEADERS                = mdstore.h
 
-md_u.h md_u.c: md.ff \
-                  $(top_builddir)/fop/libc2rt.la \
-                  $(top_builddir)/fop/fop2c 
-	$(top_builddir)/fop/fop2c -u $<
-
-
 noinst_LTLIBRARIES             = libcolibri-mdstore.la
-libcolibri_mdstore_la_SOURCES  = md_u.c md_u.h mdstore.c mdstore.h md.h md.c
+libcolibri_mdstore_la_SOURCES  = mdstore.c mdstore.h
 INCLUDES                       = -I. -I$(top_srcdir) -I$(top_srcdir)/include
-
-EXTRA_DIST                     = md.ff
-
-clean-local:
-	cd $(MDSTORE_SRCDIR) ; \
-	rm -fr md_u.[ch]
diff --git a/mdstore/md.c b/mdstore/md.c
index 414eea5..fb97051 100644
--- a/mdstore/md.c
+++ b/mdstore/md.c
@@ -20,246 +20,6 @@
 #include <fop/fop_format_def.h>
 #include "mdstore/md.ff"
 
-#define ADDB_CALL(name, rc) \
-    do {} while (0)
-
-static int md_store_create_execute(struct c2_fop *fop, struct c2_fop_ctx *ctx)
-{
-        struct c2_site           *site;
-        struct c2_md_store       *md;
-        struct c2_cob            *cob;
-        struct c2_fop_create     *req;
-        int                       rc;
-
-        site = ctx->ft_site;
-        C2_ASSERT(site != NULL);
-
-        md = site->s_md;
-        C2_ASSERT(md != NULL);
-        
-        rc = c2_fop_fol_rec_add(fop, ctx->ft_fol, ctx->ft_tx);
-        ADDB_CALL("fol_create", rc);
-        if (rc == 0) {
-                rc = c2_cob_alloc(md->md_cob, &cob);
-                if (rc)
-                        return rc;
-                req = c2_fop_data(fop);
-
-                rc = c2_md_store_create(md, cob, req, NULL, ctx);
-                ADDB_CALL("md_store_create", rc);
-        }
-        return rc;
-}
-
-static void md_store_create_free(struct c2_fop *fop)
-{
-        struct c2_fop_create *req;
-
-        req = c2_fop_data(fop);
-        c2_free(req->c_name.n_name);
-}
-
-static struct c2_fop_type_ops md_create_ops = {
-        .fto_execute = md_store_create_execute,
-	.fto_free    = md_store_create_free
-};
-
-static int md_store_open_execute(struct c2_fop *fop, struct c2_fop_ctx *ctx)
-{
-        struct c2_site           *site;
-        struct c2_md_store       *md;
-        struct c2_cob            *cob;
-        struct c2_fop_open       *req;
-        struct c2_fop_cob        *body;
-        struct c2_cob_oikey       oikey;
-        int                       rc;
-
-        site = ctx->ft_site;
-        C2_ASSERT(site != NULL);
-
-        md = site->s_md;
-        C2_ASSERT(md != NULL);
-        
-        rc = c2_fop_fol_rec_add(fop, ctx->ft_fol, ctx->ft_tx);
-        ADDB_CALL("fol_open", rc);
-        if (rc == 0) {
-                req = c2_fop_data(fop);
-                body = &req->o_body;
-
-                md_store_make_oikey(&oikey, &body->b_tfid, 0);
-
-                rc = c2_cob_locate(&md->md_cob, &oikey, &cob, ctx->ft_tx);
-                if (rc == -ENOENT) {
-                        /*
-                         * @todo: create file is open mode says so.
-                         */
-                } else if (rc) {
-                        return rc;
-                }
-        
-                rc = c2_md_store_open(md, cob, req, NULL, ctx);
-                ADDB_CALL("md_store_open", rc);
-                c2_cob_put(cob);
-        }
-        return rc;
-}
-static struct c2_fop_type_ops md_open_ops = {
-        .fto_execute = md_store_open_execute,
-        .fto_free    = NULL
-};
-
-static struct c2_fop_type_ops md_close_ops = {
-        .fto_execute = md_store_close_execute,
-	.fto_free    = md_store_close_free
-};
-
-static struct c2_fop_type_ops md_link_ops = {
-        .fto_execute = md_store_link_execute,
-	.fto_free    = md_store_link_free
-};
-
-static struct c2_fop_type_ops md_unlink_ops = {
-        .fto_execute = md_store_unlink_execute,
-	.fto_free    = md_store_unlink_free
-};
-
-static struct c2_fop_type_ops md_rename_ops = {
-        .fto_execute = md_store_rename_execute,
-	.fto_free    = md_store_rename_free
-};
-
-static struct c2_fop_type_ops md_setattr_ops = {
-        .fto_execute = md_store_setattr_execute,
-	.fto_free    = md_store_setattr_free
-};
-
-static void c2_md_store_fop_free(struct c2_fop *fop)
-{
-        struct c2_fop_create *create;
-        struct c2_fop_unlink *unlink;
-        struct c2_fop_rename *rename;
-        struct c2_fop_link   *link;
-
-        switch (fop->f_type->ft_code) {
-        case C2_FOP_CREATE:
-                create = c2_fop_data(fop);
-                c2_free(create->c_name.n_name);
-                break;
-        case C2_FOP_LINK:
-                link = c2_fop_data(fop);
-                c2_free(link->l_name.n_name);
-                break;
-        case C2_FOP_UNLINK:
-                unlink = c2_fop_data(fop);
-                c2_free(unlink->u_name.n_name);
-                break;
-        case C2_FOP_RENAME:
-                rename = c2_fop_data(fop);
-                c2_free(rename->r_sname.n_name);
-                c2_free(rename->r_tname.n_name);
-                break;
-        default:
-                break;
-        }
-}
-
-static int c2_md_store_fop_execute(struct c2_fop *fop, struct c2_fop_ctx *ctx)
-{
-        struct c2_site        *site;
-        struct c2_md_store    *md;
-        struct c2_cob         *cob;
-        struct c2_cob_oikey    oikey;
-        int                    rc = 0;
-
-        site = ctx->ft_site;
-        C2_ASSERT(site != NULL);
-
-        md = site->s_md;
-        C2_ASSERT(md != NULL);
-        
-        switch (fop->f_type->ft_code) {
-        case C2_FOP_CREATE:
-                rc = c2_fop_fol_rec_add(fop, ctx->ft_fol, ctx->ft_tx);
-                ADDB_CALL("fol_create", rc);
-                if (rc == 0) {
-                        rc = c2_md_store_create(md, fop, ctx);
-                        ADDB_CALL("md_store_create", rc);
-                }
-                break;
-        case C2_FOP_OPEN:
-                rc = c2_fop_fol_rec_add(fop, ctx->ft_fol, ctx->ft_tx);
-                ADDB_CALL("fol_open", rc);
-                if (rc == 0) {
-                        rc = c2_md_store_open(md, fop, ctx);
-                        ADDB_CALL("md_store_open", rc);
-                }
-                break;
-        case C2_FOP_CLOSE:
-                rc = c2_fop_fol_rec_add(fop, ctx->ft_fol, ctx->ft_tx);
-                ADDB_CALL("fol_close", rc);
-                if (rc == 0) {
-                        rc = c2_md_store_close(md, fop, ctx);
-                        ADDB_CALL("md_store_close", rc);
-                }
-                break;
-        case C2_FOP_SETATTR:
-                rc = c2_fop_fol_rec_add(fop, ctx->ft_fol, ctx->ft_tx);
-                ADDB_CALL("fol_setattr", rc);
-                if (rc == 0) {
-                        rc = c2_md_store_setattr(md, fop, ctx);
-                        ADDB_CALL("md_store_setattr", rc);
-                }
-                break;
-        case C2_FOP_LINK:
-                rc = c2_fop_fol_rec_add(fop, ctx->ft_fol, ctx->ft_tx);
-                ADDB_CALL("fol_link", rc);
-                if (rc == 0) {
-                        md_store_make_oikey(&oikey, &body->b_tfid, 0);
-                        rc = c2_cob_locate(&md->md_cob, &oikey, &cob, ctx->ft_tx);
-                        if (rc)
-                                return rc;
-                        rc = c2_md_store_link(md, fop, ctx);
-                        ADDB_CALL("md_store_link", rc);
-                }
-                break;
-        case C2_FOP_UNLINK:
-                rc = c2_fop_fol_rec_add(fop, ctx->ft_fol, ctx->ft_tx);
-                ADDB_CALL("fol_unlink", rc);
-
-                if (rc == 0) {
-                        rc = c2_md_store_unlink(md, fop, ctx);
-                        ADDB_CALL("md_store_unlink", rc);
-                }
-                break;
-        case C2_FOP_RENAME:
-                rc = c2_fop_fol_rec_add(fop, ctx->ft_fol, ctx->ft_tx);
-                ADDB_CALL("fol_rename", rc);
-                
-                if (rc == 0) {
-                        rc = c2_md_store_rename(md, fop, ctx);
-                        ADDB_CALL("md_store_rename", rc);
-                }
-                break;
-        default:
-                rc = EOPNOTSUPP;
-                break;
-        }
-        
-        return rc;
-}
-
-/**
-   The rest of records/fops is not yet supported. Not clear if we need them 
-   at all.
- */
-C2_FOP_TYPE_DECLARE(c2_fop_create,   "create",    C2_FOP_CREATE,  &md_create_ops);
-C2_FOP_TYPE_DECLARE(c2_fop_link,     "hardlink",  C2_FOP_LINK,    &md_link_ops);
-C2_FOP_TYPE_DECLARE(c2_fop_unlink,   "unlink",    C2_FOP_UNLINK,  &md_unlink_ops);
-C2_FOP_TYPE_DECLARE(c2_fop_open,     "open",      C2_FOP_OPEN,    &md_open_ops);
-C2_FOP_TYPE_DECLARE(c2_fop_close,    "close",     C2_FOP_CLOSE,   &md_close_ops);
-C2_FOP_TYPE_DECLARE(c2_fop_setattr,  "setattr",   C2_FOP_SETATTR, &md_setattr_ops);
-C2_FOP_TYPE_DECLARE(c2_fop_rename,   "rename",    C2_FOP_RENAME,  &md_rename_ops);
-
 static struct c2_fop_type *c2_fop_fops[] = {
         &c2_fop_create_fopt,
         &c2_fop_link_fopt,
diff --git a/mdstore/md.ff b/mdstore/md.ff
deleted file mode 100644
index 7aa90ec..0000000
--- a/mdstore/md.ff
+++ /dev/null
@@ -1,111 +0,0 @@
-/* -*- C -*- */
-
-/**
-   @addtogroup fop
-   @{
- */
-
-/** @file md.ff
- *
- * <b>Colibri metatadata fop formats</b>
- *
- */
-
-DEF(c2_fop_fid, RECORD,
-    _(f_seq, U64),
-    _(f_oid, U64));
-
-DEF(c2_fop_name, SEQUENCE,
-    _(n_count, U32),
-    _(n_name, BYTE));
-
-DEF(c2_fop_cob, RECORD,
-    _(b_index, U64),
-    _(b_flags, U32),
-    _(b_mode, U32),
-    _(b_uid, U32),
-    _(b_gid, U32),
-    _(b_sid, U32),
-    _(b_nid, U64),
-    _(b_atime, U32),
-    _(b_mtime, U32),
-    _(b_ctime, U32),
-    _(b_pfid, c2_fop_fid),
-    _(b_tfid, c2_fop_fid));
-
-DEF(c2_fop_create, RECORD,
-    _(c_body, c2_fop_cob),
-    _(c_name, c2_fop_name));
-
-DEF(c2_fop_create_rep, RECORD,
-    _(c_body, c2_fop_cob));
-
-DEF(c2_fop_link, RECORD,
-    _(l_body, c2_fop_cob),
-    _(l_name, c2_fop_name));
-
-DEF(c2_fop_link_rep, RECORD,
-    _(l_body, c2_fop_cob));
-
-DEF(c2_fop_unlink, RECORD,
-    _(u_body, c2_fop_cob),
-    _(u_name, c2_fop_name));
-
-DEF(c2_fop_unlink_rep, RECORD,
-    _(u_body, c2_fop_cob));
-
-DEF(c2_fop_rename, RECORD,
-    _(r_sbody, c2_fop_cob),
-    _(r_tbody, c2_fop_cob),
-    _(r_sname, c2_fop_name),
-    _(r_tname, c2_fop_name));
-
-DEF(c2_fop_rename_rep, RECORD,
-    _(r_body, c2_fop_cob));
-
-DEF(c2_fop_open, RECORD,
-    _(o_body, c2_fop_cob));
-
-DEF(c2_fop_open_rep, RECORD,
-    _(o_body, c2_fop_cob));
-
-DEF(c2_fop_close, RECORD,
-    _(c_body, c2_fop_cob));
-
-DEF(c2_fop_close_rep, RECORD,
-    _(c_body, c2_fop_cob));
-
-DEF(c2_fop_setattr, RECORD,
-    _(s_body, c2_fop_cob));
-
-DEF(c2_fop_setattr_rep, RECORD,
-    _(s_body, c2_fop_cob));
-
-DEF(c2_fop_getattr, RECORD,
-    _(g_body, c2_fop_cob));
-
-DEF(c2_fop_getattr_rep, RECORD,
-    _(g_body, c2_fop_cob));
-
-DEF(c2_fop_readdir, RECORD,
-    _(r_body, c2_fop_cob));
-
-DEF(c2_fop_dirent, RECORD,
-    _(d_body, c2_fop_cob),
-    _(d_name, c2_fop_name));
-
-DEF(c2_fop_readdir_rep, RECORD,
-    _(r_count, U32),
-    _(r_entry, c2_fop_dirent));
-
-/** @} end of fop group */
-
-/* 
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
diff --git a/mdstore/mdstore.c b/mdstore/mdstore.c
index eb58f01..7998ab9 100644
--- a/mdstore/mdstore.c
+++ b/mdstore/mdstore.c
@@ -16,43 +16,17 @@
 #include "db/db.h"
 #include "fop/fop.h"
 #include "cob/cob.h"
-
-#include "mdstore/md_u.h"
 #include "mdstore/mdstore.h"
 
+#include "mdservice/md_fops_u.h"
+#include "fop/fop_format_def.h"
+#include "mdservice/md_fops.ff"
+
 static const struct c2_fid C2_MD_ROOTID = {
         .f_container = 1024ULL, 
         .f_key       = 1ULL
 };
 
-void md_store_make_fid(struct c2_fid *fid, struct c2_fop_fid *ffid)
-{
-        fid->f_container = ffid->f_seq;
-        fid->f_key = ffid->f_oid;
-}
-
-void md_store_make_nskey(struct c2_cob_nskey **keyh, 
-                         struct c2_fop_fid *fid, 
-                         struct c2_fop_name *name)
-{
-        struct c2_cob_nskey *key;
-
-        key = c2_alloc(sizeof(*key) + name->n_count);
-        md_store_make_fid(&key->cnk_pfid, fid);
-        memcpy(c2_bitstring_buf_get(&key->cnk_name), 
-               name->n_name, name->n_count);
-        c2_bitstring_len_set(&key->cnk_name, name->n_count);
-        *keyh = key;
-}
-
-void md_store_make_oikey(struct c2_cob_oikey *oikey,
-                         struct c2_fop_fid *fid,
-                         int linkno)
-{
-        md_store_make_fid(&oikey->cok_fid, fid);
-        oikey->cok_linkno = 0;
-}
-
 int c2_md_store_init(struct c2_md_store *md, struct c2_cob_domain_id *id,
                      struct c2_dbenv *db)
 {
@@ -150,17 +124,10 @@ int c2_md_store_link(struct c2_md_store *md,
                      struct c2_fop_ctx *ctx)
 {
         struct c2_fop_cob     *body = &req->l_body;
-        struct c2_cob_oikey    oikey;
         struct c2_cob_nskey   *nskey;
         int                    rc;
         
-        /*
-         * Let's find stat data cob first.
-         */
-        md_store_make_oikey(&oikey, &body->b_tfid, 0);
-        rc = c2_cob_locate(&md->md_cob, &oikey, &cob, ctx->ft_tx);
-        if (rc)
-                return rc;
+        C2_ASSERT(cob != NULL);
 
         /*
          * Link @nskey to a file described with @cob
@@ -175,7 +142,6 @@ int c2_md_store_link(struct c2_md_store *md,
         cob->co_nsrec.cnr_nlink++;
         rc = c2_cob_update(cob, ctx->ft_tx);
 out:
-        c2_cob_put(cob);
         c2_free(nskey);
         return rc;
 }
@@ -187,21 +153,14 @@ int c2_md_store_unlink(struct c2_md_store *md,
                        struct c2_fop_ctx *ctx)
 {
         struct c2_fop_cob     *body = &req->u_body;
+        struct c2_cob         *ncob = NULL;
         struct c2_cob_nskey   *nskey;
         struct c2_cob_oikey    oikey;
-        struct c2_cob         *cob;
         struct c2_cob_nsrec    nsrec;
         int                    rc;
     
+        C2_ASSERT(cob != NULL);
         md_store_make_nskey(&nskey, &body->b_pfid, &unlink->u_name);
-        md_store_make_oikey(&oikey, &body->b_tfid, 0);
-
-        /*
-         * Lookup for stat data cob.
-         */
-        rc = c2_cob_locate(&md->md_cob, &oikey, &cob, ctx->ft_tx);
-        if (rc)
-                return rc;
 
         /*
          * Copy "working copy" of stat data.
@@ -227,20 +186,15 @@ int c2_md_store_unlink(struct c2_md_store *md,
          */
         if (c2_cob_nskey_cmp(nskey, cob->co_nskey) == 0) {
                 /*
-                 * Let's re-use cob variable to make this function
-                 * even shorter.
-                 */
-                c2_cob_put(cob);
-
-                /*
                  * Find next name (new stat data) in object index. Note
                  * that ->cok_stoid is already set above.
                  */
                 oikey.cok_linkno++;
                 
-                rc = c2_cob_locate(&md->md_cob, &oikey, &cob, ctx->ft_tx);
+                rc = c2_cob_locate(&md->md_cob, &oikey, &ncob, ctx->ft_tx);
                 if (rc)
                         goto out;
+                cob = ncob;
         }
 
         /*
@@ -256,7 +210,8 @@ int c2_md_store_unlink(struct c2_md_store *md,
          */
         rc = c2_cob_del_name(cob, nskey, ctx->ft_tx);
 out:
-        c2_cob_put(cob);
+        if (ncob)
+                c2_cob_put(ncob);
         c2_free(nskey);
         return rc;
 }
@@ -267,24 +222,13 @@ int c2_md_store_open(struct c2_md_store *md,
                      struct c2_fop_open_rep *rep, 
                      struct c2_fop_ctx *ctx)
 {
-        struct c2_fop_cob    *body = &req->o_body;
-        struct c2_cob_oikey   oikey;
-        struct c2_cob        *cob;
-        int                   rc;
-        
-        md_store_make_oikey(&oikey, &body->b_tfid, 0);
+        C2_ASSERT(cob != NULL);
 
-        rc = c2_cob_locate(&md->md_cob, &oikey, &cob, ctx->ft_tx);
-        if (rc == -ENOENT) {
-                /*
-                 * @todo: create file is open mode says so.
-                 */
-        } else if (rc) {
-                return rc;
-        }
-        
-        c2_cob_put(cob);
-        return rc;
+        /* 
+         * @todo: Place cob to open files table. 
+         */
+
+        return 0;
 }
 
 int c2_md_store_close(struct c2_md_store *md, 
@@ -293,25 +237,15 @@ int c2_md_store_close(struct c2_md_store *md,
                       struct c2_fop_close_rep *rep, 
                       struct c2_fop_ctx *ctx)
 {
-        struct c2_fop_cob    *body = &req->c_body;
-        struct c2_cob_oikey   oikey;
-        struct c2_cob        *cob;
-        int                   rc;
-        
-        md_store_make_oikey(&oikey, &body->b_tfid, 0);
+        C2_ASSERT(cob != NULL);
 
-        rc = c2_cob_locate(&md->md_cob, &oikey, &cob, ctx->ft_tx);
-        if (rc)
-                return rc;
-    
         /*
          * @todo:
          *   - orphans handling?
          *   - quota handling?
          */
         
-        c2_cob_put(cob);
-        return rc;
+        return 0;
 }
 
 static int c2_md_store_rename_sanity(struct c2_md_store *md, 
@@ -324,8 +258,8 @@ static int c2_md_store_rename_sanity(struct c2_md_store *md,
         struct c2_cob       *tgt;
         int                  rc;
 
-        md_store_make_fid(&srcfid, &rename->r_sbody.b_tfid);
-        md_store_make_fid(&tgtfid, &rename->r_tbody.b_tfid);
+        c2_md_store_make_fid(&srcfid, &rename->r_sbody.b_tfid);
+        c2_md_store_make_fid(&tgtfid, &rename->r_tbody.b_tfid);
         
         /*
          * Going up from the target starting point until root is
@@ -376,9 +310,11 @@ int c2_md_store_rename(struct c2_md_store *md,
         struct c2_cob_nskey  *srckey;
         struct c2_cob_nskey  *tgtkey;
         struct c2_cob_oikey   oikey;
-        struct c2_cob        *cob;
         int                   rc;
 
+
+        C2_ASSERT(cob != NULL);
+
         /*
          * Perform rename sanity checks (source should not be ancestor
          * of target dir, etc).
@@ -388,22 +324,12 @@ int c2_md_store_rename(struct c2_md_store *md,
                 return rc;
 
         /*
-         * Get stat data cob.
-         */
-        md_store_make_oikey(&oikey, &sbody->b_tfid, 0);
-
-        rc = c2_cob_locate(&md->md_cob, &oikey, &cob, ctx->ft_tx);
-        if (rc)
-                return rc;
-
-        /*
          * Prepare src and dst keys.
          */                
         md_store_make_nskey(&srckey, &sbody->b_pfid, &rename->r_sname);
         md_store_make_nskey(&tgtkey, &tbody->b_pfid, &rename->r_tname);
 
         rc = c2_cob_update_name(cob, srckey, tgtkey, ctx->ft_tx);
-        c2_cob_put(cob);
         c2_free(srckey);
         c2_free(tgtkey);
         
@@ -420,15 +346,9 @@ int c2_md_store_setattr(struct c2_md_store *md,
         struct c2_cob_nsrec    nsrec;
         struct c2_cob_fabrec   fabrec;
         struct c2_cob_omgrec   omgrec;
-        struct c2_cob_oikey    oikey;
-        struct c2_cob         *cob;
         int                    rc;
-        
-        md_store_make_oikey(&oikey, &body->b_tfid, 0);
 
-        rc = c2_cob_locate(&md->md_cob, &oikey, &cob, ctx->ft_tx);
-        if (rc)
-                return rc;
+        C2_ASSERT(cob != NULL);        
 
         /* 
          * @todo: these need to be fixed. We do have 64 bit time
@@ -451,7 +371,6 @@ int c2_md_store_setattr(struct c2_md_store *md,
         C2_SET0(&omgrec);
 
         rc = c2_cob_setattr(cob, &nsrec, &fabrec, &omgrec, ctx->ft_tx);
-        c2_cob_put(cob);
         
         return rc;
 }
@@ -462,24 +381,14 @@ int c2_md_store_getattr(struct c2_md_store *md,
                         struct c2_fop_getattr_rep *rep, 
                         struct c2_fop_ctx *ctx)
 {
-        struct c2_fop_cob     *body = &req->g_body;
-        struct c2_cob_oikey    oikey;
-        struct c2_cob         *cob;
-        int                    rc;
-        
-        md_store_make_oikey(&oikey, &body->b_tfid, 0);
-
-        rc = c2_cob_locate(&md->md_cob, &oikey, &cob, ctx->ft_tx);
-        if (rc)
-                return rc;
+        C2_ASSERT(cob != NULL);        
         
         /*
          * @todo: copy cob->co_nsrec cob->co_fabrec and cob->co_omgrec
          * to response.
          */
         
-        c2_cob_put(cob);
-        return rc;
+        return 0;
 }
 
 int c2_md_store_readdir(struct c2_md_store *md, 
@@ -488,22 +397,12 @@ int c2_md_store_readdir(struct c2_md_store *md,
                         struct c2_fop_readdir_rep *rep, 
                         struct c2_fop_ctx *ctx)
 {
-        struct c2_fop_cob     *body = &req->r_body;
-        struct c2_cob_oikey    oikey;
-        struct c2_cob         *cob;
-        int                    rc;
-        
-        md_store_make_oikey(&oikey, &body->b_tfid, 0);
-
-        rc = c2_cob_locate(&md->md_cob, &oikey, &cob, ctx->ft_tx);
-        if (rc)
-                return rc;
+        C2_ASSERT(cob != NULL);        
         
         /*
-         * @todo: Iterrate over @cob to find entries and put them
-         * to response.
+         * @todo: Go though @cob to find entries and put them
+         * to response @rep.
          */
         
-        c2_cob_put(cob);
-        return rc;
+        return 0;
 }
diff --git a/mdstore/mdstore.h b/mdstore/mdstore.h
index 0c0c8d8..9c860c4 100644
--- a/mdstore/mdstore.h
+++ b/mdstore/mdstore.h
@@ -17,26 +17,6 @@ struct c2_md_store {
 };
 
 /**
-   Make in-memory fid from fop fid.
-*/
-void md_store_make_fid(struct c2_fid *fid, 
-                       struct c2_fop_fid *ffid);
-
-/**
-   Make nskey from passed parent fid and child name.
-*/
-void md_store_make_nskey(struct c2_cob_nskey **keyh, 
-                         struct c2_fop_fid *fid, 
-                         struct c2_fop_name *name);
-
-/**
-   Make oikey from passed child fid and liunk number.
-*/
-void md_store_make_oikey(struct c2_cob_oikey *oikey,
-                         struct c2_fop_fid *fid,
-                         int linkno);
-
-/**
    Initialize mdstore with passed cob comain id and database env.
 */
 int c2_md_store_init(struct c2_md_store *md, 
@@ -167,26 +147,6 @@ int c2_md_store_readdir(struct c2_md_store *md,
 void c2_md_store_fop_fini(void);
 int c2_md_store_fop_init(void);
 
-enum c2_fop_metadata_code {
-        C2_FOP_FIRST,
-        C2_FOP_CREATE = C2_FOP_FIRST,
-        C2_FOP_LINK,
-        C2_FOP_UNLINK,
-        C2_FOP_RENAME,
-        C2_FOP_OPEN,
-        C2_FOP_CLOSE,
-        C2_FOP_SETATTR,
-        C2_FOP_LAST
-};
-
-extern struct c2_fop_type c2_fop_create_fopt;
-extern struct c2_fop_type c2_fop_link_fopt;
-extern struct c2_fop_type c2_fop_unlink_fopt;
-extern struct c2_fop_type c2_fop_rename_fopt;
-extern struct c2_fop_type c2_fop_open_fopt;
-extern struct c2_fop_type c2_fop_close_fopt;
-extern struct c2_fop_type c2_fop_setattr_fopt;
-
 /* __COLIBRI_MDSTORE_MDSTORE_H__ */
 #endif
 
diff --git a/reqh/reqh.c b/reqh/reqh.c
index 8dd7e74..335ed91 100644
--- a/reqh/reqh.c
+++ b/reqh/reqh.c
@@ -35,11 +35,11 @@ void c2_reqh_fini(struct c2_reqh *reqh)
 
 void c2_reqh_fop_handle(struct c2_reqh *reqh, struct c2_fop *fop)
 {
-        struct c2_fop_ctx ctx;
-        struct c2_fop_env env;
-        struct c2_db_tx   tx;
-	int 		  rc;
-	struct c2_fom	  *fom = NULL;
+	struct c2_fop_ctx 	ctx;
+	int			result;
+        struct c2_fop_env       env;
+        struct c2_db_tx         tx;
+	struct c2_fom	       *fom = NULL;
 
         C2_SET0(&ctx);
         C2_SET0(&env);
@@ -50,7 +50,6 @@ void c2_reqh_fop_handle(struct c2_reqh *reqh, struct c2_fop *fop)
         ctx.ft_fol  = reqh->rh_fol;
         ctx.ft_env = &env;
         ctx.ft_tx = &tx;
-
 	ctx.ft_service = s;
 	ctx.fc_cookie  = cookie;
 
@@ -60,45 +59,25 @@ void c2_reqh_fop_handle(struct c2_reqh *reqh, struct c2_fop *fop)
 	 * resource allocation, locking &c.
 	 */
 
-	/* 
-	 * This init function will allocate memory for a c2_fom 
-	 * structure. 
-	 * It will find out the respective c2_fom_type object
-	 * for the given c2_fop_type object using a mapping function
-	 * and will embed the c2_fom_type object in c2_fop_type object.
-	 */
-	rc = fop->f_type->ft_ops->fto_fom_init(fop, &fom);
-	if (rc)
+	result = fop->f_type->ft_ops->fto_fom_init(fop, &fom);
+	if (result)
 	        goto out;
+	        
+	C2_ASSERT(fom != NULL);
+	fom->fo_fop_ctx = &ctx;
 
-	/*
-	 * This create function will create a type specific FOM
-	 * structure which primarily includes the context.
-	 */
-	rc = fom->fo_type->ft_ops->fto_create(&fop->f_type->ft_fom_type, fop, &fom);
-	if (rc)
-	        goto out_free_fom;
-	
-	/*
-	 * Populate the FOM context object with whatever is 
-	 * needed from server side.
-	 */
-	fom->fo_type->ft_ops->fto_populate(fom, dom, &ctx, fol);
 	/* 
 	 * Start the FOM.
 	 */
-        rc = fom->fo_ops->fo_state(fom);
+	result = fom->fo_ops->fo_state(fom);
 
-out_free_fom:
-        if (fom)
-                c2_free(fom);
 out:
-        if (rc)
+        if (result)
                 c2_db_tx_abort(&tx);
         else 
                 c2_db_tx_commit(&tx);
         
-        return rc;
+        return result;
 }
 
 void c2_reqh_fop_sortkey_get(struct c2_reqh *reqh, struct c2_fop *fop,
diff --git a/site/site.c b/site/site.c
index 8ca5616..26e16b9 100644
--- a/site/site.c
+++ b/site/site.c
@@ -30,8 +30,8 @@ static struct c2_list c2_sites;
 int c2_site_init(struct c2_site *s, struct c2_md_store *md, 
                  struct c2_data_store *data)
 {
-        s->s_md = md;
-        s->s_data = data;
+        s->s_mdstore = md;
+        s->s_datastore = data;
         c2_list_add(&c2_sites, &s->s_linkage);
         return 0;
 }
diff --git a/site/site.h b/site/site.h
index 15f8ab8..df038a7 100644
--- a/site/site.h
+++ b/site/site.h
@@ -15,8 +15,8 @@ struct c2_data_store;
 struct c2_list_link;
 
 struct c2_site {
-        struct c2_md_store     *s_md;
-        struct c2_data_store   *s_data;
+        struct c2_md_store     *s_mdstore;
+        struct c2_data_store   *s_datastore;
         struct c2_list_link     s_linkage;
 };
 
-- 
1.8.3.2

