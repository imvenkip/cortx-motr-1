From 0540745b884a29db958e2f48e1384a6f9b3183e5 Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Mon, 25 Feb 2013 22:04:01 +0800
Subject: [PATCH 06/24] retrieve mdservice endpoint and client endpoint while
 starting ioservice.

---
 ioservice/io_service.c | 41 +++++++++++++++++++++++++----------------
 mero/setup.c           |  9 ++++-----
 mero/setup.h           |  1 +
 3 files changed, 30 insertions(+), 21 deletions(-)

diff --git a/ioservice/io_service.c b/ioservice/io_service.c
index 4d14b43..0844420 100644
--- a/ioservice/io_service.c
+++ b/ioservice/io_service.c
@@ -604,34 +604,44 @@ static void ios_stats_post_addb(struct m0_reqh_service *service)
 
 M0_INTERNAL int m0_ios_mds_rpc_ctx_init(struct m0_reqh_service *service)
 {
-	struct m0_reqh            *reqh = service->rs_reqh;
-	struct m0_reqh_io_service *serv_obj;
-	struct m0_rpc_client_ctx  *rpc_client_ctx;
-	int                        rc;
-	static char                cl_ep_addr[M0_NET_LNET_XEP_ADDR_LEN] = {0};
-	static char                srv_ep_addr[M0_NET_LNET_XEP_ADDR_LEN] = {0};
-	const char                *dbname = "sr_cdb";
-	struct m0_net_domain      *cl_ndom;
+	struct m0_reqh              *reqh = service->rs_reqh;
+	struct m0_reqh_io_service   *serv_obj;
+	struct m0_rpc_client_ctx    *rpc_client_ctx;
+	int                          rc;
+	const char                  *dbname = "sr_cdb";
+	struct m0_net_domain        *cl_ndom;
+	struct cs_endpoint_and_xprt *ep;
+	struct m0_reqh_context      *reqh_ctx = service->rs_reqh_ctx;
+	const char                  *cli_ep_addr = "";
+	const char                  *srv_ep_addr = "";
 	enum {
 		RPC_TIMEOUT              = 10, /* seconds */
 		NR_SLOTS_PER_SESSION     = 10,
 		MAX_NR_RPC_IN_FLIGHT     = 10,
 	};
 
-	return 0;
 	M0_PRE(m0_reqh_lockers_is_empty(reqh, ios_mds_rpc_ctx_key));
 
+	srv_ep_addr = reqh_ctx->rc_mero->cc_mds_epx.ex_endpoint;
+	ep = cs_eps_tlist_tail(&reqh_ctx->rc_eps);
+	if (ep != NULL)
+		cli_ep_addr = ep->ex_endpoint;
+
+	M0_LOG(M0_ERROR, "cli = %s", cli_ep_addr);
+	M0_LOG(M0_ERROR, "srv = %s", srv_ep_addr);
 	serv_obj = container_of(service, struct m0_reqh_io_service, rios_gen);
 
+	return 0;
+
 	rpc_client_ctx = m0_alloc(sizeof *rpc_client_ctx);
 	if (rpc_client_ctx == NULL)
-		return -ENOMEM;
+		M0_RETURN(-ENOMEM);
 
 	cl_ndom = &serv_obj->rios_cl_ndom;
 	m0_net_domain_init(&serv_obj->rios_cl_ndom, &m0_net_lnet_xprt,
 			   &service->rs_addb_ctx);
 	rpc_client_ctx->rcx_net_dom            = cl_ndom;
-	rpc_client_ctx->rcx_local_addr         = cl_ep_addr;
+	rpc_client_ctx->rcx_local_addr         = cli_ep_addr;
 	rpc_client_ctx->rcx_remote_addr        = srv_ep_addr;
 	rpc_client_ctx->rcx_db_name            = dbname;
 	rpc_client_ctx->rcx_dbenv              = reqh->rh_dbenv;
@@ -644,18 +654,18 @@ M0_INTERNAL int m0_ios_mds_rpc_ctx_init(struct m0_reqh_service *service)
 	rc = m0_rpc_client_start(rpc_client_ctx);
 	if (rc != 0) {
 		m0_free(rpc_client_ctx);
-		return rc;
+		M0_RETURN(rc);
 	}
 
 	m0_rwlock_write_lock(&reqh->rh_rwlock);
 	m0_reqh_lockers_set(reqh, ios_mds_rpc_ctx_key, rpc_client_ctx);
 	serv_obj->rios_mds_rpc_ctx = rpc_client_ctx;
 	m0_rwlock_write_unlock(&reqh->rh_rwlock);
-	return 0;
+	M0_RETURN(0);
 }
 
-M0_INTERNAL struct m0_rpc_client_ctx
-*m0_ios_mds_rpc_ctx_get(struct m0_reqh *reqh)
+M0_INTERNAL
+struct m0_rpc_client_ctx *m0_ios_mds_rpc_ctx_get(struct m0_reqh *reqh)
 {
 	struct m0_rpc_client_ctx *rpc_client_ctx;
 	M0_PRE(reqh != NULL);
@@ -671,7 +681,6 @@ M0_INTERNAL void m0_ios_mds_rpc_ctx_fini(struct m0_reqh_service *service)
 	struct m0_reqh            *reqh = service->rs_reqh;
 	struct m0_reqh_io_service *serv_obj;
 	struct m0_rpc_client_ctx  *rpc_client_ctx;
-
 	return;
 	serv_obj = container_of(service, struct m0_reqh_io_service, rios_gen);
 
diff --git a/mero/setup.c b/mero/setup.c
index 3c81a7f..25134ff 100644
--- a/mero/setup.c
+++ b/mero/setup.c
@@ -67,7 +67,7 @@ M0_TL_DESCR_DEFINE(cs_eps, "cs endpoints", static, struct cs_endpoint_and_xprt,
 		   ex_linkage, ex_magix, M0_CS_ENDPOINT_AND_XPRT_MAGIC,
 		   M0_CS_EPS_HEAD_MAGIC);
 
-M0_TL_DEFINE(cs_eps, static, struct cs_endpoint_and_xprt);
+M0_TL_DEFINE(cs_eps, M0_INTERNAL, struct cs_endpoint_and_xprt);
 
 static struct m0_bob_type cs_eps_bob;
 M0_BOB_DEFINE(static, &cs_eps_bob, cs_endpoint_and_xprt);
@@ -1662,7 +1662,8 @@ static int reqh_ctxs_are_valid(struct m0_mero *cctx)
 			rc = cs_endpoint_validate(cctx, ep->ex_endpoint,
 						  ep->ex_xprt);
 			if (rc != 0) {
-				M0_LOG(M0_ERROR, "endpoint_init_fail");
+				M0_LOG(M0_ERROR, "endpoint_init_fail: %s: %d",
+						 ep->ex_endpoint, rc);
 				M0_RETURN(rc);
 			}
 		} m0_tl_endfor;
@@ -1689,8 +1690,7 @@ static int reqh_ctxs_are_valid(struct m0_mero *cctx)
 		}
 	} m0_tl_endfor;
 
-	if ((rc = cs_endpoint_validate(cctx, cctx->cc_mds_epx.ex_endpoint,
-				  cctx->cc_mds_epx.ex_xprt))) {
+	if (cctx->cc_mds_epx.ex_endpoint == NULL) {
 		M0_LOG(M0_ERROR, "Missing or Invalid mdservice endpoint.\n"
 				 "Use -G to provice a valid one: %d", rc);
 		M0_RETURN(rc);
@@ -1765,7 +1765,6 @@ static int _args_parse(struct m0_mero *cctx, int argc, char **argv,
 			M0_STRINGARG('G', "mdservice endpoint address",
 				LAMBDA(void, (const char *s)
 				{
-					M0_LOG(M0_ERROR, "%s", s);
 					rc = ep_and_xprt_extract(&cctx->
 								 cc_mds_epx, s);
 				})),
diff --git a/mero/setup.h b/mero/setup.h
index a0dcb52..dc59166 100644
--- a/mero/setup.h
+++ b/mero/setup.h
@@ -482,6 +482,7 @@ M0_INTERNAL struct m0_mero *m0_cs_ctx_get(struct m0_reqh *reqh);
  */
 M0_INTERNAL struct m0_net_domain *m0_cs_net_domain_locate(struct m0_mero *cctx,
 							  const char *xprtname);
+M0_TL_DECLARE(cs_eps, M0_INTERNAL, struct cs_endpoint_and_xprt);
 
 /** @} endgroup m0d */
 
-- 
1.8.3.2

