From 9fe7d78fa14d4a9cb5353ae96394a96806e2b52c Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Tue, 5 Mar 2013 23:31:14 +0800
Subject: [PATCH 18/24] change m0_ios_poolmach_init()/m0_ios_poolmach_fini() to
 use "struct m0_reqh_service *" parameter. command line arguments are
 retirieved from reqh context in m0_ios_poolmach_init().

---
 cm/ut/cm.c             |  7 +++++--
 cm/ut/common_service.c |  6 +++++-
 cm/ut/cp.c             |  4 ++--
 ioservice/io_device.c  | 29 +++++++++++++++++++++--------
 ioservice/io_device.h  |  5 +++--
 ioservice/io_service.c |  4 ++--
 6 files changed, 38 insertions(+), 17 deletions(-)

diff --git a/cm/ut/cm.c b/cm/ut/cm.c
index 052aa50..74d8f57 100644
--- a/cm/ut/cm.c
+++ b/cm/ut/cm.c
@@ -18,6 +18,8 @@
  * Original creation date: 09/25/2012
  */
 
+#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_IOSERVICE
+#include "lib/trace.h"
 #include "lib/finject.h"
 #include "lib/memory.h"
 #include "lib/ut.h"
@@ -65,7 +67,7 @@ static void cm_setup_ut(void)
 	rc = m0_reqh_service_start(cm_ut_service);
 	M0_UT_ASSERT(rc == 0);
 
-	rc = m0_ios_poolmach_init(cm_ut_service->rs_reqh);
+	rc = m0_ios_poolmach_init(cm_ut_service);
 	M0_UT_ASSERT(rc == 0);
 
 	/* Checks if the restructuring process is started successfully. */
@@ -79,8 +81,8 @@ static void cm_setup_ut(void)
 	rc = m0_cm_stop(&cm_ut);
 	M0_UT_ASSERT(rc == 0);
 	m0_reqh_shutdown_wait(&cm_ut_reqh);
+	m0_ios_poolmach_fini(cm_ut_service);
 	cm_ut_service_cleanup();
-	m0_ios_poolmach_fini(&cm_ut_reqh);
 }
 static void cm_init_failure_ut(void)
 {
@@ -217,6 +219,7 @@ const struct m0_test_suite cm_generic_ut = {
         }
 };
 
+#undef M0_TRACE_SUBSYSTEM
 /*
  *  Local variables:
  *  c-indentation-style: "K&R"
diff --git a/cm/ut/common_service.c b/cm/ut/common_service.c
index 7293790..6242ac3 100644
--- a/cm/ut/common_service.c
+++ b/cm/ut/common_service.c
@@ -21,6 +21,7 @@
  */
 
 #include "cm/ut/common_service.h"
+#include "mero/setup.h"
 
 struct m0_reqh           cm_ut_reqh;
 struct m0_cm_cp          cm_ut_cp;
@@ -147,13 +148,16 @@ static const struct m0_reqh_service_type_ops cm_ut_service_type_ops = {
 M0_CM_TYPE_DECLARE(cm_ut, &cm_ut_service_type_ops, "cm_ut",
 		   &m0_addb_ct_ut_service);
 
+struct m0_mero         mero = { .cc_pool_width = 3 };
+struct m0_reqh_context rctx = { .rc_mero = &mero };
+
 void cm_ut_service_alloc_init()
 {
 	int rc;
 	/* Internally calls m0_cm_init(). */
 	M0_ASSERT(cm_ut_service == NULL);
 	rc = m0_reqh_service_allocate(&cm_ut_service, &cm_ut_cmt.ct_stype,
-	                              NULL);
+	                              &rctx);
 	M0_ASSERT(rc == 0);
 	m0_reqh_service_init(cm_ut_service, &cm_ut_reqh);
 }
diff --git a/cm/ut/cp.c b/cm/ut/cp.c
index a4f4b7c..ca397b2 100644
--- a/cm/ut/cp.c
+++ b/cm/ut/cp.c
@@ -283,7 +283,7 @@ static int cm_cp_init(void)
 	cm_ut_service_alloc_init();
 	rc = m0_reqh_service_start(cm_ut_service);
 	M0_ASSERT(rc == 0);
-	rc = m0_ios_poolmach_init(cm_ut_service->rs_reqh);
+	rc = m0_ios_poolmach_init(cm_ut_service);
 	M0_ASSERT(rc == 0);
 
         return 0;
@@ -292,7 +292,7 @@ static int cm_cp_init(void)
 /* Finalises the request handler. */
 static int cm_cp_fini(void)
 {
-	m0_ios_poolmach_fini(cm_ut_service->rs_reqh);
+	m0_ios_poolmach_fini(cm_ut_service);
 	cm_ut_service_cleanup();
 	m0_cm_type_deregister(&cm_ut_cmt);
         m0_reqh_fini(&cm_ut_reqh);
diff --git a/ioservice/io_device.c b/ioservice/io_device.c
index 250faf9..0a8e41f 100644
--- a/ioservice/io_device.c
+++ b/ioservice/io_device.c
@@ -234,7 +234,9 @@
 #include "ioservice/io_device.h"
 #include "pool/pool.h"
 #include "reqh/reqh.h"
+#include "reqh/reqh_service.h"
 #include "ioservice/io_fops.h"
+#include "mero/setup.h"
 
 /**
    @addtogroup io_calls_params_dldDFS
@@ -247,17 +249,20 @@
  */
 M0_EXTERN unsigned poolmach_key;
 
-M0_INTERNAL int m0_ios_poolmach_init(struct m0_reqh *reqh)
+M0_INTERNAL int m0_ios_poolmach_init(struct m0_reqh_service *service)
 {
 	int                 rc;
 	struct m0_poolmach *poolmach;
+	struct m0_reqh     *reqh = service->rs_reqh;
+	M0_PRE(service != NULL);
+	M0_PRE(service->rs_reqh_ctx != NULL);
+	M0_PRE(service->rs_reqh_ctx->rc_mero != NULL);
 
+	reqh = service->rs_reqh;
 	M0_LOG(M0_DEBUG, "key init for reqh=%p, key=%d\n", reqh, poolmach_key);
 	M0_PRE(reqh != NULL);
 	M0_PRE(m0_reqh_lockers_is_empty(reqh, poolmach_key));
 
-	m0_rwlock_write_lock(&reqh->rh_rwlock);
-
 	poolmach = m0_alloc(sizeof *poolmach);
 	if (poolmach == NULL) {
 		rc = -ENOMEM;
@@ -266,16 +271,18 @@ M0_INTERNAL int m0_ios_poolmach_init(struct m0_reqh *reqh)
 
 	/* TODO configuration information is needed here. */
 	rc = m0_poolmach_init(poolmach, reqh->rh_dtm, PM_DEFAULT_NR_NODES,
-			      PM_DEFAULT_NR_DEV, PM_DEFAULT_MAX_NODE_FAILURES,
+			      service->rs_reqh_ctx->rc_mero->cc_pool_width,
+			      PM_DEFAULT_MAX_NODE_FAILURES,
 			      PM_DEFAULT_MAX_DEV_FAILURES);
 	if (rc != 0) {
 		m0_free(poolmach);
 		goto out;
 	}
+	m0_rwlock_write_lock(&reqh->rh_rwlock);
 	m0_reqh_lockers_set(reqh, poolmach_key, poolmach);
+	m0_rwlock_write_unlock(&reqh->rh_rwlock);
 	M0_LOG(M0_DEBUG, "key init for reqh=%p, key=%d", reqh, poolmach_key);
 out:
-	m0_rwlock_write_unlock(&reqh->rh_rwlock);
 	return rc;
 }
 
@@ -292,18 +299,24 @@ M0_INTERNAL struct m0_poolmach *m0_ios_poolmach_get(struct m0_reqh *reqh)
 	return pm;
 }
 
-M0_INTERNAL void m0_ios_poolmach_fini(struct m0_reqh *reqh)
+M0_INTERNAL void m0_ios_poolmach_fini(struct m0_reqh_service *service)
 {
 	struct m0_poolmach *pm;
+	struct m0_reqh     *reqh;
+
+	M0_PRE(service != NULL);
+	reqh = service->rs_reqh;
 	M0_PRE(reqh != NULL);
 
 	M0_LOG(M0_DEBUG, "key fini for reqh=%p, key=%d", reqh, poolmach_key);
+
 	m0_rwlock_write_lock(&reqh->rh_rwlock);
 	pm = m0_reqh_lockers_get(reqh, poolmach_key);
-	m0_poolmach_fini(pm);
 	m0_reqh_lockers_clear(reqh, poolmach_key);
-	m0_free(pm);
 	m0_rwlock_write_unlock(&reqh->rh_rwlock);
+
+	m0_poolmach_fini(pm);
+	m0_free(pm);
 }
 
 M0_INTERNAL int
diff --git a/ioservice/io_device.h b/ioservice/io_device.h
index 07a2a28..e467d61 100644
--- a/ioservice/io_device.h
+++ b/ioservice/io_device.h
@@ -84,6 +84,7 @@ struct m0_fv_updates;
  */
 struct m0_reqh;
 struct m0_poolmach;
+struct m0_reqh_service;
 
 enum {
 	/**
@@ -97,7 +98,7 @@ enum {
  * Initializes the pool machine. This will create a shared reqh key
  * and call m0_poolmach_init() internally.
  */
-M0_INTERNAL int m0_ios_poolmach_init(struct m0_reqh *reqh);
+M0_INTERNAL int m0_ios_poolmach_init(struct m0_reqh_service *service);
 
 /**
  * Gets the shared pool machine.
@@ -107,7 +108,7 @@ M0_INTERNAL struct m0_poolmach *m0_ios_poolmach_get(struct m0_reqh *reqh);
 /**
  * Finializes the pool machine when it is no longer used.
  */
-M0_INTERNAL void m0_ios_poolmach_fini(struct m0_reqh *reqh);
+M0_INTERNAL void m0_ios_poolmach_fini(struct m0_reqh_service *service);
 
 /**
  * Pack the current server version and delta of failure vectors
diff --git a/ioservice/io_service.c b/ioservice/io_service.c
index 3b37cc0..676ca7d 100644
--- a/ioservice/io_service.c
+++ b/ioservice/io_service.c
@@ -473,7 +473,7 @@ static int ios_start(struct m0_reqh_service *service)
 		return rc;
 	}
 
-	rc = m0_ios_poolmach_init(service->rs_reqh);
+	rc = m0_ios_poolmach_init(service);
 	if (rc != 0) {
 		ios_delete_buffer_pool(service);
 		m0_ios_mds_rpc_ctx_fini(service);
@@ -502,7 +502,7 @@ static void ios_stop(struct m0_reqh_service *service)
 {
 	M0_PRE(service != NULL);
 
-	m0_ios_poolmach_fini(service->rs_reqh);
+	m0_ios_poolmach_fini(service);
 	ios_delete_buffer_pool(service);
 	m0_ios_cdom_fini(service->rs_reqh);
 	m0_reqh_lockers_clear(service->rs_reqh, ios_cdom_key);
-- 
1.8.3.2

