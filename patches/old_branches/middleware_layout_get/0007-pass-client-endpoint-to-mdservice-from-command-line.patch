From 8ee9c66430684a8901a319254dff183bd9f4daac Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Tue, 26 Feb 2013 00:03:44 +0800
Subject: [PATCH 07/24] pass client endpoint to mdservice from command line.
 fixes for m0_ios_mds_rpc_ctx_init/m0_ios_mds_rpc_ctx_get check getattr
 replied rc

---
 ioservice/io_service.c                      | 48 ++++++++++++++++-------------
 m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh |  9 ++++++
 m0t1fs/linux_kernel/st/m0t1fs_server_inc.sh |  1 +
 mero/setup.c                                | 15 ++++++++-
 mero/setup.h                                |  5 ++-
 5 files changed, 54 insertions(+), 24 deletions(-)

diff --git a/ioservice/io_service.c b/ioservice/io_service.c
index 0844420..24c6ea9 100644
--- a/ioservice/io_service.c
+++ b/ioservice/io_service.c
@@ -505,6 +505,7 @@ static void ios_stop(struct m0_reqh_service *service)
 
 	m0_ios_poolmach_fini(service->rs_reqh);
 	ios_delete_buffer_pool(service);
+	m0_ios_mds_rpc_ctx_fini(service);
 	m0_ios_cdom_fini(service->rs_reqh);
 	m0_reqh_lockers_clear(service->rs_reqh, ios_cdom_key);
 }
@@ -602,18 +603,23 @@ static void ios_stats_post_addb(struct m0_reqh_service *service)
 	}
 }
 
+M0_INTERNAL int m0_ios_mds_getattr(struct m0_reqh *reqh, struct m0_fid *gfid,
+				   struct m0_cob_attr *attr);
+M0_INTERNAL int m0_ios_mds_layout_get(struct m0_reqh *reqh,
+				      struct m0_layout_domain *ldom,
+				      uint64_t lid,
+				      struct m0_layout **l_out);
 M0_INTERNAL int m0_ios_mds_rpc_ctx_init(struct m0_reqh_service *service)
 {
-	struct m0_reqh              *reqh = service->rs_reqh;
-	struct m0_reqh_io_service   *serv_obj;
-	struct m0_rpc_client_ctx    *rpc_client_ctx;
-	int                          rc;
-	const char                  *dbname = "sr_cdb";
-	struct m0_net_domain        *cl_ndom;
-	struct cs_endpoint_and_xprt *ep;
-	struct m0_reqh_context      *reqh_ctx = service->rs_reqh_ctx;
-	const char                  *cli_ep_addr = "";
-	const char                  *srv_ep_addr = "";
+	struct m0_reqh            *reqh = service->rs_reqh;
+	struct m0_reqh_io_service *serv_obj;
+	struct m0_rpc_client_ctx  *rpc_client_ctx;
+	int                        rc;
+	const char                *dbname = "sr_cdb";
+	struct m0_net_domain      *cl_ndom;
+	struct m0_reqh_context    *reqh_ctx = service->rs_reqh_ctx;
+	const char                *cli_ep_addr;
+	const char                *srv_ep_addr;
 	enum {
 		RPC_TIMEOUT              = 10, /* seconds */
 		NR_SLOTS_PER_SESSION     = 10,
@@ -623,16 +629,12 @@ M0_INTERNAL int m0_ios_mds_rpc_ctx_init(struct m0_reqh_service *service)
 	M0_PRE(m0_reqh_lockers_is_empty(reqh, ios_mds_rpc_ctx_key));
 
 	srv_ep_addr = reqh_ctx->rc_mero->cc_mds_epx.ex_endpoint;
-	ep = cs_eps_tlist_tail(&reqh_ctx->rc_eps);
-	if (ep != NULL)
-		cli_ep_addr = ep->ex_endpoint;
+	cli_ep_addr = reqh_ctx->rc_mero->cc_cli2mds_epx.ex_endpoint;
 
 	M0_LOG(M0_ERROR, "cli = %s", cli_ep_addr);
 	M0_LOG(M0_ERROR, "srv = %s", srv_ep_addr);
 	serv_obj = container_of(service, struct m0_reqh_io_service, rios_gen);
 
-	return 0;
-
 	rpc_client_ctx = m0_alloc(sizeof *rpc_client_ctx);
 	if (rpc_client_ctx == NULL)
 		M0_RETURN(-ENOMEM);
@@ -661,6 +663,7 @@ M0_INTERNAL int m0_ios_mds_rpc_ctx_init(struct m0_reqh_service *service)
 	m0_reqh_lockers_set(reqh, ios_mds_rpc_ctx_key, rpc_client_ctx);
 	serv_obj->rios_mds_rpc_ctx = rpc_client_ctx;
 	m0_rwlock_write_unlock(&reqh->rh_rwlock);
+
 	M0_RETURN(0);
 }
 
@@ -669,7 +672,7 @@ struct m0_rpc_client_ctx *m0_ios_mds_rpc_ctx_get(struct m0_reqh *reqh)
 {
 	struct m0_rpc_client_ctx *rpc_client_ctx;
 	M0_PRE(reqh != NULL);
-	M0_PRE(m0_reqh_lockers_is_empty(reqh, ios_mds_rpc_ctx_key));
+	M0_PRE(!m0_reqh_lockers_is_empty(reqh, ios_mds_rpc_ctx_key));
 
 	rpc_client_ctx = m0_reqh_lockers_get(reqh, ios_mds_rpc_ctx_key);
 	M0_POST(rpc_client_ctx != NULL);
@@ -681,13 +684,12 @@ M0_INTERNAL void m0_ios_mds_rpc_ctx_fini(struct m0_reqh_service *service)
 	struct m0_reqh            *reqh = service->rs_reqh;
 	struct m0_reqh_io_service *serv_obj;
 	struct m0_rpc_client_ctx  *rpc_client_ctx;
-	return;
 	serv_obj = container_of(service, struct m0_reqh_io_service, rios_gen);
 
-	m0_net_domain_fini(&serv_obj->rios_cl_ndom);
 	m0_rwlock_write_lock(&reqh->rh_rwlock);
 	rpc_client_ctx = m0_reqh_lockers_get(reqh, ios_mds_rpc_ctx_key);
 	m0_rpc_client_stop(rpc_client_ctx);
+	m0_net_domain_fini(&serv_obj->rios_cl_ndom);
 	m0_reqh_lockers_clear(reqh, ios_mds_rpc_ctx_key);
 	m0_free(rpc_client_ctx);
 	m0_rwlock_write_unlock(&reqh->rh_rwlock);
@@ -715,13 +717,15 @@ M0_INTERNAL int m0_ios_mds_getattr(struct m0_reqh *reqh, struct m0_fid *gfid,
 	req_fop_cob = &getattr->g_body;
 	req_fop_cob->b_tfid = *gfid;
 
-	rc = m0_rpc_client_call(req, &rpc_client_ctx->rcx_session, NULL,
-				m0_time_from_now(60, 0));
-	if (rc != 0) {
+	rc = m0_rpc_client_call(req, &rpc_client_ctx->rcx_session, NULL, 0);
+	if (rc == 0) {
 		rep = m0_rpc_item_to_fop(req->f_item.ri_reply);
 		getattr_rep = m0_fop_data(rep);
 		rep_fop_cob = &getattr_rep->g_body;
-		m0_md_cob_wire2mem(attr, rep_fop_cob);
+		if (rep_fop_cob->b_rc == 0)
+			m0_md_cob_wire2mem(attr, rep_fop_cob);
+		else
+			rc = rep_fop_cob->b_rc;
 	}
 	m0_fop_put(req);
 	return rc;
diff --git a/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh b/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh
index 5fb6f7c..06a7136 100644
--- a/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh
+++ b/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh
@@ -57,6 +57,15 @@ EP=(
     12345:33:104
 )
 
+# list of client endpoints to mdservice
+EPC2M=(
+    12345:33:201
+    12345:33:202
+    12345:33:203
+    12345:33:204
+)
+
+
 unload_kernel_module()
 {
 	mero_module=$MERO_MODULE
diff --git a/m0t1fs/linux_kernel/st/m0t1fs_server_inc.sh b/m0t1fs/linux_kernel/st/m0t1fs_server_inc.sh
index e13a875..1fd8ad8 100644
--- a/m0t1fs/linux_kernel/st/m0t1fs_server_inc.sh
+++ b/m0t1fs/linux_kernel/st/m0t1fs_server_inc.sh
@@ -30,6 +30,7 @@ mero_service()
 			 -D db -S stobs -A addb-stobs \
 			 -G $XPT:${lnet_nid}:${EP[0]} \
 			 -e $XPT:${lnet_nid}:${EP[$i]} \
+			 -L $XPT:${lnet_nid}:${EPC2M[$i]} \
 			 $SNAME -m $MAX_RPC_MSG_SIZE \
 			 -q $TM_MIN_RECV_QUEUE_LEN"
 			echo $cmd
diff --git a/mero/setup.c b/mero/setup.c
index 25134ff..e614074 100644
--- a/mero/setup.c
+++ b/mero/setup.c
@@ -1569,6 +1569,7 @@ static void cs_help(FILE *out)
 "  -M num   Maximum RPC message size.\n"
 "  -C addr  Endpoint address of confd service.\n"
 "  -G addr  Endpoint address of mdservice service.\n"
+"  -L addr  Client Endpoint address to mdservice service.\n"
 "  -P str   Configuration profile.\n"
 "\n"
 "Request handler options:\n"
@@ -1691,10 +1692,16 @@ static int reqh_ctxs_are_valid(struct m0_mero *cctx)
 	} m0_tl_endfor;
 
 	if (cctx->cc_mds_epx.ex_endpoint == NULL) {
-		M0_LOG(M0_ERROR, "Missing or Invalid mdservice endpoint.\n"
+		M0_LOG(M0_ERROR, "Missing mdservice endpoint.\n"
 				 "Use -G to provice a valid one: %d", rc);
 		M0_RETURN(rc);
 	}
+	if (cctx->cc_cli2mds_epx.ex_endpoint == NULL) {
+		M0_LOG(M0_ERROR, "Missing client to mdservice endpoint.\n"
+				 "Use -L to provice a valid one: %d", rc);
+		M0_RETURN(rc);
+	}
+
 
 	M0_RETURN(rc);
 }
@@ -1768,6 +1775,12 @@ static int _args_parse(struct m0_mero *cctx, int argc, char **argv,
 					rc = ep_and_xprt_extract(&cctx->
 								 cc_mds_epx, s);
 				})),
+			M0_STRINGARG('L', "client endpoint address to mdservice",
+				LAMBDA(void, (const char *s)
+				{
+					rc = ep_and_xprt_extract(&cctx->
+								 cc_cli2mds_epx, s);
+				})),
 
 			/* -------------------------------------------
 			 * Request handler options
diff --git a/mero/setup.h b/mero/setup.h
index dc59166..2d4d986 100644
--- a/mero/setup.h
+++ b/mero/setup.h
@@ -244,9 +244,12 @@ struct m0_mero {
 	/** Segment size for any ADDB stob. */
 	size_t                   cc_addb_stob_segment_size;
 
-	/** mdservice end point */
+	/** mdservice endpoint */
 	struct cs_endpoint_and_xprt cc_mds_epx;
 
+	/** client endpoint to mdservice*/
+	struct cs_endpoint_and_xprt cc_cli2mds_epx;
+
 	/** command line arguments */
 	struct cs_args		 cc_args;
 };
-- 
1.8.3.2

