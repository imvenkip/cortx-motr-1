From ae445d2b3f9734845e9a786a0dd2fb3b59e68302 Mon Sep 17 00:00:00 2001
From: Rajesh Bhalerao <Rajesh_Bhalerao@xyratex.com>
Date: Thu, 23 May 2013 12:41:45 +0530
Subject: [PATCH 24/25] Addressed comments from CINSP-POSTUT.

---
 rm/file.c     |  80 ++++++++++++++++++------------------
 rm/rm.h       |  22 +++++-----
 rm/ut/file.c  | 130 +++++++++++++++++++++++++++++-----------------------------
 rm/ut/rings.c |  50 +++++++++++-----------
 rm/ut/rmut.c  |   8 ++--
 rm/ut/rmut.h  |  30 +++++++-------
 6 files changed, 161 insertions(+), 159 deletions(-)

diff --git a/rm/file.c b/rm/file.c
index 814cdc9..2f99563 100644
--- a/rm/file.c
+++ b/rm/file.c
@@ -154,28 +154,28 @@ static void file_lock_credit_init(struct m0_rm_resource *resource,
 static void file_lock_incoming_complete(struct m0_rm_incoming *in, int32_t rc);
 static void file_lock_incoming_conflict(struct m0_rm_incoming *in);
 
-static bool file_lock_cr_intersects(const struct m0_rm_credit *this,
+static bool file_lock_cr_intersects(const struct m0_rm_credit *self,
 				    const struct m0_rm_credit *c1);
 static m0_bcount_t file_lock_cr_len(const struct m0_rm_credit *c0);
 
-static int file_lock_cr_join(struct m0_rm_credit *this,
+static int file_lock_cr_join(struct m0_rm_credit *self,
 			     const struct m0_rm_credit *c1);
-static int file_lock_cr_disjoin(struct m0_rm_credit *this,
+static int file_lock_cr_disjoin(struct m0_rm_credit *self,
 				const struct m0_rm_credit *c1,
 				struct m0_rm_credit *intersection);
 static int file_lock_cr_copy(struct m0_rm_credit *dest,
-			     const struct m0_rm_credit *this);
-static int file_lock_cr_diff(struct m0_rm_credit *this,
+			     const struct m0_rm_credit *self);
+static int file_lock_cr_diff(struct m0_rm_credit *self,
 			     const struct m0_rm_credit *c1);
-static bool file_lock_cr_conflicts(const struct m0_rm_credit *this,
+static bool file_lock_cr_conflicts(const struct m0_rm_credit *self,
 				   const struct m0_rm_credit *c1);
-static bool file_lock_cr_is_subset(const struct m0_rm_credit *this,
+static bool file_lock_cr_is_subset(const struct m0_rm_credit *self,
 				   const struct m0_rm_credit *c1);
-static int file_lock_cr_encode(struct m0_rm_credit *this,
+static int file_lock_cr_encode(struct m0_rm_credit *self,
 			       struct m0_bufvec_cursor *cur);
-static int file_lock_cr_decode(struct m0_rm_credit *this,
+static int file_lock_cr_decode(struct m0_rm_credit *self,
 			       struct m0_bufvec_cursor *cur);
-static void file_lock_cr_free(struct m0_rm_credit *this);
+static void file_lock_cr_free(struct m0_rm_credit *self);
 
 static struct m0_rm_resource_type flock_rt = {
 	.rt_name = "File Lock Resource Type"
@@ -311,13 +311,13 @@ static bool file_lock_credit_invariant(const struct m0_rm_credit *file_cr)
 	return M0_IN(file_cr->cr_datum, (0, RM_FILE_LOCK));
 }
 
-static bool file_lock_cr_intersects(const struct m0_rm_credit *this,
+static bool file_lock_cr_intersects(const struct m0_rm_credit *self,
 				    const struct m0_rm_credit *c1)
 {
 	M0_ASSERT(c1 != NULL);
-	M0_PRE(file_lock_credit_invariant(this) &&
+	M0_PRE(file_lock_credit_invariant(self) &&
 	       file_lock_credit_invariant(c1));
-	return this->cr_datum == c1->cr_datum;
+	return self->cr_datum == c1->cr_datum;
 }
 
 static m0_bcount_t file_lock_cr_len(const struct m0_rm_credit *c0)
@@ -334,13 +334,13 @@ static m0_bcount_t file_lock_cr_len(const struct m0_rm_credit *c0)
 	return m0_xcode_length(&ctx);
 }
 
-static int file_lock_cr_join(struct m0_rm_credit *this,
+static int file_lock_cr_join(struct m0_rm_credit *self,
 			     const struct m0_rm_credit *c1)
 {
 	return 0;
 }
 
-static int file_lock_cr_disjoin(struct m0_rm_credit *this,
+static int file_lock_cr_disjoin(struct m0_rm_credit *self,
 				const struct m0_rm_credit *c1,
 				struct m0_rm_credit *intersection)
 {
@@ -348,49 +348,49 @@ static int file_lock_cr_disjoin(struct m0_rm_credit *this,
 }
 
 static int file_lock_cr_copy(struct m0_rm_credit *dest,
-			     const struct m0_rm_credit *this)
+			     const struct m0_rm_credit *self)
 {
 	M0_ASSERT(dest != NULL);
-	M0_PRE(file_lock_credit_invariant(this));
+	M0_PRE(file_lock_credit_invariant(self));
 
-	dest->cr_datum = this->cr_datum;
-	dest->cr_owner = this->cr_owner;
-	dest->cr_ops = this->cr_ops;
+	dest->cr_datum = self->cr_datum;
+	dest->cr_owner = self->cr_owner;
+	dest->cr_ops = self->cr_ops;
 	M0_POST(file_lock_credit_invariant(dest));
 	return 0;
 }
 
-static int file_lock_cr_diff(struct m0_rm_credit *this,
+static int file_lock_cr_diff(struct m0_rm_credit *self,
 			     const struct m0_rm_credit *c1)
 {
 	M0_ASSERT(c1 != NULL);
-	M0_PRE(file_lock_credit_invariant(this) &&
+	M0_PRE(file_lock_credit_invariant(self) &&
 	       file_lock_credit_invariant(c1));
 
-	this->cr_datum = max64((int64_t)(this->cr_datum - c1->cr_datum), 0);
-	M0_POST(file_lock_credit_invariant(this));
+	self->cr_datum = max64((int64_t)(self->cr_datum - c1->cr_datum), 0);
+	M0_POST(file_lock_credit_invariant(self));
 	return 0;
 }
 
-static bool file_lock_cr_conflicts(const struct m0_rm_credit *this,
+static bool file_lock_cr_conflicts(const struct m0_rm_credit *self,
 				   const struct m0_rm_credit *c1)
 {
 	M0_ASSERT(c1 != NULL);
-	M0_PRE(file_lock_credit_invariant(this) &&
+	M0_PRE(file_lock_credit_invariant(self) &&
 	       file_lock_credit_invariant(c1));
 
-	return this->cr_datum & c1->cr_datum;
+	return self->cr_datum & c1->cr_datum;
 }
 
-static bool file_lock_cr_is_subset(const struct m0_rm_credit *this,
+static bool file_lock_cr_is_subset(const struct m0_rm_credit *self,
 				   const struct m0_rm_credit *c1)
 {
-	M0_PRE(file_lock_credit_invariant(this) &&
+	M0_PRE(file_lock_credit_invariant(self) &&
 	       file_lock_credit_invariant(c1));
-	return this->cr_datum <= c1->cr_datum;
+	return self->cr_datum <= c1->cr_datum;
 }
 
-static int file_lock_cr_encdec(struct m0_rm_credit *this,
+static int file_lock_cr_encdec(struct m0_rm_credit *self,
 			       struct m0_bufvec_cursor *cur,
 			       enum m0_bufvec_what what)
 {
@@ -401,27 +401,27 @@ static int file_lock_cr_encdec(struct m0_rm_credit *this,
 	M0_ASSERT(cur != NULL);
 
 	datumobj.xo_type = &M0_XT_U64;
-	datumobj.xo_ptr = (void *)&this->cr_datum;
+	datumobj.xo_ptr = (void *)&self->cr_datum;
 	M0_RETURN(m0_xcode_encdec(&ctx, &datumobj, cur, what));
 }
 
-static int file_lock_cr_encode(struct m0_rm_credit *this,
+static int file_lock_cr_encode(struct m0_rm_credit *self,
 			       struct m0_bufvec_cursor *cur)
 {
-	M0_PRE(file_lock_credit_invariant(this));
-	return file_lock_cr_encdec(this, cur, M0_BUFVEC_ENCODE);
+	M0_PRE(file_lock_credit_invariant(self));
+	return file_lock_cr_encdec(self, cur, M0_BUFVEC_ENCODE);
 }
 
-static int file_lock_cr_decode(struct m0_rm_credit *this,
+static int file_lock_cr_decode(struct m0_rm_credit *self,
 			       struct m0_bufvec_cursor *cur)
 {
-	M0_PRE(file_lock_credit_invariant(this));
-	return file_lock_cr_encdec(this, cur, M0_BUFVEC_DECODE);
+	M0_PRE(file_lock_credit_invariant(self));
+	return file_lock_cr_encdec(self, cur, M0_BUFVEC_DECODE);
 }
 
-static void file_lock_cr_free(struct m0_rm_credit *this)
+static void file_lock_cr_free(struct m0_rm_credit *self)
 {
-	this->cr_datum = 0;
+	self->cr_datum = 0;
 }
 
 /** @} */ /* end internal FileLockInternal */
diff --git a/rm/rm.h b/rm/rm.h
index b561f18..bb53323 100644
--- a/rm/rm.h
+++ b/rm/rm.h
@@ -441,21 +441,21 @@ struct m0_rm_credit_ops {
 	 * Called when the generic code is about to free a credit. Type specific
 	 * code releases any resources associated with the credit.
 	 */
-	void (*cro_free)(struct m0_rm_credit *_this);
+	void (*cro_free)(struct m0_rm_credit *self);
 	/**
 	 * Serialises a credit of a resource into a buffer.
 	 */
-	int  (*cro_encode)(struct m0_rm_credit *_this,
+	int  (*cro_encode)(struct m0_rm_credit *self,
 			   struct m0_bufvec_cursor *cur);
 	/**
 	 * De-serialises the credit of a resource from a buffer.
 	 */
-	int  (*cro_decode)(struct m0_rm_credit *_this,
+	int  (*cro_decode)(struct m0_rm_credit *self,
 			   struct m0_bufvec_cursor *cur);
 	/**
 	 * Return the size of the credit's data.
 	 */
-	m0_bcount_t (*cro_len) (const struct m0_rm_credit *_this);
+	m0_bcount_t (*cro_len) (const struct m0_rm_credit *self);
 
 	/** @name operations.
 	 *
@@ -483,25 +483,25 @@ struct m0_rm_credit_ops {
 	 *
 	 *      - !intersects(A, 0)
 	 */
-        bool (*cro_intersects) (const struct m0_rm_credit *_this,
+        bool (*cro_intersects) (const struct m0_rm_credit *self,
                                 const struct m0_rm_credit *c1);
         /**
          * @retval True if 'this credit' is subset (or proper subset) of c1.
 	 */
-        bool (*cro_is_subset) (const struct m0_rm_credit *_this,
+        bool (*cro_is_subset) (const struct m0_rm_credit *self,
                                const struct m0_rm_credit *c1);
         /**
          * Adjoins c1 to 'this credit', updating this in place to be the sum
          * credit.
 	 */
-        int (*cro_join) (struct m0_rm_credit *_this,
+        int (*cro_join) (struct m0_rm_credit *self,
                           const struct m0_rm_credit *c1);
         /**
          * Splits this into two parts - diff(this,c1) and intersection(this, c1)
 	 * Destructively updates 'this credit' with diff(this, c1) and updates
 	 * intersection with intersection of (this, c1)
 	 */
-        int (*cro_disjoin) (struct m0_rm_credit *_this,
+        int (*cro_disjoin) (struct m0_rm_credit *self,
                             const struct m0_rm_credit *c1,
 			    struct m0_rm_credit *intersection);
 	/**
@@ -522,7 +522,7 @@ struct m0_rm_credit_ops {
          *       it, a credit to write to a variable must always imply a credit
          *       to read it.
 	 */
-        bool (*cro_conflicts) (const struct m0_rm_credit *_this,
+        bool (*cro_conflicts) (const struct m0_rm_credit *self,
 			       const struct m0_rm_credit *c1);
         /** Difference between credits.
 	 *
@@ -564,14 +564,14 @@ struct m0_rm_credit_ops {
 	 *
 	 *  This function destructively updates "this" in place.
          */
-        int  (*cro_diff)(struct m0_rm_credit *_this,
+        int  (*cro_diff)(struct m0_rm_credit *self,
 			 const struct m0_rm_credit *c1);
 	/** Creates a copy of "src" in "dst".
 	 *
 	 *  @pre dst is empty.
 	 */
         int  (*cro_copy)(struct m0_rm_credit *dst,
-			 const struct m0_rm_credit *_this);
+			 const struct m0_rm_credit *self);
         /** @} end of Credits operations. */
 };
 
diff --git a/rm/ut/file.c b/rm/ut/file.c
index 06401d7..f900ade 100644
--- a/rm/ut/file.c
+++ b/rm/ut/file.c
@@ -45,10 +45,12 @@ extern const struct m0_rm_resource_type_ops file_lock_type_ops;
  */
 
 enum flock_tests {
-	TEST1 = 0,
-	TEST2,
-	TEST3,
-	TEST4,
+	/* Test the locking on a lock client */
+	LOCK_ON_CLIENT_TEST = 0,
+	/* Test the locking on a lock server */
+	LOCK_ON_SERVER_TEST,
+	/* Test the distributed locking */
+	DISTRIBUTED_LOCK_TEST,
 	TEST_NR,
 };
 
@@ -69,19 +71,19 @@ static struct m0_chan flock_tests_chan;
 static struct m0_clink tests_clink[TEST_NR];
 static struct m0_mutex flock_tests_chan_mutex;
 
-static void fl_rtype_set(struct rm_ut_data *_this)
+static void fl_rtype_set(struct rm_ut_data *self)
 {
 	int rc;
 
-	rc = m0_file_lock_type_register(&_this->rd_dom);
+	rc = m0_file_lock_type_register(&self->rd_dom);
 	M0_UT_ASSERT(rc == 0);
-	_this->rd_rt = _this->rd_dom.rd_types[M0_RM_FLOCK_RT];
+	self->rd_rt = self->rd_dom.rd_types[M0_RM_FLOCK_RT];
 }
 
-static void fl_rtype_unset(struct rm_ut_data *_this)
+static void fl_rtype_unset(struct rm_ut_data *self)
 {
-	m0_file_lock_type_deregister(&_this->rd_dom);
-	_this->rd_rt = NULL;
+	m0_file_lock_type_deregister(&self->rd_dom);
+	self->rd_rt = NULL;
 }
 
 /*
@@ -89,7 +91,7 @@ static void fl_rtype_unset(struct rm_ut_data *_this)
  * This test needs two object hierarchies. Hence we need one more file type
  * object.
  */
-static void fl_client_rtype_set(struct rm_ut_data *_this)
+static void fl_client_rtype_set(struct rm_ut_data *self)
 {
 	struct m0_rm_resource_type *rt;
 	int			    rc;
@@ -98,19 +100,19 @@ static void fl_client_rtype_set(struct rm_ut_data *_this)
 	M0_UT_ASSERT(rt != NULL);
 	rt->rt_id = M0_RM_FLOCK_RT;
 	rt->rt_ops = &file_lock_type_ops;
-	rc = m0_rm_type_register(&_this->rd_dom, rt);
+	rc = m0_rm_type_register(&self->rd_dom, rt);
 	M0_UT_ASSERT(rc == 0);
-	_this->rd_rt = rt;
+	self->rd_rt = rt;
 }
 
-static void fl_client_rtype_unset(struct rm_ut_data *_this)
+static void fl_client_rtype_unset(struct rm_ut_data *self)
 {
-	m0_rm_type_deregister(_this->rd_rt);
-	m0_free(_this->rd_rt);
-	_this->rd_rt = NULL;
+	m0_rm_type_deregister(self->rd_rt);
+	m0_free(self->rd_rt);
+	self->rd_rt = NULL;
 }
 
-static void fl_res_set(struct rm_ut_data *_this)
+static void fl_res_set(struct rm_ut_data *self)
 {
 	struct m0_file *flock;
 	struct m0_fid   fid;
@@ -118,53 +120,52 @@ static void fl_res_set(struct rm_ut_data *_this)
 	M0_ALLOC_PTR(flock);
 	M0_UT_ASSERT(flock != NULL);
 	m0_fid_set(&fid, 1, 0);
-	m0_file_init(flock, &fid, &_this->rd_dom);
-	_this->rd_res = &flock->fi_res;
+	m0_file_init(flock, &fid, &self->rd_dom);
+	self->rd_res = &flock->fi_res;
 }
 
-static void fl_res_unset(struct rm_ut_data *_this)
+static void fl_res_unset(struct rm_ut_data *self)
 {
 	struct m0_file *flock;
 
-	flock = container_of(_this->rd_res, struct m0_file, fi_res);
+	flock = container_of(self->rd_res, struct m0_file, fi_res);
 	m0_file_fini(flock);
 	m0_free(flock);
-	_this->rd_res = NULL;
+	self->rd_res = NULL;
 }
 
-static void fl_owner_set(struct rm_ut_data *_this)
+static void fl_owner_set(struct rm_ut_data *self)
 {
 	struct m0_rm_owner *owner;
 	struct m0_file     *flock;
 
-
 	M0_ALLOC_PTR(owner);
 	M0_UT_ASSERT(owner != NULL);
-	flock = container_of(_this->rd_res, struct m0_file, fi_res);
+	flock = container_of(self->rd_res, struct m0_file, fi_res);
 	m0_file_owner_init(owner, flock, NULL);
-	_this->rd_owner = owner;
+	self->rd_owner = owner;
 }
 
-static void fl_owner_unset(struct rm_ut_data *_this)
+static void fl_owner_unset(struct rm_ut_data *self)
 {
 	int rc;
 
-	m0_rm_owner_windup(_this->rd_owner);
-	rc = m0_rm_owner_timedwait(_this->rd_owner, M0_BITS(ROS_FINAL),
+	m0_rm_owner_windup(self->rd_owner);
+	rc = m0_rm_owner_timedwait(self->rd_owner, M0_BITS(ROS_FINAL),
 				   M0_TIME_NEVER);
 	M0_UT_ASSERT(rc == 0);
-	M0_UT_ASSERT(owner_state(_this->rd_owner) == ROS_FINAL);
-	m0_file_owner_fini(_this->rd_owner);
-	m0_free(_this->rd_owner);
-	_this->rd_owner = NULL;
+	M0_UT_ASSERT(owner_state(self->rd_owner) == ROS_FINAL);
+	m0_file_owner_fini(self->rd_owner);
+	m0_free(self->rd_owner);
+	self->rd_owner = NULL;
 }
 
-static void fl_datum_set(struct rm_ut_data *_this)
+static void fl_datum_set(struct rm_ut_data *self)
 {
-	_this->rd_credit.cr_datum = RM_FILE_LOCK;
+	self->rd_credit.cr_datum = RM_FILE_LOCK;
 }
 
-static struct rm_ut_data_ops fl_srv_ut_data_ops = {
+const static struct rm_ut_data_ops fl_srv_ut_data_ops = {
 	.rtype_set = fl_rtype_set,
 	.rtype_unset = fl_rtype_unset,
 	.resource_set = fl_res_set,
@@ -174,7 +175,7 @@ static struct rm_ut_data_ops fl_srv_ut_data_ops = {
 	.credit_datum_set = fl_datum_set
 };
 
-static struct rm_ut_data_ops fl_client_ut_data_ops = {
+const static struct rm_ut_data_ops fl_client_ut_data_ops = {
 	.rtype_set = fl_client_rtype_set,
 	.rtype_unset = fl_client_rtype_unset,
 	.resource_set = fl_res_set,
@@ -184,7 +185,7 @@ static struct rm_ut_data_ops fl_client_ut_data_ops = {
 	.credit_datum_set = fl_datum_set
 };
 
-void flock_client_utdata_ops_set(struct rm_ut_data *data)
+static void flock_client_utdata_ops_set(struct rm_ut_data *data)
 {
 	data->rd_ops = &fl_client_ut_data_ops;
 }
@@ -246,19 +247,19 @@ static void test_verify(enum flock_tests test_id)
 	struct m0_rm_owner *srv  = rm_ctx[SERVER_2].rc_test_data.rd_owner;
 
 	switch(test_id) {
-	case TEST1:
+	case LOCK_ON_CLIENT_TEST:
 		M0_UT_ASSERT(!m0_rm_ur_tlist_is_empty(&srv->ro_sublet));
 		M0_UT_ASSERT(!m0_rm_ur_tlist_is_empty(&clnt->ro_borrowed));
 		M0_UT_ASSERT(!m0_rm_ur_tlist_is_empty(
 				&clnt->ro_owned[OWOS_CACHED]));
 		break;
-	case TEST2:
+	case LOCK_ON_SERVER_TEST:
 		M0_UT_ASSERT(m0_rm_ur_tlist_is_empty(&srv->ro_sublet));
 		M0_UT_ASSERT(!m0_rm_ur_tlist_is_empty(
 				&srv->ro_owned[OWOS_CACHED]));
 		M0_UT_ASSERT(m0_rm_ur_tlist_is_empty(&clnt->ro_borrowed));
 		break;
-	case TEST3:
+	case DISTRIBUTED_LOCK_TEST:
 		M0_UT_ASSERT(!m0_rm_ur_tlist_is_empty(&srv->ro_sublet) ||
 			     !m0_rm_ur_tlist_is_empty(
                                 &srv->ro_owned[OWOS_CACHED]) ||
@@ -270,7 +271,7 @@ static void test_verify(enum flock_tests test_id)
 	}
 }
 
-static void test3_lock(enum rm_server srv_id, int n)
+static void dlock(enum rm_server srv_id, int n)
 {
 	struct m0_rm_owner    *owner = rm_ctx[srv_id].rc_test_data.rd_owner;
 	struct m0_rm_incoming  req;
@@ -279,7 +280,7 @@ static void test3_lock(enum rm_server srv_id, int n)
 	M0_SET0(&req);
 	m0_file_lock(owner, &req);
 	m0_rm_owner_lock(owner);
-	test_verify(TEST3);
+	test_verify(DISTRIBUTED_LOCK_TEST);
 	if (incoming_state(&req) == RI_WAIT) {
 		rc = m0_sm_timedwait(&req.rin_sm,
 				     M0_BITS(RI_SUCCESS, RI_FAILURE),
@@ -299,12 +300,12 @@ static void test3_lock(enum rm_server srv_id, int n)
 	M0_SET0(&req);
 }
 
-static void srv_lock(int n)
+static void srv_dlock(int n)
 {
-	test3_lock(SERVER_2, n);
+	dlock(SERVER_2, n);
 }
 
-static void srv_test3_run()
+static void srv_dlock_run()
 {
 	int i;
 	int sum;
@@ -312,7 +313,7 @@ static void srv_test3_run()
 
 	for (sum = i = 0; i < SRV_THR_NR; ++i) {
 		rc = M0_THREAD_INIT(&srv_thr[i], int, NULL,
-				    &srv_lock, i, "srv_lock");
+				    &srv_dlock, i, "srv_dlock");
 		M0_UT_ASSERT(rc == 0);
 		sum += i;
 	}
@@ -324,12 +325,13 @@ static void srv_test3_run()
 	M0_UT_ASSERT(srv_counter == sum);
 }
 
-static void clnt_lock(int n)
+static void clnt_dlock(int n)
 {
-	test3_lock(SERVER_1, n);
+	/* SERVER_1 acts as a client */
+	dlock(SERVER_1, n);
 }
 
-static void client_test3_run()
+static void client_dlock_run()
 {
 	int i;
 	int sum;
@@ -340,7 +342,7 @@ static void client_test3_run()
 
 	for (sum = i = 0; i < CLNT_THR_NR; ++i) {
 		rc = M0_THREAD_INIT(&clnt_thr[i], int, NULL,
-				    &clnt_lock, i, "clnt_lock");
+				    &clnt_dlock, i, "clnt_dlock");
 		M0_UT_ASSERT(rc == 0);
 		sum += i;
 	}
@@ -353,7 +355,7 @@ static void client_test3_run()
 }
 
 /* DLD - Test 3 */
-static void test2_run()
+static void server_lock_test()
 {
 	/* Take a wait lock on server */
 	wait_lock(SERVER_2);
@@ -401,40 +403,40 @@ static void testcase1_run()
 	loan_session_set(SERVER_2, SERVER_1);
 }
 
-static void test1_run()
+static void client_lock_test()
 {
 	testcase1_run();
-	test_verify(TEST1);
+	test_verify(LOCK_ON_CLIENT_TEST);
 	testcase2_run();
-	test_verify(TEST1);
+	test_verify(LOCK_ON_CLIENT_TEST);
 }
 
 static void client_tests(void)
 {
-	m0_chan_wait(&tests_clink[TEST1]);
+	m0_chan_wait(&tests_clink[LOCK_ON_CLIENT_TEST]);
 
 	/* Test encode/decode for code coverage */
 	file_encdec_test(&rm_ctx[SERVER_1].rc_test_data);
 
 	/* Now start the use-cases */
-	test1_run();
+	client_lock_test();
 
 	/* Begin next test */
 	m0_chan_signal_lock(&flock_tests_chan);
-	m0_chan_wait(&tests_clink[TEST3]);
+	m0_chan_wait(&tests_clink[DISTRIBUTED_LOCK_TEST]);
 
-	client_test3_run();
+	client_dlock_run();
 }
 
 static void server_tests(void)
 {
-	m0_chan_wait(&tests_clink[TEST2]);
-	test2_run();
-	test_verify(TEST2);
+	m0_chan_wait(&tests_clink[LOCK_ON_SERVER_TEST]);
+	server_lock_test();
+	test_verify(LOCK_ON_SERVER_TEST);
 
 	/* Begin next test */
 	m0_chan_signal_lock(&flock_tests_chan);
-	srv_test3_run();
+	srv_dlock_run();
 }
 
 static void rm_server_start(const int tid)
diff --git a/rm/ut/rings.c b/rm/ut/rings.c
index 8ae57eb..e459bf1 100644
--- a/rm/ut/rings.c
+++ b/rm/ut/rings.c
@@ -52,7 +52,7 @@ const struct m0_rm_resource_ops rings_ops = {
 	.rop_credit_init   = rings_credit_init
 };
 
-static void rings_rtype_set(struct rm_ut_data *_this)
+static void rings_rtype_set(struct rm_ut_data *self)
 {
 	struct m0_rm_resource_type *rings_rtype;
 	int			    rc;
@@ -61,63 +61,63 @@ static void rings_rtype_set(struct rm_ut_data *_this)
 	M0_UT_ASSERT(rings_rtype != NULL);
 	rings_rtype->rt_id = 0;
 	rings_rtype->rt_ops = &rings_rtype_ops;
-	rc = m0_rm_type_register(&_this->rd_dom, rings_rtype);
+	rc = m0_rm_type_register(&self->rd_dom, rings_rtype);
 	M0_UT_ASSERT(rc == 0);
-	_this->rd_rt = rings_rtype;
+	self->rd_rt = rings_rtype;
 }
 
-static void rings_rtype_unset(struct rm_ut_data *_this)
+static void rings_rtype_unset(struct rm_ut_data *self)
 {
-	m0_rm_type_deregister(_this->rd_rt);
-	m0_free(_this->rd_rt);
-	_this->rd_rt = NULL;
+	m0_rm_type_deregister(self->rd_rt);
+	m0_free(self->rd_rt);
+	self->rd_rt = NULL;
 }
 
-static void rings_res_set(struct rm_ut_data *_this)
+static void rings_res_set(struct rm_ut_data *self)
 {
 	struct m0_rings *rings_res;
 
 	M0_ALLOC_PTR(rings_res);
 	M0_UT_ASSERT(rings_res != NULL);
 	rings_res->rs_resource.r_ops = &rings_ops;
-	m0_rm_resource_add(_this->rd_rt, &rings_res->rs_resource);
-	_this->rd_res = &rings_res->rs_resource;
+	m0_rm_resource_add(self->rd_rt, &rings_res->rs_resource);
+	self->rd_res = &rings_res->rs_resource;
 }
 
-static void rings_res_unset(struct rm_ut_data *_this)
+static void rings_res_unset(struct rm_ut_data *self)
 {
 	struct m0_rings *rings_res;
 
-	m0_rm_resource_del(_this->rd_res);
-	rings_res = container_of(_this->rd_res, struct m0_rings, rs_resource);
+	m0_rm_resource_del(self->rd_res);
+	rings_res = container_of(self->rd_res, struct m0_rings, rs_resource);
 	m0_free(rings_res);
-	_this->rd_res = NULL;
+	self->rd_res = NULL;
 }
 
-static void rings_owner_set(struct rm_ut_data *_this)
+static void rings_owner_set(struct rm_ut_data *self)
 {
 	struct m0_rm_owner *owner;
 
 	M0_ALLOC_PTR(owner);
 	M0_UT_ASSERT(owner != NULL);
-	m0_rm_owner_init(owner, _this->rd_res, NULL);
-	_this->rd_owner = owner;
+	m0_rm_owner_init(owner, self->rd_res, NULL);
+	self->rd_owner = owner;
 }
 
-static void rings_owner_unset(struct rm_ut_data *_this)
+static void rings_owner_unset(struct rm_ut_data *self)
 {
-	m0_rm_owner_windup(_this->rd_owner);
-	m0_rm_owner_fini(_this->rd_owner);
-	m0_free(_this->rd_owner);
-	_this->rd_owner = NULL;
+	m0_rm_owner_windup(self->rd_owner);
+	m0_rm_owner_fini(self->rd_owner);
+	m0_free(self->rd_owner);
+	self->rd_owner = NULL;
 }
 
-static void rings_datum_set(struct rm_ut_data *_this)
+static void rings_datum_set(struct rm_ut_data *self)
 {
-	_this->rd_credit.cr_datum = ALLRINGS;
+	self->rd_credit.cr_datum = ALLRINGS;
 }
 
-static struct rm_ut_data_ops rings_ut_data_ops = {
+const static struct rm_ut_data_ops rings_ut_data_ops = {
 	.rtype_set = rings_rtype_set,
 	.rtype_unset = rings_rtype_unset,
 	.resource_set = rings_res_set,
diff --git a/rm/ut/rmut.c b/rm/ut/rmut.c
index b5ec0c8..b21c821 100644
--- a/rm/ut/rmut.c
+++ b/rm/ut/rmut.c
@@ -69,13 +69,13 @@ const static struct m0_net_buffer_pool_ops buf_ops = {
 	.nbpo_not_empty	      = buf_empty,
 };
 
-void rm_test_owner_capital_raise(struct rm_ut_data *_this)
+void rm_test_owner_capital_raise(struct rm_ut_data *self)
 {
-	struct m0_rm_owner  *owner  = _this->rd_owner;
-	struct m0_rm_credit *credit = &_this->rd_credit;
+	struct m0_rm_owner  *owner  = self->rd_owner;
+	struct m0_rm_credit *credit = &self->rd_credit;
 
 	m0_rm_credit_init(credit, owner);
-	_this->rd_ops->credit_datum_set(_this);
+	self->rd_ops->credit_datum_set(self);
 	m0_rm_owner_selfadd(owner, credit);
 	M0_UT_ASSERT(!m0_rm_ur_tlist_is_empty(&owner->ro_borrowed));
 	M0_UT_ASSERT(!m0_rm_ur_tlist_is_empty(&owner->ro_owned[OWOS_CACHED]));
diff --git a/rm/ut/rmut.h b/rm/ut/rmut.h
index 66677cb..276d789 100644
--- a/rm/ut/rmut.h
+++ b/rm/ut/rmut.h
@@ -53,26 +53,26 @@ enum rm_server {
 struct rm_ut_data;
 
 struct rm_ut_data_ops {
-	void (*rtype_set)(struct rm_ut_data *_this);
-	void (*rtype_unset)(struct rm_ut_data *_this);
-	void (*resource_set)(struct rm_ut_data *_this);
-	void (*resource_unset)(struct rm_ut_data *_this);
-	void (*owner_set)(struct rm_ut_data *_this);
-	void (*owner_unset)(struct rm_ut_data *_this);
-	void (*credit_datum_set)(struct rm_ut_data *_this);
+	void (*rtype_set)(struct rm_ut_data *self);
+	void (*rtype_unset)(struct rm_ut_data *self);
+	void (*resource_set)(struct rm_ut_data *self);
+	void (*resource_unset)(struct rm_ut_data *self);
+	void (*owner_set)(struct rm_ut_data *self);
+	void (*owner_unset)(struct rm_ut_data *self);
+	void (*credit_datum_set)(struct rm_ut_data *self);
 };
 
 /*
  * Resource manager class-collection.
  */
 struct rm_ut_data {
-	struct m0_rm_domain	    rd_dom;
-	struct m0_rm_resource_type *rd_rt;
-	struct m0_rm_resource	   *rd_res;
-	struct m0_rm_owner	   *rd_owner;
-	struct m0_rm_incoming	    rd_in;
-	struct m0_rm_credit	    rd_credit;
-	struct rm_ut_data_ops	   *rd_ops;
+	struct m0_rm_domain	     rd_dom;
+	struct m0_rm_resource_type  *rd_rt;
+	struct m0_rm_resource	    *rd_res;
+	struct m0_rm_owner	    *rd_owner;
+	struct m0_rm_incoming	     rd_in;
+	struct m0_rm_credit	     rd_credit;
+	const struct rm_ut_data_ops *rd_ops;
 };
 
 /*
@@ -110,7 +110,7 @@ M0_EXTERN struct rm_ut_data rm_test_data;
 
 void rm_utdata_init(struct rm_ut_data *data, enum obj_type type);
 void rm_utdata_fini(struct rm_ut_data *data, enum obj_type type);
-void rm_test_owner_capital_raise(struct rm_ut_data *_this);
+void rm_test_owner_capital_raise(struct rm_ut_data *self);
 
 /* Test server functions */
 void rm_ctx_config(enum rm_server id);
-- 
1.8.3.2

