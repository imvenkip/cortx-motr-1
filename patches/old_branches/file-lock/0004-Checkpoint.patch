From 4b795fca5eef8d5aa764571dc807276f2cdff15e Mon Sep 17 00:00:00 2001
From: Rajesh Bhalerao <Rajesh_Bhalerao@xyratex.com>
Date: Mon, 18 Mar 2013 10:52:32 +0530
Subject: [PATCH 04/25] Checkpoint.

---
 rm/Makefile.sub |  2 ++
 rm/file.c       | 81 +++++++++++++++++++++++++++++++++++++++++++++++----------
 rm/file.h       |  4 +--
 3 files changed, 71 insertions(+), 16 deletions(-)

diff --git a/rm/Makefile.sub b/rm/Makefile.sub
index 4299fde..7738825 100644
--- a/rm/Makefile.sub
+++ b/rm/Makefile.sub
@@ -1,11 +1,13 @@
 nobase_mero_include_HEADERS += rm/rm.h \
 			       rm/rm_fops.h \
 			       rm/rm_foms.h \
+			       rm/file.h \
 			       rm/rm_xc.h
 
 mero_libmero_la_SOURCES     += rm/rm_fops.c \
 			       rm/rm.c \
 			       rm/rm_foms.c \
+			       rm/file.c \
 			       rm/rm_xc.c
 
 XC_FILES                    += rm/rm_xc.h
diff --git a/rm/file.c b/rm/file.c
index 1ff9e06..4a6eac8 100644
--- a/rm/file.c
+++ b/rm/file.c
@@ -154,6 +154,10 @@
    @{
  */
 
+static struct m0_rm_resource_type flock_rt = {
+	.rt_name = "File Lock Resource Type"
+};
+
 const struct m0_rm_resource_type_ops file_lock_type_ops = {
 	.rto_eq     = file_lock_equal,
 	.rto_decode = file_lock_decode,
@@ -193,23 +197,47 @@ static bool file_lock_equal(const struct m0_rm_resource *resource0,
 static int file_lock_encode(struct m0_bufvec_cursor *cur,
 			    const struct m0_rm_resource *resource)
 {
+	struct m0_file *fl;
+
+	M0_ENTRY();
+	M0_PRE(resource != NULL);
+	
+	fl = container_of(resource, struct m0_file, fi_res);
+	m0_bufvec_cursor_copyto(cur, (void *)&fl->fi_fid, sizeof fl->fi_fid);
+
+	M0_RETURN(0);
 }
 
 /** Decode file_lock - from the wire */
 static int file_lock_decode(const struct m0_bufvec_cursor *cur,
 			    struct m0_rm_resource **resource)
 {
+	struct m0_file *fl;
+
+	M0_ENTRY();
+	M0_PRE(resource != NULL);
+
+	M0_ALLOC_PTR(fl);
+	if (fl == NULL)
+		M0_RETURN(-ENOMEM);
+
+	m0_bufvec_cursor_copyfrom(cur, &fl->fi_fid, sizeof fl->fi_fid);
+	*resource = &fl->fi_res;
+	M0_RETURN(0);
 }
 
 /** Initialises credit (lock state) and ops vector for the file_lock */
 static void file_lock_credit_init(struct m0_rm_resource *resource,
 				  struct m0_rm_credit *credit)
 {
+	credit->cr_ops = &file_lock_credit_ops;
 }
 
 /** Lock request completion callback */
 static void file_lock_incoming_complete(struct m0_rm_incoming *in, int32_t rc)
 {
+	/* Do nothing */
+	return;
 }
 
 /** Lock request conflict callback - Invalid for file_lock */
@@ -221,55 +249,75 @@ static void file_lock_incoming_conflict(struct m0_rm_incoming *in)
 static bool file_lock_cr_intersects(const struct m0_rm_credit *c0,
 				    const struct m0_rm_credit *c1)
 {
+	return c0->cr_datum == c1->cr_datum;
 }
 
-static bool file_lock_cr_len(const struct m0_rm_credit *c0)
+static m0_bcount_t file_lock_cr_len(const struct m0_rm_credit *c0)
 {
+	return (m0_bcount_t) sizeof(uint64_t);
 }
 
 static int file_lock_cr_join(struct m0_rm_credit *c0,
 			     const struct m0_rm_credit *c1)
 {
+	return 0;
 }
 
 static int file_lock_cr_disjoin(struct m0_rm_credit *c0,
 				const struct m0_rm_credit *c1,
 				struct m0_rm_credit *intersection)
 {
+	return -EPERM;
 }
 
 static int file_lock_cr_copy(struct m0_rm_credit *dst,
 			     const struct m0_rm_credit *src)
 {
+	dest->cr_datum = src->cr_datum;
+	dest->cr_owner = src->cr_owner;
+	dest->cr_ops = src->cr_ops;
+
+	return 0;
 }
 
 static int file_lock_cr_diff(struct m0_rm_credit *c0,
 			     const struct m0_rm_credit *c1)
 {
+	c0->cr_datum -= c1->cr_datum;
+	return 0;
 }
 
 static bool file_lock_cr_conflicts(const struct m0_rm_credit *c0,
 				   const struct m0_rm_credit *c1)
 {
+	return false;
 }
 
 static bool file_lock_cr_is_subset(const struct m0_rm_credit *c0,
 				   const struct m0_rm_credit *c1)
 {
+	return true;
 }
 
 staic int file_lock_cr_encode(const struct m0_rm_credit *credit,
 			      struct m0_bufvec_cursor *cur)
 {
+	m0_bufvec_cursor_copyto(cur, (void *)&credit->cr_datum,
+				sizeof credit->cr_datum);
+	return 0;
 }
 
 static int file_lock_cr_decode(struct m0_rm_credit *credit,
 			       struct m0_bufvec_cursor *cur)
 {
+	m0_bufvec_cursor_copyfrom(cur, &credit->cr_datum,
+				  sizeof credit->cr_datum);
+	return 0;
 }
 
 static void file_lock_cr_free(struct m0_rm_credit *credit)
 {
+	credit->cr_datum = 0;
 }
 
 /** @} */ /* end internal FileLockInternal */
@@ -282,44 +330,49 @@ M0_INTERNAL int m0_file_owner_init(struct m0_file *file,
 				   struct m0_rm_owner *owner,
 				   struct m0_rm_remote *creditor)
 {
+	m0_rm_owner_init(owner, &file->fl_res, creditor);
 }
 M0_EXPORTED(m0_file_owner_init);
 
 M0_INTERNAL void m0_file_owner_fini(struct m0_rm_owner *owner)
 {
+	m0_rm_owner_fini(owner);
 }
 M0_EXPORTED(m0_file_owner_fini);
 
 M0_INTERNAL int m0_file_lock(struct m0_rm_owner *owner,
 			     struct m0_rm_incoming *req)
 {
-	/*
-	 * Possible steps:
-	 * 1. m0_rm_incoming_init(req, owner, M0_RIT_LOCAL,
-	 *                        RIP_NONE, RIF_MAY_BORROW);
-	 * 2. Initialise req->rin_want
-	 * 3. m0_rm_credit_get(req);
-	 */
+	M0_ENTRY();
+	m0_rm_incoming_init(req, owner, M0_RIT_LOCAL, RIP_NONE, RIF_MAY_BORROW);
+	req->rin_want = RM_FILE_LOCK;
+	M0_RETURN(m0_rm_credit_get(req));
 }
 M0_EXPORTED(m0_file_lock);
 
-M0_INTERNAL int m0_file_unlock(struct m0_rm_incoming *req)
+M0_INTERNAL void m0_file_unlock(struct m0_rm_incoming *req)
 {
-	/*
-	 * Possible steps:
-	 * 1. m0_rm_credit_put(req);
-	 * 2. m0_rm_incoming_fini(req);
-	 */
+	M0_ENTRY();
+	m0_rm_credit_put(req);
+	m0_rm_incoming_fini(req);
+	M0_LEAVE();
 }
 M0_EXPORTED(m0_file_unlock);
 
 M0_INTERNAL int m0_file_lock_type_register(struct m0_rm_domain *dom)
 {
+	M0_ENTRY();
+	M0_SET0(&flock_rt);
+	flock_rt.rt_id = M0_RM_FLOCK_RT;
+	M0_RETURN(m0_rm_type_register(dom, &flock_rt));
 }
 M0_EXPORTED(m0_file_lock_type_register);
 
 M0_INTERNAL void m0_file_lock_type_deregister(struct m0_rm_domain *dom)
 {
+	M0_ENTRY();
+	m0_rm_type_deregister(dom, &flock_rt);
+	M0_LEAVE();
 }
 M0_EXPORTED(m0_file_lock_type_deregister);
 
diff --git a/rm/file.h b/rm/file.h
index d7d435c..392397c 100644
--- a/rm/file.h
+++ b/rm/file.h
@@ -102,9 +102,9 @@ M0_INTERNAL int m0_file_lock(struct m0_rm_owner *owner,
 			     struct m0_rm_incoming *req);
 
 /**
- * Asynchronously sends a request to unlock the distributed file lock.
+ * Unlocks the distributed file lock.
  */
-M0_INTERNAL int m0_file_unlock(struct m0_file *req);
+M0_INTERNAL void m0_file_unlock(struct m0_file *req);
 
 /**
  * Registers the resource of type 'distributed mutex' with a resource domain.
-- 
1.8.3.2

