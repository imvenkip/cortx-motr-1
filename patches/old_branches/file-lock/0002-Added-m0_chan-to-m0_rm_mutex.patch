From 890a7b753c84b728c4be470b23776d0d14c783d1 Mon Sep 17 00:00:00 2001
From: Rajesh Bhalerao <Rajesh_Bhalerao@xyratex.com>
Date: Mon, 4 Mar 2013 16:09:50 +0530
Subject: [PATCH 02/25] Added m0_chan to m0_rm_mutex. Added few comments.

---
 rm/mutex.c | 36 ++++++++++++++++++++++++++++++++----
 rm/mutex.h |  6 ++++++
 2 files changed, 38 insertions(+), 4 deletions(-)

diff --git a/rm/mutex.c b/rm/mutex.c
index 2d86890..3ee8298 100644
--- a/rm/mutex.c
+++ b/rm/mutex.c
@@ -18,6 +18,8 @@
  * Original creation date: 02/26/2013
  */
 
+#include "rm/mutex.h"
+
 /**
    @page RMmutex Distributed Mutex DLD
 
@@ -121,7 +123,8 @@
    <hr>
    @section RMmutexDLD-st System Tests
 
-   This will get tested through a subsystem that uses the distributed mutex.
+   System tests will be performed by the subsystem that uses the distributed
+   mutex.
 
    <hr>
    @section RMmutexDLD-ref References
@@ -139,12 +142,10 @@
    - m0_rm_mutex_* external interfaces
 
  */
-
-
-#include "rm/mutex.h"
 
 /**
    @defgroup RMmutexInternal Distributed Mutex Internals
+   @ingroup RMmutex
 
    This section contains the functions that are internal to the distributed
    mutex. They implement various resource manager ops.
@@ -281,6 +282,14 @@ static void mutex_cr_free(struct m0_rm_credit *credit)
 M0_INTERNAL int m0_rm_mutex_init(struct m0_rm_mutex *mutex,
 				 const struct m0_uint128 *res_id)
 {
+	/*
+	 * Possible steps:
+	 * 1. Initialise of mutex and resource structures
+	 * 2. Use m0_rm_resource_locate() to obtain the creditor information
+	 * 3. If (2) succeeds, add resource to a resouce type.
+	 *    Get the resoruce type pointer from resource doamain array for
+	 *    resource types.
+	 */
 }
 M0_EXPORTED(m0_rm_mutex_init);
 
@@ -291,16 +300,35 @@ M0_EXPORTED(m0_rm_mutex_fini);
 
 M0_INTERNAL int m0_rm_mutex_lock(struct m0_rm_mutex *mutex)
 {
+	/*
+	 * Possible steps:
+	 * 1. m0_rm_incoming_init(&mutex->mx_in);
+	 * 2. Initialise mutex->mx_in.rin_want
+	 * 3. m0_rm_credit_get(&mutex->mx_in);
+	 * 4. m0_chan_wait(&mutex->mx_chan);
+	 */
 }
 M0_EXPORTED(m0_rm_mutex_lock);
 
 M0_INTERNAL int m0_rm_mutex_unlock(struct m0_rm_mutex *mutex)
 {
+	/*
+	 * Possible steps:
+	 * 1. m0_rm_credit_put(&mutex->mx_in);
+	 * 2. m0_rm_incoming_fini(&mutex->mx_in);
+	 */
 }
 M0_EXPORTED(m0_rm_mutex_unlock);
 
 M0_INTERNAL int m0_rm_mutex_trylock(struct m0_rm_mutex *mutex)
 {
+	/*
+	 * Possible steps:
+	 * 1. m0_rm_incoming_init(&mutex->mx_in);
+	 * 2. Initialise mutex->mx_in.rin_want
+	 * 3. Initialise mx_in.rin_flags = RI_WAIT
+	 * 4. m0_rm_credit_get(&mutex->mx_in);
+	 */
 }
 M0_EXPORTED(m0_rm_mutex_trylock);
 
diff --git a/rm/mutex.h b/rm/mutex.h
index c6384e9..485ac9b 100644
--- a/rm/mutex.h
+++ b/rm/mutex.h
@@ -23,6 +23,9 @@
 #ifndef __MERO_RM_MUTEX_H__
 #define __MERO_RM_MUTEX_H__
 
+#include "lib/chan.h"
+#include "rm/rm.h"
+
 /**
    @page RMmutex Distributed Mutex DLD
 
@@ -78,6 +81,9 @@ struct m0_rm_mutex {
 
 	/** An incoming RM request for lock operations */
 	struct m0_rm_incoming mx_in;
+
+	/** Wait channel for the mutex */
+	struct m0_chan        mx_chan;
 };
 
 /**
-- 
1.8.3.2

