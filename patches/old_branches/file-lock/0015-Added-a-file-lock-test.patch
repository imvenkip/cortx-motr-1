From 6d28b0f78078cb2ec626d0fd0db93727a7c8c17b Mon Sep 17 00:00:00 2001
From: Rajesh Bhalerao <Rajesh_Bhalerao@xyratex.com>
Date: Fri, 12 Apr 2013 13:47:51 +0530
Subject: [PATCH 15/25] Added a file-lock test.

---
 rm/ut/file.c     | 45 +++++++++++++++++++++++++++++++++++++++++++--
 rm/ut/rcredits.c |  4 ++++
 2 files changed, 47 insertions(+), 2 deletions(-)

diff --git a/rm/ut/file.c b/rm/ut/file.c
index f826c09..5cac6ce 100644
--- a/rm/ut/file.c
+++ b/rm/ut/file.c
@@ -23,6 +23,7 @@
 #include "lib/memory.h"
 #include "lib/time.h"
 #include "lib/ut.h"
+#include "lib/vec.h"
 #include "fop/fom_generic.h"
 #include "fop/fom_generic.h"
 #include "fid/fid.h"
@@ -134,10 +135,13 @@ static void fl_res_unset(struct rm_ut_data *_this)
 static void fl_owner_set(struct rm_ut_data *_this)
 {
 	struct m0_rm_owner *owner;
+	struct m0_file     *flock;
+
 
 	M0_ALLOC_PTR(owner);
 	M0_UT_ASSERT(owner != NULL);
-	m0_rm_owner_init(owner, _this->rd_res, NULL);
+	flock = container_of(_this->rd_res, struct m0_file, fi_res);
+	m0_file_owner_init(owner, flock, NULL);
 	_this->rd_owner = owner;
 }
 
@@ -150,7 +154,7 @@ static void fl_owner_unset(struct rm_ut_data *_this)
 				   M0_TIME_NEVER);
 	M0_UT_ASSERT(rc == 0);
 	M0_UT_ASSERT(owner_state(_this->rd_owner) == ROS_FINAL);
-	m0_rm_owner_fini(_this->rd_owner);
+	m0_file_owner_fini(_this->rd_owner);
 	m0_free(_this->rd_owner);
 	_this->rd_owner = NULL;
 }
@@ -190,6 +194,32 @@ void flock_srv_utdata_ops_set(struct rm_ut_data *data)
 	data->rd_ops = &fl_srv_ut_data_ops;
 }
 
+static void file_encdec_test(struct rm_ut_data *utdata)
+{
+	struct m0_file        *decfile;
+	struct m0_rm_resource *dec_res;
+	m0_bcount_t             buf_count = 16;
+	int                     rc;
+	char                    caddr[16];
+	void                   *addr = &caddr[0];
+	struct m0_bufvec        bufvec = M0_BUFVEC_INIT_BUF(&addr, &buf_count);
+	struct m0_bufvec_cursor cur;
+
+	/* Encode the resource from the data-set */
+	m0_bufvec_cursor_init(&cur, &bufvec);
+	rc = utdata->rd_rt->rt_ops->rto_encode(&cur, utdata->rd_res);
+	M0_UT_ASSERT(rc == 0);
+
+	rc = utdata->rd_rt->rt_ops->rto_decode(&cur, &dec_res);
+	M0_UT_ASSERT(rc == 0);
+	M0_UT_ASSERT(dec_res != NULL);
+	decfile = container_of(dec_res, struct m0_file, fi_res);
+
+	M0_UT_ASSERT(utdata->rd_rt->rt_ops->rto_eq(utdata->rd_res,
+						   &decfile->fi_res));
+	m0_free(decfile);
+}
+
 static void wait_lock(enum rm_server srv_id)
 {
 	struct m0_rm_incoming *in    = &rm_ctx[srv_id].rc_test_data.rd_in;
@@ -381,6 +411,13 @@ static void test1_run()
 static void client_tests(void)
 {
 	m0_chan_wait(&tests_clink[TEST1]);
+
+	/* Test encode/decode for code coverage */
+	printf("Encode/Decode test started\n");
+	file_encdec_test(&rm_ctx[SERVER_1].rc_test_data);
+	printf("Encode/Decode test completed\n");
+
+	/* Now start the use-cases */
 	test1_run();
 
 	/* Begin next test */
@@ -466,6 +503,10 @@ static void flock_utfini(void)
 	rm_ctx_server_windup(SERVER_2);
 	rm_ctx_server_windup(SERVER_1);
 
+	/*
+	 * Following loops cannot be combined.
+	 * The ops within the loops need sync points. Hence they are separate.
+	 */
 	/* Disconnect the servers */
 	for (i = 0; i < test_servers_nr; ++i) {
 		rm_ctx_server_stop(i);
diff --git a/rm/ut/rcredits.c b/rm/ut/rcredits.c
index 977d6e0..112755c 100644
--- a/rm/ut/rcredits.c
+++ b/rm/ut/rcredits.c
@@ -380,6 +380,10 @@ static void remote_credits_utfini(void)
 {
 	uint32_t i;
 
+	/*
+	 * Following loops cannot be combined.
+	 * The ops within the loops need sync points. Hence they are separate.
+	 */
 	/* De-construct RM objects hierarchy */
 	for (i = 0; i < test_servers_nr; ++i) {
 		rm_ctx_server_windup(i);
-- 
1.8.3.2

