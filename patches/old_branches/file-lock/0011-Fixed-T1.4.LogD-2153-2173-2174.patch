From 2c122a798d580234df67fa43d45b8d7d726a5971 Mon Sep 17 00:00:00 2001
From: Rajesh Bhalerao <Rajesh_Bhalerao@xyratex.com>
Date: Tue, 9 Apr 2013 17:54:50 +0530
Subject: [PATCH 11/25] Fixed T1.4.LogD#2153, 2173, 2174.

---
 rm/file.c        |  1 +
 rm/file.h        |  2 +-
 rm/rm.c          | 50 +++++++++++++++++++++++++++++++++++++---------
 rm/rm_foms.c     |  2 +-
 rm/rm_fops.c     | 17 +++++++++-------
 rm/ut/filelock.c | 60 ++++++++++++++++++++++++++++++++++++++++++++++++++------
 rm/ut/rm_fops.c  | 11 ++++++++---
 7 files changed, 116 insertions(+), 27 deletions(-)

diff --git a/rm/file.c b/rm/file.c
index 4a17ddd..daea00d 100644
--- a/rm/file.c
+++ b/rm/file.c
@@ -352,6 +352,7 @@ static int file_lock_cr_diff(struct m0_rm_credit *this,
 			     const struct m0_rm_credit *c1)
 {
 	M0_ASSERT(c1 != NULL);
+	M0_ASSERT(this->cr_datum == c1->cr_datum);
 
 	this->cr_datum -= c1->cr_datum;
 	return 0;
diff --git a/rm/file.h b/rm/file.h
index add5bfe..5fa69a0 100644
--- a/rm/file.h
+++ b/rm/file.h
@@ -87,7 +87,7 @@ enum m0_file_credit {
 	RM_FILE_LOCK = 1
 };
 
-/* Help function - Sets the resource op vector */
+/* Helper function - Sets the resource op vector */
 M0_INTERNAL void m0_file_res_ops_set(struct m0_file *file);
 
 /**
diff --git a/rm/rm.c b/rm/rm.c
index 34eb8bf..8a3790d 100644
--- a/rm/rm.c
+++ b/rm/rm.c
@@ -1092,6 +1092,7 @@ static int cached_credits_remove(struct m0_rm_incoming *in)
 		credit = pin->rp_credit;
 
 		pin_del(pin);
+		M0_ASSERT(credit_pin_nr(credit, M0_RPF_TRACK) == 0);
 		m0_rm_ur_tlist_move(&remove_list, credit);
 		if (!credit->cr_ops->cro_is_subset(credit, &in->rin_want)) {
 			/*
@@ -1119,7 +1120,6 @@ static int cached_credits_remove(struct m0_rm_incoming *in)
 		     m0_rm_ur_tlist_del(credit);
 		     m0_rm_credit_fini(credit);
 		     m0_free(credit);
-
 	} m0_tl_endfor;
 
 	m0_tl_for(m0_rm_ur, rc ? &remove_list : &diff_list, credit) {
@@ -1535,6 +1535,7 @@ static void incoming_check(struct m0_rm_incoming *in)
 
 	M0_ENTRY();
 	M0_PRE(m0_rm_incoming_bob_check(in));
+
 	/*
 	 * This function is reentrant. An outgoing request might set
 	 * the processing error for the incoming structure. Check for the
@@ -1545,6 +1546,7 @@ static void incoming_check(struct m0_rm_incoming *in)
 		m0_rm_credit_init(&rest, in->rin_want.cr_owner);
 		rc = credit_copy(&rest, &in->rin_want) ?:
 		     incoming_check_with(in, &rest);
+		M0_ASSERT(ergo(rc >= 0, credit_is_empty(&rest)));
 		m0_rm_credit_fini(&rest);
 	} else
 		rc = in->rin_rc;
@@ -1570,10 +1572,16 @@ static void incoming_check(struct m0_rm_incoming *in)
 		 * partial failure (with part of the request failing)
 		 * of incoming request, it's necesary to check that it's
 		 * complete (and there are no outstanding outgoing requests
-		 * pending againt it).
+		 * pending againt it). On partial failure put the request in
+		 * RI_WAIT state.
 		 */
 		if (incoming_is_complete(in))
 			incoming_complete(in, rc);
+		else {
+			in->rin_rc = rc;
+			incoming_state_set(in, RI_WAIT);
+		}
+		
 	}
 	M0_LEAVE();
 }
@@ -1679,6 +1687,7 @@ static int incoming_check_with(struct m0_rm_incoming *in,
 			 * @todo - Revoke entire loan?? rest could be subset
 			 * of r
 			 */
+			M0_ASSERT(!credit_is_empty(r));	
 			rc = revoke_send(in, loan, r) ?: credit_diff(rest, r);
 			if (rc != 0)
 				M0_RETURN(rc);
@@ -1739,7 +1748,6 @@ static void incoming_complete(struct m0_rm_incoming *in, int32_t rc)
 	M0_LOG(M0_DEBUG, "Incoming req: %p, state change:[%d -> %d]\n",
 			 in, in->rin_sm.sm_state,
 			 rc == 0 ? RI_SUCCESS : RI_FAILURE);
-	m0_sm_move(&in->rin_sm, rc, rc == 0 ? RI_SUCCESS : RI_FAILURE);
 	/*
 	 * incoming_release() might have moved the request into excited
 	 * state when the last tracking pin was removed, shun it back
@@ -1747,11 +1755,13 @@ static void incoming_complete(struct m0_rm_incoming *in, int32_t rc)
 	 */
 	m0_rm_ur_tlist_move(&owner->ro_incoming[in->rin_priority][OQS_GROUND],
 			    &in->rin_want);
+	m0_sm_move(&in->rin_sm, rc, rc == 0 ? RI_SUCCESS : RI_FAILURE);
 	if (rc != 0) {
 		incoming_release(in);
 		m0_rm_ur_tlist_del(&in->rin_want);
 		M0_ASSERT(pi_tlist_is_empty(&in->rin_pins));
 	}
+	M0_POST(incoming_invariant(in));
 	in->rin_ops->rio_complete(in, rc);
 	M0_POST(owner_invariant(owner));
 	M0_LEAVE();
@@ -1828,14 +1838,25 @@ static int outgoing_check(struct m0_rm_incoming *in,
  * loan.
  */
 static int revoke_send(struct m0_rm_incoming *in,
-		       struct m0_rm_loan *loan, struct m0_rm_credit *credit)
+		       struct m0_rm_loan *loan,
+		       struct m0_rm_credit *credit)
 {
-	int rc;
+	struct m0_rm_credit rest;
+	int                 rc;
 
 	M0_ENTRY("incoming: %p credit: %lu", in, credit->cr_datum);
-	rc = outgoing_check(in, M0_ROT_REVOKE, credit, loan->rl_other);
-	if (!credit_is_empty(credit) && rc == 0)
-		rc = m0_rm_request_out(M0_ROT_REVOKE, in, loan, credit);
+
+	/*
+	 * Credit is part of sublet loan (sent from incoming_check_with()).
+	 * outgoing_check() destructively modifies outgoing credit. Hence,
+	 * make a copy.
+	 */
+	m0_rm_credit_init(&rest, in->rin_want.cr_owner);
+	rc = credit_copy(&rest, credit) ?:
+		outgoing_check(in, M0_ROT_REVOKE, &rest, loan->rl_other);
+	if (!credit_is_empty(&rest) && rc == 0)
+		rc = m0_rm_request_out(M0_ROT_REVOKE, in, loan, &rest);
+	m0_rm_credit_fini(&rest);
 	M0_RETURN(rc);
 }
 
@@ -1850,10 +1871,19 @@ static int borrow_send(struct m0_rm_incoming *in, struct m0_rm_credit *credit)
 	M0_ENTRY("incoming: %p credit: %lu", in, credit->cr_datum);
 	M0_PRE(in->rin_want.cr_owner->ro_creditor != NULL);
 
+	/*
+	 * Borrow sends the remaining credit request to the creditor. It's
+	 * ok if outgoing_check() modifies it. It goes well with
+	 * incoming_check_with() - which keeps on reducing the request set.
+	 */
 	rc = outgoing_check(in, M0_ROT_BORROW, credit,
 				in->rin_want.cr_owner->ro_creditor);
+	/*
+	 * Sends the entire credit request to the creditor. Empty the credit.
+	 */
 	if (!credit_is_empty(credit) && rc == 0)
-		rc = m0_rm_request_out(M0_ROT_BORROW, in, NULL, credit);
+		rc = m0_rm_request_out(M0_ROT_BORROW, in, NULL, credit) ?:
+			credit_diff(credit, credit);
 	M0_RETURN(rc);
 }
 
@@ -2157,6 +2187,8 @@ static void incoming_release(struct m0_rm_incoming *in)
 	struct m0_rm_owner  *o = in->rin_want.cr_owner;
 
 	M0_ENTRY("incoming: %p", in);
+	M0_PRE(ergo(in->rin_type == M0_RIT_LOCAL, incoming_invariant(in)));
+
 	m0_tl_for(pi, &in->rin_pins, kingpin) {
 		M0_ASSERT(m0_rm_pin_bob_check(kingpin));
 		if (kingpin->rp_flags & M0_RPF_PROTECT) {
diff --git a/rm/rm_foms.c b/rm/rm_foms.c
index 83aac24..89ca7d4 100644
--- a/rm/rm_foms.c
+++ b/rm/rm_foms.c
@@ -162,7 +162,7 @@ static void remote_incoming_complete(struct m0_rm_incoming *in, int32_t rc)
 
 static void remote_incoming_conflict(struct m0_rm_incoming *in)
 {
-	in->rin_sm.sm_rc = -EACCES;
+	/* Do nothing */
 }
 
 /*
diff --git a/rm/rm_fops.c b/rm/rm_fops.c
index f054c71..0f1d31f 100644
--- a/rm/rm_fops.c
+++ b/rm/rm_fops.c
@@ -88,7 +88,7 @@ extern const struct m0_sm_conf revoke_sm_conf;
  */
 static int rm_out_create(struct rm_out **out,
 			 enum m0_rm_outgoing_type otype,
-			 struct m0_rm_remote *creditor,
+			 struct m0_rm_remote *other,
 			 struct m0_rm_credit *credit)
 {
 	struct rm_out *outreq;
@@ -104,12 +104,13 @@ static int rm_out_create(struct rm_out **out,
 	}
 
 	m0_rm_outgoing_init(&outreq->ou_req, otype);
-	rc = m0_rm_loan_init(&outreq->ou_req.rog_want, credit, creditor);
+	rc = m0_rm_loan_init(&outreq->ou_req.rog_want, credit, other);
 	if (rc != 0) {
 		m0_free(outreq);
 		goto out;
 	}
 
+	M0_ASSERT(outreq->ou_req.rog_want.rl_other != NULL);
 	*out = outreq;
 
 out:
@@ -216,6 +217,7 @@ int m0_rm_request_out(enum m0_rm_outgoing_type otype,
 		      struct m0_rm_credit *credit)
 {
 	struct m0_rpc_session *session = NULL;
+	struct m0_rm_remote   *other;
 	struct rm_out	      *outreq;
 	int		       rc;
 
@@ -223,22 +225,22 @@ int m0_rm_request_out(enum m0_rm_outgoing_type otype,
 		 otype, in, credit->cr_datum);
 	M0_PRE(M0_IN(otype, (M0_ROT_BORROW, M0_ROT_REVOKE)));
 
-	rc = rm_out_create(&outreq, otype, in->rin_want.cr_owner->ro_creditor,
-			   credit);
+	other = otype == M0_ROT_BORROW ? in->rin_want.cr_owner->ro_creditor :
+					 loan->rl_other;
+
+	rc = rm_out_create(&outreq, otype, other, credit);
 	if (rc != 0)
 		goto out;
 
 	switch (otype) {
 	case M0_ROT_BORROW:
 		rc = borrow_fop_fill(outreq, in, credit);
-		session = in->rin_want.cr_owner->ro_creditor->rem_session;
 		outreq->ou_ast.sa_cb = &borrow_ast;
 		break;
 	case M0_ROT_REVOKE:
 		M0_ASSERT(loan != NULL);
 		M0_ASSERT(loan->rl_other != NULL);
 		rc = revoke_fop_fill(outreq, in, loan, credit);
-		session = loan->rl_other->rem_session;
 		outreq->ou_ast.sa_cb = &revoke_ast;
 		break;
 	default:
@@ -260,7 +262,8 @@ int m0_rm_request_out(enum m0_rm_outgoing_type otype,
 
 	M0_LOG(M0_DEBUG, "sending request:%p over session: %p",
 			 outreq, session);
-	outreq->ou_fop.f_item.ri_session = session;
+	outreq->ou_fop.f_item.ri_session =
+		outreq->ou_req.rog_want.rl_other->rem_session;
 	outreq->ou_fop.f_item.ri_ops = &rm_request_rpc_ops;
 	m0_rpc_post(&outreq->ou_fop.f_item);
 
diff --git a/rm/ut/filelock.c b/rm/ut/filelock.c
index efa100b..b59049b 100644
--- a/rm/ut/filelock.c
+++ b/rm/ut/filelock.c
@@ -51,11 +51,14 @@ enum flock_tests {
 };
 
 enum {
-	CLNT_THR_NR = 10
+	CLNT_THR_NR = 10,
+	SRV_THR_NR = 10
 };
 
 static struct m0_thread clnt_thr[CLNT_THR_NR];
+static struct m0_thread srv_thr[SRV_THR_NR];
 static int clnt_counter;
+static int srv_counter;
 
 /* Maximum test servers for this testcase */
 static enum rm_server test_servers_nr;
@@ -222,31 +225,75 @@ static void test_verify(enum flock_tests test_id)
 				&srv->ro_owned[OWOS_CACHED]));
 		M0_UT_ASSERT(m0_rm_ur_tlist_is_empty(&clnt->ro_borrowed));
 		break;
+	case TEST3:
+		M0_UT_ASSERT(!m0_rm_ur_tlist_is_empty(&srv->ro_sublet) ||
+			     !m0_rm_ur_tlist_is_empty(
+                                &srv->ro_owned[OWOS_CACHED]) ||
+			     !m0_rm_ur_tlist_is_empty(
+                                &srv->ro_owned[OWOS_HELD]));
+		break;
 	default:
 		break;
 	}
 }
 
-static void clnt_lock(int n)
+static void test3_lock(enum rm_server srv_id, int n)
 {
-	struct m0_rm_owner    *owner = rm_ctx[SERVER_1].rc_test_data.rd_owner;
+	struct m0_rm_owner    *owner = rm_ctx[srv_id].rc_test_data.rd_owner;
 	struct m0_rm_incoming  req;
 	int		       rc;
 
 	M0_SET0(&req);
 	m0_file_lock(owner, &req);
 	m0_rm_owner_lock(owner);
+	test_verify(TEST3);
 	if (incoming_state(&req) == RI_WAIT) {
 		rc = m0_sm_timedwait(&req.rin_sm,
 				     M0_BITS(RI_SUCCESS, RI_FAILURE),
 				     M0_TIME_NEVER);
 		M0_UT_ASSERT(rc == 0);
 	}
-	m0_rm_owner_unlock(owner);
 	M0_UT_ASSERT(req.rin_rc == 0);
-	clnt_counter += n;
-	loan_session_set(SERVER_2, SERVER_1);
+	M0_UT_ASSERT(incoming_state(&req) == RI_SUCCESS);
+	m0_rm_owner_unlock(owner);
+	if (srv_id == SERVER_1) {
+		clnt_counter += n;
+		loan_session_set(SERVER_2, SERVER_1);
+	} else if (srv_id == SERVER_2) {
+		srv_counter += n;
+	}
 	m0_file_unlock(&req);
+	M0_SET0(&req);
+}
+
+static void srv_lock(int n)
+{
+	test3_lock(SERVER_2, n);
+}
+
+static void srv_test3_run()
+{
+	int i;
+	int sum;
+	int rc;
+
+	for (sum = i = 0; i < SRV_THR_NR; ++i) {
+		rc = M0_THREAD_INIT(&srv_thr[i], int, NULL,
+				    &srv_lock, i, "srv_lock");
+		M0_UT_ASSERT(rc == 0);
+		sum += i;
+	}
+
+	for (i = 0; i < SRV_THR_NR; ++i) {
+		m0_thread_join(&srv_thr[i]);
+		m0_thread_fini(&srv_thr[i]);
+	}
+	M0_UT_ASSERT(srv_counter == sum);
+}
+
+static void clnt_lock(int n)
+{
+	test3_lock(SERVER_1, n);
 }
 
 static void client_test3_run()
@@ -349,6 +396,7 @@ static void server_tests(void)
 
 	/* Begin next test */
 	m0_chan_signal_lock(&flock_tests_chan);
+	srv_test3_run();
 }
 
 static void rm_server_start(const int tid)
diff --git a/rm/ut/rm_fops.c b/rm/ut/rm_fops.c
index cbdd70c..815a4ad 100644
--- a/rm/ut/rm_fops.c
+++ b/rm/ut/rm_fops.c
@@ -279,26 +279,31 @@ static void reply_test(enum m0_rm_incoming_type reqtype, int err)
  */
 static void request_test(enum m0_rm_incoming_type reqtype)
 {
-	int rc = 0;
+	struct m0_rm_credit rest;
+	int                 rc = 0;
 
 	request_param_init(reqtype);
 
 	m0_fi_enable_once("m0_rm_request_out", "no-rpc");
+	m0_rm_credit_init(&rest, rm_test_data.rd_owner);
+	rc = rest.cr_ops->cro_copy(&rest, &rm_test_data.rd_credit);
+	M0_UT_ASSERT(rc == 0);
 	switch (reqtype) {
 	case M0_RIT_BORROW:
 		rm_test_data.rd_in.rin_flags |= RIF_MAY_BORROW;
 		rc = m0_rm_request_out(M0_ROT_BORROW, &rm_test_data.rd_in, NULL,
-				       &rm_test_data.rd_credit);
+				       &rest);
 		break;
 	case M0_RIT_REVOKE:
 		rm_test_data.rd_in.rin_flags |= RIF_MAY_REVOKE;
 		rc = m0_rm_request_out(M0_ROT_REVOKE, &rm_test_data.rd_in,
-				       test_loan, &test_loan->rl_credit);
+				       test_loan, &rest);
 		break;
 	default:
 		M0_IMPOSSIBLE("Invalid RM-FOM type");
 	}
 	M0_UT_ASSERT(rc == 0);
+	m0_rm_credit_fini(&rest);
 
 	rm_req_fop_validate(reqtype);
 	request_param_fini();
-- 
1.8.3.2

