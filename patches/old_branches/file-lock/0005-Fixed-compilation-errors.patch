From 204b8d168190b2680daa3f167008dd40e418e4ed Mon Sep 17 00:00:00 2001
From: Rajesh Bhalerao <Rajesh_Bhalerao@xyratex.com>
Date: Mon, 25 Mar 2013 14:37:34 +0530
Subject: [PATCH 05/25] Fixed compilation errors.

---
 rm/file.c | 78 +++++++++++++++++++++++++++++++++++++++++++++++++++------------
 rm/file.h | 23 +++++++++++++------
 rm/rm.h   |  6 ++++-
 3 files changed, 84 insertions(+), 23 deletions(-)

diff --git a/rm/file.c b/rm/file.c
index 4a6eac8..47965ec 100644
--- a/rm/file.c
+++ b/rm/file.c
@@ -154,6 +154,42 @@
    @{
  */
 
+/* Forward Declarations */
+static bool file_lock_equal(const struct m0_rm_resource *resource0,
+			    const struct m0_rm_resource *resource1);
+static int file_lock_encode(struct m0_bufvec_cursor *cur,
+			    const struct m0_rm_resource *resource);
+static int file_lock_decode(struct m0_bufvec_cursor *cur,
+			    struct m0_rm_resource **resource);
+static void file_lock_credit_init(struct m0_rm_resource *resource,
+				  struct m0_rm_credit *credit);
+
+static void file_lock_incoming_complete(struct m0_rm_incoming *in, int32_t rc);
+static void file_lock_incoming_conflict(struct m0_rm_incoming *in);
+
+static bool file_lock_cr_intersects(const struct m0_rm_credit *c0,
+				    const struct m0_rm_credit *c1);
+static m0_bcount_t file_lock_cr_len(const struct m0_rm_credit *c0);
+
+static int file_lock_cr_join(struct m0_rm_credit *c0,
+			     const struct m0_rm_credit *c1);
+static int file_lock_cr_disjoin(struct m0_rm_credit *c0,
+				const struct m0_rm_credit *c1,
+				struct m0_rm_credit *intersection);
+static int file_lock_cr_copy(struct m0_rm_credit *dest,
+			     const struct m0_rm_credit *src);
+static int file_lock_cr_diff(struct m0_rm_credit *c0,
+			     const struct m0_rm_credit *c1);
+static bool file_lock_cr_conflicts(const struct m0_rm_credit *c0,
+				   const struct m0_rm_credit *c1);
+static bool file_lock_cr_is_subset(const struct m0_rm_credit *c0,
+				   const struct m0_rm_credit *c1);
+static int file_lock_cr_encode(const struct m0_rm_credit *credit,
+			       struct m0_bufvec_cursor *cur);
+static int file_lock_cr_decode(struct m0_rm_credit *credit,
+			       struct m0_bufvec_cursor *cur);
+static void file_lock_cr_free(struct m0_rm_credit *credit);
+
 static struct m0_rm_resource_type flock_rt = {
 	.rt_name = "File Lock Resource Type"
 };
@@ -187,10 +223,20 @@ const struct m0_rm_incoming_ops file_lock_incoming_ops = {
 	.rio_conflict = file_lock_incoming_conflict
 };
 
-/** Compare Ids of two file_lockes */
+/** Compare Ids of two file locks */
 static bool file_lock_equal(const struct m0_rm_resource *resource0,
 			    const struct m0_rm_resource *resource1)
 {
+	struct m0_file *file0;
+	struct m0_file *file1;
+
+	M0_PRE(resource0 != NULL && resource1 != NULL);
+
+	file0 = container_of(resource0, struct m0_file, fi_res);
+	file1 = container_of(resource1, struct m0_file, fi_res);
+	
+	return file0->fi_fid.f_container == file1->fi_fid.f_container &&
+	       file0->fi_fid.f_key == file1->fi_fid.f_key;
 }
 
 /** Encode file_lock - ready to send over the wire */
@@ -209,7 +255,7 @@ static int file_lock_encode(struct m0_bufvec_cursor *cur,
 }
 
 /** Decode file_lock - from the wire */
-static int file_lock_decode(const struct m0_bufvec_cursor *cur,
+static int file_lock_decode(struct m0_bufvec_cursor *cur,
 			    struct m0_rm_resource **resource)
 {
 	struct m0_file *fl;
@@ -243,7 +289,7 @@ static void file_lock_incoming_complete(struct m0_rm_incoming *in, int32_t rc)
 /** Lock request conflict callback - Invalid for file_lock */
 static void file_lock_incoming_conflict(struct m0_rm_incoming *in)
 {
-	C2_IMPOSSIBLE();
+	M0_IMPOSSIBLE();
 }
 
 static bool file_lock_cr_intersects(const struct m0_rm_credit *c0,
@@ -270,7 +316,7 @@ static int file_lock_cr_disjoin(struct m0_rm_credit *c0,
 	return -EPERM;
 }
 
-static int file_lock_cr_copy(struct m0_rm_credit *dst,
+static int file_lock_cr_copy(struct m0_rm_credit *dest,
 			     const struct m0_rm_credit *src)
 {
 	dest->cr_datum = src->cr_datum;
@@ -299,7 +345,7 @@ static bool file_lock_cr_is_subset(const struct m0_rm_credit *c0,
 	return true;
 }
 
-staic int file_lock_cr_encode(const struct m0_rm_credit *credit,
+static int file_lock_cr_encode(const struct m0_rm_credit *credit,
 			      struct m0_bufvec_cursor *cur)
 {
 	m0_bufvec_cursor_copyto(cur, (void *)&credit->cr_datum,
@@ -326,12 +372,13 @@ static void file_lock_cr_free(struct m0_rm_credit *credit)
  * @addtogroup FileLock
  * @{
  */
-M0_INTERNAL int m0_file_owner_init(struct m0_file *file,
-				   struct m0_rm_owner *owner,
-				   struct m0_rm_remote *creditor)
+M0_INTERNAL void m0_file_owner_init(struct m0_file *file,
+				    struct m0_rm_owner *owner,
+				    struct m0_rm_remote *creditor)
 {
-	m0_rm_owner_init(owner, &file->fl_res, creditor);
+	m0_rm_owner_init(owner, &file->fi_res, creditor);
 }
+
 M0_EXPORTED(m0_file_owner_init);
 
 M0_INTERNAL void m0_file_owner_fini(struct m0_rm_owner *owner)
@@ -340,13 +387,14 @@ M0_INTERNAL void m0_file_owner_fini(struct m0_rm_owner *owner)
 }
 M0_EXPORTED(m0_file_owner_fini);
 
-M0_INTERNAL int m0_file_lock(struct m0_rm_owner *owner,
-			     struct m0_rm_incoming *req)
+M0_INTERNAL void m0_file_lock(struct m0_rm_owner *owner,
+			      struct m0_rm_incoming *req)
 {
 	M0_ENTRY();
 	m0_rm_incoming_init(req, owner, M0_RIT_LOCAL, RIP_NONE, RIF_MAY_BORROW);
-	req->rin_want = RM_FILE_LOCK;
-	M0_RETURN(m0_rm_credit_get(req));
+	req->rin_want.cr_datum = RM_FILE_LOCK;
+	m0_rm_credit_get(req);
+	M0_LEAVE();
 }
 M0_EXPORTED(m0_file_lock);
 
@@ -368,10 +416,10 @@ M0_INTERNAL int m0_file_lock_type_register(struct m0_rm_domain *dom)
 }
 M0_EXPORTED(m0_file_lock_type_register);
 
-M0_INTERNAL void m0_file_lock_type_deregister(struct m0_rm_domain *dom)
+M0_INTERNAL void m0_file_lock_type_deregister()
 {
 	M0_ENTRY();
-	m0_rm_type_deregister(dom, &flock_rt);
+	m0_rm_type_deregister(&flock_rt);
 	M0_LEAVE();
 }
 M0_EXPORTED(m0_file_lock_type_deregister);
diff --git a/rm/file.h b/rm/file.h
index 392397c..1c98274 100644
--- a/rm/file.h
+++ b/rm/file.h
@@ -23,8 +23,13 @@
 #ifndef __MERO_RM_FILE_H__
 #define __MERO_RM_FILE_H__
 
+#include "lib/errno.h"
+#include "lib/misc.h"
+#include "lib/memory.h"
+#include "lib/trace.h"
 #include "fid/fid.h"
 #include "rm/rm.h"
+#include "rm/rm_internal.h"
 
 /**
    @page FileLock Distributed File Lock DLD
@@ -78,6 +83,10 @@ struct m0_file {
 	struct m0_rm_resource fi_res;
 };
 
+enum m0_file_credit {
+	RM_FILE_LOCK = 1
+};
+
 /**
  * Initialises owner for a file-lock resource.
  *
@@ -85,9 +94,9 @@ struct m0_file {
  * @param owner - Owner for file
  * @param creditor - Creditor for this owner
  */
-M0_INTERNAL int m0_file_owner_init(struct m0_file *file,
-				   struct m0_rm_owner *owner,
-				   struct m0_rm_remote *creditor)
+M0_INTERNAL void m0_file_owner_init(struct m0_file *file,
+				    struct m0_rm_owner *owner,
+				    struct m0_rm_remote *creditor);
 
 /**
  * Finalises the owner of file-lock
@@ -98,13 +107,13 @@ M0_INTERNAL void m0_file_owner_fini(struct m0_rm_owner *owner);
  * Asynchronously sends a distributed file lock request. A caller can
  * decide to wait, if necessary.
  */
-M0_INTERNAL int m0_file_lock(struct m0_rm_owner *owner,
-			     struct m0_rm_incoming *req);
+M0_INTERNAL void m0_file_lock(struct m0_rm_owner *owner,
+			      struct m0_rm_incoming *req);
 
 /**
  * Unlocks the distributed file lock.
  */
-M0_INTERNAL void m0_file_unlock(struct m0_file *req);
+M0_INTERNAL void m0_file_unlock(struct m0_rm_incoming *req);
 
 /**
  * Registers the resource of type 'distributed mutex' with a resource domain.
@@ -114,7 +123,7 @@ M0_INTERNAL int m0_file_lock_type_register(struct m0_rm_domain *dom);
 /**
  * De-registers the resource of type 'distributed mutex' from a resource domain.
  */
-M0_INTERNAL void m0_file_lock_type_deregister(struct m0_rm_domain *dom);
+M0_INTERNAL void m0_file_lock_type_deregister();
 
 /** @} end of FileLock */
 
diff --git a/rm/rm.h b/rm/rm.h
index 8f43243..866ee2e 100644
--- a/rm/rm.h
+++ b/rm/rm.h
@@ -300,6 +300,10 @@ struct m0_rm_resource_ops {
 			        struct m0_rm_credit *credit);
 };
 
+enum m0_res_type_id {
+	M0_RM_FLOCK_RT = 1
+};
+
 /**
  * Resources are classified into disjoint types.
  *
@@ -375,7 +379,7 @@ struct m0_rm_resource_type_ops {
 	/**
 	 * De-serialises the resource from a buffer.
 	 */
-	int  (*rto_decode)(const struct m0_bufvec_cursor *cur,
+	int  (*rto_decode)(struct m0_bufvec_cursor *cur,
 			   struct m0_rm_resource **resource);
 	/**
 	 * Serialise a resource into a buffer.
-- 
1.8.3.2

