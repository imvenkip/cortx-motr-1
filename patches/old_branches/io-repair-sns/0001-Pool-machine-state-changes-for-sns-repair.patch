From fb0db897115167558adba02960b95651166cc0a9 Mon Sep 17 00:00:00 2001
From: Mandar Sawant <mandar_sawant@xyratex.com>
Date: Mon, 17 Dec 2012 16:41:41 +0530
Subject: [PATCH 01/10] - Pool machine state changes for sns repair.

---
 cm/cm.c         |  5 +++++
 cm/cm.h         |  3 +++
 sns/repair/cm.c | 26 ++++++++++++++++++++++++--
 3 files changed, 32 insertions(+), 2 deletions(-)

diff --git a/cm/cm.c b/cm/cm.c
index 4078454..aa39ff6 100644
--- a/cm/cm.c
+++ b/cm/cm.c
@@ -28,6 +28,7 @@
 #include "lib/errno.h"
 #include "lib/finject.h"
 #include "mero/magic.h"
+#include "ioservice/io_device.h"
 
 #include "cm/cm.h"
 #include "cm/ag.h"
@@ -494,6 +495,10 @@ M0_INTERNAL int m0_cm_start(struct m0_cm *cm)
 	M0_PRE(m0_cm_state_get(cm) == M0_CMS_IDLE);
 	M0_PRE(m0_cm_invariant(cm));
 
+        cm->cm_pm = m0_ios_poolmach_get(cm->cm_service.rs_reqh);
+        if (cm->cm_pm == NULL)
+                return -EINVAL;
+
 	rc = cm->cm_ops->cmo_start(cm);
 	cm_move(cm, rc, M0_CMS_ACTIVE, M0_CM_ERR_START);
 	/* Start pump FOM to create copy packets. */
diff --git a/cm/cm.h b/cm/cm.h
index 3c0de58..bd9a460 100644
--- a/cm/cm.h
+++ b/cm/cm.h
@@ -151,6 +151,9 @@ struct m0_cm_type {
 struct m0_cm {
 	struct m0_sm			 cm_mach;
 
+        /** Pool machine for this node. */
+        struct m0_poolmach              *cm_pm;
+
 	/**
 	 * Copy machine id. Copy machines are identified by this id.
 	 * Copy machines can be located with this id by querying some
diff --git a/sns/repair/cm.c b/sns/repair/cm.c
index d604ca1..4d13562 100644
--- a/sns/repair/cm.c
+++ b/sns/repair/cm.c
@@ -32,6 +32,8 @@
 
 #include "mero/setup.h"
 #include "net/net.h"
+#include "ioservice/io_device.h"
+#include "pool/pool.h"
 #include "reqh/reqh.h"
 #include "cm/ag.h"
 #include "sns/repair/cm.h"
@@ -408,16 +410,29 @@ static size_t cm_buffer_pool_provision(struct m0_net_buffer_pool *bp,
 	return bnr;
 }
 
+static int pm_event_setup_and_post(struct m0_poolmach *pm,
+				   struct m0_pool_event *pme,
+				   enum m0_pool_event_owner_type et,
+				   uint32_t oid,
+				   enum m0_pool_nd_state state)
+{
+        pme->pe_type  = et;
+        pme->pe_index = oid;
+        pme->pe_state = state;
+
+	return m0_poolmach_state_transit(pm, pme);
+}
+
 static int cm_start(struct m0_cm *cm)
 {
 	struct m0_sns_repair_cm *rcm;
+	struct m0_pool_event     pm_event;
 	int                      bufs_nr;
 	int                      rc;
 
 	M0_ENTRY("cm: %p", cm);
 
 	rcm = cm2sns(cm);
-
 	bufs_nr = cm_buffer_pool_provision(&rcm->rc_ibp, SNS_INCOMING_BUF_NR);
 	if (bufs_nr == 0)
 		return -ENOMEM;
@@ -430,8 +445,12 @@ static int cm_start(struct m0_cm *cm)
 	if (bufs_nr == 0)
 		return -ENOMEM;
 	rc = m0_sns_repair_iter_init(rcm);
-	if (rc == 0)
+	if (rc == 0) {
 		m0_cm_sw_fill(cm);
+		rc = pm_event_setup_and_post(cm->cm_pm, &pm_event,
+					     M0_POOL_DEVICE, rcm->rc_fdata,
+					     M0_PNDS_SNS_REPAIRING);
+	}
 
 	M0_LEAVE();
 	return rc;
@@ -440,12 +459,15 @@ static int cm_start(struct m0_cm *cm)
 static int cm_stop(struct m0_cm *cm)
 {
 	struct m0_sns_repair_cm *rcm;
+	struct m0_pool_event     pm_event;
 
 	M0_PRE(cm != NULL);
 
 	rcm = cm2sns(cm);
 	m0_sns_repair_iter_fini(rcm);
 
+	pm_event_setup_and_post(cm->cm_pm, &pm_event, M0_POOL_DEVICE,
+				rcm->rc_fdata, M0_PNDS_SNS_REPAIRED);
 	return 0;
 }
 
-- 
1.8.3.2

