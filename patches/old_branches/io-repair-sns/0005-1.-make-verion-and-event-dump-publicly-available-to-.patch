From eef0231fd0a15a874133e2513ee1e96bcf7ccb4d Mon Sep 17 00:00:00 2001
From: Hua Huang <hua_huang@xyratex.com>
Date: Wed, 19 Dec 2012 22:53:36 +0800
Subject: [PATCH 05/10] 1. make verion and event dump publicly available to
 other code. 2. Correctly check failure vector version mismatch and pass error
 code correctly to caller. 3. check -EAGAIN in m0t1fs_aio().

---
 ioservice/cob_foms.c       |  6 ++++++
 ioservice/io_foms.c        |  3 +++
 lib/trace.h                |  3 ++-
 m0t1fs/linux_kernel/file.c | 40 ++++++++++++++++++++++++++++++----------
 pool/pool.c                | 41 +++++++++++++++++++++++++++++++++++++++++
 pool/pool.h                |  4 ++++
 pool/ut/test_pm.c          | 42 ++++--------------------------------------
 sns/repair/st/repair_cli.c |  2 +-
 8 files changed, 91 insertions(+), 50 deletions(-)

diff --git a/ioservice/cob_foms.c b/ioservice/cob_foms.c
index 3543ea2..66c3295 100644
--- a/ioservice/cob_foms.c
+++ b/ioservice/cob_foms.c
@@ -215,9 +215,12 @@ static int cc_fom_tick(struct m0_fom *fom)
 	m0_poolmach_current_version_get(poolmach, &curr);
 	verp = (struct m0_pool_version_numbers*)&fop->cc_common.c_version;
 
+	m0_poolmach_version_dump(verp);
+	m0_poolmach_version_dump(&curr);
 	/* Check the client version and server version before any processing */
 	if (!m0_poolmach_version_equal(verp, &curr)) {
 		rc = M0_IOP_ERROR_FAILURE_VECTOR_VER_MISMATCH;
+		M0_LOG(M0_DEBUG, "VERSION MISMATCH!");
 		goto out;
 	}
 
@@ -417,9 +420,12 @@ static int cd_fom_tick(struct m0_fom *fom)
 	m0_poolmach_current_version_get(poolmach, &curr);
 	verp = (struct m0_pool_version_numbers*)&fop->cd_common.c_version;
 
+	m0_poolmach_version_dump(verp);
+	m0_poolmach_version_dump(&curr);
 	/* Check the client version and server version before any processing */
 	if (!m0_poolmach_version_equal(verp, &curr)) {
 		rc = M0_IOP_ERROR_FAILURE_VECTOR_VER_MISMATCH;
+		M0_LOG(M0_DEBUG, "VERSION MISMATCH!");
 		goto out;
 	}
 
diff --git a/ioservice/io_foms.c b/ioservice/io_foms.c
index ab6e872..c74df2d 100644
--- a/ioservice/io_foms.c
+++ b/ioservice/io_foms.c
@@ -1659,12 +1659,15 @@ static int m0_io_fom_cob_rw_tick(struct m0_fom *fom)
 	rwfop = io_rw_get(fom->fo_fop);
 	verp = (struct m0_pool_version_numbers*)(&rwfop->crw_version);
 
+	m0_poolmach_version_dump(verp);
+	m0_poolmach_version_dump(&curr);
 	/* Check the client version and server version before any processing */
 	if (!m0_poolmach_version_equal(verp, &curr)) {
 		rc = M0_FSO_AGAIN;
 		m0_fom_phase_move(fom,
 				  M0_IOP_ERROR_FAILURE_VECTOR_VER_MISMATCH,
 				  M0_FOPH_FAILURE);
+		M0_LOG(M0_DEBUG, "VERSION MISMATCH!");
 	} else {
 
 		st = m0_is_read_fop(fom->fo_fop) ?
diff --git a/lib/trace.h b/lib/trace.h
index c5a5b60..238839d 100644
--- a/lib/trace.h
+++ b/lib/trace.h
@@ -208,7 +208,8 @@ M0_INTERNAL void m0_trace_fini(void);
   M0_TRACE_SUBSYS(CONF,      16) \
   M0_TRACE_SUBSYS(LIB,       17) \
   M0_TRACE_SUBSYS(STOB,      18) \
-  M0_TRACE_SUBSYS(FOP,       19)
+  M0_TRACE_SUBSYS(FOP,       19) \
+  M0_TRACE_SUBSYS(POOL,      20)
 
 #define M0_TRACE_SUBSYS(name, value) M0_TRACE_SUBSYS_ ## name = (1 << value),
 /** The subsystem bitmask definitions */
diff --git a/m0t1fs/linux_kernel/file.c b/m0t1fs/linux_kernel/file.c
index 35b2a1d..36da82e 100644
--- a/m0t1fs/linux_kernel/file.c
+++ b/m0t1fs/linux_kernel/file.c
@@ -2208,6 +2208,10 @@ static int ioreq_iosm_handle(struct io_request *req)
 
 		M0_ASSERT(ioreq_sm_state(req) == state);
 
+		if (req->ir_rc != 0) {
+			rc = req->ir_rc;
+			goto fail;
+		}
 		if (state == IRS_READ_COMPLETE) {
 			rc = req->ir_ops->iro_user_data_copy(req,
 					CD_COPY_TO_USER, 0);
@@ -2862,6 +2866,7 @@ M0_INTERNAL ssize_t m0t1fs_aio(struct kiocb *kcb,
 	M0_PRE(ivec != NULL);
 	M0_PRE(M0_IN(rw, (IRT_READ, IRT_WRITE)));
 
+again:
 	M0_ALLOC_PTR_ADDB(req, &m0t1fs_addb, &io_addb_loc);
 	if (req == NULL)
 		M0_RETERR(-ENOMEM, "Failed to allocate memory for io_request");
@@ -2889,7 +2894,9 @@ M0_INTERNAL ssize_t m0t1fs_aio(struct kiocb *kcb,
 		goto last;
 	}
 
-	rc    = req->ir_ops->iro_iosm_handle(req);
+	rc = req->ir_ops->iro_iosm_handle(req);
+	if (rc == 0)
+		rc = req->ir_rc;
 	M0_LOG(M0_INFO, "nxr_bytes = %llu, copied_nr = %llu",
 		req->ir_nwxfer.nxr_bytes, req->ir_copied_nr);
 	count = min64u(req->ir_nwxfer.nxr_bytes, req->ir_copied_nr);
@@ -2899,9 +2906,12 @@ M0_INTERNAL ssize_t m0t1fs_aio(struct kiocb *kcb,
 last:
 	m0_free(req);
 	++iommstats.d_ioreq_nr;
-	M0_LOG(M0_INFO, "io request returned %lu bytes", count);
-	M0_LEAVE();
 
+	M0_LOG(M0_DEBUG, "rc = %d, io request returned %lu bytes", rc, count);
+	if (rc == -EAGAIN)
+		goto again;
+
+	M0_LEAVE();
 	return count;
 }
 
@@ -3178,7 +3188,9 @@ static int failure_vector_mismatch(struct io_req_fop *irfop)
 	reply_updates = &rw_reply->rwr_fv_updates;
 	srv = (struct m0_pool_version_numbers *)reply_version;
 	cli = &csb->csb_pool.po_mach->pm_state.pst_version;
-
+	m0_poolmach_version_dump(cli);
+	m0_poolmach_version_dump(srv);
+	M0_LOG(M0_DEBUG, "VERSION MISMATCH!");
 	/*
 	 * Retrieve the latest server version and
 	 * updates and apply to the client's copy.
@@ -3188,6 +3200,8 @@ static int failure_vector_mismatch(struct io_req_fop *irfop)
 	rc = -EAGAIN;
 	*cli = *srv;
 
+	/* TODO XXX FIXME Anand: Please release bulk for this request */
+
 	while (i < reply_updates->fvu_count) {
 		event = &reply_updates->fvu_events[i];
 		m0_poolmach_state_transit(csb->csb_pool.po_mach,
@@ -3199,10 +3213,13 @@ static int failure_vector_mismatch(struct io_req_fop *irfop)
 
 static void io_bottom_half(struct m0_sm_group *grp, struct m0_sm_ast *ast)
 {
-	int                  rc;
-	struct io_req_fop   *irfop;
-	struct io_request   *req;
-	struct target_ioreq *tioreq;
+	int                         rc;
+	struct io_req_fop          *irfop;
+	struct io_request          *req;
+	struct target_ioreq        *tioreq;
+	struct m0_fop              *reply;
+	struct m0_rpc_item         *reply_item;
+	struct m0_fop_cob_rw_reply *rw_reply;
 
 	M0_ENTRY("sm_group %p sm_ast %p", grp, ast);
 	M0_PRE(grp != NULL);
@@ -3216,8 +3233,11 @@ static void io_bottom_half(struct m0_sm_group *grp, struct m0_sm_ast *ast)
 	M0_ASSERT(M0_IN(irfop->irf_pattr, (PA_DATA, PA_PARITY)));
 	M0_ASSERT(M0_IN(ioreq_sm_state(req), (IRS_READING, IRS_WRITING)));
 
-	if (irfop->irf_iofop.if_rbulk.rb_rc ==
-	    M0_IOP_ERROR_FAILURE_VECTOR_VER_MISMATCH) {
+	reply_item = irfop->irf_iofop.if_fop.f_item.ri_reply;
+	reply      = m0_rpc_item_to_fop(reply_item);
+	rw_reply   = io_rw_rep_get(reply);
+
+	if (rw_reply->rwr_rc == M0_IOP_ERROR_FAILURE_VECTOR_VER_MISMATCH) {
 		rc = failure_vector_mismatch(irfop);
 		if (rc != 0)
 			tioreq->ti_rc = rc;
diff --git a/pool/pool.c b/pool/pool.c
index fada933..eb9b3e2 100644
--- a/pool/pool.c
+++ b/pool/pool.c
@@ -17,6 +17,9 @@
  * Original creation date: 07/15/2010
  */
 
+#undef M0_TRACE_SUBSYSTEM
+#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_RPC
+#include "lib/trace.h"      /* M0_LOG */
 #include "lib/errno.h"
 #include "lib/memory.h"
 #include "stob/stob.h"
@@ -556,6 +559,44 @@ M0_INTERNAL void m0_poolmach_state_free(struct m0_poolmach *pm,
 {
 }
 
+static int lno = 0;
+
+/* Change this value to make it more verbose, e.g. to M0_ERROR */
+#define dump_level M0_DEBUG
+
+M0_INTERNAL void m0_poolmach_version_dump(struct m0_pool_version_numbers *v)
+{
+	M0_LOG(dump_level, "%4d:readv = %llx writev = %llx\n", lno++,
+		(unsigned long long)v->pvn_version[PVE_READ],
+		(unsigned long long)v->pvn_version[PVE_WRITE]);
+}
+
+M0_INTERNAL void m0_poolmach_event_dump(struct m0_pool_event *e)
+{
+	M0_LOG(dump_level, "%4d:pe_type  = %10s pe_index = %2x pe_state=%10s\n",
+		lno++,
+		e->pe_type == M0_POOL_DEVICE ? "device":"node",
+		e->pe_index,
+		e->pe_state == M0_PNDS_ONLINE? "ONLINE" :
+		    e->pe_state == M0_PNDS_FAILED? "FAILED" :
+			e->pe_state == M0_PNDS_OFFLINE? "OFFLINE" :
+				"RECOVERING"
+	);
+}
+
+M0_INTERNAL void m0_poolmach_event_list_dump(struct m0_tl *head)
+{
+	struct m0_pool_event_link *scan;
+
+	m0_tl_for(poolmach_events, head, scan) {
+		m0_poolmach_event_dump(&scan->pel_event);
+		m0_poolmach_version_dump(&scan->pel_new_version);
+	} m0_tl_endfor;
+	M0_LOG(dump_level, "=====\n");
+}
+#undef dump_level
+
+#undef M0_TRACE_SUBSYSTEM
 /** @} end group pool */
 
 /*
diff --git a/pool/pool.h b/pool/pool.h
index 6a9d305..356d862 100644
--- a/pool/pool.h
+++ b/pool/pool.h
@@ -460,6 +460,10 @@ M0_INTERNAL int m0_poolserver_device_join(struct m0_poolserver *srv,
 M0_INTERNAL int m0_poolserver_device_leave(struct m0_poolserver *srv,
 					   struct m0_pooldev *dev);
 
+M0_INTERNAL void m0_poolmach_version_dump(struct m0_pool_version_numbers *v);
+M0_INTERNAL void m0_poolmach_event_dump(struct m0_pool_event *e);
+M0_INTERNAL void m0_poolmach_event_list_dump(struct m0_tl *head);
+
 /** @} end of servermachine group */
 
 
diff --git a/pool/ut/test_pm.c b/pool/ut/test_pm.c
index 6c82f6b..50c2322 100644
--- a/pool/ut/test_pm.c
+++ b/pool/ut/test_pm.c
@@ -24,7 +24,6 @@
 #include "lib/misc.h"
 #include "pool/pool.h"
 
-static int verbose = 0;
 enum {
 	PM_TEST_DEFAULT_DEVICE_NUMBER      = 10,
 	PM_TEST_DEFAULT_NODE_NUMBER        = 1,
@@ -46,39 +45,6 @@ static void pm_test_init_fini(void)
 	m0_poolmach_fini(&pm);
 }
 
-static void dump_version(struct m0_pool_version_numbers *v)
-{
-	if (verbose)
-		printf("readv = %llx writev = %llx\n",
-			(unsigned long long)v->pvn_version[PVE_READ],
-			(unsigned long long)v->pvn_version[PVE_WRITE]);
-}
-
-static void dump_event(struct m0_pool_event *e)
-{
-	if (verbose)
-		printf("pe_type  = %10s pe_index = %2x pe_state=%10s\n",
-			e->pe_type == M0_POOL_DEVICE ? "device":"node",
-			e->pe_index,
-			e->pe_state == M0_PNDS_ONLINE? "ONLINE" :
-			    e->pe_state == M0_PNDS_FAILED? "FAILED" :
-				e->pe_state == M0_PNDS_OFFLINE? "OFFLINE" :
-					"RECOVERING"
-		);
-}
-
-static void dump_event_list(struct m0_tl *head)
-{
-	struct m0_pool_event_link *scan;
-
-	m0_tl_for(poolmach_events, head, scan) {
-		dump_event(&scan->pel_event);
-		dump_version(&scan->pel_new_version);
-	} m0_tl_endfor;
-	if (verbose)
-		printf("=====\n");
-}
-
 static void pm_test_transit(void)
 {
 	struct m0_poolmach             pm;
@@ -150,10 +116,10 @@ static void pm_test_transit(void)
 	M0_UT_ASSERT(!equal);
 	equal = m0_poolmach_version_equal(&v1, &v2);
 	M0_UT_ASSERT(!equal);
-	dump_event_list(&pm.pm_state.pst_events_list);
-	dump_version(&v0);
-	dump_version(&v1);
-	dump_version(&v2);
+	m0_poolmach_event_list_dump(&pm.pm_state.pst_events_list);
+	m0_poolmach_version_dump(&v0);
+	m0_poolmach_version_dump(&v1);
+	m0_poolmach_version_dump(&v2);
 
 	/* case 1: from v0 to v1 */
 	poolmach_events_tlist_init(&events_list);
diff --git a/sns/repair/st/repair_cli.c b/sns/repair/st/repair_cli.c
index f6fee47..38d342d 100644
--- a/sns/repair/st/repair_cli.c
+++ b/sns/repair/st/repair_cli.c
@@ -55,7 +55,7 @@ struct m0_cob_domain     cl_cdom;
 struct m0_rpc_client_ctx cl_ctx;
 
 //const char *cl_ep_addr = "0@lo:12345:34:2";
-const char *cl_ep_addr = "192.168.147.128@tcp:12345:33:102";
+const char *cl_ep_addr = "172.16.0.128@tcp:12345:33:102";
 char *srv_ep_addr;
 const char *dbname = "sr_cdb";
 static int cl_cdom_id = 10001;
-- 
1.8.3.2

