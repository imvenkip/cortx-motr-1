From bbc989bbf4164afffdad57b02e958a807d6e5dca Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Mon, 4 Mar 2013 14:25:24 +0200
Subject: [PATCH 1/2] Added additional abstraction layer oi_ in between rpc and
 net.

---
 m0t1fs/linux_kernel/st/st |   2 +-
 rpc/Makefile.sub          |   6 +-
 rpc/frmops.c              |  14 ++--
 rpc/outer_interface.c     | 165 ++++++++++++++++++++++++++++++++++++++++++++++
 rpc/outer_interface.h     | 134 +++++++++++++++++++++++++++++++++++++
 rpc/rpc.c                 |  21 +++---
 rpc/rpc_machine.c         |  31 ++++-----
 rpc/rpclib.c              |   6 +-
 rpc/session_foms.c        |   3 +-
 rpc/session_fops.c        |   3 +-
 10 files changed, 347 insertions(+), 38 deletions(-)
 create mode 100644 rpc/outer_interface.c
 create mode 100644 rpc/outer_interface.h

diff --git a/m0t1fs/linux_kernel/st/st b/m0t1fs/linux_kernel/st/st
index 757969d..eb0b69f 100755
--- a/m0t1fs/linux_kernel/st/st
+++ b/m0t1fs/linux_kernel/st/st
@@ -19,7 +19,7 @@ die() { echo "$@" >&2; exit 1; }
 
 M0_CORE_DIR=`readlink -f $0`
 M0_CORE_DIR=${M0_CORE_DIR%/*/*/*/*}
-[ "${M0_CORE_DIR##*/}" = mero ] || die 'Unable to determine M0_CORE_DIR'
+# [ "${M0_CORE_DIR##*/}" = mero ] || die "Unable to determine M0_CORE_DIR: $M0_CORE_DIR"
 
 ## Path to the file with configuration string for confd.
 CONF_FILE=$SANDBOX_DIR/conf.txt
diff --git a/rpc/Makefile.sub b/rpc/Makefile.sub
index 7249b6f..09afe42 100644
--- a/rpc/Makefile.sub
+++ b/rpc/Makefile.sub
@@ -22,7 +22,8 @@ nobase_mero_include_HEADERS += rpc/session.h \
                                   rpc/slot_internal.h \
                                   rpc/rpc_internal.h \
                                   rpc/session_fops_xc.h \
-				  rpc/rpc_addb.h
+                                  rpc/rpc_addb.h \
+                                  rpc/outer_interface.h
 
 mero_libmero_la_SOURCES  += rpc/session.c \
                                   rpc/slot.c \
@@ -43,7 +44,8 @@ mero_libmero_la_SOURCES  += rpc/session.c \
                                   rpc/service.c \
                                   rpc/rpc_onwire_xc.c \
                                   rpc/session_fops_xc.c \
-				  rpc/rpc_addb.c
+                                  rpc/rpc_addb.c \
+                                  rpc/outer_interface.c
 
 rpc/rpc_onwire.h:   dtm/verno_xc.h
 rpc/session_fops.h: rpc/rpc_onwire_xc.h
diff --git a/rpc/frmops.c b/rpc/frmops.c
index dfc0be5..e2d669b 100644
--- a/rpc/frmops.c
+++ b/rpc/frmops.c
@@ -28,7 +28,7 @@
 #include "lib/finject.h"
 
 #include "mero/magic.h"
-#include "net/net.h"
+#include "rpc/outer_interface.h"
 #include "rpc/rpc_internal.h"
 
 /**
@@ -236,7 +236,7 @@ static int net_buffer_allocate(struct m0_net_buffer *netbuf,
 		goto out;
 	}
 
-	rc = m0_net_buffer_register(netbuf, ndom);
+	rc = oi_net_buffer_register(netbuf, ndom);
 	if (rc != 0) {
 		M0_LOG(M0_ERROR, "net buf registeration failed");
 		m0_bufvec_free_aligned(&netbuf->nb_buffer, M0_SEG_SHIFT);
@@ -263,9 +263,9 @@ static void bufvec_geometry(struct m0_net_domain *ndom,
 
 	M0_ENTRY();
 
-	max_buf_size     = m0_net_domain_get_max_buffer_size(ndom);
-	max_segment_size = m0_net_domain_get_max_buffer_segment_size(ndom);
-	max_nr_segments  = m0_net_domain_get_max_buffer_segments(ndom);
+	max_buf_size     = oi_net_domain_get_max_buffer_size(ndom);
+	max_segment_size = oi_net_domain_get_max_buffer_segment_size(ndom);
+	max_nr_segments  = oi_net_domain_get_max_buffer_segments(ndom);
 
 	M0_LOG(M0_DEBUG,
 		"max_buf_size: %llu max_segment_size: %llu max_nr_seg: %d",
@@ -303,7 +303,7 @@ static void net_buffer_free(struct m0_net_buffer *netbuf,
 	M0_ENTRY("netbuf: %p ndom: %p", netbuf, ndom);
 	M0_PRE(netbuf != NULL && ndom != NULL);
 
-	m0_net_buffer_deregister(netbuf, ndom);
+	oi_net_buffer_deregister(netbuf, ndom);
 	m0_bufvec_free_aligned(&netbuf->nb_buffer, M0_SEG_SHIFT);
 
 	M0_LEAVE();
@@ -327,7 +327,7 @@ static int rpc_buffer_submit(struct rpc_buffer *rpcbuf)
 	netbuf->nb_callbacks = &outgoing_buf_callbacks;
 
 	machine = rpc_buffer__rmachine(rpcbuf);
-	rc = m0_net_buffer_add(netbuf, &machine->rm_tm);
+	rc = oi_net_buffer_add(netbuf, &machine->rm_tm);
 
 	M0_RETURN(rc);
 }
diff --git a/rpc/outer_interface.c b/rpc/outer_interface.c
new file mode 100644
index 0000000..caa0816
--- /dev/null
+++ b/rpc/outer_interface.c
@@ -0,0 +1,165 @@
+#include "rpc/outer_interface.h"
+#include "lib/cdefs.h"
+
+/* net domain */
+M0_INTERNAL m0_bcount_t oi_net_domain_get_max_buffer_size(struct m0_net_domain
+							  *dom)
+{
+	return m0_net_domain_get_max_buffer_size(dom);
+}
+
+
+M0_INTERNAL m0_bcount_t oi_net_domain_get_max_buffer_segment_size(struct
+								  m0_net_domain
+								  *dom)
+{
+	return m0_net_domain_get_max_buffer_segment_size(dom);
+}
+
+
+M0_INTERNAL m0_bcount_t oi_net_domain_get_max_buffer_segments(struct
+							      m0_net_domain
+							      *dom)
+{
+	return m0_net_domain_get_max_buffer_segments(dom);
+}
+
+
+/* net buffer */
+M0_INTERNAL int oi_net_buffer_register(struct m0_net_buffer *buf,
+				       struct m0_net_domain *dom)
+{
+	return m0_net_buffer_register(buf, dom);
+}
+
+
+M0_INTERNAL void oi_net_buffer_deregister(struct m0_net_buffer *buf,
+					  struct m0_net_domain *dom)
+{
+	return m0_net_buffer_deregister(buf, dom);
+}
+
+
+M0_INTERNAL int oi_net_buffer_add(struct m0_net_buffer *buf,
+				  struct m0_net_transfer_mc *tm)
+{
+	return m0_net_buffer_add(buf, tm);
+}
+
+
+/* buffer pool */
+M0_INTERNAL int oi_net_buffer_pool_init(struct m0_net_buffer_pool *pool,
+					struct m0_net_domain *ndom,
+					uint32_t threshold, uint32_t seg_nr,
+					m0_bcount_t seg_size, uint32_t colours,
+					unsigned shift)
+{
+	return m0_net_buffer_pool_init(pool, ndom, threshold, seg_nr, seg_size,
+				       colours, shift);
+}
+
+
+M0_INTERNAL void oi_net_buffer_pool_lock(struct m0_net_buffer_pool *pool)
+{
+	return m0_net_buffer_pool_lock(pool);
+}
+
+
+M0_INTERNAL int oi_net_buffer_pool_provision(struct m0_net_buffer_pool *pool,
+					     uint32_t buf_nr)
+{
+	return m0_net_buffer_pool_provision(pool, buf_nr);
+}
+
+
+M0_INTERNAL void oi_net_buffer_pool_unlock(struct m0_net_buffer_pool *pool)
+{
+	return m0_net_buffer_pool_unlock(pool);
+}
+
+
+M0_INTERNAL void oi_net_buffer_pool_fini(struct m0_net_buffer_pool *pool)
+{
+	return m0_net_buffer_pool_fini(pool);
+}
+
+
+M0_INTERNAL void oi_net_buffer_pool_put(struct m0_net_buffer_pool *pool,
+					struct m0_net_buffer *buf,
+					uint32_t colour)
+{
+	return m0_net_buffer_pool_put(pool, buf, colour);
+}
+
+
+
+/* m0_net_tm */
+M0_INTERNAL int oi_net_tm_init(struct m0_net_transfer_mc *tm,
+			       struct m0_net_domain      *dom,
+			       struct m0_addb_mc         *addb_mc,
+			       struct m0_addb_ctx        *ctx)
+{
+	return m0_net_tm_init(tm, dom, addb_mc, ctx);
+}
+
+
+
+M0_INTERNAL void oi_net_tm_fini(struct m0_net_transfer_mc *tm)
+{
+	return m0_net_tm_fini(tm);
+}
+
+
+M0_INTERNAL int oi_net_tm_start(struct m0_net_transfer_mc *tm,
+				const char *addr)
+{
+	return m0_net_tm_start(tm, addr);
+}
+
+
+M0_INTERNAL int oi_net_tm_stop(struct m0_net_transfer_mc *tm,
+			       bool abort)
+{
+	return m0_net_tm_stop(tm, abort);
+}
+
+
+M0_INTERNAL int oi_net_tm_pool_attach(struct m0_net_transfer_mc *tm,
+				      struct m0_net_buffer_pool *bufpool,
+				      const struct m0_net_buffer_callbacks
+				      *callbacks, m0_bcount_t min_recv_size,
+				      uint32_t max_recv_msgs,
+				      uint32_t min_recv_queue_len)
+{
+	return m0_net_tm_pool_attach(tm, bufpool, callbacks, min_recv_size,
+				     max_recv_msgs, min_recv_queue_len);
+}
+
+
+M0_INTERNAL void oi_net_tm_colour_set(struct m0_net_transfer_mc *tm,
+				      uint32_t colour)
+{
+	return m0_net_tm_colour_set(tm, colour);
+}
+
+
+/* endpoint */
+M0_INTERNAL void oi_net_end_point_get(struct m0_net_end_point *ep)
+{
+	return m0_net_end_point_get(ep);
+}
+
+
+M0_INTERNAL void oi_net_end_point_put(struct m0_net_end_point *ep)
+{
+	return m0_net_end_point_put(ep);
+}
+
+
+M0_INTERNAL int oi_net_end_point_create(struct m0_net_end_point **epp,
+					struct m0_net_transfer_mc *tm,
+					const char *addr)
+{
+	return m0_net_end_point_create(epp, tm, addr);
+}
+
diff --git a/rpc/outer_interface.h b/rpc/outer_interface.h
new file mode 100644
index 0000000..976342b
--- /dev/null
+++ b/rpc/outer_interface.h
@@ -0,0 +1,134 @@
+#pragma once
+
+#ifndef __MERO_RPC_OUTIF_H__
+#define __MERO_RPC_OUTIF_H__
+
+#include "net/net.h"
+#include "net/buffer_pool.h"
+
+#ifndef __KERNEL__
+/* net domain */
+M0_INTERNAL m0_bcount_t oi_net_domain_get_max_buffer_size(struct m0_net_domain
+							  *dom);
+
+M0_INTERNAL m0_bcount_t oi_net_domain_get_max_buffer_segment_size(struct
+								  m0_net_domain
+								  *dom);
+
+M0_INTERNAL m0_bcount_t oi_net_domain_get_max_buffer_segments(struct
+							      m0_net_domain
+							      *dom);
+
+/* net buffer */
+M0_INTERNAL int oi_net_buffer_register(struct m0_net_buffer *buf,
+				       struct m0_net_domain *dom);
+
+M0_INTERNAL void oi_net_buffer_deregister(struct m0_net_buffer *buf,
+					  struct m0_net_domain *dom);
+
+M0_INTERNAL int oi_net_buffer_add(struct m0_net_buffer *buf,
+				  struct m0_net_transfer_mc *tm);
+
+
+/* buffer pool */
+M0_INTERNAL int oi_net_buffer_pool_init(struct m0_net_buffer_pool *pool,
+					struct m0_net_domain *ndom,
+					uint32_t threshold, uint32_t seg_nr,
+					m0_bcount_t seg_size, uint32_t colours,
+					unsigned shift);
+
+M0_INTERNAL void oi_net_buffer_pool_lock(struct m0_net_buffer_pool *pool);
+
+M0_INTERNAL int oi_net_buffer_pool_provision(struct m0_net_buffer_pool *pool,
+					     uint32_t buf_nr);
+
+M0_INTERNAL void oi_net_buffer_pool_unlock(struct m0_net_buffer_pool *pool);
+
+M0_INTERNAL void oi_net_buffer_pool_fini(struct m0_net_buffer_pool *pool);
+
+M0_INTERNAL void oi_net_buffer_pool_put(struct m0_net_buffer_pool *pool,
+					struct m0_net_buffer *buf,
+					uint32_t colour);
+
+
+/* m0_net_tm */
+
+M0_INTERNAL int oi_net_tm_init(struct m0_net_transfer_mc *tm,
+			       struct m0_net_domain      *dom,
+			       struct m0_addb_mc         *addb_mc,
+			       struct m0_addb_ctx        *ctx);
+
+M0_INTERNAL void oi_net_tm_fini(struct m0_net_transfer_mc *tm);
+
+M0_INTERNAL int oi_net_tm_start(struct m0_net_transfer_mc *tm,
+				const char *addr);
+
+M0_INTERNAL int oi_net_tm_stop(struct m0_net_transfer_mc *tm,
+			       bool abort);
+
+
+M0_INTERNAL int oi_net_tm_pool_attach(struct m0_net_transfer_mc *tm,
+				      struct m0_net_buffer_pool *bufpool,
+				      const struct m0_net_buffer_callbacks
+				      *callbacks, m0_bcount_t min_recv_size,
+				      uint32_t max_recv_msgs,
+				      uint32_t min_recv_queue_len);
+
+M0_INTERNAL void oi_net_tm_colour_set(struct m0_net_transfer_mc *tm,
+				      uint32_t colour);
+
+/* endpoint */
+M0_INTERNAL void oi_net_end_point_get(struct m0_net_end_point *ep);
+M0_INTERNAL void oi_net_end_point_put(struct m0_net_end_point *ep);
+
+M0_INTERNAL int oi_net_end_point_create(struct m0_net_end_point **epp,
+					struct m0_net_transfer_mc *tm,
+					const char *addr);
+#else /* !__KERNEL__ */
+
+#define oi_net_tm_pool_attach m0_net_tm_pool_attach
+#define oi_net_end_point_get m0_net_end_point_get
+#define oi_net_domain_get_max_buffer_size m0_net_domain_get_max_buffer_size
+#define oi_net_tm_fini m0_net_tm_fini
+#define oi_net_buffer_pool_unlock m0_net_buffer_pool_unlock
+#define oi_net_buffer_pool_provision m0_net_buffer_pool_provision
+#define oi_net_domain_get_max_buffer_segment_size m0_net_domain_get_max_buffer_segment_size
+#define oi_net_tm_start m0_net_tm_start
+#define oi_net_tm_stop m0_net_tm_stop
+#define oi_net_buffer_register m0_net_buffer_register
+#define oi_net_domain_get_max_buffer_segments m0_net_domain_get_max_buffer_segments
+#define oi_net_end_point_put m0_net_end_point_put
+#define oi_net_buffer_pool_init m0_net_buffer_pool_init
+#define oi_net_buffer_pool_put m0_net_buffer_pool_put
+#define oi_net_buffer_add m0_net_buffer_add
+#define oi_net_buffer_pool_lock m0_net_buffer_pool_lock
+#define oi_net_buffer_deregister m0_net_buffer_deregister
+#define oi_net_tm_init m0_net_tm_init
+#define oi_net_tm_colour_set m0_net_tm_colour_set
+#define oi_net_buffer_pool_fini m0_net_buffer_pool_fini
+#define oi_net_end_point_create m0_net_end_point_create
+#define oi_net_tm_pool_attach m0_net_tm_pool_attach
+#define oi_net_end_point_get m0_net_end_point_get
+#define oi_net_domain_get_max_buffer_size m0_net_domain_get_max_buffer_size
+#define oi_net_tm_fini m0_net_tm_fini
+#define oi_net_buffer_pool_unlock m0_net_buffer_pool_unlock
+#define oi_net_buffer_pool_provision m0_net_buffer_pool_provision
+#define oi_net_domain_get_max_buffer_segment_size m0_net_domain_get_max_buffer_segment_size
+#define oi_net_tm_start m0_net_tm_start
+#define oi_net_tm_stop m0_net_tm_stop
+#define oi_net_buffer_register m0_net_buffer_register
+#define oi_net_domain_get_max_buffer_segments m0_net_domain_get_max_buffer_segments
+#define oi_net_end_point_put m0_net_end_point_put
+#define oi_net_buffer_pool_init m0_net_buffer_pool_init
+#define oi_net_buffer_pool_put m0_net_buffer_pool_put
+#define oi_net_buffer_add m0_net_buffer_add
+#define oi_net_buffer_pool_lock m0_net_buffer_pool_lock
+#define oi_net_buffer_deregister m0_net_buffer_deregister
+#define oi_net_tm_init m0_net_tm_init
+#define oi_net_tm_colour_set m0_net_tm_colour_set
+#define oi_net_buffer_pool_fini m0_net_buffer_pool_fini
+#define oi_net_end_point_create m0_net_end_point_create
+
+#endif /* __KERNEL__ */
+
+#endif /* __MERO_RPC_OUTIF_H__ */
diff --git a/rpc/rpc.c b/rpc/rpc.c
index e496baa..d68a736 100644
--- a/rpc/rpc.c
+++ b/rpc/rpc.c
@@ -32,6 +32,8 @@
 
 #include "rpc/rpc.h"
 #include "rpc/rpc_internal.h"
+#include "rpc/outer_interface.h"
+
 
 /**
  * @addtogroup rpc
@@ -45,6 +47,7 @@ struct m0_addb_ctx m0_rpc_addb_ctx;
 static int rpc_service_start(struct m0_reqh_service *service)
 {
 	M0_PRE(service != NULL);
+
 	return 0;
 }
 
@@ -327,15 +330,15 @@ M0_INTERNAL int m0_rpc_net_buffer_pool_setup(struct m0_net_domain *ndom,
 	seg_size = m0_rpc_max_seg_size(ndom);
 	segs_nr  = m0_rpc_max_segs_nr(ndom);
 	app_pool->nbp_ops = &b_ops;
-	rc = m0_net_buffer_pool_init(app_pool, ndom,
+	rc = oi_net_buffer_pool_init(app_pool, ndom,
 				     M0_NET_BUFFER_POOL_THRESHOLD,
 				     segs_nr, seg_size, tm_nr, M0_SEG_SHIFT);
 	if (rc != 0)
 		M0_RETERR(rc, "net_buf_pool: Initialization");
 
-	m0_net_buffer_pool_lock(app_pool);
-	rc = m0_net_buffer_pool_provision(app_pool, bufs_nr);
-	m0_net_buffer_pool_unlock(app_pool);
+	oi_net_buffer_pool_lock(app_pool);
+	rc = oi_net_buffer_pool_provision(app_pool, bufs_nr);
+	oi_net_buffer_pool_unlock(app_pool);
 
 	M0_RETURN(rc == bufs_nr ? 0 : -ENOMEM);
 }
@@ -344,7 +347,7 @@ M0_EXPORTED(m0_rpc_net_buffer_pool_setup);
 void m0_rpc_net_buffer_pool_cleanup(struct m0_net_buffer_pool *app_pool)
 {
 	M0_PRE(app_pool != NULL);
-	m0_net_buffer_pool_fini(app_pool);
+	oi_net_buffer_pool_fini(app_pool);
 }
 M0_EXPORTED(m0_rpc_net_buffer_pool_cleanup);
 
@@ -365,7 +368,7 @@ M0_INTERNAL m0_bcount_t m0_rpc_max_seg_size(struct m0_net_domain *ndom)
 {
 	M0_PRE(ndom != NULL);
 
-	return min64u(m0_net_domain_get_max_buffer_segment_size(ndom),
+	return min64u(oi_net_domain_get_max_buffer_segment_size(ndom),
 		      M0_SEG_SIZE);
 }
 
@@ -373,7 +376,7 @@ M0_INTERNAL uint32_t m0_rpc_max_segs_nr(struct m0_net_domain *ndom)
 {
 	M0_PRE(ndom != NULL);
 
-	return m0_net_domain_get_max_buffer_size(ndom) /
+	return oi_net_domain_get_max_buffer_size(ndom) /
 	       m0_rpc_max_seg_size(ndom);
 }
 
@@ -384,7 +387,7 @@ M0_INTERNAL m0_bcount_t m0_rpc_max_msg_size(struct m0_net_domain *ndom,
 
 	M0_PRE(ndom != NULL);
 
-	mbs = m0_net_domain_get_max_buffer_size(ndom);
+	mbs = oi_net_domain_get_max_buffer_size(ndom);
 	return rpc_size != 0 ? min64u(mbs, max64u(rpc_size, M0_SEG_SIZE)) : mbs;
 }
 
@@ -393,7 +396,7 @@ M0_INTERNAL uint32_t m0_rpc_max_recv_msgs(struct m0_net_domain *ndom,
 {
 	M0_PRE(ndom != NULL);
 
-	return m0_net_domain_get_max_buffer_size(ndom) /
+	return oi_net_domain_get_max_buffer_size(ndom) /
 	       m0_rpc_max_msg_size(ndom, rpc_size);
 }
 
diff --git a/rpc/rpc_machine.c b/rpc/rpc_machine.c
index 6b7a6c3..aadd1d5 100644
--- a/rpc/rpc_machine.c
+++ b/rpc/rpc_machine.c
@@ -41,6 +41,7 @@
 #include "net/buffer_pool.h"   /* m0_net_buffer_pool_[lock|unlock] */
 #include "reqh/reqh.h"
 #include "rpc/rpc_internal.h"
+#include "rpc/outer_interface.h"
 
 #define RPCMC_ADDB_FUNCFAIL(rc, mc, loc, parentctx, ctx)		\
 	M0_ADDB_FUNC_FAIL(mc, M0_RPC_ADDB_LOC_##loc, rc,		\
@@ -365,28 +366,28 @@ static int rpc_tm_setup(struct m0_net_transfer_mc *tm,
 	addb_mc = REQH_ADDB_MC_CONFIGURED(machine->rm_reqh) ?
 		  &machine->rm_reqh->rh_addb_mc : &m0_addb_gmc;
 
-	rc = m0_net_tm_init(tm, net_dom, addb_mc, &machine->rm_addb_ctx);
+	rc = oi_net_tm_init(tm, net_dom, addb_mc, &machine->rm_addb_ctx);
 	if (rc < 0)
 		M0_RETERR(rc, "TM initialization");
 
-	rc = m0_net_tm_pool_attach(tm, pool,
+	rc = oi_net_tm_pool_attach(tm, pool,
 				   &m0_rpc_rcv_buf_callbacks,
 				   m0_rpc_max_msg_size(net_dom, msg_size),
 				   m0_rpc_max_recv_msgs(net_dom, msg_size),
 				   qlen);
 	if (rc < 0) {
-		m0_net_tm_fini(tm);
+		oi_net_tm_fini(tm);
 		M0_RETERR(rc, "m0_net_tm_pool_attach");
 	}
 
-	m0_net_tm_colour_set(tm, colour);
+	oi_net_tm_colour_set(tm, colour);
 
 	/* Start the transfer machine so that users of this rpc_machine
 	   can send/receive messages. */
 	m0_clink_init(&tmwait, NULL);
 	m0_clink_add(&tm->ntm_chan, &tmwait);
 
-	rc = m0_net_tm_start(tm, ep_addr);
+	rc = oi_net_tm_start(tm, ep_addr);
 	if (rc == 0) {
 		while (tm->ntm_state != M0_NET_TM_STARTED &&
 		       tm->ntm_state != M0_NET_TM_FAILED)
@@ -400,7 +401,7 @@ static int rpc_tm_setup(struct m0_net_transfer_mc *tm,
 		    tm does not report cause of failure.
 		 */
 		rc = -ENETUNREACH;
-		m0_net_tm_fini(tm);
+		oi_net_tm_fini(tm);
 		M0_RETERR(rc, "TM start");
 	}
 	M0_RETURN(rc);
@@ -418,7 +419,7 @@ static void rpc_tm_cleanup(struct m0_rpc_machine *machine)
 	m0_clink_init(&tmwait, NULL);
 	m0_clink_add(&tm->ntm_chan, &tmwait);
 
-	rc = m0_net_tm_stop(tm, true);
+	rc = oi_net_tm_stop(tm, true);
 
 	if (rc < 0) {
 		m0_clink_del(&tmwait);
@@ -441,7 +442,7 @@ static void rpc_tm_cleanup(struct m0_rpc_machine *machine)
 	m0_clink_fini(&tmwait);
 
 	/* Fini the transfer machine here and deallocate the chan. */
-	m0_net_tm_fini(tm);
+	oi_net_tm_fini(tm);
 	M0_LEAVE();
 }
 
@@ -625,7 +626,7 @@ static struct m0_rpc_chan *rpc_chan_locate(struct m0_rpc_machine *machine,
 			  dest_ep->nep_tm->ntm_dom);
 		if (chan->rc_destep == dest_ep) {
 			m0_ref_get(&chan->rc_ref);
-			m0_net_end_point_get(chan->rc_destep);
+			oi_net_end_point_get(chan->rc_destep);
 			found = true;
 			break;
 		}
@@ -662,7 +663,7 @@ static int rpc_chan_create(struct m0_rpc_chan **chan,
 	ch->rc_rpc_machine = machine;
 	ch->rc_destep = dest_ep;
 	m0_ref_init(&ch->rc_ref, 1, rpc_chan_ref_release);
-	m0_net_end_point_get(dest_ep);
+	oi_net_end_point_get(dest_ep);
 
 	ndom = machine->rm_tm.ntm_dom;
 
@@ -671,7 +672,7 @@ static int rpc_chan_create(struct m0_rpc_chan **chan,
 	constraints.fc_max_nr_bytes_accumulated =
 				constraints.fc_max_packet_size;
 	constraints.fc_max_nr_segments =
-				m0_net_domain_get_max_buffer_segments(ndom);
+				oi_net_domain_get_max_buffer_segments(ndom);
 
 	m0_rpc_frm_init(&ch->rc_frm, &constraints, &m0_rpc_frm_default_ops);
 	rpc_chan_tlink_init_at(ch, &machine->rm_chans);
@@ -692,7 +693,7 @@ M0_INTERNAL void rpc_chan_put(struct m0_rpc_chan *chan)
 	machine = chan->rc_rpc_machine;
 	M0_PRE(m0_rpc_machine_is_locked(machine));
 
-	m0_net_end_point_put(chan->rc_destep);
+	oi_net_end_point_put(chan->rc_destep);
 	m0_ref_put(&chan->rc_ref);
 	M0_LEAVE();
 }
@@ -850,10 +851,10 @@ static void rpc_recv_pool_buffer_put(struct m0_net_buffer *nb)
 	M0_PRE(tm->ntm_recv_pool == nb->nb_pool);
 
 	nb->nb_ep = NULL;
-	m0_net_buffer_pool_lock(tm->ntm_recv_pool);
-	m0_net_buffer_pool_put(tm->ntm_recv_pool, nb,
+	oi_net_buffer_pool_lock(tm->ntm_recv_pool);
+	oi_net_buffer_pool_put(tm->ntm_recv_pool, nb,
 			       tm->ntm_pool_colour);
-	m0_net_buffer_pool_unlock(tm->ntm_recv_pool);
+	oi_net_buffer_pool_unlock(tm->ntm_recv_pool);
 
 	M0_LEAVE();
 }
diff --git a/rpc/rpclib.c b/rpc/rpclib.c
index 251f2ff..e935cc3 100644
--- a/rpc/rpclib.c
+++ b/rpc/rpclib.c
@@ -41,6 +41,8 @@
 #include "mero/setup.h"
 #endif
 
+#include "rpc/outer_interface.h"
+
 #ifndef __KERNEL__
 int m0_rpc_server_start(struct m0_rpc_server_ctx *sctx)
 {
@@ -110,13 +112,13 @@ M0_INTERNAL int m0_rpc_client_connect(struct m0_rpc_conn    *conn,
 
 	M0_ENTRY();
 
-	rc = m0_net_end_point_create(&ep, &rpc_mach->rm_tm, remote_addr);
+	rc = oi_net_end_point_create(&ep, &rpc_mach->rm_tm, remote_addr);
 	if (rc != 0)
 		M0_RETURN(rc);
 
 	rc = m0_rpc_conn_create(conn, ep, rpc_mach, max_rpcs_in_flight,
 				m0_time_from_now(rpc_timeout_sec, 0));
-	m0_net_end_point_put(ep);
+	oi_net_end_point_put(ep);
 	if (rc != 0)
 		M0_RETURN(rc);
 
diff --git a/rpc/session_foms.c b/rpc/session_foms.c
index 7fa675b..466f83d 100644
--- a/rpc/session_foms.c
+++ b/rpc/session_foms.c
@@ -28,6 +28,7 @@
 #include "stob/stob.h"
 #include "net/net.h"
 #include "rpc/rpc_internal.h"
+#include "rpc/outer_interface.h"
 
 /**
    @addtogroup rpc_session
@@ -196,7 +197,7 @@ M0_INTERNAL int m0_rpc_fom_conn_establish_tick(struct m0_fom *fom)
 	rc = m0_rpc_rcv_conn_init(conn, ctx->cec_sender_ep, machine,
 				  &item->ri_slot_refs[0].sr_ow.osr_uuid);
 	/* we won't need ctx->cec_sender_ep after this point */
-	m0_net_end_point_put(ctx->cec_sender_ep);
+	oi_net_end_point_put(ctx->cec_sender_ep);
 	if (rc == 0) {
 		session0 = m0_rpc_conn_session0(conn);
 		if (ow_sref->osr_slot_id >= session0->s_nr_slots) {
diff --git a/rpc/session_fops.c b/rpc/session_fops.c
index ef92165..6dfdaba 100644
--- a/rpc/session_fops.c
+++ b/rpc/session_fops.c
@@ -29,6 +29,7 @@
 #include "fop/fop_item_type.h"
 #include "dtm/verno_xc.h" /* m0_xc_verno_init */
 #include "rpc/rpc_internal.h"
+#include "rpc/outer_interface.h"
 
 /**
    @addtogroup rpc_session
@@ -221,7 +222,7 @@ M0_INTERNAL void m0_rpc_fop_conn_establish_ctx_init(struct m0_rpc_item *item,
 
 	ctx = container_of(item, struct m0_rpc_fop_conn_establish_ctx,
 				cec_fop.f_item);
-	m0_net_end_point_get(ep);
+	oi_net_end_point_get(ep);
 	ctx->cec_sender_ep = ep;
 	M0_LEAVE();
 }
-- 
1.8.3.2

