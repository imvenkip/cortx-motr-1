From c9efe8896ceff501509d4ecfaeced1fd4820f3e6 Mon Sep 17 00:00:00 2001
From: Anatoliy Bilenko <anatoliy_bilenko@xyratex.com>
Date: Tue, 5 Mar 2013 10:44:18 +0200
Subject: [PATCH 2/2] Add oi_* rpc sending path.

     XXX: Seems net and rpc are tightly coupled.
          Switching to bulk in-memory transport.
---
 rpc/outer_interface.c | 294 ++++++++++++++++++++++++++++++++++++++++++++++++++
 rpc/outer_interface.h |   4 +-
 2 files changed, 296 insertions(+), 2 deletions(-)

diff --git a/rpc/outer_interface.c b/rpc/outer_interface.c
index caa0816..68b57b0 100644
--- a/rpc/outer_interface.c
+++ b/rpc/outer_interface.c
@@ -1,5 +1,20 @@
+#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_RPC
+#include "lib/trace.h"
+
 #include "rpc/outer_interface.h"
 #include "lib/cdefs.h"
+#include "lib/list.h"
+#include "lib/mutex.h"
+#include "lib/memory.h"
+#include "lib/errno.h"
+#include "lib/string.h"
+
+/***********************************************************************
+ *
+ *                  GENERIC RPC CALLS WRAPPED BY oi_*()
+ *
+ ***********************************************************************/
+#if 0
 
 /* net domain */
 M0_INTERNAL m0_bcount_t oi_net_domain_get_max_buffer_size(struct m0_net_domain
@@ -163,3 +178,282 @@ M0_INTERNAL int oi_net_end_point_create(struct m0_net_end_point **epp,
 	return m0_net_end_point_create(epp, tm, addr);
 }
 
+/***********************************************************************
+ *
+ *               UNIT BENCHMARK RPC CALLS WRAPPED BY oi_*()
+ *
+ ***********************************************************************/
+#else
+
+/* net domain */
+M0_INTERNAL m0_bcount_t oi_net_domain_get_max_buffer_size(struct m0_net_domain
+							  *dom)
+{
+	return 1048576;
+}
+
+
+M0_INTERNAL m0_bcount_t oi_net_domain_get_max_buffer_segment_size(struct
+								  m0_net_domain
+								  *dom)
+{
+	return 4096;
+}
+
+
+M0_INTERNAL m0_bcount_t oi_net_domain_get_max_buffer_segments(struct
+							      m0_net_domain
+							      *dom)
+{
+	return 256;
+}
+
+/* net buffer */
+struct ep2tm {
+	const char		  *et_ep;
+	struct m0_net_transfer_mc *et_tm;
+};
+
+static size_t g_contextes = 0;
+static struct ep2tm    g_ep2tm[10];
+static struct m0_list  g_bufs;
+static struct m0_mutex g_buffer_pool_lock;
+static struct m0_mutex g_ep_lock;
+static struct m0_mutex g_thread_lock;
+static const struct m0_net_buffer_callbacks *g_callbacks;
+
+M0_INTERNAL int oi_net_buffer_register(struct m0_net_buffer *buf,
+				       struct m0_net_domain *dom)
+{
+	M0_LOG(M0_DEBUG, "(%p,%p)", buf, dom);
+
+	return 0;
+}
+
+
+M0_INTERNAL void oi_net_buffer_deregister(struct m0_net_buffer *buf,
+					  struct m0_net_domain *dom)
+{
+	M0_LOG(M0_DEBUG, "(%p,%p)", buf, dom);
+}
+
+
+M0_INTERNAL int oi_net_buffer_add(struct m0_net_buffer *buf,
+				  struct m0_net_transfer_mc *tm)
+{
+ /* void (*m0_net_buffer_cb_proc_t)(const struct m0_net_buffer_event *ev); */
+	m0_net_buffer_cb_proc_t    cb = g_callbacks->nbc_cb[M0_NET_QT_MSG_RECV];
+	struct m0_net_buffer_event ev;
+	size_t			   i;
+
+	M0_LOG(M0_DEBUG, "(%p,%p)", buf, tm);
+
+	for (i = 0; i < g_contextes; ++i) {
+		IS_IN_ARRAY(index, g_ep2tm);
+		if (strcmp(g_ep2tm[i].et_ep, buf->nb_ep->nep_addr) == 0) {
+			ev.nbe_ep     = buf->nb_ep;
+			ev.nbe_length = buf->nb_length;
+			ev.nbe_offset = buf->nb_offset;
+			ev.nbe_buffer = buf;
+			ev.nbe_status = 0;
+			buf->nb_flags = M0_NET_BUF_QUEUED;
+
+			buf->nb_tm = g_ep2tm[i].et_tm;
+			//cb(&ev);
+
+
+			printf("1\n");
+			m0_mutex_lock(&g_thread_lock);
+			{
+			   struct m0_thread t;
+			   M0_THREAD_INIT(&t, int, NULL,
+			    LAMBDA(void, (int y) { cb(&ev); } ),
+					  42, "t0");
+			   m0_thread_join(&t);
+			   m0_thread_fini(&t);
+			}
+			m0_mutex_unlock(&g_thread_lock);
+			printf("2\n");
+
+			return 0;
+		}
+	}
+
+	return -EINVAL;
+}
+
+
+/* buffer pool */
+M0_INTERNAL int oi_net_buffer_pool_init(struct m0_net_buffer_pool *pool,
+					struct m0_net_domain *ndom,
+					uint32_t threshold, uint32_t seg_nr,
+					m0_bcount_t seg_size, uint32_t colours,
+					unsigned shift)
+{
+	M0_LOG(M0_DEBUG, "(%p,%p)", pool, ndom);
+	pool->nbp_ndom	     = ndom;
+	return 0;
+}
+
+M0_INTERNAL void oi_net_buffer_pool_fini(struct m0_net_buffer_pool *pool)
+{
+	M0_LOG(M0_DEBUG, "(%p)", pool);
+}
+
+M0_INTERNAL int oi_net_buffer_pool_provision(struct m0_net_buffer_pool *pool,
+					     uint32_t buf_nr)
+{
+	M0_LOG(M0_DEBUG, "(%p,%u)", pool, buf_nr);
+
+	return buf_nr;
+}
+
+M0_INTERNAL void oi_net_buffer_pool_lock(struct m0_net_buffer_pool *pool)
+{
+	M0_LOG(M0_DEBUG, "(%p)", pool);
+	m0_mutex_lock(&g_buffer_pool_lock);
+}
+
+M0_INTERNAL void oi_net_buffer_pool_unlock(struct m0_net_buffer_pool *pool)
+{
+	M0_LOG(M0_DEBUG, "(%p)", pool);
+	m0_mutex_unlock(&g_buffer_pool_lock);
+}
+
+M0_INTERNAL void oi_net_buffer_pool_put(struct m0_net_buffer_pool *pool,
+					struct m0_net_buffer *buf,
+					uint32_t colour)
+{
+	M0_LOG(M0_DEBUG, "(%p,%p)", pool, buf);
+}
+
+
+
+/* m0_net_tm */
+M0_INTERNAL int oi_net_tm_init(struct m0_net_transfer_mc *tm,
+			       struct m0_net_domain      *dom,
+			       struct m0_addb_mc         *addb_mc,
+			       struct m0_addb_ctx        *ctx)
+{
+	M0_LOG(M0_DEBUG, "(%p,%p,%lu)", tm, dom, g_contextes);
+
+	if (++g_contextes < 2) {
+		m0_mutex_init(&g_buffer_pool_lock);
+		m0_mutex_init(&g_ep_lock);
+		m0_mutex_init(&g_thread_lock);
+		m0_list_init(&g_bufs);
+	}
+
+	m0_chan_init(&tm->ntm_chan);
+	tm->ntm_state = M0_NET_TM_STARTED;
+	tm->ntm_dom = dom;
+
+
+	return 0;
+}
+
+
+
+M0_INTERNAL void oi_net_tm_fini(struct m0_net_transfer_mc *tm)
+{
+
+	M0_LOG(M0_DEBUG, "(%p,%lu)", tm, g_contextes);
+
+	if (--g_contextes == 0) {
+		m0_mutex_fini(&g_buffer_pool_lock);
+		m0_mutex_fini(&g_ep_lock);
+		m0_list_fini(&g_bufs);
+		m0_mutex_fini(&g_thread_lock);
+	}
+
+	m0_chan_fini(&tm->ntm_chan);
+}
+
+
+M0_INTERNAL int oi_net_tm_start(struct m0_net_transfer_mc *tm,
+				const char *addr)
+{
+	M0_LOG(M0_DEBUG, "(%p,%p)", tm, addr);
+
+	IS_IN_ARRAY(g_contextes-1, g_ep2tm);
+	g_ep2tm[g_contextes-1].et_ep = addr;
+	g_ep2tm[g_contextes-1].et_tm = tm;
+
+	return 0;
+}
+
+
+M0_INTERNAL int oi_net_tm_stop(struct m0_net_transfer_mc *tm,
+			       bool abort)
+{
+	M0_LOG(M0_DEBUG, "(%p)", tm);
+	return 0;
+}
+
+
+M0_INTERNAL int oi_net_tm_pool_attach(struct m0_net_transfer_mc *tm,
+				      struct m0_net_buffer_pool *bufpool,
+				      const struct m0_net_buffer_callbacks
+				      *callbacks, m0_bcount_t min_recv_size,
+				      uint32_t max_recv_msgs,
+				      uint32_t min_recv_queue_len)
+{
+	M0_LOG(M0_DEBUG, "(%p)", callbacks);
+	g_callbacks = callbacks;
+	return 0;
+}
+
+
+M0_INTERNAL void oi_net_tm_colour_set(struct m0_net_transfer_mc *tm,
+				      uint32_t colour)
+{
+	M0_LOG(M0_DEBUG, "-");
+}
+
+
+/* endpoint */
+M0_INTERNAL void oi_net_end_point_get(struct m0_net_end_point *ep)
+{
+
+	struct m0_ref *ref = &ep->nep_ref;
+
+	M0_LOG(M0_DEBUG, "(%p)", ep);
+	M0_PRE(ep != NULL && m0_atomic64_get(&ref->ref_cnt) >= 1);
+
+	m0_ref_get(ref);
+}
+
+
+M0_INTERNAL void oi_net_end_point_put(struct m0_net_end_point *ep)
+{
+	struct m0_ref *ref = &ep->nep_ref;
+
+	M0_LOG(M0_DEBUG, "(%p)", ep);
+	M0_PRE(ep != NULL && m0_atomic64_get(&ref->ref_cnt) >= 1);
+
+	m0_mutex_lock(&g_ep_lock);
+	m0_ref_put(ref);
+	m0_mutex_unlock(&g_ep_lock);
+}
+
+static void release(struct m0_ref *r)
+{
+	M0_LOG(M0_DEBUG, "(%p)", r);
+}
+
+M0_INTERNAL int oi_net_end_point_create(struct m0_net_end_point **epp,
+					struct m0_net_transfer_mc *tm,
+					const char *addr)
+{
+	M0_ALLOC_PTR(*epp);
+	if (*epp == NULL)
+		return -ENOMEM;
+
+	m0_ref_init(&(*epp)->nep_ref, 1, release);
+	(*epp)->nep_addr = strdup(addr);
+	(*epp)->nep_tm   = tm;
+
+	return 0;
+}
+
+#endif
diff --git a/rpc/outer_interface.h b/rpc/outer_interface.h
index 976342b..a47536e 100644
--- a/rpc/outer_interface.h
+++ b/rpc/outer_interface.h
@@ -6,7 +6,7 @@
 #include "net/net.h"
 #include "net/buffer_pool.h"
 
-#ifndef __KERNEL__
+#ifndef __KERNEL__ /* !__KERNEL__ */
 /* net domain */
 M0_INTERNAL m0_bcount_t oi_net_domain_get_max_buffer_size(struct m0_net_domain
 							  *dom);
@@ -84,7 +84,7 @@ M0_INTERNAL void oi_net_end_point_put(struct m0_net_end_point *ep);
 M0_INTERNAL int oi_net_end_point_create(struct m0_net_end_point **epp,
 					struct m0_net_transfer_mc *tm,
 					const char *addr);
-#else /* !__KERNEL__ */
+#else /* __KERNEL__ */
 
 #define oi_net_tm_pool_attach m0_net_tm_pool_attach
 #define oi_net_end_point_get m0_net_end_point_get
-- 
1.8.3.2

