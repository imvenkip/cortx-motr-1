From 7b5fa3218df1be3da1a709e60fc16be23a5fdbc2 Mon Sep 17 00:00:00 2001
From: Carl Braganza <carl_braganza@xyratex.com>
Date: Thu, 10 Jan 2013 17:48:25 -0800
Subject: [PATCH 3/6] Introduced the rso_prepare_to_stop() service method and
 associated m0_reqh_service_prepare_to_stop() sub. The m0_reqh_shutdown_wait()
 sub now invokes this method first. Added m0_reqh_fom_domain_idle_wait() for
 UTs that just want to wait on FOMs without actually shutting down. Created
 the m0_reqh_services_terminate() sub with logic previously in
 mero/setup.c::cs_services_fini(). Updated existing code to use new
 interfaces.

---
 addb/user_space/addb_svc.c | 22 ++++++++++---
 cm/ut/cp.c                 |  6 ++--
 mero/setup.c               | 54 +++----------------------------
 reqh/reqh.c                | 38 ++++++++++++++++++----
 reqh/reqh.h                | 24 ++++++++++++--
 reqh/reqh_service.c        | 18 +++++++++--
 reqh/reqh_service.h        | 81 +++++++++++++++++++++++++++++-----------------
 sns/repair/ut/repair.c     |  2 +-
 sns/repair/ut/storage.c    |  6 ++--
 sns/repair/ut/xform.c      |  6 ++--
 10 files changed, 152 insertions(+), 105 deletions(-)

diff --git a/addb/user_space/addb_svc.c b/addb/user_space/addb_svc.c
index b565a78..9d5b9f3 100644
--- a/addb/user_space/addb_svc.c
+++ b/addb/user_space/addb_svc.c
@@ -99,6 +99,7 @@ static int addb_svc_rso_start(struct m0_reqh_service *service)
 {
 	struct addb_svc *svc;
 
+	M0_PRE(service->rs_state == M0_RST_STARTING);
 	svc = bob_of(service, struct addb_svc, as_reqhs, &addb_svc_bob);
 	if (addb_svc_start_pfom)
 		addb_pfom_start(svc);
@@ -107,24 +108,34 @@ static int addb_svc_rso_start(struct m0_reqh_service *service)
 }
 
 /**
-   The rso_stop method to stop the ADDB service and terminate persistent FOMs.
+   The rso_prepare_to_stop method terminates the persistent FOMs.
  */
-static void addb_svc_rso_stop(struct m0_reqh_service *service)
+static void addb_svc_rso_prepare_to_stop(struct m0_reqh_service *service)
 {
 	struct addb_svc *svc;
 
+	M0_PRE(service->rs_state == M0_RST_STARTED);
 	svc = bob_of(service, struct addb_svc, as_reqhs, &addb_svc_bob);
 	if (addb_svc_start_pfom)
 		addb_pfom_stop(svc);
 }
 
 /**
+   The rso_stop method to stop the ADDB service.
+ */
+static void addb_svc_rso_stop(struct m0_reqh_service *service)
+{
+	M0_PRE(service->rs_state == M0_RST_STOPPING);
+}
+
+/**
    The rso_fini method to finalize the ADDB service.
  */
 static void addb_svc_rso_fini(struct m0_reqh_service *service)
 {
 	struct addb_svc *svc;
 
+	M0_PRE(M0_IN(service->rs_state, (M0_RST_STOPPED, M0_RST_FAILED)));
 	svc = bob_of(service, struct addb_svc, as_reqhs, &addb_svc_bob);
 	m0_cond_fini(&svc->as_cond);
 	addb_svc_bob_fini(svc);
@@ -133,9 +144,10 @@ static void addb_svc_rso_fini(struct m0_reqh_service *service)
 }
 
 static const struct m0_reqh_service_ops addb_service_ops = {
-	.rso_start = addb_svc_rso_start,
-	.rso_stop  = addb_svc_rso_stop,
-	.rso_fini  = addb_svc_rso_fini
+	.rso_start           = addb_svc_rso_start,
+	.rso_prepare_to_stop = addb_svc_rso_prepare_to_stop,
+	.rso_stop            = addb_svc_rso_stop,
+	.rso_fini            = addb_svc_rso_fini
 };
 
 /*
diff --git a/cm/ut/cp.c b/cm/ut/cp.c
index 6cc32eb..ea16fdb 100644
--- a/cm/ut/cp.c
+++ b/cm/ut/cp.c
@@ -1,6 +1,6 @@
 /* -*- C -*- */
 /*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
  *
  * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
  * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
@@ -227,7 +227,7 @@ static void test_cp_single_thread(void)
          * Wait until all the foms in the request handler locality runq are
          * processed.
          */
-        m0_reqh_shutdown_wait(&cm_ut_reqh);
+        m0_reqh_fom_domain_idle_wait(&cm_ut_reqh);
 	m0_semaphore_fini(&sem);
 }
 
@@ -273,7 +273,7 @@ static void test_cp_multi_thread(void)
          * Wait until all the foms in the request handler locality runq are
          * processed.
          */
-        m0_reqh_shutdown_wait(&cm_ut_reqh);
+        m0_reqh_fom_domain_idle_wait(&cm_ut_reqh);
         m0_free(cp_thread);
 	m0_semaphore_fini(&sem);
 }
diff --git a/mero/setup.c b/mero/setup.c
index 74f8c80..dcda474 100644
--- a/mero/setup.c
+++ b/mero/setup.c
@@ -181,7 +181,8 @@ static struct m0_net_xprt *cs_xprt_lookup(const char *xprt_name,
 /**
    Lists supported network transports.
  */
-static void cs_xprts_list(FILE *out, struct m0_net_xprt **xprts, size_t xprts_nr)
+static void cs_xprts_list(FILE *out, struct m0_net_xprt **xprts,
+			  size_t xprts_nr)
 {
 	int i;
 
@@ -1028,30 +1029,6 @@ cs_service_init(const char *name, const char *arg, struct m0_reqh *reqh)
 	M0_RETURN(rc);
 }
 
-/**
-   Finalises a service.
-   Transitions service to M0_RSPH_STOPPING phase, stops a service and then
-   finalises the same.
-
-   @param service Service to be finalised
-
-   @pre service != NULL
-
-   @see m0_reqh_service_stop()
-   @see m0_reqh_service_fini()
- */
-static void cs_service_fini(struct m0_reqh_service *service)
-{
-	M0_PRE(service != NULL);
-
-	M0_ENTRY("%s", service->rs_type->rst_name);
-
-	m0_reqh_service_stop(service);
-	m0_reqh_service_fini(service);
-}
-
-static void cs_services_fini(struct m0_reqh *reqh);
-
 static int _services_init(struct cs_reqh_context *rctx)
 {
 	const char *name;
@@ -1069,7 +1046,7 @@ static int _services_init(struct cs_reqh_context *rctx)
 			&rctx->rc_reqh);
 	}
 	if (rc != 0)
-		cs_services_fini(&rctx->rc_reqh);
+		m0_reqh_services_terminate(&rctx->rc_reqh);
 	M0_RETURN(rc);
 }
 
@@ -1101,29 +1078,6 @@ static int cs_services_init(struct m0_mero *cctx)
 }
 
 /**
-   Finalises all the services registered with a request handler.
-   Also traverses through the services list and invokes cs_service_fini() on
-   each individual service.
-
-   @param reqh Request handler of which the services are to be finalised
-
-   @pre reqh != NULL
- */
-static void cs_services_fini(struct m0_reqh *reqh)
-{
-	struct m0_reqh_service *svc;
-
-	M0_PRE(reqh != NULL);
-
-	M0_ENTRY();
-
-	m0_tl_for(m0_reqh_svc, &reqh->rh_services, svc) {
-		M0_ASSERT(m0_reqh_service_invariant(svc));
-		cs_service_fini(svc);
-	} m0_tl_endfor;
-}
-
-/**
    Initialises network domains per given distinct xport:endpoint pair in a
    mero context.
 
@@ -1442,7 +1396,7 @@ static void cs_request_handler_stop(struct cs_reqh_context *rctx)
 	reqh = &rctx->rc_reqh;
 	m0_reqh_shutdown_wait(reqh);
 
-	cs_services_fini(reqh);
+	m0_reqh_services_terminate(reqh);
 	cs_rpc_machines_fini(reqh);
 	m0_reqh_fini(reqh);
 	m0_fol_fini(&rctx->rc_fol);
diff --git a/reqh/reqh.c b/reqh/reqh.c
index 764b6a3..9bc7a8c 100644
--- a/reqh/reqh.c
+++ b/reqh/reqh.c
@@ -1,6 +1,6 @@
 /* -*- C -*- */
 /*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
  *
  * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
  * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
@@ -197,14 +197,11 @@ M0_INTERNAL void m0_reqh_fop_handle(struct m0_reqh *reqh, struct m0_fop *fop)
 	m0_rwlock_read_unlock(&reqh->rh_rwlock);
 }
 
-M0_INTERNAL void m0_reqh_shutdown_wait(struct m0_reqh *reqh)
+M0_INTERNAL void m0_reqh_fom_domain_idle_wait(struct m0_reqh *reqh)
 {
 	struct m0_clink clink;
 
-        m0_rwlock_write_lock(&reqh->rh_rwlock);
-        reqh->rh_shutdown = true;
-        m0_rwlock_write_unlock(&reqh->rh_rwlock);
-
+	M0_PRE(reqh != NULL);
         m0_clink_init(&clink, NULL);
         m0_clink_add(&reqh->rh_sd_signal, &clink);
 
@@ -215,6 +212,35 @@ M0_INTERNAL void m0_reqh_shutdown_wait(struct m0_reqh *reqh)
 	m0_clink_fini(&clink);
 }
 
+M0_INTERNAL void m0_reqh_shutdown_wait(struct m0_reqh *reqh)
+{
+	struct m0_reqh_service *service;
+
+	M0_PRE(reqh != NULL);
+        m0_rwlock_write_lock(&reqh->rh_rwlock);
+        reqh->rh_shutdown = true;
+        m0_rwlock_write_unlock(&reqh->rh_rwlock);
+
+	m0_tl_for(m0_reqh_svc, &reqh->rh_services, service) {
+		M0_ASSERT(m0_reqh_service_invariant(service));
+		m0_reqh_service_prepare_to_stop(service);
+	} m0_tl_endfor;
+
+	m0_reqh_fom_domain_idle_wait(reqh);
+}
+
+M0_INTERNAL void m0_reqh_services_terminate(struct m0_reqh *reqh)
+{
+	struct m0_reqh_service *service;
+
+	M0_PRE(reqh != NULL);
+	m0_tl_for(m0_reqh_svc, &reqh->rh_services, service) {
+		M0_ASSERT(m0_reqh_service_invariant(service));
+		m0_reqh_service_stop(service);
+		m0_reqh_service_fini(service);
+	} m0_tl_endfor;
+}
+
 M0_INTERNAL void m0_reqh_stats_post_addb(struct m0_reqh *reqh)
 {
 	struct m0_reqh_service *service;
diff --git a/reqh/reqh.h b/reqh/reqh.h
index e375b08..bcf2897 100644
--- a/reqh/reqh.h
+++ b/reqh/reqh.h
@@ -1,6 +1,6 @@
 /* -*- C -*- */
 /*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
  *
  * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
  * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
@@ -218,14 +218,32 @@ M0_INTERNAL void m0_reqh_fop_handle(struct m0_reqh *reqh, struct m0_fop *fop);
 M0_INTERNAL void m0_reqh_stats_post_addb(struct m0_reqh *reqh);
 
 /**
-   Waits on m0_reqh::rh_sd_signal using the given clink until
-   m0_fom_domain_is_idle().
+   Waits on the request handler channel (m0_reqh::rh_sd_signal) until the
+   request handler FOM domain (m0_reqh::rh_fom_dom) is idle.
+
+   @note Use with caution. This can block forever if FOMs do not terminate.
+   @see m0_fom_domain_is_idle()
+   @see m0_reqh_shutdown_wait()
+ */
+M0_INTERNAL void m0_reqh_fom_domain_idle_wait(struct m0_reqh *reqh);
+
+/**
+   Initiates the termination of services and then wait for FOMs to
+   terminate.
 
    @param reqh request handler to be shutdown
+   @see m0_reqh_service_prepare_to_stop(), m0_reqh_fom_domain_idle_wait()
  */
 M0_INTERNAL void m0_reqh_shutdown_wait(struct m0_reqh *reqh);
 
 /**
+   Stops and finalises all the services registered with a request handler.
+   @see m0_reqh_service_stop()
+   @see m0_reqh_service_fini()
+ */
+M0_INTERNAL void m0_reqh_services_terminate(struct m0_reqh *reqh);
+
+/**
     Initializes global reqh objects like reqh fops and addb context,
     invoked from m0_init().
  */
diff --git a/reqh/reqh_service.c b/reqh/reqh_service.c
index c1bd77b..424f955 100644
--- a/reqh/reqh_service.c
+++ b/reqh/reqh_service.c
@@ -1,6 +1,6 @@
 /* -*- C -*- */
 /*
- * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
  *
  * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
  * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
@@ -146,15 +146,29 @@ M0_INTERNAL int m0_reqh_service_start(struct m0_reqh_service *service)
 	return rc;
 }
 
+M0_INTERNAL void m0_reqh_service_prepare_to_stop(struct m0_reqh_service
+						 *service)
+{
+	M0_PRE(m0_reqh_service_invariant(service));
+	M0_PRE(service->rs_state == M0_RST_STARTED);
+
+	if (service->rs_ops->rso_prepare_to_stop != NULL)
+		service->rs_ops->rso_prepare_to_stop(service);
+	service->rs_state = M0_RST_STOPPING;
+}
+
 M0_INTERNAL void m0_reqh_service_stop(struct m0_reqh_service *service)
 {
 	struct m0_reqh *reqh;
 	unsigned        key;
 
 	M0_ASSERT(m0_reqh_service_invariant(service));
+	M0_ASSERT(M0_IN(service->rs_state, (M0_RST_STARTED, M0_RST_STOPPING)));
+
+	if (service->rs_state != M0_RST_STOPPING)
+		m0_reqh_service_prepare_to_stop(service);
 
 	reqh = service->rs_reqh;
-	service->rs_state = M0_RST_STOPPING;
 	service->rs_ops->rso_stop(service);
 	m0_rwlock_write_lock(&reqh->rh_rwlock);
 	m0_reqh_svc_tlist_del(service);
diff --git a/reqh/reqh_service.h b/reqh/reqh_service.h
index a2d49bf..d0f38f0 100644
--- a/reqh/reqh_service.h
+++ b/reqh/reqh_service.h
@@ -1,6 +1,6 @@
 /* -*- C -*- */
 /*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
  *
  * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
  * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
@@ -102,34 +102,32 @@
 
    - unregister service using m0_reqh_service_type_unregister().
 
-   A typical service transitions through its states as below,
+   A typical service transitions through its states as illustrated below.
+   The triggering subroutine is identified, and the service method or
+   service type method invoked is shown within square braces.
    @verbatim
-
-     cs_service_init()
-          |
-          v                 allocated
-     rsto_service_allocate()+------------>M0_RST_INITIALISING
-                                            |
+  m0_reqh_service_allocate()
+       <<START>> ---------------------> M0_RST_INITIALISING
+   [rsto_service_allocate()]                |
                                             | m0_reqh_service_init()
                                             v
                                         M0_RST_INITIALISED
                                             |
-                                            | rso_start()
-                    start up failed         v
-        +------------------------------+M0_RST_STARTING
-        |              rc != 0              |
-	|                                   | m0_reqh_service_start()
-        v                                   v
-   M0_RST_FAILED                          M0_RST_STARTED
-        |                                   |
-        v                                   | rso_stop()
-    rso_fini()                              v
+                                            | m0_reqh_service_start()
+                                            v
+        +------------------------------ M0_RST_STARTING [rso_start()]
+        |                       failure     | success
+        v                                   |
+   M0_RST_FAILED                            |
+        |                              M0_RST_STARTED
+        | m0_reqh_service_fini()            | m0_reqh_service_prepare_to_stop()
+        v                                   |  [rso_prepare_to_stop()]*
+     <<END>> [rso_fini()]                   v
         ^                               M0_RST_STOPPING
-        |                                   |
         |                                   | m0_reqh_service_stop()
+        |                                   | [rso_stop()]
         |     m0_reqh_service_fini()        v
-	+------------------------------+M0_RST_STOPPED
-
+	+------------------------------ M0_RST_STOPPED
    @endverbatim
 
    @{
@@ -172,16 +170,19 @@ enum m0_reqh_service_state {
 	 */
 	M0_RST_STARTED,
 	/**
-	   A service transitions to M0_RST_STOPPING state before service
-           specific stop routine is invoked.
-
-	   @see m0_reqh_service_stop()
+	   A service transitions to M0_RST_STOPPING state before the service
+           specific rso_stop() routine is invoked.
+	   The optional rso_prepare_to_stop() method will be called
+	   when this state is entered.  This gives a service a chance
+	   to trigger FOM termination before its rso_stop() method is
+	   invoked.
+	   @see m0_reqh_shutdown_wait()
 	 */
 	M0_RST_STOPPING,
 	/**
 	   A service transitions to M0_RST_STOPPED state, once service specific
-           stop routine completes successfully and after it is unregistered from
-           the request handler.
+           rso_stop() routine completes successfully and after it is
+           unregistered from the request handler.
 	 */
 	M0_RST_STOPPED,
 	/**
@@ -275,6 +276,17 @@ struct m0_reqh_service_ops {
 	int (*rso_start)(struct m0_reqh_service *service);
 
 	/**
+	   Optional method to notify the service that the request handler
+	   is preparing to shut down.  After this call is made the request
+	   handler will block waiting for FOM termination, so any long
+	   lived service FOMs should notified that they should stop by this
+	   method.
+	   The service will be in the M0_RST_STOPPING state when the method
+	   is invoked.
+	 */
+	void (*rso_prepare_to_stop)(struct m0_reqh_service *service);
+
+	/**
 	   Performs service specific finalisation of objects.
 	   Once stopped, no incoming request related to this service
 	   on a node will be processed further.
@@ -412,6 +424,16 @@ M0_INTERNAL struct m0_reqh_service_type *m0_reqh_service_type_find(const char
 M0_INTERNAL int m0_reqh_service_start(struct m0_reqh_service *service);
 
 /**
+   Transition the service to the M0_RST_STOPPING state and invoke its
+   rso_prepare_to_stop() method if it is defined.
+   @pre service != NULL
+   @pre service->rs_state == M0_RST_STARTED
+   @post service->rs_state == M0_RST_STOPPING
+ */
+M0_INTERNAL void m0_reqh_service_prepare_to_stop(struct m0_reqh_service
+						 *service);
+
+/**
    Stops a particular service.
    Unregisters a service from the request handler and transitions service to
    M0_RST_STOPPED state.
@@ -422,7 +444,8 @@ M0_INTERNAL int m0_reqh_service_start(struct m0_reqh_service *service);
    @pre service != NULL
 
    @see struct m0_reqh_service_ops
-   @see cs_service_fini()
+   @see m0_reqh_service_prepare_to_stop()
+   @see m0_reqh_services_terminate()
  */
 M0_INTERNAL void m0_reqh_service_stop(struct m0_reqh_service *service);
 
@@ -451,7 +474,7 @@ M0_INTERNAL void m0_reqh_service_init(struct m0_reqh_service *service,
    @pre service != NULL && service->rs_state == M0_RST_STOPPED
 
    @see struct m0_reqh_service_ops
-   @see cs_service_fini()
+   @see m0_reqh_services_terminate()
  */
 M0_INTERNAL void m0_reqh_service_fini(struct m0_reqh_service *service);
 
diff --git a/sns/repair/ut/repair.c b/sns/repair/ut/repair.c
index 8ed6a19..6661b8b 100644
--- a/sns/repair/ut/repair.c
+++ b/sns/repair/ut/repair.c
@@ -1,6 +1,6 @@
 /* -*- C -*- */
 /*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
  *
  * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
  * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
diff --git a/sns/repair/ut/storage.c b/sns/repair/ut/storage.c
index df56960..e9f746e 100644
--- a/sns/repair/ut/storage.c
+++ b/sns/repair/ut/storage.c
@@ -1,6 +1,6 @@
 /* -*- C -*- */
 /*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
  *
  * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
  * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
@@ -225,7 +225,7 @@ void write_post(void)
 	 * Wait until all the foms in the request handler locality runq are
 	 * processed. This is required for further validity checks.
 	 */
-	m0_reqh_shutdown_wait(reqh);
+	m0_reqh_fom_domain_idle_wait(reqh);
 }
 
 const struct m0_cm_cp_ops read_cp_dummy_ops = {
@@ -265,7 +265,7 @@ static void read_post(void)
          * Wait until all the foms in the request handler locality runq are
          * processed. This is required for further validity checks.
          */
-	m0_reqh_shutdown_wait(reqh);
+	m0_reqh_fom_domain_idle_wait(reqh);
 }
 
 static void test_cp_write_read(void)
diff --git a/sns/repair/ut/xform.c b/sns/repair/ut/xform.c
index 93146d6..ec2e17c 100644
--- a/sns/repair/ut/xform.c
+++ b/sns/repair/ut/xform.c
@@ -1,6 +1,6 @@
 /* -*- C -*- */
 /*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
  *
  * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
  * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
@@ -161,7 +161,7 @@ static void test_single_cp(void)
 	 * Wait until all the foms in the request handler locality runq are
 	 * processed. This is required for further validity checks.
 	 */
-	m0_reqh_shutdown_wait(reqh);
+	m0_reqh_fom_domain_idle_wait(reqh);
 
 	/*
 	 * These asserts ensure that the single copy packet has been treated
@@ -197,7 +197,7 @@ static void test_multiple_cp(void)
 	 * Wait until the fom in the request handler locality runq is
 	 * processed. This is required for further validity checks.
 	 */
-	m0_reqh_shutdown_wait(reqh);
+	m0_reqh_fom_domain_idle_wait(reqh);
 
 	/*
 	 * These asserts ensure that all the copy packets have been collected
-- 
1.8.3.2

