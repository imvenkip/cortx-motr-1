From 27c7aa538962e305833d81f4aceb23196e6e3f51 Mon Sep 17 00:00:00 2001
From: Carl Braganza <carl_braganza@xyratex.com>
Date: Thu, 10 Jan 2013 20:26:02 -0800
Subject: [PATCH 4/6] Use an AST to cancel the FOM timer and make the FOM stop
 itself when the service prepare_to_stop method is called. Removed the very
 short timer.

---
 addb/user_space/addb_pfom.c | 70 +++++++++++++++++++++++++++++----------------
 addb/user_space/addb_svc.c  |  6 +++-
 addb/user_space/addb_svc.h  |  4 ++-
 addb/ut/addb_ut_svc.c       | 40 ++++++++++++++++++++------
 4 files changed, 85 insertions(+), 35 deletions(-)

diff --git a/addb/user_space/addb_pfom.c b/addb/user_space/addb_pfom.c
index b1231d2..0587077 100644
--- a/addb/user_space/addb_pfom.c
+++ b/addb/user_space/addb_pfom.c
@@ -1,6 +1,6 @@
 /* -*- C -*- */
 /*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
  *
  * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
  * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
@@ -67,6 +67,8 @@
    The posting fom is launched only if the ::addb_svc_start_pfom global
    permits.  This control is provided for unit testing.
 
+   The FOM is terminated by invoking addb_pfom_stop().  The subroutine
+   posts an AST to cancel its timer and force it to stop itself.
  */
 
 /* This file is designed to be included by addb/addb.c */
@@ -149,14 +151,6 @@ static struct m0_fom_type addb_pfom_type;
 /** UT hook to track a singleton FOM */
 static bool the_addb_pfom_started;
 
-/**
-   The statistics posting FOM's normal clock tick.
-   The value is relatively low to make the FOM responsive during process
-   termination.  This is because the m0_reqh_shutdown_wait() sub has no
-   mechanism to notify long-lived FOMs to quit.
- */
-static m0_time_t addb_pfom_max_sleep_period = M0_MKTIME(1, 0);
-
 enum {
 	/**
 	   Tolerance on the posting epoch when re-computing the next epoch.
@@ -179,12 +173,14 @@ static void addb_pfom_fo_fini(struct m0_fom *fom)
 						   as_pfom);
 	struct m0_reqh_service *rsvc = &svc->as_reqhs;
 
+	M0_ENTRY();
+
 	m0_fom_fini(fom);
 	m0_fom_timeout_fini(&pfom->pf_timeout);
 	addb_post_fom_bob_fini(pfom);
 
 	/* Mustn't free as the fom is embedded in the service object, but
-	 * notify waiters.
+	 * notify UT waiters.
 	 */
 	m0_mutex_lock(&rsvc->rs_mutex);
 	pfom->pf_running = false;
@@ -205,12 +201,19 @@ static int addb_pfom_fo_tick(struct m0_fom *fom)
 	struct addb_svc        *svc = container_of(pfom, struct addb_svc,
 						   as_pfom);
 	struct m0_reqh         *reqh = svc->as_reqhs.rs_reqh;
+	struct m0_reqh_service *rsvc = &svc->as_reqhs;
 	int                     rc = M0_FSO_AGAIN;
 	m0_time_t               now;
 
+	M0_ENTRY();
+
 	switch (m0_fom_phase(fom)) {
 	case ADDB_PFOM_PHASE_INIT:
+		M0_LOG(M0_DEBUG, "init");
+		m0_mutex_lock(&rsvc->rs_mutex);
 		the_addb_pfom_started = true;
+		m0_cond_broadcast(&svc->as_cond, &rsvc->rs_mutex); /* for UT */
+		m0_mutex_unlock(&rsvc->rs_mutex);
 		m0_fom_phase_set(fom, ADDB_PFOM_PHASE_CTO);
 		break;
 	case ADDB_PFOM_PHASE_CTO:
@@ -224,11 +227,12 @@ static int addb_pfom_fo_tick(struct m0_fom *fom)
 		break;
 	case ADDB_PFOM_PHASE_SLEEP:
 		if (pfom->pf_timeout.to_cb.fc_fom != NULL) {
+			M0_LOG(M0_DEBUG, "timeout reset");
 			m0_fom_timeout_cancel(&pfom->pf_timeout);
 			m0_fom_timeout_fini(&pfom->pf_timeout);
 			m0_fom_timeout_init(&pfom->pf_timeout);
 		}
-		if (pfom->pf_shutdown || reqh->rh_shutdown) {
+		if (pfom->pf_shutdown) {
 			M0_LOG(M0_DEBUG, "fini");
 			m0_fom_phase_set(fom, ADDB_PFOM_PHASE_FINI);
 			rc = M0_FSO_WAIT;
@@ -239,9 +243,9 @@ static int addb_pfom_fo_tick(struct m0_fom *fom)
 			m0_fom_phase_set(fom, ADDB_PFOM_PHASE_POST);
 			break;
 		}
-		m0_fom_timeout_wait_on(&pfom->pf_timeout, &pfom->pf_fom, now +
-				       min64u(pfom->pf_next_post - now,
-					      addb_pfom_max_sleep_period));
+		m0_fom_timeout_wait_on(&pfom->pf_timeout, &pfom->pf_fom,
+				       pfom->pf_next_post);
+		M0_LOG(M0_DEBUG, "wait");
 		rc = M0_FSO_WAIT;
 		break;
 	case ADDB_PFOM_PHASE_POST:
@@ -256,7 +260,7 @@ static int addb_pfom_fo_tick(struct m0_fom *fom)
 		M0_IMPOSSIBLE("Phasors were not on stun!");
 	}
 
-	return rc;
+	M0_RETURN(rc);
 }
 
 static void addb_pfom_fo_addb_init(struct m0_fom *fom, struct m0_addb_mc *mc)
@@ -299,6 +303,7 @@ static void addb_pfom_start(struct addb_svc *svc)
 	struct m0_fom        *fom = &pfom->pf_fom;
 	struct m0_reqh       *reqh = svc->as_reqhs.rs_reqh;
 
+	M0_ENTRY();
 	M0_PRE(addb_svc_invariant(svc));
 
 	m0_rwlock_read_lock(&reqh->rh_rwlock);
@@ -322,12 +327,29 @@ static void addb_pfom_start(struct addb_svc *svc)
 }
 
 /**
-   Stops the statistics posting FOM. Returns only after the FOM has
-   terminated.  Uses the service mutex internally.
+   AST callback to safely stop the FOM.
+ */
+static void addb_pfom_stop_cb(struct m0_sm_group *grp, struct m0_sm_ast *ast)
+{
+        struct addb_post_fom *pfom = bob_of(ast, struct addb_post_fom,
+					    pf_ast, &addb_pfom_bob);
+
+	M0_LOG(M0_DEBUG, "pfom_stop_cb: %d\n", (int)pfom->pf_running);
+	if (pfom->pf_running) {
+		m0_fom_timeout_cancel(&pfom->pf_timeout);
+		pfom->pf_shutdown = true;
+		m0_fom_ready(&pfom->pf_fom);
+	}
+}
+
+/**
+   Initiates the termination of the statistics posting FOM. Does not block.
+   Uses the service mutex internally.
  */
 static void addb_pfom_stop(struct addb_svc *svc)
 {
         struct addb_post_fom   *pfom = &svc->as_pfom;
+	struct m0_fom          *fom  = &pfom->pf_fom;
 	struct m0_reqh_service *rsvc = &svc->as_reqhs;
 
 	M0_ENTRY();
@@ -338,17 +360,17 @@ static void addb_pfom_stop(struct addb_svc *svc)
 	m0_mutex_lock(&rsvc->rs_mutex);
 	if (pfom->pf_running) {
 		M0_ASSERT(addb_pfom_invariant(pfom));
-		pfom->pf_shutdown = true;
 
-		/* The fom wakes up frequently to check for shutdown */
+		M0_LOG(M0_DEBUG, "posting stop ast");
+		pfom->pf_ast.sa_cb = addb_pfom_stop_cb;
+		m0_sm_ast_post(&fom->fo_loc->fl_group, &pfom->pf_ast);
 
-		/* block until termination */
-		while (pfom->pf_running) {
-			m0_cond_wait(&svc->as_cond, &rsvc->rs_mutex);
-		}
+		/* We could wait for termination on pf_running but
+		 * there is no need to as the request handler will
+		 * wait for FOM termination.
+		 */
 	}
 	m0_mutex_unlock(&rsvc->rs_mutex);
-	M0_POST(!addb_pfom_invariant(pfom));
 }
 
 /**
diff --git a/addb/user_space/addb_svc.c b/addb/user_space/addb_svc.c
index 9d5b9f3..9ba65a8 100644
--- a/addb/user_space/addb_svc.c
+++ b/addb/user_space/addb_svc.c
@@ -1,6 +1,6 @@
 /* -*- C -*- */
 /*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
  *
  * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
  * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
@@ -99,6 +99,7 @@ static int addb_svc_rso_start(struct m0_reqh_service *service)
 {
 	struct addb_svc *svc;
 
+	M0_ENTRY();
 	M0_PRE(service->rs_state == M0_RST_STARTING);
 	svc = bob_of(service, struct addb_svc, as_reqhs, &addb_svc_bob);
 	if (addb_svc_start_pfom)
@@ -114,6 +115,7 @@ static void addb_svc_rso_prepare_to_stop(struct m0_reqh_service *service)
 {
 	struct addb_svc *svc;
 
+	M0_ENTRY();
 	M0_PRE(service->rs_state == M0_RST_STARTED);
 	svc = bob_of(service, struct addb_svc, as_reqhs, &addb_svc_bob);
 	if (addb_svc_start_pfom)
@@ -125,6 +127,7 @@ static void addb_svc_rso_prepare_to_stop(struct m0_reqh_service *service)
  */
 static void addb_svc_rso_stop(struct m0_reqh_service *service)
 {
+	M0_ENTRY();
 	M0_PRE(service->rs_state == M0_RST_STOPPING);
 }
 
@@ -135,6 +138,7 @@ static void addb_svc_rso_fini(struct m0_reqh_service *service)
 {
 	struct addb_svc *svc;
 
+	M0_ENTRY();
 	M0_PRE(M0_IN(service->rs_state, (M0_RST_STOPPED, M0_RST_FAILED)));
 	svc = bob_of(service, struct addb_svc, as_reqhs, &addb_svc_bob);
 	m0_cond_fini(&svc->as_cond);
diff --git a/addb/user_space/addb_svc.h b/addb/user_space/addb_svc.h
index a8df705..216e929 100644
--- a/addb/user_space/addb_svc.h
+++ b/addb/user_space/addb_svc.h
@@ -1,6 +1,6 @@
 /* -*- C -*- */
 /*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
  *
  * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
  * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
@@ -58,6 +58,8 @@ struct addb_post_fom {
 	bool                  pf_shutdown;
 	/** Running flag.  Used to synchronize termination. */
 	bool                  pf_running;
+	/** trap used to get into the locality to interact with the fom */
+	struct m0_sm_ast      pf_ast;
 	/** The FOM timer */
 	struct m0_fom_timeout pf_timeout;
 	/** Embedded FOM object. */
diff --git a/addb/ut/addb_ut_svc.c b/addb/ut/addb_ut_svc.c
index 72d92d5..fc4096b 100644
--- a/addb/ut/addb_ut_svc.c
+++ b/addb/ut/addb_ut_svc.c
@@ -1,6 +1,6 @@
 /* -*- C -*- */
 /*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
  *
  * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
  * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
@@ -111,16 +111,36 @@ void addb_ut_svc_test(void)
 	M0_UT_ASSERT(addb_ut_svc_rspa_called == 0);
 	M0_UT_ASSERT(server_start() == 0);
 	M0_UT_ASSERT(the_addb_svc != NULL);
-	m0_nanosleep(addb_pfom_max_sleep_period / 10, NULL);
 	addb_ut_svc_service_ops = *the_addb_svc->as_reqhs.rs_ops;
 	addb_ut_svc_service_ops.rso_stats_post_addb = addb_ut_svc_rspa;
 	the_addb_svc->as_reqhs.rs_ops = &addb_ut_svc_service_ops;
 	pfom = &the_addb_svc->as_pfom;
 	fom = &pfom->pf_fom;
-	m0_nanosleep(addb_pfom_max_sleep_period * 3, NULL);
-	M0_UT_ASSERT(the_addb_pfom_started);
-	M0_UT_ASSERT(fom->fo_transitions > 4);
+
+	/* wait for the fom to start */
+	m0_mutex_lock(&the_addb_svc->as_reqhs.rs_mutex);
+	while (!the_addb_pfom_started)
+		m0_cond_wait(&the_addb_svc->as_cond,
+			     &the_addb_svc->as_reqhs.rs_mutex);
+	m0_mutex_unlock(&the_addb_svc->as_reqhs.rs_mutex);
+
+	/* explicitly terminate the fom */
 	addb_pfom_stop(the_addb_svc);
+	m0_reqh_fom_domain_idle_wait(the_addb_svc->as_reqhs.rs_reqh);
+	M0_UT_ASSERT(!the_addb_pfom_started);
+
+	/* restart the fom */
+	M0_SET0(pfom);
+	addb_pfom_start(the_addb_svc);
+
+	/* wait for the fom to start */
+	m0_mutex_lock(&the_addb_svc->as_reqhs.rs_mutex);
+	while (!the_addb_pfom_started)
+		m0_cond_wait(&the_addb_svc->as_cond,
+			     &the_addb_svc->as_reqhs.rs_mutex);
+	m0_mutex_unlock(&the_addb_svc->as_reqhs.rs_mutex);
+
+	/* terminate with service */
 	server_stop();
 	M0_UT_ASSERT(!the_addb_pfom_started);
 	M0_UT_ASSERT(the_addb_svc == NULL);
@@ -132,7 +152,9 @@ void addb_ut_svc_test(void)
 	 *       Check that stopping the request handler terminates the FOM.
 	 */
 	saved_period = addb_pfom_period;
-	addb_pfom_period = addb_pfom_max_sleep_period / 50;
+#undef MS
+#define MS(ms) (ms) * 1000000ULL
+	addb_pfom_period = MS(10);
 	M0_UT_ASSERT(!the_addb_pfom_started);
 	M0_UT_ASSERT(addb_ut_svc_rspa_called == 0);
 	M0_UT_ASSERT(server_start() == 0);
@@ -142,13 +164,13 @@ void addb_ut_svc_test(void)
 	the_addb_svc->as_reqhs.rs_ops = &addb_ut_svc_service_ops;
 	pfom = &the_addb_svc->as_pfom;
 	fom = &pfom->pf_fom;
-	m0_nanosleep(addb_pfom_max_sleep_period / 10, NULL);
+	m0_nanosleep(MS(210), NULL);
 	M0_UT_ASSERT(the_addb_pfom_started);
-	M0_UT_ASSERT(addb_ut_svc_rspa_called != 0);
-	M0_ASSERT(fom->fo_transitions > 4 * addb_ut_svc_rspa_called);
+	M0_UT_ASSERT(addb_ut_svc_rspa_called >= 19);
 	server_stop();
 	M0_UT_ASSERT(!the_addb_pfom_started);
 	M0_UT_ASSERT(the_addb_svc == NULL);
+#undef MS
 	addb_pfom_period = saved_period;
 }
 
-- 
1.8.3.2

