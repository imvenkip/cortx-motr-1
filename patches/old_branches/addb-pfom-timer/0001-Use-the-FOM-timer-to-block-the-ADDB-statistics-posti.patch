From 3e7ba3ceb503f4cc2f329d834ed26749699b210e Mon Sep 17 00:00:00 2001
From: Carl Braganza <carl_braganza@xyratex.com>
Date: Tue, 8 Jan 2013 20:13:16 -0800
Subject: [PATCH 1/6] Use the FOM timer to block the ADDB statistics posting
 FOM. Posting epoch computation ignores time taken to post stats. Updated UTs
 accordingly.

---
 addb/user_space/addb_pfom.c | 71 +++++++++++++++++++++++++++++++--------------
 addb/user_space/addb_svc.h  | 18 +++++++-----
 addb/ut/addb_ut_svc.c       | 26 ++++++++---------
 3 files changed, 72 insertions(+), 43 deletions(-)

diff --git a/addb/user_space/addb_pfom.c b/addb/user_space/addb_pfom.c
index 909f168..b1231d2 100644
--- a/addb/user_space/addb_pfom.c
+++ b/addb/user_space/addb_pfom.c
@@ -42,16 +42,21 @@
    }
    @enddot
    - The FOM starts in the Init phase then transitions to the ComputeTimeout
-   phase.
+   phase.  It forces the next phase to compute the next posting epoch based
+   on the current time.
    - In the ComputeTimeout phase the FOM calculates the absolute time of the
-   next posting epoch.  It then transitions to the Sleep phase.
+   next posting epoch.  The next epoch is computed relative to the previous
+   epoch so as to reduce the impact of the actual time it takes to post the
+   statistics.  However, if the current time has already advanced significantly
+   toward the next epoch, then it will compute the next epoch against current
+   time.  The latter computation is forced on the first iteration, but could
+   conceivably happen at run time because a ready FOM is subject to scheduling
+   delays.  The FOM transitions to the Sleep phase next.
    - In the Sleep phase, it checks to see if the FOM has been shutdown, and
    if so, will transition to the Fini phase.  If not shutdown, it checks to
    see if the current time exceeds the next posting epoch, and if so will
    transition to the Post phase.  Otherwise it will block the FOM until
    the next posting epoch.
-      - Currently using the FOM thread itself to block on as timer based
-        solutions fail.
    - The Post phase will invoke m0_reqh_stats_post_addb() to post pending
    statistics.  It will then transition to the ComputeTimeout phase to repeat
    the cycle.
@@ -144,6 +149,23 @@ static struct m0_fom_type addb_pfom_type;
 /** UT hook to track a singleton FOM */
 static bool the_addb_pfom_started;
 
+/**
+   The statistics posting FOM's normal clock tick.
+   The value is relatively low to make the FOM responsive during process
+   termination.  This is because the m0_reqh_shutdown_wait() sub has no
+   mechanism to notify long-lived FOMs to quit.
+ */
+static m0_time_t addb_pfom_max_sleep_period = M0_MKTIME(1, 0);
+
+enum {
+	/**
+	   Tolerance on the posting epoch when re-computing the next epoch.
+	   The number is expressed as a fraction of the posting period.  The
+	   greater the number the narrower the tolerance.
+	 */
+	M0_ADDB_PFOM_PERIOD_FRAC_TOLERANCE = 10,
+};
+
 static bool addb_pfom_invariant(const struct addb_post_fom *pfom)
 {
 	return addb_post_fom_bob_check(pfom);
@@ -158,6 +180,7 @@ static void addb_pfom_fo_fini(struct m0_fom *fom)
 	struct m0_reqh_service *rsvc = &svc->as_reqhs;
 
 	m0_fom_fini(fom);
+	m0_fom_timeout_fini(&pfom->pf_timeout);
 	addb_post_fom_bob_fini(pfom);
 
 	/* Mustn't free as the fom is embedded in the service object, but
@@ -181,9 +204,9 @@ static int addb_pfom_fo_tick(struct m0_fom *fom)
 					      &addb_pfom_bob);
 	struct addb_svc        *svc = container_of(pfom, struct addb_svc,
 						   as_pfom);
-	struct m0_reqh_service *rsvc = &svc->as_reqhs;
 	struct m0_reqh         *reqh = svc->as_reqhs.rs_reqh;
 	int                     rc = M0_FSO_AGAIN;
+	m0_time_t               now;
 
 	switch (m0_fom_phase(fom)) {
 	case ADDB_PFOM_PHASE_INIT:
@@ -192,31 +215,34 @@ static int addb_pfom_fo_tick(struct m0_fom *fom)
 		break;
 	case ADDB_PFOM_PHASE_CTO:
 		M0_LOG(M0_DEBUG, "cto");
-		pfom->pf_next_post = m0_time_now() + pfom->pf_period;
+		now = m0_time_now();
+		if (now < pfom->pf_next_post + pfom->pf_tolerance)
+			pfom->pf_next_post += pfom->pf_period;
+		else
+			pfom->pf_next_post = now + pfom->pf_period;
 		m0_fom_phase_set(fom, ADDB_PFOM_PHASE_SLEEP);
 		break;
 	case ADDB_PFOM_PHASE_SLEEP:
+		if (pfom->pf_timeout.to_cb.fc_fom != NULL) {
+			m0_fom_timeout_cancel(&pfom->pf_timeout);
+			m0_fom_timeout_fini(&pfom->pf_timeout);
+			m0_fom_timeout_init(&pfom->pf_timeout);
+		}
 		if (pfom->pf_shutdown || reqh->rh_shutdown) {
 			M0_LOG(M0_DEBUG, "fini");
 			m0_fom_phase_set(fom, ADDB_PFOM_PHASE_FINI);
 			rc = M0_FSO_WAIT;
 			break;
 		}
-		if (m0_time_now() >= pfom->pf_next_post) {
+		now = m0_time_now();
+		if (now >= pfom->pf_next_post) {
 			m0_fom_phase_set(fom, ADDB_PFOM_PHASE_POST);
 			break;
 		}
-		m0_mutex_lock(&rsvc->rs_mutex);
-		pfom->pf_timer_started = true;
-		/** @todo Replace with m0_fom_timeout_wait_on() */
-		m0_fom_block_enter(fom);
-		/* Don't sleep for long time to not hang on process exit */
-		m0_cond_timedwait(&svc->as_cond, &rsvc->rs_mutex,
-		                  m0_time_now() +
-		                  min64u(pfom->pf_period, M0_MKTIME(1, 0)));
-		m0_fom_block_leave(fom);
-		pfom->pf_timer_started = false;
-		m0_mutex_unlock(&rsvc->rs_mutex);
+		m0_fom_timeout_wait_on(&pfom->pf_timeout, &pfom->pf_fom, now +
+				       min64u(pfom->pf_next_post - now,
+					      addb_pfom_max_sleep_period));
+		rc = M0_FSO_WAIT;
 		break;
 	case ADDB_PFOM_PHASE_POST:
 		M0_LOG(M0_DEBUG, "post");
@@ -282,7 +308,11 @@ static void addb_pfom_start(struct addb_svc *svc)
 
 	m0_fom_init(fom, &addb_pfom_type, &addb_pfom_ops, NULL, NULL,
 		    reqh, svc->as_reqhs.rs_type);
+	m0_fom_timeout_init(&pfom->pf_timeout);
 	pfom->pf_period = addb_pfom_period;
+	pfom->pf_tolerance = pfom->pf_period
+		/ M0_ADDB_PFOM_PERIOD_FRAC_TOLERANCE;
+	pfom->pf_next_post = 0; /* force the first timeout calculation */
 	pfom->pf_running = true;
 
         M0_PRE(m0_fom_phase(fom) == ADDB_PFOM_PHASE_INIT);
@@ -310,10 +340,7 @@ static void addb_pfom_stop(struct addb_svc *svc)
 		M0_ASSERT(addb_pfom_invariant(pfom));
 		pfom->pf_shutdown = true;
 
-		M0_LOG(M0_DEBUG, "wake up the fom");
-		/* wake up the fom */
-		if (pfom->pf_timer_started)
-			m0_cond_broadcast(&svc->as_cond, &rsvc->rs_mutex);
+		/* The fom wakes up frequently to check for shutdown */
 
 		/* block until termination */
 		while (pfom->pf_running) {
diff --git a/addb/user_space/addb_svc.h b/addb/user_space/addb_svc.h
index b30d275..a8df705 100644
--- a/addb/user_space/addb_svc.h
+++ b/addb/user_space/addb_svc.h
@@ -47,19 +47,21 @@ extern struct m0_reqh_service_type m0_addb_svc_type;
    ADDB statistics posting FOM
  */
 struct addb_post_fom {
-	uint64_t      pf_magic;
+	uint64_t              pf_magic;
 	/** Periodicity of the statistics post. */
-	m0_time_t            pf_period;
+	m0_time_t             pf_period;
+	/** Tolerance limit in epoch calculation */
+	m0_time_t             pf_tolerance;
 	/** Next post time. */
-	m0_time_t            pf_next_post;
+	m0_time_t             pf_next_post;
 	/** Shutdown request flag. */
-	bool                 pf_shutdown;
+	bool                  pf_shutdown;
 	/** Running flag.  Used to synchronize termination. */
-	bool                 pf_running;
-	/** Timer indicator */
-	bool                 pf_timer_started;
+	bool                  pf_running;
+	/** The FOM timer */
+	struct m0_fom_timeout pf_timeout;
 	/** Embedded FOM object. */
-	struct m0_fom        pf_fom;
+	struct m0_fom         pf_fom;
 };
 
 /**
diff --git a/addb/ut/addb_ut_svc.c b/addb/ut/addb_ut_svc.c
index 6ca943c..72d92d5 100644
--- a/addb/ut/addb_ut_svc.c
+++ b/addb/ut/addb_ut_svc.c
@@ -103,35 +103,36 @@ void addb_ut_svc_test(void)
 
 	/*
 	 * Test: Run the posting fom and test that we can stop it.
+	 *       Also test that it loops on the minimum sleep period
+	 *       without doing a post.
 	 */
 	addb_svc_start_pfom = true;
 	M0_UT_ASSERT(!the_addb_pfom_started);
+	M0_UT_ASSERT(addb_ut_svc_rspa_called == 0);
 	M0_UT_ASSERT(server_start() == 0);
 	M0_UT_ASSERT(the_addb_svc != NULL);
+	m0_nanosleep(addb_pfom_max_sleep_period / 10, NULL);
+	addb_ut_svc_service_ops = *the_addb_svc->as_reqhs.rs_ops;
+	addb_ut_svc_service_ops.rso_stats_post_addb = addb_ut_svc_rspa;
+	the_addb_svc->as_reqhs.rs_ops = &addb_ut_svc_service_ops;
 	pfom = &the_addb_svc->as_pfom;
 	fom = &pfom->pf_fom;
-	m0_nanosleep(M0_MKTIME(1,0), NULL);
+	m0_nanosleep(addb_pfom_max_sleep_period * 3, NULL);
 	M0_UT_ASSERT(the_addb_pfom_started);
-	m0_mutex_lock(&the_addb_svc->as_reqhs.rs_mutex);
-	M0_UT_ASSERT(pfom->pf_timer_started);
-	m0_mutex_unlock(&the_addb_svc->as_reqhs.rs_mutex);
+	M0_UT_ASSERT(fom->fo_transitions > 4);
 	addb_pfom_stop(the_addb_svc);
-	m0_mutex_lock(&the_addb_svc->as_reqhs.rs_mutex);
-	M0_UT_ASSERT(!pfom->pf_timer_started);
-	m0_mutex_unlock(&the_addb_svc->as_reqhs.rs_mutex);
 	server_stop();
 	M0_UT_ASSERT(!the_addb_pfom_started);
 	M0_UT_ASSERT(the_addb_svc == NULL);
+	M0_UT_ASSERT(addb_ut_svc_rspa_called == 0);
 
 	/*
 	 * Test: Adjust the period of the posting fom and check that it
 	 *       "ticks".
 	 *       Check that stopping the request handler terminates the FOM.
 	 */
-#undef MS
-#define MS(n) (n) * 1000000ULL
 	saved_period = addb_pfom_period;
-	addb_pfom_period = MS(10);
+	addb_pfom_period = addb_pfom_max_sleep_period / 50;
 	M0_UT_ASSERT(!the_addb_pfom_started);
 	M0_UT_ASSERT(addb_ut_svc_rspa_called == 0);
 	M0_UT_ASSERT(server_start() == 0);
@@ -141,15 +142,14 @@ void addb_ut_svc_test(void)
 	the_addb_svc->as_reqhs.rs_ops = &addb_ut_svc_service_ops;
 	pfom = &the_addb_svc->as_pfom;
 	fom = &pfom->pf_fom;
-	m0_nanosleep(MS(200), NULL);
+	m0_nanosleep(addb_pfom_max_sleep_period / 10, NULL);
 	M0_UT_ASSERT(the_addb_pfom_started);
-	M0_ASSERT(fom->fo_transitions > 10);
 	M0_UT_ASSERT(addb_ut_svc_rspa_called != 0);
+	M0_ASSERT(fom->fo_transitions > 4 * addb_ut_svc_rspa_called);
 	server_stop();
 	M0_UT_ASSERT(!the_addb_pfom_started);
 	M0_UT_ASSERT(the_addb_svc == NULL);
 	addb_pfom_period = saved_period;
-#undef MS
 }
 
 
-- 
1.8.3.2

