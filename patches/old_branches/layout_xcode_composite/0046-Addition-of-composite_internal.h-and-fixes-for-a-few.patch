From 4041fe437f10bedbf1eff4fa93f435104fc8c5c1 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Fri, 11 Jan 2013 14:48:58 +0530
Subject: [PATCH 046/157] Addition of composite_internal.h and fixes for a few
 style issues

---
 layout/composite.c          |  55 ++++++++++++-----------
 layout/composite.h          | 104 +++++++++++++++-----------------------------
 layout/composite_internal.h |  97 +++++++++++++++++++++++++++++++++++++++++
 layout/layout.c             |  49 ++++++++++-----------
 layout/layout.h             |  25 +++++------
 layout/layout_internal.h    |  31 +++++++------
 layout/ut/composite.c       |  37 ++++++++--------
 mero/magic.h                |  18 ++++----
 8 files changed, 240 insertions(+), 176 deletions(-)
 create mode 100644 layout/composite_internal.h

diff --git a/layout/composite.c b/layout/composite.c
index 92b5991..7da6ac5 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -36,6 +36,7 @@
 
 #include "layout/layout_internal.h"
 #include "layout/composite.h"
+#include "layout/composite_internal.h"
 
 extern struct m0_addb_ctx layout_global_ctx;
 
@@ -74,7 +75,8 @@ struct composite_schema_data {
 /**
  * layer_sublayout table.
  *
- * @note These two structures needs to be maintained as 8 bytes aligned.
+ * @note These two key and rec structures need to be maintained as 8 bytes
+ * aligned.
  */
 struct layer_sublayout_key {
 	/** Layout id for the composite layout. */
@@ -94,8 +96,6 @@ struct layer_sublayout_rec {
 };
 M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct layer_sublayout_rec)));
 
-// todo M0_ADDB_EV_DECLARE(comp_ext_op_fail, M0_ADDB_CALL);
-
 /**
  * Compare layer_sublayout table keys.
  * This is a 3WAY comparison.
@@ -110,7 +110,7 @@ static int cl_key_cmp(struct m0_table *table,
 		M0_3WAY(k0->lrsmk_layer_idx, k1->lrsmk_layer_idx);
 }
 
-/** table_ops for layer_sublayout table. */
+/** table_ops for the layer_sublayout table. */
 static const struct m0_table_ops composite_table_ops = {
 	.to = {
 		[TO_KEY] = {
@@ -142,15 +142,18 @@ struct layout_prefix {
 	uint32_t lp_filler;
 };
 
-M0_TL_DESCR_DEFINE(m0_layer, "composite-layer-list", M0_INTERNAL,
-		   struct m0_composite_layer, clr_list_linkage, clr_magic,
-		   M0_LAYOUT_COMP_SUBL_MAGIC, M0_LAYOUT_COMP_SUBL_HEAD_MAGIC);
-M0_TL_DEFINE(m0_layer, M0_INTERNAL, struct m0_composite_layer);
+M0_TL_DESCR_DEFINE(comp_layer, "composite-layer-list",
+		   /* global */, struct m0_composite_layer,
+		   clr_list_linkage, clr_magic,
+		   M0_LAYOUT_COMPOSITE_LAYER_MAGIC,
+		   LAYER_LIST_HEAD_MAGIC);
+M0_TL_DEFINE(comp_layer, /* global */, struct m0_composite_layer);
 
 M0_TL_DESCR_DEFINE(m0_layer_extent, "composite-layer-extent-list",
 		   M0_INTERNAL, struct m0_composite_layer_extent,
 		   cle_list_linkage, cle_magic,
-		   M0_LAYOUT_EXTENT_MAGIC, M0_LAYOUT_EXTENT_HEAD_MAGIC);
+		   M0_LAYOUT_COMPOSITE_LAYER_EXTENT_MAGIC,
+		   M0_LAYOUT_COMPOSITE_LAYER_EXTENT_HEAD_MAGIC);
 M0_TL_DEFINE(m0_layer_extent, M0_INTERNAL, struct m0_composite_layer_extent);
 
 static bool composite_allocated_invariant(const struct m0_composite_layout *cl)
@@ -160,7 +163,7 @@ static bool composite_allocated_invariant(const struct m0_composite_layout *cl)
 		m0_layout__allocated_invariant(&cl->cl_base) &&
 		m0_mutex_is_locked(&cl->cl_base.l_lock) &&
 		cl->cl_layers != NULL &&
-		m0_layer_tlist_is_empty(cl->cl_layers) &&
+		comp_layer_tlist_is_empty(cl->cl_layers) &&
 		cl->cl_layers_nr == 0;
 }
 
@@ -174,8 +177,8 @@ static bool composite_invariant(const struct m0_composite_layout *cl)
 		m0_layout__invariant(&cl->cl_base) &&
 		cl->cl_layers != NULL &&
 		cl->cl_layers_nr > 0 &&
-		cl->cl_layers_nr == m0_layer_tlist_length(cl->cl_layers) &&
-		m0_tl_forall(m0_layer, layer, cl->cl_layers,
+		cl->cl_layers_nr == comp_layer_tlist_length(cl->cl_layers) &&
+		m0_tl_forall(comp_layer, layer, cl->cl_layers,
 			     m0_layout__invariant(layer->clr_l) &&
 			     layer->clr_idx == i++ &&
 			     ergo(layer->clr_idx == 0,
@@ -194,7 +197,7 @@ static bool composite_invariant(const struct m0_composite_layout *cl)
  * involved. This will require changes to UT.
  */
 #if 0
-		m0_tl_forall(m0_layer, layer, cl->cl_layers,
+		m0_tl_forall(comp_layer, layer, cl->cl_layers,
 			     m0_layout__invariant(layer->clr_l) &&
 			     layer->clr_idx == i++ && ...
 			     m0_tl_forall(m0_layer_extent, extent,
@@ -336,7 +339,7 @@ err1_injected:
 #endif
 		return -ENOMEM;
 	}
-	m0_layer_tlist_init(cl->cl_layers);
+	comp_layer_tlist_init(cl->cl_layers);
 
 	m0_layout__init(&cl->cl_base, dom, lid,
 			(struct m0_layout_type *)&m0_composite_layout_type,
@@ -363,7 +366,7 @@ static void composite_delete(struct m0_layout *l)
 	m0_mutex_unlock(&l->l_lock);
 	m0_composite_layout_bob_fini(cl);
 	m0_layout__delete(&cl->cl_base);
-	m0_layer_tlist_fini(cl->cl_layers);
+	comp_layer_tlist_fini(cl->cl_layers);
 	m0_free(cl);
 	M0_LEAVE();
 }
@@ -407,7 +410,7 @@ static int layer_in_memory_add(struct m0_composite_layout *cl,
 	layer->clr_extents = (struct m0_tl *)extlist;
 	m0_layout_get(layer->clr_l);
 	m0_layout_user_count_inc(layer->clr_l);
-	m0_layer_tlink_init_at_tail(layer, cl->cl_layers);
+	comp_layer_tlink_init_at_tail(layer, cl->cl_layers);
 	M0_CNT_INC(cl->cl_layers_nr);
 	*lr = layer;
 	M0_POST(composite_invariant(cl));
@@ -435,7 +438,7 @@ static void layer_in_memory_delete(struct m0_composite_layout *cl,
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer->clr_idx);
 
-	m0_layer_tlink_del_fini(layer);
+	comp_layer_tlink_del_fini(layer);
 	m0_layout_user_count_dec(layer->clr_l);
 	m0_layout_put(layer->clr_l);
 	M0_CNT_DEC(cl->cl_layers_nr);
@@ -526,16 +529,16 @@ static void composite_fini(struct m0_ref *ref)
 	cl = m0_layout_to_cl(l);
 	m0_composite_layout_bob_fini(cl);
 
-	m0_tl_for(m0_layer, cl->cl_layers, layer) {
+	m0_tl_for(comp_layer, cl->cl_layers, layer) {
 		if (layer->clr_idx > 0) /* Except for the zeroth layer. */
 			extlist_free(layer->clr_extents);
 		/* Release the reference acquired by layer_in_memory_add(). */
 		m0_layout_put(layer->clr_l);
-		m0_layer_tlist_del(layer);
-		m0_layer_tlink_fini(layer);
+		comp_layer_tlist_del(layer);
+		comp_layer_tlink_fini(layer);
 		m0_free(layer);
 	} m0_tl_endfor;
-	m0_layer_tlist_fini(cl->cl_layers);
+	comp_layer_tlist_fini(cl->cl_layers);
 	m0_free(cl->cl_layers);
 
 	m0_layout__fini(&cl->cl_base);
@@ -1705,7 +1708,7 @@ static int comp_layout_in_db_add(struct m0_composite_layout *cl,
 	 * Collect the old layout id by referring to the zeroth layer from
 	 * the in-memory layout.
 	 */
-	layer = m0_layer_tlist_head(cl->cl_layers);
+	layer = comp_layer_tlist_head(cl->cl_layers);
 	M0_ASSERT(layer->clr_idx == 0);
 	rc = sublayout_id_in_db_add(cl, layer, tx);
 	M0_LEAVE("lid %llu, rc %d", (unsigned long long)cl->cl_base.l_id, rc);
@@ -1724,7 +1727,7 @@ static int comp_layout_in_db_delete(struct m0_composite_layout *cl,
 	 * A composite layout can be deleted from the DB if and only if none of
 	 * its layers contain any valid extent.
 	 */
-	m0_tl_for(m0_layer, cl->cl_layers, layer) {
+	m0_tl_for(comp_layer, cl->cl_layers, layer) {
 		if (layer->clr_idx > 0) { /* Except for the zeroth layer. */
 			if (!m0_layer_extent_tlist_is_empty(
 							layer->clr_extents)) {
@@ -1739,7 +1742,7 @@ static int comp_layout_in_db_delete(struct m0_composite_layout *cl,
 		}
 	} m0_tl_endfor;
 
-	m0_tl_for(m0_layer, cl->cl_layers, layer) {
+	m0_tl_for(comp_layer, cl->cl_layers, layer) {
 		rc = sublayout_id_in_db_delete(cl, layer, tx);
 		if (rc != 0)
 			break;
@@ -1778,7 +1781,7 @@ static void comp_layout_in_buf_write(const struct m0_composite_layout *cl,
 	 */
 	M0_ASSERT(m0_bufvec_cursor_step(out) >= cl->cl_layers_nr *
 						sizeof lr_header);
-	m0_tl_for(m0_layer, cl->cl_layers, layer) {
+	m0_tl_for(comp_layer, cl->cl_layers, layer) {
 		lr_header.clh_lid = layer->clr_l->l_id;
 		lr_header.clh_idx = layer->clr_idx;
 		lr_header.clh_extents_nr = layer->clr_extents_nr;
@@ -1858,7 +1861,7 @@ static struct m0_composite_layer *layer_find(
 	M0_PRE(layer_idx < cl->cl_layers_nr);
 
 	layer = NULL;
-	m0_tl_for(m0_layer, cl->cl_layers, layer) {
+	m0_tl_for(comp_layer, cl->cl_layers, layer) {
 		if (layer->clr_idx == layer_idx)
 			break;
 	} m0_tl_endfor;
diff --git a/layout/composite.h b/layout/composite.h
index 83b584d..3ef82ee 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -115,8 +115,8 @@ struct m0_composite_layer {
 /**
  * State of an extent.
  *
- * Value of this enum is stored (in memory and in the DB) along with each
- * extent of each layer from every composite layout.
+ * Such state is stored (in memory and in the DB) along with each extent of
+ * each layer from every composite layout.
  *
  * Two back-to-back extents can be merged if and only if their states are the
  * same.
@@ -124,12 +124,10 @@ struct m0_composite_layer {
 enum m0_composite_layer_ext_state {
 	/**
 	 * This value is used to tag an extent that does not belong to the
-	 * layer. For example:
-	 * - an extent [0, M0_BINDEX_MAX + 1) would be with M0_CLRES_INVALID
-	 *   state for 'the zeroth layer that does not contain any extents'.
-	 * - an extent [0, X) would be with M0_CLRES_INVALID state for a
-	 *   layer 'that has a single extent [X, M0_BINDEX_MAX + 1) with
-	 *   M0_CLRES_VALID state, associated with it'.
+	 * layer.
+	 * For example, an extent [0, X) would be with M0_CLRES_INVALID state
+	 * for a layer 'that has a single extent [X, M0_BINDEX_MAX + 1) with
+	 * M0_CLRES_VALID state, associated with it'.
 	 *
 	 * This relates to the implementation of the m0_emap that by default
 	 * has the name-space from 0 to M0_BINDEX_MAX.
@@ -145,7 +143,10 @@ enum m0_composite_layer_ext_state {
 	 * they are associated with.
 	 *
 	 * Any extent added using m0_composite_layer_ext_add(), gets added
-	 * with M0_CLRES_VALID as its default state.
+	 * with M0_CLRES_VALID as its default state. In other words, an extent
+	 * when associated with a layer, starts its lifecycle with this
+	 * state and (after flattening process) ends it with M0_CLRES_INVALID
+	 * state.
 	 */
 	M0_CLRES_VALID,
 
@@ -180,7 +181,7 @@ struct m0_composite_layer_extent {
 	struct m0_tlink  cle_list_linkage;
 };
 
-M0_TL_DECLARE(m0_layer, M0_INTERNAL, struct m0_composite_layer);
+//M0_TL_DECLARE(comp_layer, /* global */, struct m0_composite_layer);
 M0_TL_DECLARE(m0_layer_extent, M0_INTERNAL, struct m0_composite_layer_extent);
 
 /**
@@ -223,6 +224,13 @@ M0_INTERNAL int m0_composite_build(struct m0_layout_domain *dom,
  *
  * @pre The composite layout has been added to the DB.
  *
+ * @param extlist List of the extents to be associated with the layer being
+ * added.
+ *
+ * @note In case the layer is added successfully, the user shall not free the
+ * extlist supplied as an argument. It will be implicitly freed when the
+ * composite layout is finalised by the user.
+ *
  * @todo This API is available only to the user space code. Is that fine?
  */
 M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
@@ -236,6 +244,15 @@ M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
  * offset. Also, returns the state of the extent and the sublayout owned by
  * the specific layer.
  *
+ * @param offset In paramemer to specify the offset to be looked up.
+ * @param layer_idx Out parameter to report back the layer the extent belongs
+ * to.
+ * @param ext Out parameter to report back the extent the offset belongs to.
+ * @param ext_state Out parameter to report back the state of the extent being
+ * returned.
+ * @param sublayout Out parameter to report back the sublayout owned by the
+ * layer being returned.
+ *
  * The lookup starts with the top-most layer and goes upto the first layer.
  * If the extent containing the offset is not found upto the first layer, then
  * (the layer id of) the zeroth layer is returned. Zeroth layer does not
@@ -264,7 +281,7 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
 
 /**
  * Adds an extent to the specified layer of the specified composite layout,
- * by right away updating the extents list in the DB.
+ * by right away updating the extent list in the DB.
  *
  * @todo This API is available only to the user space code. Is that fine?
  *
@@ -284,7 +301,8 @@ M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
  * Updates state of an extent owned by a specified layer of a specified
  * composite layout, by right away updating it in the DB.
  *
- * @pre The exact extent ext exists in the specified layer.
+ * @pre The exact extent supplied as an argument 'ext' exists in the specified
+ * layer.
  *
  * @todo This API is available only to the user space code. Is that fine?
  *
@@ -304,7 +322,7 @@ M0_INTERNAL int m0_composite_layer_ext_state_update(
 
 /**
  * Deletes an extent from the specified layer of the specified composite
- * layout, by right away updating the extents list in the DB.
+ * layout, by right away updating the extent list in the DB.
  *
  * @todo This API is available only to the user space code. Is that fine?
  */
@@ -313,11 +331,10 @@ M0_INTERNAL int m0_composite_layer_ext_delete(struct m0_composite_layout *cl,
 					      const struct m0_ext *ext,
 					      struct m0_db_tx *tx);
 
-M0_INTERNAL struct m0_composite_layout *
-m0_layout_to_cl(const struct m0_layout *l);
-
-M0_INTERNAL struct m0_layout *
-m0_cl_to_layout(struct m0_composite_layout *cl);
+M0_INTERNAL struct m0_composite_layout *m0_layout_to_cl(
+					const struct m0_layout *l);
+M0_INTERNAL struct m0_layout *m0_cl_to_layout(
+					struct m0_composite_layout *cl);
 
 /** Returns m0_composite_instance object given a m0_layout_instance object. */
 M0_INTERNAL struct m0_composite_instance *m0_layout_instance_to_ci(
@@ -325,57 +342,6 @@ M0_INTERNAL struct m0_composite_instance *m0_layout_instance_to_ci(
 
 extern struct m0_layout_type m0_composite_layout_type;
 
-/**
- * Following structures are a part of the internal implementation. They are
- * required to be accessed by the UT as well. Hence, they are placed here in
- * the header file.
- */
-
-/**
- * Structure used to store header information for a composite layout like
- * number of layers in it. It is used in the buffer representation of a
- * composite layout.
- *
- * @note This structure needs to be maintained as 8 bytes aligned.
- */
-struct composite_header {
-	/** Total number of layers in a specific composite layout. */
-	uint32_t ch_layers_nr;
-
-	/** Padding to make the structure 8 bytes aligned. */
-	uint32_t ch_pad;
-};
-M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct composite_header)));
-
-/**
- * Structure used to store header information for 'a layer of a composite
- * layout' like the number of extents in it. It is used in the buffer
- * representation of a composite layout.
- *
- * @note This structure needs to be maintained as 8 bytes aligned.
- */
-struct composite_layer_header {
-	/** Layout id for the layout used for this layer (sublayout). */
-	uint64_t clh_lid;
-
-	/** Index of this layer into its owner composite layout. */
-	uint32_t clh_idx;
-
-	/** Number of extents belonging to this layer. */
-	uint32_t clh_extents_nr;
-
-	/** Padding to make the structure 8 bytes aligned. */
-	uint32_t clh_pad;
-
-	/**
-	 * Payload storing list of extents (struct m0_ext) for a specific
-	 * layer.
-	 */
-	char     clh_extents[0];
-
-};
-M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct composite_layer_header)));
-
 /** @} end group composite */
 
 /* __MERO_LAYOUT_COMPOSITE_H__ */
diff --git a/layout/composite_internal.h b/layout/composite_internal.h
new file mode 100644
index 0000000..fe747ab
--- /dev/null
+++ b/layout/composite_internal.h
@@ -0,0 +1,97 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Trupti Patil <trupti_patil@xyratex.com>
+ * Original creation date: 01/11/2013
+ */
+
+#pragma once
+
+#ifndef __MERO_LAYOUT_COMPOSITE_INTERNAL_H__
+#define __MERO_LAYOUT_COMPOSITE_INTERNAL_H__
+
+#include "layout/layout_addb.h"
+
+/**
+ * @addtogroup layout
+ * @{
+ */
+
+/* import */
+struct m0_composite_layer;
+
+/* export - Required to be accessed by UT. */
+M0_TL_DECLARE(comp_layer, /* global */, struct m0_composite_layer);
+
+/**
+ * Structure used to store header information for a composite layout like
+ * number of layers in it. It is used in the buffer representation of a
+ * composite layout.
+ *
+ * @note This structure needs to be maintained as 8 bytes aligned.
+ */
+struct composite_header {
+	/** Total number of layers in a specific composite layout. */
+	uint32_t ch_layers_nr;
+
+	/** Padding to make the structure 8 bytes aligned. */
+	uint32_t ch_pad;
+};
+M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct composite_header)));
+
+/**
+ * Structure used to store header information for 'a layer of a composite
+ * layout' like the number of extents in it. It is used in the buffer
+ * representation of a composite layout.
+ *
+ * @note This structure needs to be maintained as 8 bytes aligned.
+ */
+struct composite_layer_header {
+	/** Layout id for the layout used for this layer (sublayout). */
+	uint64_t clh_lid;
+
+	/** Index of this layer into its owner composite layout. */
+	uint32_t clh_idx;
+
+	/** Number of extents belonging to this layer. */
+	uint32_t clh_extents_nr;
+
+	/** Padding to make the structure 8 bytes aligned. */
+	uint32_t clh_pad;
+
+	/**
+	 * Payload storing list of extents (struct m0_ext) for a specific
+	 * layer.
+	 */
+	char     clh_extents[0];
+
+};
+M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct composite_layer_header)));
+
+/** @} end group layout */
+
+/* __MERO_LAYOUT_COMPOSITE_INTERNAL_H__ */
+#endif
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/layout/layout.c b/layout/layout.c
index ed39d73..952ed48 100644
--- a/layout/layout.c
+++ b/layout/layout.c
@@ -129,7 +129,7 @@ M0_BOB_DEFINE(static, &layout_instance_bob, m0_layout_instance);
 
 M0_TL_DESCR_DEFINE(layout, "layout-list", static,
 		   struct m0_layout, l_list_linkage, l_magic,
-		   M0_LAYOUT_MAGIC, M0_LAYOUT_HEAD_MAGIC);
+		   M0_LAYOUT_MAGIC, LAYOUT_LIST_HEAD_MAGIC);
 M0_TL_DEFINE(layout, static, struct m0_layout);
 
 M0_INTERNAL bool m0_layout__domain_invariant(const struct m0_layout_domain *dom)
@@ -192,8 +192,8 @@ m0_layout__striped_allocated_invariant(const struct m0_striped_layout *stl)
 		m0_layout__allocated_invariant(&stl->sl_base);
 }
 
-M0_INTERNAL bool m0_layout__striped_invariant(const struct m0_striped_layout
-					      *stl)
+M0_INTERNAL bool m0_layout__striped_invariant(
+				const struct m0_striped_layout *stl)
 {
 	return
 		stl != NULL &&
@@ -201,8 +201,8 @@ M0_INTERNAL bool m0_layout__striped_invariant(const struct m0_striped_layout
 		m0_layout__invariant(&stl->sl_base);
 }
 
-M0_INTERNAL bool m0_layout__instance_invariant(const struct m0_layout_instance
-					       *li)
+M0_INTERNAL bool m0_layout__instance_invariant(
+				const struct m0_layout_instance *li)
 {
 	return
 		m0_layout_instance_bob_check(li) &&
@@ -277,10 +277,10 @@ static void layout_list_add(struct m0_layout *l)
  * reference is acquired on it if value of ref_increment is true.
  * @post ergo(l != NULL && ref_increment, m0_ref_read(&l->l_ref) > 1);
  */
-M0_INTERNAL struct m0_layout *m0_layout__list_lookup(const struct
-						     m0_layout_domain *dom,
-						     uint64_t lid,
-						     bool ref_increment)
+M0_INTERNAL struct m0_layout *m0_layout__list_lookup(
+					const struct m0_layout_domain *dom,
+					uint64_t lid,
+					bool ref_increment)
 {
 	struct m0_layout *l;
 
@@ -558,8 +558,8 @@ static const struct m0_table_ops layouts_table_ops = {
 	.key_cmp = l_key_cmp
 };
 
-M0_INTERNAL m0_bcount_t m0_layout__enum_max_recsize(struct m0_layout_domain
-						    *dom)
+M0_INTERNAL m0_bcount_t m0_layout__enum_max_recsize(
+					struct m0_layout_domain *dom)
 {
 	m0_bcount_t e_recsize;
 	m0_bcount_t max_recsize = 0;
@@ -755,8 +755,8 @@ M0_INTERNAL int m0_layout_standard_types_register(struct m0_layout_domain *dom)
 	return rc;
 }
 
-M0_INTERNAL void m0_layout_standard_types_unregister(struct m0_layout_domain
-						     *dom)
+M0_INTERNAL void m0_layout_standard_types_unregister(
+					struct m0_layout_domain *dom)
 {
 	M0_PRE(m0_layout__domain_invariant(dom));
 
@@ -1062,16 +1062,16 @@ err1_injected:
 	return rc;
 }
 
-M0_INTERNAL m0_bcount_t m0_layout_max_recsize(const struct m0_layout_domain
-					      *dom)
+M0_INTERNAL m0_bcount_t m0_layout_max_recsize(
+					const struct m0_layout_domain *dom)
 {
 	M0_PRE(m0_layout__domain_invariant(dom));
 	M0_POST(dom->ld_max_recsize >= sizeof (struct m0_layout_rec));
 	return dom->ld_max_recsize;
 }
 
-M0_INTERNAL struct m0_striped_layout *m0_layout_to_striped(const struct
-							   m0_layout *l)
+M0_INTERNAL struct m0_striped_layout *m0_layout_to_striped(
+					const struct m0_layout *l)
 {
 	struct m0_striped_layout *stl;
 
@@ -1081,9 +1081,8 @@ M0_INTERNAL struct m0_striped_layout *m0_layout_to_striped(const struct
 	return stl;
 }
 
-M0_INTERNAL struct m0_layout_enum *m0_striped_layout_to_enum(const struct
-							     m0_striped_layout
-							     *stl)
+M0_INTERNAL struct m0_layout_enum *m0_striped_layout_to_enum(
+					const struct m0_striped_layout *stl)
 {
 	M0_PRE(m0_layout__striped_invariant(stl));
 	return stl->sl_enum;
@@ -1114,11 +1113,11 @@ M0_INTERNAL void m0_layout_enum_get(const struct m0_layout_enum *e,
 	e->le_ops->leo_get(e, idx, gfid, out);
 }
 
-M0_INTERNAL void m0_layout__instance_init(struct m0_layout_instance *li,
-					  const struct m0_fid *gfid,
-					  struct m0_layout *l,
-					  const struct m0_layout_instance_ops
-					  *ops)
+M0_INTERNAL void m0_layout__instance_init(
+				struct m0_layout_instance *li,
+				const struct m0_fid *gfid,
+				struct m0_layout *l,
+				const struct m0_layout_instance_ops *ops)
 {
 	M0_PRE(li != NULL);
 	M0_PRE(m0_layout__invariant(l));
diff --git a/layout/layout.h b/layout/layout.h
index e9498c0..a0f62a7 100644
--- a/layout/layout.h
+++ b/layout/layout.h
@@ -613,11 +613,11 @@ struct m0_layout_instance_ops {
 };
 
 /**
- * Returns enum object embedded in the layout referred by the layout instance.
+ * Returns enum object embedded, if any, in 'the layout referred by the layout
+ * instance'.
  */
-M0_INTERNAL struct m0_layout_enum *m0_layout_instance_to_enum(const struct
-							      m0_layout_instance
-							      *li);
+M0_INTERNAL struct m0_layout_enum *m0_layout_instance_to_enum(
+					const struct m0_layout_instance *li);
 
 /**
  * Allocates and builds a layout instance using the supplied layout;
@@ -687,8 +687,8 @@ M0_INTERNAL void m0_layout_domain_fini(struct m0_layout_domain *dom);
 M0_INTERNAL int m0_layout_standard_types_register(struct m0_layout_domain *dom);
 
 /** Unrgisters all the standard layout types and enum types. */
-M0_INTERNAL void m0_layout_standard_types_unregister(struct m0_layout_domain
-						     *dom);
+M0_INTERNAL void m0_layout_standard_types_unregister(
+					struct m0_layout_domain *dom);
 
 /**
  * Registers a new layout type with the layout types maintained by
@@ -874,20 +874,19 @@ M0_INTERNAL int m0_layout_encode(struct m0_layout *l,
  * considering the data in the tables other than layouts), from what is
  * maintained in the m0_layout_domain object.
  */
-M0_INTERNAL m0_bcount_t m0_layout_max_recsize(const struct m0_layout_domain
-					      *dom);
+M0_INTERNAL m0_bcount_t m0_layout_max_recsize(
+				const struct m0_layout_domain *dom);
 
 /** Returns m0_striped_layout object for the specified m0_layout object. */
-M0_INTERNAL struct m0_striped_layout *m0_layout_to_striped(const struct
-							   m0_layout *l);
+M0_INTERNAL struct m0_striped_layout *m0_layout_to_striped(
+				const struct m0_layout *l);
 
 /**
  * Returns m0_layout_enum object for the specified m0_striped_layout
  * object.
  */
-M0_INTERNAL struct m0_layout_enum *m0_striped_layout_to_enum(const struct
-							     m0_striped_layout
-							     *stl);
+M0_INTERNAL struct m0_layout_enum *m0_striped_layout_to_enum(
+				const struct m0_striped_layout *stl);
 
 M0_INTERNAL struct m0_layout_enum *m0_layout_to_enum(const struct m0_layout *l);
 
diff --git a/layout/layout_internal.h b/layout/layout_internal.h
index beced60..e690c13 100644
--- a/layout/layout_internal.h
+++ b/layout/layout_internal.h
@@ -106,15 +106,15 @@ enum {
  */
 extern struct m0_addb_ctx m0_layout_mod_ctx;
 
-M0_INTERNAL bool m0_layout__domain_invariant(const struct m0_layout_domain
-					     *dom);
+M0_INTERNAL bool m0_layout__domain_invariant(
+				const struct m0_layout_domain *dom);
 M0_INTERNAL bool m0_layout__allocated_invariant(const struct m0_layout *l);
 M0_INTERNAL bool m0_layout__invariant(const struct m0_layout *l);
 M0_INTERNAL bool m0_layout__enum_invariant(const struct m0_layout_enum *le);
-M0_INTERNAL bool m0_layout__striped_allocated_invariant(const struct
-							m0_striped_layout *s);
-M0_INTERNAL bool m0_layout__striped_invariant(const struct m0_striped_layout
-					      *stl);
+M0_INTERNAL bool m0_layout__striped_allocated_invariant(
+				const struct m0_striped_layout *s);
+M0_INTERNAL bool m0_layout__striped_invariant(
+				const struct m0_striped_layout *stl);
 
 M0_INTERNAL struct m0_layout *m0_layout__list_lookup(const struct
 						     m0_layout_domain *dom,
@@ -154,18 +154,17 @@ M0_INTERNAL void m0_layout__log(const char         *fn_name,
 				uint64_t            lid,
 				int                 rc);
 
-M0_INTERNAL m0_bcount_t m0_layout__enum_max_recsize(struct m0_layout_domain
-						    *dom);
+M0_INTERNAL m0_bcount_t m0_layout__enum_max_recsize(
+				struct m0_layout_domain *dom);
 
-M0_INTERNAL void m0_layout__instance_init(struct m0_layout_instance *li,
-					  const struct m0_fid *gfid,
-					  struct m0_layout *l,
-					  const struct m0_layout_instance_ops
-					  *ops);
+M0_INTERNAL void m0_layout__instance_init(
+				struct m0_layout_instance *li,
+				const struct m0_fid *gfid,
+				struct m0_layout *l,
+				const struct m0_layout_instance_ops *ops);
 M0_INTERNAL void m0_layout__instance_fini(struct m0_layout_instance *li);
-M0_INTERNAL bool m0_layout__instance_invariant(const struct m0_layout_instance
-					       *li);
-
+M0_INTERNAL bool m0_layout__instance_invariant(
+				const struct m0_layout_instance *li);
 /** @} end group layout */
 
 /* __MERO_LAYOUT_LAYOUT_INTERNAL_H__ */
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index 7aabb89..1bc289a 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -27,9 +27,10 @@
 #include "layout/layout_db.h"
 #include "layout/pdclust.h"         /* m0_pdl_to_layout() */
 #include "layout/composite.h"
+#include "layout/composite_internal.h"
 #include "layout/ut/layout.h"
 
-M0_TL_DESCR_DECLARE(m0_layer, extern);
+M0_TL_DESCR_DECLARE(comp_layer, extern);
 M0_TL_DESCR_DECLARE(m0_layer_extent, extern);
 static int rc;
 
@@ -212,7 +213,7 @@ static void composite_layout_verify(struct m0_layout *l,
 	/* Verify the layers */
 	extents_nr = min_extents_nr;
 	i = 0;
-        m0_tl_for(m0_layer, cl->cl_layers, layer) {
+        m0_tl_for(comp_layer, cl->cl_layers, layer) {
 		/* Verify the sublayout. */
 		sublayout_id = composite_lid * 100 + i;
 		enum_id = sublayout_id % 2 ? LIST_ENUM_ID : LINEAR_ENUM_ID;
@@ -909,8 +910,8 @@ static void composite_layout_compare(const struct m0_layout *l1,
 	cl2 = container_of(l2, struct m0_composite_layout, cl_base);
 
 	M0_UT_ASSERT(cl1->cl_layers_nr == cl2->cl_layers_nr);
-	layer2 = m0_layer_tlist_head(cl2->cl_layers);
-	m0_tl_for(m0_layer, cl1->cl_layers, layer1) {
+	layer2 = comp_layer_tlist_head(cl2->cl_layers);
+	m0_tl_for(comp_layer, cl1->cl_layers, layer1) {
 		M0_UT_ASSERT(layer1->clr_l == layer2->clr_l);
 		M0_UT_ASSERT(layer1->clr_extents_nr == layer2->clr_extents_nr);
 		/* Zeroth layer does not contain any extents. */
@@ -930,7 +931,7 @@ static void composite_layout_compare(const struct m0_layout *l1,
 							extent2);
 			} m0_tl_endfor;
 		}
-		layer2 = m0_layer_tlist_next(cl2->cl_layers, layer2);
+		layer2 = comp_layer_tlist_next(cl2->cl_layers, layer2);
 	} m0_tl_endfor;
 }
 
@@ -960,9 +961,9 @@ static void composite_layout_copy(const struct m0_layout *l_src,
 
 	M0_ALLOC_PTR(cl_dest->cl_layers);
 	M0_UT_ASSERT(cl_dest->cl_layers != NULL);
-	m0_layer_tlist_init(cl_dest->cl_layers);
+	comp_layer_tlist_init(cl_dest->cl_layers);
 
-	m0_tl_for(m0_layer, cl_src->cl_layers, layer_src) {
+	m0_tl_for(comp_layer, cl_src->cl_layers, layer_src) {
 		M0_ALLOC_PTR(layer_dest);
 		M0_UT_ASSERT(layer_dest != NULL);
 
@@ -989,7 +990,7 @@ static void composite_layout_copy(const struct m0_layout *l_src,
 						layer_dest->clr_extents);
 			} m0_tl_endfor;
 		}
-		m0_layer_tlink_init_at_tail(layer_dest, cl_dest->cl_layers);
+		comp_layer_tlink_init_at_tail(layer_dest, cl_dest->cl_layers);
 	} m0_tl_endfor;
 
 	composite_layout_compare(&cl_src->cl_base, &cl_dest->cl_base, false);
@@ -1004,7 +1005,7 @@ static void composite_layout_copy_delete(struct m0_layout *l)
 	M0_UT_ASSERT(l != NULL);
 
 	cl = container_of(l, struct m0_composite_layout, cl_base);
-	m0_tl_for(m0_layer, cl->cl_layers, layer) {
+	m0_tl_for(comp_layer, cl->cl_layers, layer) {
 		/* Zeroth layer does not contain any extents. */
 		if (layer->clr_idx > 0) {
 			m0_tl_for(m0_layer_extent, layer->clr_extents,
@@ -1015,11 +1016,11 @@ static void composite_layout_copy_delete(struct m0_layout *l)
 			} m0_tl_endfor;
 			m0_free(layer->clr_extents);
 		}
-		m0_layer_tlist_del(layer);
-		m0_layer_tlink_fini(layer);
+		comp_layer_tlist_del(layer);
+		comp_layer_tlink_fini(layer);
 		m0_free(layer);
 	} m0_tl_endfor;
-	m0_layer_tlist_fini(cl->cl_layers);
+	comp_layer_tlist_fini(cl->cl_layers);
 	m0_free(cl->cl_layers);
 	m0_free(cl);
 }
@@ -1422,7 +1423,7 @@ int test_delete_composite(uint64_t lid,
 	/* Delete all the extents associated with the composite layout. */
 	rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
 	M0_UT_ASSERT(rc == 0);
-	m0_tl_for(m0_layer, cl->cl_layers, layer) {
+	m0_tl_for(comp_layer, cl->cl_layers, layer) {
 		if (layer->clr_idx == 0)
 			continue;
 		m0_tl_for(m0_layer_extent, layer->clr_extents, lr_ext) {
@@ -1440,7 +1441,7 @@ int test_delete_composite(uint64_t lid,
 	 * Verify the user count of the sublayouts to be 1 since one user
 	 * count is added with the respective layer addition.
 	 */
-	m0_tl_for(m0_layer, cl->cl_layers, layer) {
+	m0_tl_for(comp_layer, cl->cl_layers, layer) {
 		M0_UT_ASSERT(layer->clr_l->l_user_count == 1);
 	} m0_tl_endfor;
 
@@ -1458,7 +1459,7 @@ int test_delete_composite(uint64_t lid,
 	M0_UT_ASSERT(rc_tmp == 0);
 
 	/* Verify the user count of the sublayouts to be 0. */
-	m0_tl_for(m0_layer, cl->cl_layers, layer) {
+	m0_tl_for(comp_layer, cl->cl_layers, layer) {
 		M0_UT_ASSERT(layer->clr_l->l_user_count == 0);
 	} m0_tl_endfor;
 
@@ -1512,7 +1513,7 @@ static void extent_to_be_operated(const struct m0_composite_layout *cl,
 
 	/* Find the layer with the specified layer id. */
 	layer = NULL;
-	m0_tl_for(m0_layer, cl->cl_layers, layer) {
+	m0_tl_for(comp_layer, cl->cl_layers, layer) {
 		if (layer->clr_idx == layer_idx)
 			break;
 	} m0_tl_endfor;
@@ -1611,14 +1612,14 @@ static int layout_lookup(uint64_t lid,
 	return rc;
 }
 
-enum extent_op {
+enum extent_operation {
 	EXTENT_LOOKUP,
 	EXTENT_ADD,
 	EXTENT_UPDATE,
 	EXTENT_DELETE
 };
 
-int ext_operate(enum extent_op eop,
+int ext_operate(enum extent_operation eop,
 		uint64_t lid,
 		struct m0_layout_domain *domain,
 		uint32_t layers_nr,
diff --git a/mero/magic.h b/mero/magic.h
index 9523d3b..15ba979 100644
--- a/mero/magic.h
+++ b/mero/magic.h
@@ -341,7 +341,7 @@ enum m0_magic_satchel {
 	M0_LAYOUT_ENUM_MAGIC = 0x331dea1f0111e577,
 
 	/* layout_tlist::head_magic (biddable blad) */
-	M0_LAYOUT_HEAD_MAGIC = 0x33b1ddab1eb1ad77,
+	LAYOUT_LIST_HEAD_MAGIC = 0x33b1ddab1eb1ad77,
 
 	/* m0_layout_instance::li_magic (cicilial cell) */
 	M0_LAYOUT_INSTANCE_MAGIC = 0x33c1c111a1ce1177,
@@ -364,17 +364,17 @@ enum m0_magic_satchel {
 	/* m0_composite_instance::ci_magic (blob saleable) */
 	M0_LAYOUT_COMPOSITE_INSTANCE_MAGIC = 0x33b10b5a1eab1e77,
 
-	/* m0_composite_sub_layout::csl_magic (zodiac zoisia) */
-	M0_LAYOUT_COMP_SUBL_MAGIC = 0x3320d1ac20151a77,
+	/* m0_composite_layer::clr_magic (zodiac zoisia) */
+	M0_LAYOUT_COMPOSITE_LAYER_MAGIC = 0x3320d1ac20151a77,
 
-	/* m0_sub_layout_tlist::head_magic (ss solidified) */
-	M0_LAYOUT_COMP_SUBL_HEAD_MAGIC = 0x33555011d1f1ed77,
+	/* comp_layer_tlist::head_magic (ss solidified) */
+	LAYER_LIST_HEAD_MAGIC = 0x33555011d1f1ed77,
 
-	/* m0_sub_layout_extent::sle_magic (add addable ad) */
-	M0_LAYOUT_EXTENT_MAGIC = 0x33addaddab1ead77,
+	/* m0_composite_layer_extent::cle_magic (add addable ad) */
+	M0_LAYOUT_COMPOSITE_LAYER_EXTENT_MAGIC = 0x33addaddab1ead77,
 
-	/* m0_layout_extent::head_magic (addable addle) */
-	M0_LAYOUT_EXTENT_HEAD_MAGIC = 0x33addab1eadd1e77,
+	/* m0_layout_extent_tlist::head_magic (addable addle) */
+	M0_LAYOUT_COMPOSITE_LAYER_EXTENT_HEAD_MAGIC = 0x33addab1eadd1e77,
 
 /* Net */
 	/* m0_net_domain::nd_magix (acidic access) */
-- 
1.8.3.2

