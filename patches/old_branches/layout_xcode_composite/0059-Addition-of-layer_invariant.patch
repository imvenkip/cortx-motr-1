From b919c3e44104d6b64164001242ec1d7c16f81d3a Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Tue, 22 Jan 2013 16:36:02 +0530
Subject: [PATCH 059/157] Addition of layer_invariant()

---
 layout/composite.c | 66 ++++++++++++++++++++++++++++++------------------------
 layout/composite.h |  8 +------
 2 files changed, 38 insertions(+), 36 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index 551c529..3508f49 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -186,24 +186,24 @@ static bool composite_invariant(const struct m0_composite_layout *cl)
 							layer->clr_extents));
 }
 
-/*
- * todo Once confirmed through the open DLDINSP, add a layer invariant that
- * should check that extents are listed in the ascending order of the offsets
- * involved.
- */
-#if 0
-		m0_tl_forall(comp_layer, layer, &cl->cl_layers,
-			     m0_layout__invariant(layer->clr_l) &&
-			     layer->clr_idx == i++ && ...
-			     m0_tl_forall(m0_composite_layer_ext, extent,
-					  layer->clr_extents,
-					  extent->cle_ext.e_start == X &&
-					  extent->cle_ext.e_end == Y)));
+static bool layer_invariant(const struct m0_composite_layer *layer)
+{
+	struct m0_composite_layer_extent *extent;
+	m0_bindex_t                       addr = 0;
+
+	/*
+	 * Since assignment can not be performed in a m0_tl_forall() loop,
+	 * it has not been used in this invariant.
+	 */
+	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, extent) {
+		M0_ASSERT(extent->cle_ext.e_start >= addr);
+		addr = extent->cle_ext.e_start;
+	} m0_tl_endfor;
+	return true;
 }
-#endif
 
 static bool composite_instance_invariant(
-			const struct m0_composite_instance *ci)
+				const struct m0_composite_instance *ci)
 {
 	struct m0_composite_layout *cl;
 
@@ -348,6 +348,7 @@ static void composite_delete(struct m0_layout *l)
 	M0_LEAVE();
 }
 
+//todo Check if layer is needed to be returned back
 /** Adds a layer to the in-memory layout. */
 static int layer_in_memory_add(struct m0_composite_layout *cl,
 			       struct m0_layout *sublayout,
@@ -386,6 +387,7 @@ static int layer_in_memory_add(struct m0_composite_layout *cl,
 	comp_layer_tlink_init_at_tail(layer, &cl->cl_layers);
 	M0_CNT_INC(cl->cl_layers_nr);
 	*lr = layer;
+	M0_POST(layer_invariant(layer));
 	M0_POST(composite_invariant(cl));
 	M0_LEAVE("lid %llu, layer %lu", (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer->clr_idx);
@@ -435,7 +437,7 @@ static void layer_in_memory_delete(struct m0_composite_layout *cl,
 
 static int composite_populate(struct m0_composite_layout *cl,
 			      uint32_t user_count,
-			      struct m0_layout *oldlayout,
+			      struct m0_layout *sublayout,
 			      struct m0_tl *extlist,
 			      uint32_t ext_nr)
 {
@@ -443,12 +445,12 @@ static int composite_populate(struct m0_composite_layout *cl,
 	int                        rc;
 
 	M0_PRE(composite_allocated_invariant(cl));
-	M0_PRE(m0_layout__invariant(oldlayout));
+	M0_PRE(m0_layout__invariant(sublayout));
 
 	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 	m0_layout__populate(&cl->cl_base, user_count);
 
-	rc = layer_in_memory_add(cl, oldlayout, extlist, ext_nr, &layer);
+	rc = layer_in_memory_add(cl, sublayout, extlist, ext_nr, &layer);
 	M0_ASSERT(layer->clr_idx == 0);
 
 	M0_POST(composite_invariant(cl));
@@ -459,7 +461,7 @@ static int composite_populate(struct m0_composite_layout *cl,
 
 M0_INTERNAL int m0_composite_build(struct m0_layout_domain *dom,
 				   uint64_t lid,
-				   struct m0_layout *oldlayout,
+				   struct m0_layout *sublayout,
 				   struct m0_tl *extlist,
 				   uint32_t ext_nr,
 				   struct m0_composite_layout **out)
@@ -477,7 +479,7 @@ M0_INTERNAL int m0_composite_build(struct m0_layout_domain *dom,
 		cl = bob_of(l, struct m0_composite_layout, cl_base,
 			    &composite_bob);
 		M0_ASSERT(composite_allocated_invariant(cl));
-		rc = composite_populate(cl, 0, oldlayout, extlist, ext_nr);
+		rc = composite_populate(cl, 0, sublayout, extlist, ext_nr);
 		if (rc == 0) {
 			*out = cl;
 			m0_mutex_unlock(&l->l_lock);
@@ -1236,6 +1238,7 @@ M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
 	}
 
 DB_sync_skipped:
+	M0_POST(ergo(rc == 0, layer_invariant(layer)));
 	M0_POST(composite_invariant(cl));
 	M0_RETURN(rc);
 }
@@ -1562,11 +1565,9 @@ static int comp_layout_in_db_read(struct m0_composite_layout *cl,
 						extents, extents_nr);
 		else
 			/* Now, write the layer to the in-memory layout. */
-			//todo Check if layer is needed to be obtained back
 			rc = layer_in_memory_add(cl, sublayout, extents,
 						 extents_nr, &layer);
 		if (rc != 0) {
-			//todo Check the msg
 			M0_LOG(M0_ERROR, "lid %llu, layer %lu could not be "
 			       "written to the layout",
 			       (unsigned long long)cl->cl_base.l_id,
@@ -1641,17 +1642,22 @@ static int comp_layout_in_db_add(struct m0_composite_layout *cl,
 
 	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 
-	/*
-	 * Collect the old layout id by referring to the zeroth layer from
-	 * the in-memory layout.
-	 */
+	/* Collect the zeroth layer from the in-memory layout. */
 	layer = comp_layer_tlist_head(&cl->cl_layers);
 	M0_ASSERT(layer->clr_idx == 0);
 	rc = sublayout_id_in_db_add(cl, layer, tx);
-	if (rc == 0)
+	if (rc == 0) {
 		/* Add 'the extent map for this layer' to the DB. */
 		rc = extmap_in_db_add(cl, layer, tx);
-	//todo Err handling
+		if (rc != 0)
+			/*
+			 * If extmap_in_db_add() has failed for no apparent
+			 * reason, it is likely that sublayout_id_in_db_delete()
+			 * would fail. Hence, ignoring its return status.
+			 */
+			sublayout_id_in_db_delete(cl, layer, tx);
+	}
+
 	M0_LEAVE("lid %llu, rc %d", (unsigned long long)cl->cl_base.l_id, rc);
 	return rc;
 }
@@ -1951,6 +1957,7 @@ M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
 	m0_emap_close(&it);
 	m0_mutex_unlock(&cl->cl_base.l_lock);
+	M0_POST(layer_invariant(layer));
 	M0_LEAVE("lid %llu, layer %lu, e_start %llu, e_end %llu, rc %d",
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
@@ -2043,6 +2050,7 @@ M0_INTERNAL int m0_composite_layer_ext_state_update(
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
 	m0_emap_close(&it);
 	m0_mutex_unlock(&cl->cl_base.l_lock);
+	M0_POST(layer_invariant(layer));
 	M0_POST(composite_invariant(cl));
 	M0_LEAVE("lid %llu, layer %lu, e_start %llu, e_end %llu, "
 		 "e_state %llu, rc %d",
@@ -2110,7 +2118,7 @@ M0_INTERNAL int m0_composite_layer_ext_delete(struct m0_composite_layout *cl,
 			       cl->cl_base.l_id, rc);
 	m0_emap_close(&it);
 	m0_mutex_unlock(&cl->cl_base.l_lock);
-
+	M0_POST(layer_invariant(layer));
 	M0_LEAVE("lid %llu, layer %lu, e_start %llu, e_end %llu, rc %d",
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
diff --git a/layout/composite.h b/layout/composite.h
index 972525f..5d1e2e6 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -221,7 +221,7 @@ struct m0_composite_instance {
  */
 M0_INTERNAL int m0_composite_build(struct m0_layout_domain *dom,
 				   uint64_t lid,
-				   struct m0_layout *oldlayout,
+				   struct m0_layout *sublayout,
 				   struct m0_tl *extlist,
 				   uint32_t ext_nr,
 				   struct m0_composite_layout **out);
@@ -302,12 +302,6 @@ M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
  *
  * @todo This API is available only to the user space code. Is that fine?
  *
- * @todo Since user is not expected to update an existing extent but is
- * expected to update state of an existing extent, this API is named as
- * m0_composite_layer_ext_state_update() and not m0_composite_layer_update.
- * Is that fine OR should the name still be m0_composite_layer_ext_update()?
- * (The existing extents are expected to be updated using
- * m0_composite_layer_ext_add() and m0_composite_layer_ext_delete().)
  */
 M0_INTERNAL int m0_composite_layer_ext_state_update(
 					struct m0_composite_layout *cl,
-- 
1.8.3.2

