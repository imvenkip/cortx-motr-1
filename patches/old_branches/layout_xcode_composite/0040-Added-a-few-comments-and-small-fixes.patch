From 897fb8743efcfacb1e4b02d24bbcd3df66088eb7 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Tue, 8 Jan 2013 16:04:41 +0530
Subject: [PATCH 040/157] Added a few comments and small fixes

---
 layout/composite.c    | 264 +++++++++++++++++++++-----------------------------
 layout/composite.h    |  25 +++--
 layout/ut/composite.c |   2 +-
 layout/ut/layout.c    |  17 +++-
 4 files changed, 144 insertions(+), 164 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index 45dfb9f..349d508 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -76,7 +76,7 @@ struct composite_schema_data {
 /**
  * layer_sublayout table.
  *
- * @note This structure needs to be maintained as 8 bytes aligned.
+ * @note These two structures needs to be maintained as 8 bytes aligned.
  */
 struct layer_sublayout_key {
 	/** Layout id for the composite layout. */
@@ -90,9 +90,6 @@ struct layer_sublayout_key {
 };
 M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct layer_sublayout_key)));
 
-/**
- * @note This structure needs to be maintained as 8 bytes aligned.
- */
 struct layer_sublayout_rec {
 	/** Layout id for the sublayout. */
 	uint64_t lrsmr_sublayout_lid;
@@ -193,41 +190,97 @@ static bool composite_invariant(const struct m0_composite_layout *cl)
 							layer->clr_extents)));
 }
 
-//todo Add a layer invariant that should check that extents are listed in the
-//ascending order of the offsets involved
-
+/*
+ * todo Once confirmed through the open DLDINSP, add a layer invariant that
+ * should check that extents are listed in the ascending order of the offsets
+ * involved. This will require changes to UT.
+ */
 #if 0
-static bool composite_invariant(const struct m0_composite_layout *cl)
-	uint32_t i = 0;
-
-	return
-		m0_composite_layout_bob_check(cl) &&
-		m0_layout__invariant(&cl->cl_base) &&
-		cl->cl_layers != NULL &&
-		cl->cl_layers_nr > 0 &&
-		cl->cl_layers_nr == m0_layer_tlist_length(cl->cl_layers) &&
 		m0_tl_forall(m0_layer, layer, cl->cl_layers,
 			     m0_layout__invariant(layer->clr_l) &&
-			     layer->clr_idx == i++ &&
-			     ergo(layer->clr_idx == 0,
-				  layer->clr_extents_nr == 0 &&
-				  layer->clr_extents == NULL) &&
-			     ergo(layer->clr_idx > 0,
-				  layer->clr_extents != NULL &&
-				  layer->clr_extents_nr > 0 &&
-			          layer->clr_extents_nr ==
-			          m0_layer_extent_tlist_length(
-							layer->clr_extents) &&
-				  layer->clr_extents_nr == 1 &&
-				  m0_tl_forall(m0_layer_extent, extent,
-					       layer->clr_extents,
-					       extent->cle_ext.e_start ==
-					       1400900 &&
-					       extent->cle_ext.e_end ==
-					       70745449)));
+			     layer->clr_idx == i++ && ...
+			     m0_tl_forall(m0_layer_extent, extent,
+					  layer->clr_extents,
+					  extent->cle_ext.e_start == X &&
+					  extent->cle_ext.e_end == Y)));
 }
 #endif
 
+/** Implementation of lto_register for COMPOSITE layout type. */
+static int composite_register(struct m0_layout_domain *dom,
+			      const struct m0_layout_type *lt)
+{
+	struct composite_schema_data *csd;
+	int                           rc;
+
+	M0_PRE(m0_layout__domain_invariant(dom));
+	M0_PRE(lt != NULL);
+	M0_PRE(IS_IN_ARRAY(lt->lt_id, dom->ld_type));
+	M0_PRE(dom->ld_type_data[lt->lt_id] == NULL);
+
+	M0_ENTRY("Layout_type_id %lu", (unsigned long)lt->lt_id);
+
+	if (M0_FI_ENABLED("mem_err")) { csd = NULL; goto err1_injected; }
+	M0_ALLOC_PTR(csd);
+err1_injected:
+	if (csd == NULL) {
+		m0_layout__log("composite_register", "M0_ALLOC_PTR() failed",
+			       &m0_addb_oom, &layout_global_ctx, LID_NONE,
+			       -ENOMEM);
+		return -ENOMEM;
+	}
+
+	if (M0_FI_ENABLED("table_init_err"))
+		{ rc = -EEXIST; goto err2_injected; }
+	rc = m0_table_init(&csd->csd_layer_sublayout, dom->ld_dbenv,
+			   "layer_sublayout", DEFAULT_DB_FLAG,
+			   &composite_table_ops);
+err2_injected:
+	if (rc != 0) {
+		m0_layout__log("composite_register", "m0_table_init() failed",
+			       &m0_addb_func_fail, &layout_global_ctx,
+			       LID_NONE, rc);
+		m0_free(csd);
+		return rc;
+	}
+
+	if (M0_FI_ENABLED("emap_init_err"))
+		{ rc = -EEXIST; goto err3_injected; }
+	rc = m0_emap_init(&csd->csd_layer_ext_map, dom->ld_dbenv,
+			  "layer_ext_map");
+err3_injected:
+	if (rc != 0) {
+		m0_layout__log("composite_register", "m0_emap_init() failed",
+			       &m0_addb_func_fail, &layout_global_ctx,
+			       LID_NONE, rc);
+		m0_table_fini(&csd->csd_layer_sublayout);
+		m0_free(csd);
+		return rc;
+	}
+
+	dom->ld_type_data[lt->lt_id] = csd;
+	M0_LEAVE("Layout_type_id %lu, rc %d", (unsigned long)lt->lt_id, rc);
+	return rc;
+}
+
+/** Implementation of lto_unregister for COMPOSITE layout type. */
+static void composite_unregister(struct m0_layout_domain *dom,
+				 const struct m0_layout_type *lt)
+{
+	struct composite_schema_data *csd;
+
+	M0_PRE(m0_layout__domain_invariant(dom));
+	M0_PRE(lt != NULL);
+
+	M0_ENTRY("Layout_type_id %lu", (unsigned long)lt->lt_id);
+	csd = dom->ld_type_data[lt->lt_id];
+	m0_table_fini(&csd->csd_layer_sublayout);
+	m0_emap_fini(&csd->csd_layer_ext_map);
+	dom->ld_type_data[lt->lt_id] = NULL;
+	m0_free(csd);
+	M0_LEAVE("Layout_type_id %lu", (unsigned long)lt->lt_id);
+}
+
 static const struct m0_layout_ops composite_ops;
 /* Implementation of lto_allocate for COMPOSITE layout type. */
 static int composite_allocate(struct m0_layout_domain *dom,
@@ -440,7 +493,7 @@ M0_INTERNAL struct m0_composite_layout *m0_layout_to_cl(
 	return cl;
 }
 
-struct m0_layout *m0_cl_to_layout(struct m0_composite_layout *cl)
+M0_INTERNAL struct m0_layout *m0_cl_to_layout(struct m0_composite_layout *cl)
 {
 	M0_PRE(composite_invariant(cl));
 	return &cl->cl_base;
@@ -452,81 +505,6 @@ static m0_bcount_t composite_recsize(const struct m0_layout *l)
 	return sizeof(struct m0_layout_rec);
 }
 
-/** Implementation of lto_register for COMPOSITE layout type. */
-static int composite_register(struct m0_layout_domain *dom,
-			      const struct m0_layout_type *lt)
-{
-	struct composite_schema_data *csd;
-	int                           rc;
-
-	M0_PRE(m0_layout__domain_invariant(dom));
-	M0_PRE(lt != NULL);
-	M0_PRE(IS_IN_ARRAY(lt->lt_id, dom->ld_type));
-	M0_PRE(dom->ld_type_data[lt->lt_id] == NULL);
-
-	M0_ENTRY("Layout_type_id %lu", (unsigned long)lt->lt_id);
-
-	if (M0_FI_ENABLED("mem_err")) { csd = NULL; goto err1_injected; }
-	M0_ALLOC_PTR(csd);
-err1_injected:
-	if (csd == NULL) {
-		m0_layout__log("composite_register", "M0_ALLOC_PTR() failed",
-			       &m0_addb_oom, &layout_global_ctx, LID_NONE,
-			       -ENOMEM);
-		return -ENOMEM;
-	}
-
-	if (M0_FI_ENABLED("table_init_err"))
-		{ rc = -EEXIST; goto err2_injected; }
-	rc = m0_table_init(&csd->csd_layer_sublayout, dom->ld_dbenv,
-			   "layer_sublayout", DEFAULT_DB_FLAG,
-			   &composite_table_ops);
-err2_injected:
-	if (rc != 0) {
-		m0_layout__log("composite_register", "m0_table_init() failed",
-			       &m0_addb_func_fail, &layout_global_ctx,
-			       LID_NONE, rc);
-		m0_free(csd);
-		return rc;
-	}
-
-	if (M0_FI_ENABLED("emap_init_err"))
-		{ rc = -EEXIST; goto err3_injected; }
-	rc = m0_emap_init(&csd->csd_layer_ext_map, dom->ld_dbenv,
-			  "layer_ext_map");
-err3_injected:
-	if (rc != 0) {
-		m0_layout__log("composite_register", "m0_emap_init() failed",
-			       &m0_addb_func_fail, &layout_global_ctx,
-			       LID_NONE, rc);
-		m0_table_fini(&csd->csd_layer_sublayout);
-		m0_free(csd);
-		return rc;
-	}
-
-	dom->ld_type_data[lt->lt_id] = csd;
-	M0_LEAVE("Layout_type_id %lu, rc %d", (unsigned long)lt->lt_id, rc);
-	return rc;
-}
-
-/** Implementation of lto_unregister for COMPOSITE layout type. */
-static void composite_unregister(struct m0_layout_domain *dom,
-				 const struct m0_layout_type *lt)
-{
-	struct composite_schema_data *csd;
-
-	M0_PRE(m0_layout__domain_invariant(dom));
-	M0_PRE(lt != NULL);
-
-	M0_ENTRY("Layout_type_id %lu", (unsigned long)lt->lt_id);
-	csd = dom->ld_type_data[lt->lt_id];
-	m0_table_fini(&csd->csd_layer_sublayout);
-	m0_emap_fini(&csd->csd_layer_ext_map);
-	dom->ld_type_data[lt->lt_id] = NULL;
-	m0_free(csd);
-	M0_LEAVE("Layout_type_id %lu", (unsigned long)lt->lt_id);
-}
-
 /** Implementation of lto_max_recsize() for COMPOSITE layout type. */
 static m0_bcount_t composite_max_recsize(struct m0_layout_domain *dom)
 {
@@ -555,7 +533,6 @@ enum extent_op {
 };
 
 #ifndef __KERNEL__
-
 static int extent_in_memory_add(struct m0_composite_layer *layer,
 				const struct m0_ext *ext,
 				uint64_t ext_state)
@@ -760,7 +737,6 @@ static int ext_in_memory_adjust(struct m0_composite_layer *layer,
 
 	M0_RETURN(rc);
 }
-
 #endif /* __KERNEL__ */
 
 /*
@@ -1052,7 +1028,6 @@ static struct m0_emap *emap_from_cl(const struct m0_composite_layout *cl)
 
 static int extentmap_in_db_write(struct m0_composite_layout *cl,
 				 struct m0_composite_layer *layer,
-				 bool if_extents_associated,
 				 struct m0_db_tx *tx)
 {
 	struct m0_emap                   *emap;
@@ -1062,12 +1037,10 @@ static int extentmap_in_db_write(struct m0_composite_layout *cl,
 	struct layout_prefix              prefix;
 	int                               rc;
 
-	M0_ENTRY("lid %llu, layer %lu, sublayout_id %llu, "
-		 "if_extents_associated %d",
+	M0_ENTRY("lid %llu, layer %lu, sublayout_id %llu",
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)layer->clr_l->l_id,
-		 if_extents_associated);
+		 (unsigned long long)layer->clr_l->l_id);
 
 	emap = emap_from_cl(cl);
 	prefix_set(&prefix, cl->cl_base.l_id, layer->clr_idx);
@@ -1081,9 +1054,6 @@ static int extentmap_in_db_write(struct m0_composite_layout *cl,
 		return rc;
 	}
 
-	if (!if_extents_associated)
-		M0_RETURN(rc);
-
 	rc = m0_emap_lookup(emap, tx, (struct m0_uint128 *)&prefix, 0, &it);
 	if (rc != 0) {
 		m0_layout__log("extentmap_in_db_write",
@@ -1139,7 +1109,7 @@ static int layer_in_db_write(struct m0_composite_layout *cl,
 		 (unsigned long)layer->clr_idx);
 
 	/* Write 'the extent map for this layer' to the DB. */
-	rc = extentmap_in_db_write(cl, layer, true, tx);
+	rc = extentmap_in_db_write(cl, layer, tx);
 	if (rc != 0)
 		M0_RETURN(rc);
 
@@ -1163,11 +1133,12 @@ M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
 	M0_PRE(m0_mutex_is_locked(&cl->cl_base.l_lock));
 	M0_PRE(m0_layout__invariant(sublayout));
 	M0_PRE(extlist != NULL);
+	/* M0_PRE(tx != NULL) is mentioned below. */
 
-	M0_ENTRY("lid %llu, sublayout_id %llu, extlist %p, ext_nr %ld",
+	M0_ENTRY("lid %llu, sublayout_id %llu, extlist %p, ext_nr %ld, tx %p",
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long long)sublayout->l_id,
-		 extlist, (unsigned long)ext_nr);
+		 extlist, (unsigned long)ext_nr, tx);
 
 	if (m0_layer_extent_tlist_is_empty(extlist) || ext_nr == 0) {
 		rc = -EINVAL;
@@ -1187,24 +1158,24 @@ M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
 		return rc;
 	}
 
-	if (tx == NULL)
-		return rc; //todo Handle. What user space code shall do?
-
 	/*
-	 * todo If the DB is accessible (that is if the yet-to-be-defined
-	 * cl->cl_base.l_dom->ld_is_DB_available is true),
-	 * add the layer to the DB. Shud this be made available only for
-	 * kernel space? If not, who will sync it up into the DB and when?
+	 * The following fault injection point helps testing encode decode
+	 * operations on 'an in-memory composite layout with having some
+	 * layers added to it', without having dependency on the DB.
 	 */
+	if (M0_FI_ENABLED("skip_DB_sync")) { goto DB_sync_skipped; }
+
+	M0_PRE(tx != NULL);
 	rc = layer_in_db_write(cl, layer, tx);
 	if (rc != 0) {
 		m0_layout__log("m0_composite_layer_add",
 			       "failed to write layer in DB",
 			       &comp_ext_op_fail, &cl->cl_base.l_addb,
 			       cl->cl_base.l_id, rc);
-		/* todo Undo Writing layer to the DB ? */
+		/* todo Undo Writing layer in-memory ? */
 	}
 
+DB_sync_skipped:
 	M0_POST(composite_invariant(cl));
 	M0_RETURN(rc);
 }
@@ -1225,10 +1196,10 @@ static struct m0_layout *layout_find(struct m0_layout_domain *dom,
 	 *   so that the DB lookup can be performed for it.
 	 *
 	 * Until the time above changes are implemented (through the task
-	 * lined up next to the current one), the user (UT for the time being)
-	 * shall ensure that the sublayouts are cached prior to 'creating a
-	 * composite layout and adding layers to it'. The following assert
-	 * ensures the same.
+	 * "getattr changes for layout", lined up next to the current one),
+	 * the user shall ensure that the sublayouts are cached prior to
+	 * 'creating a composite layout and adding layers to it'. The following
+	 * assert ensures the same.
 	 *
 	 * Remove the following assert once the above mentioned changes
 	 * are implemented.
@@ -1598,6 +1569,7 @@ static int composite_decode(struct m0_layout *l,
 	int                         rc;
 
 	M0_PRE(m0_layout__allocated_invariant(l));
+	M0_PRE(m0_mutex_is_locked(&l->l_lock));
 	M0_PRE(cur != NULL);
 	M0_PRE(M0_IN(op, (M0_LXO_DB_LOOKUP, M0_LXO_BUFFER_OP)));
 	M0_PRE(ergo(op == M0_LXO_DB_LOOKUP, tx != NULL));
@@ -1640,24 +1612,7 @@ static int composite_layout_in_db_add(struct m0_composite_layout *cl,
 	 */
 	layer = m0_layer_tlist_head(cl->cl_layers);
 	M0_ASSERT(layer->clr_idx == 0);
-	M0_ASSERT(layer->clr_extents_nr == 0);
-	M0_ASSERT(layer->clr_l->l_id > 0); /* old layout id */
-
-	/* Write 'the extent map for the zeroth layer' to the DB. */
-	rc = extentmap_in_db_write(cl, layer, false, tx);
-	if (rc == 0)
-		/* Write 'the sublayout id for the zeroth layer' to the DB. */
-		rc = sublayout_id_in_db_write(cl, layer, tx);
-
-	/**
-	 * @todo In fact, there are no valid extents associated with
-	 * layer 0. So, do we need to make this extent entry with
-	 * M0_CLRES_INVALID state to the layer_ext_map table? Probably
-	 * not unless there is a chance that zeroth layer may need to
-	 * store some extents in future. Will it?
-	 *
-	 * todo Do not write extentmap for the zeroth layer
-	 */
+	rc = sublayout_id_in_db_write(cl, layer, tx);
 	M0_LEAVE("lid %llu, rc %d", (unsigned long long)cl->cl_base.l_id, rc);
 	return rc;
 }
@@ -1670,8 +1625,6 @@ static int composite_layout_in_db_delete(struct m0_composite_layout *cl,
 
 	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 
-	//todo m0_mutex_lock();
-
 	/*
 	 * A composite layout can be deleted from the DB if and only if none of
 	 * its layers contain any valid extent.
@@ -1722,6 +1675,7 @@ static int composite_encode(struct m0_layout *l,
 	int                               rc;
 
 	M0_PRE(l != NULL);
+	M0_PRE(m0_mutex_is_locked(&l->l_lock));
 	M0_PRE(M0_IN(op, (M0_LXO_DB_ADD, M0_LXO_DB_UPDATE,
 			  M0_LXO_DB_DELETE, M0_LXO_BUFFER_OP)));
 	M0_PRE(ergo(op != M0_LXO_BUFFER_OP, tx != NULL));
@@ -2015,7 +1969,7 @@ M0_INTERNAL int m0_composite_layer_ext_state_update(
 	if (seg->ee_ext.e_start != ext->e_start ||
 	    seg->ee_ext.e_end != ext->e_end ||
 	    seg->ee_val == M0_CLRES_INVALID) {
-		rc = -ENOENT; //todo Change it to -EINVAL
+		rc = -EINVAL;
 		m0_layout__log("m0_composite_layer_ext_state_update",
 			       "A non-existing extent can not be updated",
 			       &comp_ext_op_fail, &cl->cl_base.l_addb,
diff --git a/layout/composite.h b/layout/composite.h
index 93d23d3..0452bc9 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -48,8 +48,8 @@
  * 5) Eventually, “layout flattening” will be invoked that will convert
  *    composite layouts to new non-composite layouts. (Future)
  *
- * @todo Imagination is that the extents owned by various layers are exclusive
- * of each other. Shall this be enforced through the invariants?
+ * @todo Understanding is that the extents owned by various layers are
+ * exclusive of each other. Shall this be enforced through the invariants?
  *
  * @{
  */
@@ -209,8 +209,9 @@ M0_INTERNAL int m0_composite_build(struct m0_layout_domain *dom,
 /**
  * Adds a layer to the composite layout and updates the layout in the DB.
  *
- * @pre The composite layout has already been added to the DB using
- * m0_layout_add().
+ * @pre The composite layout has been added to the DB.
+ *
+ * @todo This API is available only to the user space code. Is that fine?
  */
 M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
 				       struct m0_layout *sublayout,
@@ -238,7 +239,8 @@ M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
  *    that seem fine?
  * 3) This API currently directly looks up into the DB using the readily
  *    available m0_emap_lookup(). Is it ok OR it should be changed to look up
- *    into the in-memory list of the extents?
+ *    into the in-memory list of the extents? In other words, is this API
+ *    required for the kernel space code?
  */
 M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
 					      m0_bindex_t offset,
@@ -252,11 +254,14 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
  * Adds an extent to the specified layer of the specified composite layout,
  * by right away updating the extents list in the DB.
  *
+ * @todo This API is available only to the user space code. Is that fine?
+ *
  * @todo The extent is necessarily added with the M0_CLRES_VALID state. Do we
  * need to support adding the extents with any specific extent state? The
  * imagination is that any valid extent would start its lifecycle with the
  * M0_CLRES_VALID state and then would change its state to something else if
- * required, for example to M0_CLRES_FLATTENING and then to M0_CLRES_INVALID.
+ * required, for example to M0_CLRES_FLATTENING and then back to
+ * M0_CLRES_INVALID.
  */
 M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
 					   uint32_t layer_idx,
@@ -267,10 +272,14 @@ M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
  * Updates state of an extent owned by a specified layer of a specified
  * composite layout, by right away updating it in the DB.
  *
+ * @pre The exact extent ext exists in the specified layer.
+ *
+ * @todo This API is available only to the user space code. Is that fine?
+ *
  * @todo Since user is not expected to update an existing extent but is
  * expected to update state of an existing extent, this API is named as
  * m0_composite_layer_ext_state_update() and not m0_composite_layer_update.
- * Is that fine?
+ * Is that fine OR should the name still be m0_composite_layer_ext_update()?
  * (The existing extents are expected to be updated using
  * m0_composite_layer_ext_add() and m0_composite_layer_ext_delete().)
  */
@@ -284,6 +293,8 @@ M0_INTERNAL int m0_composite_layer_ext_state_update(
 /**
  * Deletes an extent from the specified layer of the specified composite
  * layout, by right away updating the extents list in the DB.
+ *
+ * @todo This API is available only to the user space code. Is that fine?
  */
 M0_INTERNAL int m0_composite_layer_ext_delete(struct m0_composite_layout *cl,
 					      uint32_t layer_idx,
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index 72f0ad8..58b9a5c 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -1659,7 +1659,7 @@ int ext_operate(enum extent_op eop,
 		if (kind_of_extent_to_operate == EXACT_EXISTING)
 			M0_UT_ASSERT(rc == 0);
 		else
-			M0_UT_ASSERT(rc == -ENOENT);
+			M0_UT_ASSERT(rc == -EINVAL);
 
 		rc = m0_composite_layer_ext_lookup(cl,
 						   offset_to_operate,
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 4b46571..d97d815 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -812,6 +812,8 @@ static void test_build(void)
 				!FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
+	m0_fi_enable("m0_composite_layer_add", "skip_DB_sync");
+
 	/*
 	 * Build a layout object with COMPOSITE layout type, with contiguous
 	 * extents in its layers and destroy it.
@@ -842,6 +844,8 @@ static void test_build(void)
 				  0, M0_BINDEX_MAX,
 				  !CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
+
+	m0_fi_disable("m0_composite_layer_add", "skip_DB_sync");
 }
 
 static void test_build_failure(void)
@@ -1149,6 +1153,8 @@ static void test_decode(void)
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
+	m0_fi_enable("m0_composite_layer_add", "skip_DB_sync");
+
 	/*
 	 * Decode a layout object with COMPOSITE layout type and with
 	 * contiguous extents in its layers.
@@ -1169,8 +1175,8 @@ static void test_decode(void)
 				   !CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-
 	//todo ? 0, M0_BINDEX_MAX,
+	m0_fi_disable("m0_composite_layer_add", "skip_DB_sync");
 }
 
 static void test_decode_failure(void)
@@ -1454,6 +1460,7 @@ static void test_encode(void)
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
+	m0_fi_enable("m0_composite_layer_add", "skip_DB_sync");
 	/*
 	 * Encode for COMPOSITE layout type with contiguous extents in its
 	 * layers.
@@ -1475,6 +1482,8 @@ static void test_encode(void)
 	M0_UT_ASSERT(rc == 0);
 
 	//todo ? 0, M0_BINDEX_MAX,
+
+	m0_fi_disable("m0_composite_layer_add", "skip_DB_sync");
 }
 
 static void test_encode_failure(void)
@@ -1758,6 +1767,7 @@ static void test_decode_encode(void)
 					INLINE_NOT_APPLICABLE);
 	M0_UT_ASSERT(rc == 0);
 
+	m0_fi_enable("m0_composite_layer_add", "skip_DB_sync");
 	/*
 	 * Build a layout buffer representing a layout with COMPOSITE layout
 	 * type.
@@ -1771,6 +1781,8 @@ static void test_decode_encode(void)
 					  lid * 100, lid * 10 * 100,
 					  CONTIGUOUS_EXTENTS);
 	M0_UT_ASSERT(rc == 0);
+
+	m0_fi_disable("m0_composite_layer_add", "skip_DB_sync");
 }
 
 /* Compares generic part of the layout objects. */
@@ -2103,6 +2115,7 @@ static void test_encode_decode(void)
 					INLINE_NOT_APPLICABLE);
 	M0_UT_ASSERT(rc == 0);
 
+	m0_fi_enable("m0_composite_layer_add", "skip_DB_sync");
 	/*
 	 * Build a layout object with COMPOSITE layout type. Encode it into a
 	 * layout buffer. Then decode that layout buffer again into another
@@ -2115,6 +2128,8 @@ static void test_encode_decode(void)
 					  lid * 100, lid * 100 * 100,
 					  CONTIGUOUS_EXTENTS);
 	M0_UT_ASSERT(rc == 0);
+
+	m0_fi_disable("m0_composite_layer_add", "skip_DB_sync");
 }
 
 /*
-- 
1.8.3.2

