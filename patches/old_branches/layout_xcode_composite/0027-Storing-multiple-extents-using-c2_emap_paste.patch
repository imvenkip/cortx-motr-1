From b983b8e8f22b9fc822961fd87e636d2be1d7d227 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Tue, 4 Dec 2012 17:30:12 +0530
Subject: [PATCH 027/157] Storing multiple extents using c2_emap_paste()

---
 layout/composite.c    | 279 ++++++++++++++++++++++++++++++++++++++++----------
 layout/composite.h    |   7 +-
 layout/ut/composite.c |  22 +++-
 layout/ut/layout.c    |  69 ++++++++++---
 4 files changed, 302 insertions(+), 75 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index 8b5fe6c..86c9e77 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -146,29 +146,40 @@ struct layout_prefix {
 };
 
 /**
- * Types of extents belonging to a particular layer of a particular composite
- * layout.
+ * State of an extent.
  *
- * Value of this enum is stored along with each extent of each layer from
- * every composite layoout.
+ * Value of this enum is stored (in memory and in the DB) along with each
+ * extent of each layer from every composite layoout.
+ *
+ * Two extents can be merged if and only if their states are the same and they
+ * are back to back.
  */
-enum layer_extent_type {
+enum layer_extent_state {
+	/**
+	 * This value is used to tag an extent that does not belong to the
+	 * layer's address-space. For example, an extent (0, C2_BINDEX_MAX + 1)
+	 * would be LRET_INVALID for 'the zeroth layer that does not contain
+	 * any extents'. This relates to the implemtation of the extent map
+	 * that by default has the name-space from 0 to C2_BINDEX_MAX.
+	 *
+	 * Extents with this state are not stored in the in-memory list of the
+	 * extents.
+	 */
+	LRET_INVALID,
+
 	/**
 	 * Normal extent associated with a particular layer. All extents with
 	 * this value belong to the layer they are associated with.
 	 */
 	LRET_VALID,
+
 	/**
-	 * This value is used to tag an extent that does not belong to the
-	 * layer's address-space. For example, an extent (0, C2_BINDEX_MAX + 1)
-	 * would be LRET_NONE for 'the zeroth layer that does not contain any
-	 * extents'.
-	 */
-	LRET_NONE,
-	/**
-	 * This value is used to tag a hole in the layer.
+	 * This value is used to tag an extent that is involved into the
+	 * ongoing layout flattening process (future).
+	 * @note This value, though not in use currently, is placed here to
+	 * illustrate the usage of this enum.
 	 */
-	LRET_HOLE
+	LRET_VALID_FLATTENING
 };
 
 C2_TL_DESCR_DEFINE(c2_layer, "composite-layer-list", /* global */,
@@ -195,6 +206,9 @@ static bool composite_allocated_invariant(const struct c2_composite_layout *cl)
 
 static bool composite_invariant(const struct c2_composite_layout *cl)
 {
+	/* To verify that the layers are sequentially ordered. */
+	uint32_t i = 0;
+
 	return
 		c2_composite_layout_bob_check(cl) &&
 		c2_layout__invariant(&cl->cl_base) &&
@@ -203,6 +217,7 @@ static bool composite_invariant(const struct c2_composite_layout *cl)
 		cl->cl_layers_nr == c2_layer_tlist_length(cl->cl_layers) &&
 		c2_tl_forall(c2_layer, layer, cl->cl_layers,
 			     c2_layout__invariant(layer->clr_l) &&
+			     layer->clr_idx == i++ &&
 			     ergo(layer->clr_idx == 0,
 				  layer->clr_extents_nr == 0 &&
 				  layer->clr_extents == NULL) &&
@@ -214,6 +229,39 @@ static bool composite_invariant(const struct c2_composite_layout *cl)
 							layer->clr_extents)));
 }
 
+#if 0
+static bool composite_invariant(const struct c2_composite_layout *cl)
+{
+	uint32_t i = 0;
+
+	return
+		c2_composite_layout_bob_check(cl) &&
+		c2_layout__invariant(&cl->cl_base) &&
+		cl->cl_layers != NULL &&
+		cl->cl_layers_nr > 0 &&
+		cl->cl_layers_nr == c2_layer_tlist_length(cl->cl_layers) &&
+		c2_tl_forall(c2_layer, layer, cl->cl_layers,
+			     c2_layout__invariant(layer->clr_l) &&
+			     layer->clr_idx == i++ && //todo rm
+			     ergo(layer->clr_idx == 0,
+				  layer->clr_extents_nr == 0 &&
+				  layer->clr_extents == NULL) &&
+			     ergo(layer->clr_idx > 0,
+				  layer->clr_extents != NULL &&
+				  layer->clr_extents_nr > 0 &&
+			          layer->clr_extents_nr ==
+			          c2_layer_extent_tlist_length(
+							layer->clr_extents) &&
+				  layer->clr_extents_nr == 1 &&
+				  c2_tl_forall(c2_layer_extent, extent,
+					       layer->clr_extents,
+					       extent->cle_ext.e_start ==
+					       1400900 &&
+					       extent->cle_ext.e_end ==
+					       70745449)));
+}
+#endif
+
 static const struct c2_layout_ops composite_ops;
 /* Implementation of lto_allocate for COMPOSITE layout type. */
 static int composite_allocate(struct c2_layout_domain *dom,
@@ -284,6 +332,11 @@ static int layer_in_memory_write(struct c2_composite_layout *cl,
 {
 	struct c2_composite_layer *layer;
 
+	C2_PRE(ergo(cl->cl_layers_nr == 0, composite_allocated_invariant(cl)));
+	C2_PRE(ergo(cl->cl_layers_nr > 0, composite_invariant(cl)));
+	C2_PRE(ergo(cl->cl_layers_nr == 0, extlist == NULL && ext_nr == 0));
+	C2_PRE(ergo(cl->cl_layers_nr > 0, extlist != NULL && ext_nr > 0));
+
 	C2_ALLOC_PTR(layer);
 	C2_ASSERT(layer != NULL); //todo handle error
 
@@ -520,31 +573,127 @@ static int seg_free(struct c2_composite_layer *layer,
 	//return val < LRET_MIN ? ad_free(cl, &tocut) : 0;
 	return val == 0 ? layer_extent_free(layer, &tocut) : 0;
 }
+#endif
+
+#if 0
+/**
+ * Handles extent deletion.
+ */
+static void extent_delete(struct c2_emap_seg *seg)
+{
+	C2_ASSERT(0);
+}
+
+/**
+ * Cuts left - Cuts 'an extent that is left to the extent supplied', in the
+ * list of extents stored in the layer that is from the inmemory version of
+ * the composite layout).
+ */
+static void cut_left(struct c2_emap_seg *seg,
+		     struct c2_ext *ext,
+		     uint64_t val)
+{
+	struct c2_composite_layer_extent *extent;
+
+#if 0
+	if (c2_emap_ext_is_first(&seg->ee_ext) && val == LRET_INVALID) {
+		/*
+		 * Nothing to be done since it is the left most but invalid
+		 * segment that exists in the DB only for the sake of
+		 * implemtation of the DB version of the layer's extent map.
+		 */
+		return;
+	}
+#endif
+
+	/* Delete the previous extent by making use of _tlist_prev() */
+	//C2_ASSERT(0);
+	extent = c2_layer_extent_tlist_prev(layer->clr_extents);
+	C2_ASSERT(extent != NULL);
+}
+
+/**
+ * Cuts right.
+ */
+static void cut_right(struct c2_emap_seg *seg,
+		      struct c2_ext *ext,
+		      uint64_t val)
+{
+	if (c2_emap_ext_is_last(&seg->ee_ext) && val == LRET_INVALID) {
+		/*
+		 * Nothing to be done since it is the right most but invalid
+		 * segment that exists in the DB only for the sake of
+		 * implemtation of the DB version of the layer's extent map.
+		 */
+		return;
+	}
+
+	/* Delete the next extent by making use of _tlist_next() */
+	C2_ASSERT(0);
+}
+#endif
 
-static int extent_adjust(struct c2_emap_cursor *it,
-			 struct c2_composite_layer *layer,
-			 struct c2_ext *ext
-			 /* todo seg state */)
+#ifndef __KERNEL__
+static int ext_inmemory_adjust(const struct c2_composite_layer *layer,
+			       const struct c2_emap_seg *seg,
+			       const struct c2_ext *ext,
+			       uint64_t val)
+{
+	C2_LOG(C2_DEBUG, "layer[%lu]: seg e_start %llu, seg e_end %llu, "
+	       "seg val %llu, e_start %llu, e_end %llu",
+	       (unsigned long)layer->clr_idx,
+	       (unsigned long long)seg->ee_ext.e_start,
+	       (unsigned long long)seg->ee_ext.e_end,
+	       (unsigned long long)seg->ee_val,
+	       (unsigned long long)ext->e_start,
+	       (unsigned long long)ext->e_end);
+
+	return 0;
+}
+#endif /* __KERNEL__ */
+
+static int extent_add(struct c2_emap_cursor *it,
+		      const struct c2_composite_layer *layer,
+		      struct c2_ext *ext
+		      /* todo seg state */)
 {
 	int rc;
+	//Check about the locking
 
 	C2_LOG(C2_DEBUG, "layer idx %lu, e_start %llu, e_end %llu",
 	       (unsigned long)layer->clr_idx,
 	       (unsigned long long)ext->e_start,
 	       (unsigned long long)ext->e_end);
-
 	/*
 	 * todo seg->ee_val shall not be read as sublayout-id but
 	 * the sublayout-id shall be read from another table.
 	 */
+#ifndef __KERNEL__
+	/* LAMBDA is not available for the kernel mode. */
 
-
-	rc = c2_emap_paste(it, ext, /* todo LRET_MIN */,
+	/*
+	 * Insert a new segment into the layer's extent map, overwriting
+	 * parts of the map, as applicable.
+	 *
+	 * Some existing segments are deleted completely, others are cut.
+	 * c2_emap_paste invokes supplied call-backs to notify the caller about
+	 * the changes in the map.
+	 *
+	 * Call-backs are used to adjust the extents in the in-memory list of
+	 * extents for the specific layer.
+	 *
+	 * Each call-back takes a segment argument, seg. seg->ee_ext is an
+	 * extent associated with the specified layer (todo) and seg->ee_val
+	 * is the state of the extent.
+	 */
+	rc = c2_emap_paste(it, ext, LRET_VALID,
 			   LAMBDA(void, (struct c2_emap_seg *seg) {
 				/* Handle extent deletion. */
-				rc = rc ?: seg_free(layer, seg,
-				//todo optimize number of args ?
-						    &seg->ee_ext, seg->ee_val);
+					//todo optimize number of args ?
+				rc = rc ?: ext_inmemory_adjust(layer,
+							       seg,
+							       &seg->ee_ext,
+							       seg->ee_val);
 			   }),
 			   LAMBDA(void, (struct c2_emap_seg *seg,
 					 struct c2_ext *ext,
@@ -552,20 +701,29 @@ static int extent_adjust(struct c2_emap_cursor *it,
 				/* Cut left. */
 				C2_ASSERT(ext->e_start > seg->ee_ext.e_start);
 				seg->ee_val = val;
-				rc = rc ?: seg_free(layer, seg, ext, val);)
+				rc = rc ?: ext_inmemory_adjust(layer,
+							       seg,
+							       &seg->ee_ext,
+							       seg->ee_val);
 			   }),
 			   LAMBDA(void, (struct c2_emap_seg *seg,
 					 struct c2_ext *ext,
 					 uint64_t val) {
 				/* Cur right. */
 				C2_ASSERT(seg->ee_ext.e_end > ext->e_end);
-				if (val > 0) {
+
+				rc = rc ?: ext_inmemory_adjust(layer,
+							       seg,
+							       &seg->ee_ext,
+							       seg->ee_val);
+/*
+//from ad.c, tune it.
+				if (val == LRET_VALID) {
+
+						       seg->ee_ext.e_start);
 					seg->ee_val = val +
 						      (ext->e_end -
 
-/*						       seg->ee_ext.e_start);
----if 0
-//from ad.c, tune it.
 					*
 					 * Free physical sub-extent, but only
 					 * when sub-extent starts at the left
@@ -578,15 +736,18 @@ static int extent_adjust(struct c2_emap_cursor *it,
 						rc = rc ?: seg_free(io, adom,
 								    seg, ext,
 								    val);
----endif
-*/
 				} else
 					seg->ee_val = val;
+*/
 			   }));
-	C2_ASSERT(rc == 0); //todo Handle error
+
+#else
+	C2_ASSERT(0);
+	rc = -EPROTO;
+#endif /* __KERNEL__ */
+
 	return rc;
 }
-#endif
 
 static int sublayout_id_in_db_read(struct composite_schema_data *csd,
 				   struct c2_db_tx *tx,
@@ -602,7 +763,7 @@ static int sublayout_id_in_db_read(struct composite_schema_data *csd,
 	key.lrsmk_comp_lid = composite_lid;
 	key.lrsmk_layer_idx = layer_idx;
 	key.lrsmk_pad = 0;
-	rec.lrsmr_sublayout_lid = 0; /* This will be overwritten. */
+	rec.lrsmr_sublayout_lid = 0; /* To be overwritten with the lookup. */
 	c2_db_pair_setup(&pair, &csd->csd_layer_sublayout,
 			 &key, sizeof key, &rec, sizeof rec);
 	rc = c2_table_lookup(tx, &pair);
@@ -661,16 +822,17 @@ static int sublayout_id_in_db_write(struct composite_schema_data *csd,
 	return rc;
 }
 
-static int extentmap_in_db_write(const struct c2_composite_layout *cl,
+static int extentmap_in_db_write(struct c2_composite_layout *cl,
 				 const struct c2_composite_layer *layer,
 				 bool if_extents_associated,
 				 struct c2_db_tx *tx)
 {
 	struct composite_schema_data     *csd;
 	struct c2_emap                   *emap;
-	struct c2_composite_layer_extent *extent;
 	struct c2_emap_cursor             it;
+	struct c2_composite_layer_extent *extent;
 	struct c2_emap_seg               *seg;
+	struct c2_ext                     ext;
 	struct layout_prefix              prefix;
 	int                               rc;
 
@@ -678,7 +840,7 @@ static int extentmap_in_db_write(const struct c2_composite_layout *cl,
 	emap = &csd->csd_layer_ext_map;
 	prefix_set(&prefix, cl->cl_base.l_id, layer->clr_idx);
 	rc = c2_emap_obj_insert(emap, tx, (struct c2_uint128 *)&prefix,
-				LRET_NONE);
+				LRET_INVALID);
 	C2_ASSERT(rc == 0); // todo || rc == -EEXIST); //todo handle err
 	if (rc == -EEXIST)
 		return rc; //todo ADDB rec etc.
@@ -691,30 +853,32 @@ static int extentmap_in_db_write(const struct c2_composite_layout *cl,
 	seg = c2_emap_seg_get(&it);
 	C2_ASSERT(seg->ee_ext.e_start == 0);
 	C2_ASSERT(seg->ee_ext.e_end == C2_BINDEX_MAX + 1);
-	C2_ASSERT(seg->ee_val == LRET_NONE);
+	C2_ASSERT(seg->ee_val == LRET_INVALID);
 
 	C2_LOG(C2_DEBUG, "layer[%lu]: sublayout_lid %llu",
 	       (unsigned long)layer->clr_idx,
 	       (unsigned long long)layer->clr_l->l_id);
 
 	c2_tl_for(c2_layer_extent, layer->clr_extents, extent) {
-#if 0
-		//todo rc = extent_adjust(&it, &extent->cle_ext
-				   /* , seg state */);
+		ext = extent->cle_ext;
+		rc = extent_add(&it, layer, &ext);
 		C2_ASSERT(rc == 0); //todo Handle
-#endif
 	} c2_tl_endfor;
 	c2_emap_close(&it);
+
+
 	return rc;
 }
 
-static int layer_in_db_write(const struct c2_composite_layout *cl,
+static int layer_in_db_write(struct c2_composite_layout *cl,
 			     const struct c2_composite_layer *layer,
 			     struct c2_db_tx *tx)
 {
 	struct composite_schema_data *csd;
 	int                           rc;
 
+	C2_PRE(composite_invariant(cl));
+	/* Zeroth layer is already written through c2_layout_add(). */
 	C2_PRE(layer->clr_idx > 0);
 	C2_PRE(tx != NULL);
 
@@ -727,6 +891,7 @@ static int layer_in_db_write(const struct c2_composite_layout *cl,
 	rc = extentmap_in_db_write(cl, layer, true, tx);
 	C2_ASSERT(rc == 0); //todo Handle
 
+	C2_POST(composite_invariant(cl));
 	return rc;
 }
 
@@ -752,7 +917,6 @@ int c2_composite_layer_add(struct c2_composite_layout *cl,
 
 	rc = layer_in_memory_write(cl, sublayout, extlist, ext_nr, &layer);
 	C2_ASSERT(rc == 0); //todo Handle error
-	C2_ASSERT(layer->clr_idx > 0);
 
 	if (tx == NULL)
 		return rc; //todo Handle. What user space code shall do?
@@ -764,6 +928,7 @@ int c2_composite_layer_add(struct c2_composite_layout *cl,
 	 */
 	rc = layer_in_db_write(cl, layer, tx);
 
+	C2_POST(composite_invariant(cl));
 	C2_LEAVE(); //todo addb record
 	return rc;
 }
@@ -910,29 +1075,32 @@ static int extentmap_in_db_read(struct c2_emap *emap,
 
 	*extents_nr = 0;
 	seg = c2_emap_seg_get(&it);
-	C2_ASSERT(!c2_ext_is_empty(&seg->ee_ext));
-	//C2_ASSERT(C2_IN(seg->ee_val), ...); //todo Add after every c2_emap_seg_get
 	while (1) {
+		C2_ASSERT(seg != NULL);
+		C2_ASSERT(!c2_ext_is_empty(&seg->ee_ext));
+		//C2_ASSERT(C2_IN(seg->ee_val), ...); //todo Add after every c2_emap_seg_get
 		C2_ALLOC_PTR(extent);
 		C2_ASSERT(extent != NULL); //todo Handle error
 		extent->cle_ext = seg->ee_ext;
-		c2_layer_extent_tlink_init_at_tail(extent, *extents);
 		C2_LOG(C2_DEBUG, "layer[%lu], extent[%lu] "
-		       "e_start %llu, e_end %llu",
+		       "e_start %llu, e_end %llu, seg_val %llu",
 		       (unsigned long)layer_idx,
 		       (unsigned long)*extents_nr,
 		       (unsigned long long)seg->ee_ext.e_start,
-		       (unsigned long long)seg->ee_ext.e_end);
+		       (unsigned long long)seg->ee_ext.e_end,
+		       (unsigned long long)seg->ee_val);
 
-		++*extents_nr;
+		if (seg->ee_val != LRET_INVALID) {
+			c2_layer_extent_tlink_init_at_tail(extent, *extents);
+			++*extents_nr;
+		}
 		if (c2_emap_ext_is_last(&seg->ee_ext))
 			break;
 
 		c2_emap_next(&it);
 		seg = c2_emap_seg_get(&it);
-		C2_ASSERT(seg != NULL);
-		//C2_ASSERT(C2_IN(seg->ee_val), ...);
 	}
+
 	c2_emap_close(&it);
 
 	C2_POST(!c2_layer_extent_tlist_is_empty(*extents));
@@ -1116,14 +1284,15 @@ static int composite_layout_in_db_write(struct c2_composite_layout *cl,
 		rc = sublayout_id_in_db_write(csd, tx, cl, layer);
 		C2_ASSERT(rc == 0); //todo Handle
 
-		/* todo Make use of the function for this part */
 		/* Write 'the extent map for this layer' to the DB. */
 		rc = extentmap_in_db_write(cl, layer, false, tx);
 		C2_ASSERT(rc == 0); //todo Handle
 		/**
 		 * @todo In fact, there are no valid extents associated with
 		 * layer 0. So, do we need to make this extent entry with
-		 * LRET_NONE state to the layer_ext_map table?
+		 * LRET_INVALID state to the layer_ext_map table? Probably
+		 * not unless there is a chance that zeroth layer may need to
+		 * store some extents in future. Will it?
 		 */
 	}
 	return rc;
@@ -1156,7 +1325,7 @@ static int composite_encode(struct c2_layout *l,
 		/*
 		 * Read layers information from the composite layout and store
 		 * it in the buffer.
-		 * Move it into layers_in_cursor_write()
+		 * todo Move it into layers_in_cursor_write()
 		 */
 		C2_ASSERT(c2_bufvec_cursor_step(out) >= sizeof cl_header);
 		cl_header.ch_layers_nr = cl->cl_layers_nr;
diff --git a/layout/composite.h b/layout/composite.h
index 80cd23e..8716f05 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -148,7 +148,12 @@ int c2_composite_build(struct c2_layout_domain *dom,
 		       struct c2_layout *old_layout,
 		       struct c2_composite_layout **out);
 
-/** Adds a layer to the composite layout. */
+/**
+ * Adds a layer to the composite layout.
+ *
+ * @pre The Composite layout has already been added to the DB using
+ * c2_layout_add().
+ */
 /* todo Add op as another arg? */
 int c2_composite_layer_add(struct c2_composite_layout *cl,
 			   struct c2_layout *l,
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index e01cd68..4c6457a 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -58,6 +58,17 @@ static void sublayout_build(uint64_t lid, struct c2_layout **sublayout)
 	*sublayout = c2_pdl_to_layout(pl);
 }
 
+
+/* todo due to it being approximate_end_offset and not end_offset, the boundary
+ * condition of the last extent's e_end being equal to C2_BINDEX_MAX is not
+ * being tested. Change accordingly.
+00000036bb:0000000000:
+	00000 [               0 .. ffffffffffffffff) (ffffffffffffffff):                0
+00000036bb:0000000001:
+	00000 [               0 .. 7fffffffffffffff) (7fffffffffffffff):                1
+	00001 [7fffffffffffffff .. fffffffffffffffe) (7fffffffffffffff):                1
+	00002 [fffffffffffffffe .. ffffffffffffffff) (               1):                0    <----
+ */
 static void extentlist_build(struct c2_tl **extlist,
 			     uint32_t extents_nr,
 			     c2_bindex_t min_start_offset,
@@ -91,7 +102,7 @@ static void extentlist_build(struct c2_tl **extlist,
 		C2_UT_ASSERT(extent != NULL);
 		extent->cle_ext.e_start = min_start_offset +
 					  (multiplier * i * delta);
-		extent->cle_ext.e_end = extent->cle_ext.e_start + delta - 1;
+		extent->cle_ext.e_end = extent->cle_ext.e_start + delta;
 #ifndef __KERNEL__
 		printf("ext[%u]: start %llu, end %llu \n", i,
 			(unsigned long long)extent->cle_ext.e_start,
@@ -229,8 +240,7 @@ static void composite_layout_verify(struct c2_layout *l,
 					     min_start_offset +
 					     (multiplier * j * delta));
 				C2_UT_ASSERT(extent->cle_ext.e_end ==
-					     extent->cle_ext.e_start +
-					     delta - 1);
+					     extent->cle_ext.e_start + delta);
 				++j;
 			} c2_tl_endfor;
 			C2_UT_ASSERT(j == extents_nr);
@@ -310,6 +320,7 @@ static int composite_layers_add(struct c2_composite_layout *cl,
 		extentlist_build(&extents, extents_nr,
 				 min_start_offset, approximate_end_offset,
 				 if_contiguous_extents);
+
 		rc = c2_composite_layer_add(cl, sublayout, extents, extents_nr,
 					    tx);
 		C2_UT_ASSERT(rc == 0);
@@ -490,7 +501,7 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 		for (j = 0; j < layer_header.clh_extents_nr; ++j) {
 			ext.e_start = min_start_offset +
 				      multiplier * j * delta;
-			ext.e_end = ext.e_start + delta - 1;
+			ext.e_end = ext.e_start + delta;
 			nbytes = c2_bufvec_cursor_copyto(dcur, &ext,
 							 sizeof ext);
 			C2_ASSERT(nbytes == sizeof ext);
@@ -638,7 +649,7 @@ static void composite_layout_buf_verify(uint64_t lid,
 			c2_bufvec_cursor_move(cur, sizeof *ext);
 			C2_UT_ASSERT(ext->e_start == min_start_offset +
 						     multiplier * j * delta);
-			C2_UT_ASSERT(ext->e_end == ext->e_start + delta - 1);
+			C2_UT_ASSERT(ext->e_end == ext->e_start + delta);
 		}
 		//todo enable once c2_emap_paste works ++extents_nr;
 	}
@@ -932,6 +943,7 @@ static void composite_layout_copy(const struct c2_layout *l_src,
 		C2_UT_ASSERT(layer_dest != NULL);
 
 		layer_dest->clr_l = layer_src->clr_l;
+		layer_dest->clr_idx = layer_src->clr_idx;
 		layer_dest->clr_extents_nr = layer_src->clr_extents_nr;
 
 		if (layer_src->clr_idx == 0) {
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index ad1e882..0c3f2dc 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -819,7 +819,6 @@ static void test_build(void)
 	lid = 1005;
 	rc = test_build_composite(lid, &domain, 5, 100,
 				  lid * 100, lid * 100 * 100,
-				  //0, C2_BINDEX_MAX,
 				  CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 
@@ -830,7 +829,17 @@ static void test_build(void)
 	lid = 1006;
 	rc = test_build_composite(lid, &domain, 6, 100,
 				  lid * 100, lid * 100 * 100,
-				  //0, C2_BINDEX_MAX,
+				  !CONTIGUOUS_EXTENTS, !FAILURE_TEST);
+	C2_UT_ASSERT(rc == 0);
+
+	/*
+	 * Build a layout object with COMPOSITE layout type, with noncontiguous
+	 * extents in its layers and with the extents with the range from 0 to
+	 * C2_BINDEX_MAX and destroy it.
+	 */
+	lid = 1007;
+	rc = test_build_composite(lid, &domain, 6, 100,
+				  0, C2_BINDEX_MAX,
 				  !CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 }
@@ -1147,7 +1156,6 @@ static void test_decode(void)
 	lid = 3005;
 	rc = test_decode_composite(lid, &domain, 7, 10,
 				   lid * 100, lid * 100 * 100,
-				   //0, C2_BINDEX_MAX,
 				   CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 
@@ -1158,9 +1166,11 @@ static void test_decode(void)
 	lid = 3006;
 	rc = test_decode_composite(lid, &domain, 8, 10,
 				   lid * 100, lid * 100 * 100,
-				   //0, C2_BINDEX_MAX,
 				   !CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
+
+
+	//todo ? 0, C2_BINDEX_MAX,
 }
 
 static void test_decode_failure(void)
@@ -1452,7 +1462,6 @@ static void test_encode(void)
 	lid = 5005;
 	rc = test_encode_composite(lid, &domain, 9, 25,
 				   lid * 100, lid * 100 * 100,
-				   //0, C2_BINDEX_MAX,
 				   CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 
@@ -1463,9 +1472,10 @@ static void test_encode(void)
 	lid = 5006;
 	rc = test_encode_composite(lid, &domain, 10, 25,
 				   lid * 100, lid * 100 * 100,
-				   //0, C2_BINDEX_MAX,
 				   !CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
+
+	//todo ? 0, C2_BINDEX_MAX,
 }
 
 static void test_encode_failure(void)
@@ -1760,7 +1770,6 @@ static void test_decode_encode(void)
 	lid = 7005;
 	rc = test_decode_encode_composite(lid, &domain, 11, 21,
 					  lid * 100, lid * 10 * 100,
-					  //0, C2_BINDEX_MAX,
 					  CONTIGUOUS_EXTENTS);
 	C2_UT_ASSERT(rc == 0);
 }
@@ -2105,7 +2114,6 @@ static void test_encode_decode(void)
 	lid = 8005;
 	rc = test_encode_decode_composite(lid, &domain, 7, 27,
 					  lid * 100, lid * 100 * 100,
-					  //0, C2_BINDEX_MAX,
 					  CONTIGUOUS_EXTENTS);
 	C2_UT_ASSERT(rc == 0);
 }
@@ -3032,26 +3040,50 @@ static void test_lookup(void)
 	rc = test_lookup_composite(lid, &domain,
 				   7, 107,
 				   lid * 100, lid * 100 * 100,
-				   //0, C2_BINDEX_MAX,
 				   !CONTIGUOUS_EXTENTS,
 				   !EXISTING_TEST,
 				   FAILURE_TEST);
 	C2_UT_ASSERT(rc == -ENOENT);
 
-#if 1 //Nov 22 Need to preseve the sublayouts
 	/*
 	 * Add a layout object with COMPOSITE layout type. Then perform lookup
 	 * for it.
 	 */
 	lid = 14009;
 	rc = test_lookup_composite(lid, &domain,
-				   10, 1, /* todo 2, 108 */
+				   2, 2, /* 10, 108, */ /* 2, 5, */
 				   lid * 100, lid * 100 * 100,
-				   //0, C2_BINDEX_MAX,
 				   !CONTIGUOUS_EXTENTS,
 				   EXISTING_TEST,
 				   !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
+
+	/*
+	 * Add a layout object with COMPOSITE layout type. Then perform lookup
+	 * for it.
+	 */
+	lid = 14010;
+	rc = test_lookup_composite(lid, &domain,
+				   /* todo 10, 108 */ 2, 5,
+				   lid * 100, lid * 100 * 100,
+				   CONTIGUOUS_EXTENTS,
+				   EXISTING_TEST,
+				   !FAILURE_TEST);
+	C2_UT_ASSERT(rc == 0);
+
+#if 1 //todo
+	/*
+	 * Add a layout object with COMPOSITE layout type. Then perform lookup
+	 * for it.
+	 */
+	lid = 14011;
+	rc = test_lookup_composite(lid, &domain,
+				   2, 2, /* 10, 108, */ /* 2, 5, */
+				   0, C2_BINDEX_MAX,
+				   CONTIGUOUS_EXTENTS,
+				   EXISTING_TEST,
+				   !FAILURE_TEST);
+	C2_UT_ASSERT(rc == 0);
 #endif
 }
 
@@ -3298,9 +3330,18 @@ static void test_add(void)
 	/* Add a layout object with COMPOSITE layout type. */
 	/* todo This test has mem leak of about 30 KB */
 	lid = 16005;
-	rc = test_add_composite(lid, &domain, 7 /* todo 7 */, 2 /* todo 107 */,
+	rc = test_add_composite(lid, &domain, 7, 5, /* todo 7, 107 */
 				lid * 100, lid * 100 * 100,
-				//0, C2_BINDEX_MAX,
+				!CONTIGUOUS_EXTENTS,
+				LAYOUT_DESTROY, NULL,
+				!DUPLICATE_TEST,
+				!FAILURE_TEST);
+	C2_UT_ASSERT(rc == 0);
+
+	/* Add a layout object with COMPOSITE layout type. */
+	lid = 16006;
+	rc = test_add_composite(lid, &domain, 7, 5, /* todo 7, 107 */
+				0, C2_BINDEX_MAX,
 				!CONTIGUOUS_EXTENTS,
 				LAYOUT_DESTROY, NULL,
 				!DUPLICATE_TEST,
-- 
1.8.3.2

