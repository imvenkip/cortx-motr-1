From 723f4f9d38f0f8f362a105406debe6b5d396f0ca Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Tue, 12 Feb 2013 18:29:17 +0530
Subject: [PATCH 062/157] Some issues fixed with the extent list manipulations

---
 layout/composite.c    | 302 ++++++++++++++++++++++++++++++++++++--------------
 layout/ut/composite.c | 180 +++++++++++++++++++++---------
 layout/ut/composite.h |   2 +
 layout/ut/layout.c    |  38 +------
 4 files changed, 353 insertions(+), 169 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index b794ba4..6a9b5e1 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -193,7 +193,7 @@ static bool composite_invariant(const struct m0_composite_layout *cl)
  */
 static bool layer_invariant(const struct m0_composite_layer *layer)
 {
-	struct m0_composite_layer_extent *extent;
+	struct m0_composite_layer_extent *lr_ext;
 	m0_bindex_t                       addr = 0;
 	uint32_t                          i = 0;
 
@@ -206,21 +206,14 @@ static bool layer_invariant(const struct m0_composite_layer *layer)
 	 * Since assignment can not be performed in a m0_tl_forall() loop,
 	 * it has not been used in this invariant.
 	 */
-	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, extent) {
-		M0_ASSERT(extent->cle_ext.e_start == addr);
-		addr = extent->cle_ext.e_end;
-#if 0
-		M0_ASSERT(ergo(i == 0, extent->cle_ext.e_start == 0));
-		M0_ASSERT(ergo(i == layer->clr_extents_nr - 1,
-			  extent->cle_ext.e_end == M0_BINDEX_MAX + 1));
-#endif
-#if 1
-		if (i == 0 && extent->cle_ext.e_start != 0)
+	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+		M0_ASSERT(lr_ext->cle_ext.e_start == addr);
+		addr = lr_ext->cle_ext.e_end;
+		if (i == 0 && lr_ext->cle_ext.e_start != 0)
 			return false;
 		if (i == layer->clr_extents_nr - 1 &&
-		    extent->cle_ext.e_end != M0_BINDEX_MAX + 1)
+		    lr_ext->cle_ext.e_end != M0_BINDEX_MAX + 1)
 			return false;
-#endif
 		++i;
 	} m0_tl_endfor;
 	return true;
@@ -648,7 +641,7 @@ static int ext_in_memory_find(struct m0_composite_layer *layer,
 
 	if (ext_found) {
 		rc = 0;
-		if (lr_ext != NULL)
+		if (lr_ext_out != NULL)
 			*lr_ext_out = lr_ext;
 	} else
 		rc = -ENOENT;
@@ -667,6 +660,9 @@ static int ext_in_memory_find(struct m0_composite_layer *layer,
 	M0_RETURN(rc);
 }
 
+//todo Create another common subroutine from this that does not care for the
+//layer invariant
+
 //to Use this fn where applicable to avoid code duplication e.g. in
 //extlist_in_buf_read() but this adds before and not at tail. So, a flag will
 //be required
@@ -677,11 +673,12 @@ static int ext_add_internal(struct m0_composite_layer *layer,
 			    bool is_add_after)
 {
 	struct m0_composite_layer_extent *lr_ext1;
-	struct m0_composite_layer_extent *lr_ext2; //todo rm
-	int                               rc; //todo rm
+	//struct m0_composite_layer_extent *lr_ext2; //todo rm
+	//int                               rc; //todo rm
 
 	M0_PRE(m0_composite_layer_ext_tlink_is_in(adjacent_lr_ext));
-#if 1 //todo rm
+	M0_PRE(!m0_ext_is_empty(ext));
+#if 0 //todo rm
 	rc = ext_in_memory_find(layer, &adjacent_lr_ext->cle_ext,
 				adjacent_lr_ext->cle_state, &lr_ext2);
 	M0_ASSERT(rc == 0);
@@ -725,13 +722,20 @@ static int ext_add_internal(struct m0_composite_layer *layer,
 static void ext_del_internal(struct m0_composite_layer *layer,
 			     struct m0_composite_layer_extent *lr_ext)
 {
+#ifndef __KERNEL__
+	printf("ext_del_internal(): lid %llu, layer %lu, \n"
+		"\te_start %llu, e_end %llu, \n",
+		 (unsigned long long)layer->clr_l->l_id,
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)lr_ext->cle_ext.e_start,
+		 (unsigned long long)lr_ext->cle_ext.e_end);
+#endif
 	m0_composite_layer_ext_tlist_del(lr_ext);
 	m0_composite_layer_ext_tlink_fini(lr_ext);
 	m0_free(lr_ext);
 	M0_CNT_DEC(layer->clr_extents_nr);
 }
 
-#ifndef __KERNEL__
 //todo check placement of this and a few of the following functions
 /**
  * @pre Since this function is used in the context of the callback from
@@ -812,6 +816,7 @@ static int ext_in_memory_add(struct m0_composite_layer *layer,
 	M0_RETURN(0);
 }
 
+#ifndef __KERNEL__
 /** Trims the existing extent as requested. */
 static int ext_in_memory_trim(struct m0_composite_layer *layer,
 			      enum extent_op extent_op,
@@ -875,7 +880,7 @@ static int ext_in_memory_delete(struct m0_composite_layer *layer,
 	bool                              lr_ext_to_delete_found;
 	int                               rc;
 
-	M0_PRE(old_ext_state != M0_CLRES_INVALID);
+	//todo rm M0_PRE(old_ext_state != M0_CLRES_INVALID);
 #ifndef __KERNEL__
 	printf("ext_in_memory_delete(): lid %llu, layer %lu, "
 		"e_start %llu, e_end %llu, old_e_state %llu, ext %p\n",
@@ -958,12 +963,14 @@ static int ext_in_memory_adjust(struct m0_composite_layer *layer,
 		 (ext != NULL) ? (unsigned long long)ext->e_start : 0,
 		 (ext != NULL) ? (unsigned long long)ext->e_end : 0);
 
+#if 0 //todo Feb 12
 	/*
 	 * Extents with the state M0_CLRES_INVALID are not stored in the
 	 * in-memory list of the extents. Hence, return right away.
 	 */
 	if (seg->ee_val == M0_CLRES_INVALID)
 		M0_RETURN(0);
+#endif
 
 	if (extent_op == DELETE)
 		/*
@@ -1014,23 +1021,20 @@ static int ext_in_db_write(struct m0_emap_cursor *it,
 		 (unsigned long long)ext_to_operate->e_end,
 		 (unsigned long long)new_ext_state,
 		 in_memory_list_update ? 1 : 0, ext_to_operate);
-
 	M0_PRE(layer_invariant(layer));
 
-
 	/*
 	 * Insert a new segment into the layer's extent map, overwriting
 	 * parts of the map, as applicable.
 	 *
 	 * Some existing segments are deleted completely, others are cut.
 	 * m0_emap_paste() invokes supplied call-backs to notify the caller
-	 * about the changes in the map.
-	 *
-	 * Call-backs are used to adjust the extents in the in-memory list of
-	 * the extents for the specific layer.
+	 * about the changes in the map. These call-backs are used to adjust
+	 * the extents in the in-memory list of the extents for the specific
+	 * layer.
 	 *
-	 * Each call-back takes a segment argument, viz. seg. seg->ee_ext is an
-	 * extent associated with the specified layer as is stored in the
+	 * Each call-back takes a segment argument, viz. seg. seg->ee_ext is
+	 * an extent associated with the specified layer as is stored in the
 	 * on-disk extent map and seg->ee_val is the state of that extent.
 	 *
 	 * Here is an example to illustrate the sequence of the operations
@@ -1118,14 +1122,13 @@ static int ext_in_db_write(struct m0_emap_cursor *it,
 
 	if (rc == 0 && in_memory_list_update) {
 		/*
-		 * Now that the deletion of the extents from the in-memory list
-		 * of the extents (if appplicable) has been handled through the
-		 * usage of ext_in_memory_adjust() as above, let's add the
-		 * extent to the in-memory list of the extents (if applicable).
-		 *
-		 * Extents with the state M0_CLRES_INVALID are not stored in
-		 * the in-memory list of the extents. Hence, the latter
-		 * condition above.
+		 * Now that the deletion/trimming of the overlapping extents
+		 * from the in-memory list of the extents has been
+		 * handled above, let's add the ultimate whole extent.
+		 */
+		/*
+		 * todo Handle the case that there may be existing INVALID ext.
+		 * Refer to ext_add_in_mem().
 		 */
 		rc = ext_in_memory_find(layer, ext_to_operate, new_ext_state,
 					NULL);
@@ -1334,7 +1337,8 @@ static int extmap_in_db_add(struct m0_composite_layout *cl,
 	M0_ASSERT(seg->ee_val == M0_CLRES_INVALID);
 
 	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
-		M0_ASSERT(M0_IN(lr_ext->cle_state, (M0_CLRES_VALID,
+		M0_ASSERT(M0_IN(lr_ext->cle_state, (M0_CLRES_INVALID,
+						    M0_CLRES_VALID,
 						    M0_CLRES_FLATTENING)));
 		rc = ext_in_db_write(&it, layer, &lr_ext->cle_ext,
 				     lr_ext->cle_state, false);
@@ -1424,6 +1428,8 @@ M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
 	 * The following fault injection point helps testing encode decode
 	 * operations on 'an in-memory composite layout with having some
 	 * layers added to it', but without having dependency on the DB.
+	 *
+	 * todo Get rid of this now that in-mem-only ops are supported on layer
 	 */
 	if (M0_FI_ENABLED("skip_DB_sync")) { goto DB_sync_skipped; }
 
@@ -1513,7 +1519,8 @@ static int extlist_in_buf_read(struct m0_composite_layout *cl,
 		m0_bufvec_cursor_move(cur, sizeof *ext_state);
 
 		if (m0_ext_is_empty(ext) ||
-		    !M0_IN(*ext_state, (M0_CLRES_VALID,
+		    !M0_IN(*ext_state, (M0_CLRES_INVALID,
+					M0_CLRES_VALID,
 				        M0_CLRES_FLATTENING))) {
 			m0_layout__log("extlist_in_buf_read",
 				       "Invalid extent found in the buffer",
@@ -1915,7 +1922,7 @@ static void comp_layout_in_buf_write(const struct m0_composite_layout *cl,
 	/* Write composite layout header into the buffer. */
 	M0_ASSERT(m0_bufvec_cursor_step(out) >= sizeof cl_header);
 	cl_header.ch_layers_nr = cl->cl_layers_nr;
-	cl_header.ch_pad       = 0;
+	cl_header.ch_pad = 0;
 	nbytes = m0_bufvec_cursor_copyto(out, &cl_header, sizeof cl_header);
 	M0_ASSERT(nbytes == sizeof cl_header);
 
@@ -2101,9 +2108,16 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
 	M0_LEAVE("lid %llu, offset %llu, rc %d, layer_id %lu",
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long long)offset, rc, (unsigned long)*layer_idx);
+#ifndef __KERNEL__
+	printf("m0_composite_layer_ext_lookup(): lid %llu, offset %llu, "
+		"rc %d, layer_id %lu\n",
+		(unsigned long long)cl->cl_base.l_id,
+		(unsigned long long)offset, rc, (unsigned long)*layer_idx);
+#endif
 	return rc;
 }
 
+//todo Rename to ext_split_in...
 static int extent_split_internal(struct m0_composite_layer *layer,
 				 struct m0_composite_layer_extent *lr_ext,
 				 struct m0_indexvec *vec,
@@ -2156,7 +2170,7 @@ static int extent_split_internal(struct m0_composite_layer *layer,
 	M0_ASSERT(rc == 0);
 #endif
 	ext_del_internal(layer, lr_ext);
-	M0_POST(layer_invariant(layer));
+	//M0_POST(layer_invariant(layer));
 	return rc;
 }
 
@@ -2167,14 +2181,19 @@ static int ext_add_in_mem(struct m0_composite_layout *cl,
 			  uint64_t ext_state)
 {
 	struct m0_composite_layer_extent *lr_ext;
+	struct m0_composite_layer_extent *next_lr_ext;
+	struct m0_composite_layer_extent *lr_ext_to_del;
+	struct m0_composite_layer_extent *lr_ext_to_del1; //todo rm
 	struct m0_composite_layer_extent *ext_to_insert_into;
 	uint64_t                          ext_state_orig;
 	struct m0_ext                    *chunk;
 	const struct m0_ext               ext0 = *ext;
 	uint32_t                          i; //todo rm
 	int                               rc;
+	int                               rc1;
 
 	M0_PRE(composite_invariant(cl));
+	M0_PRE(!m0_ext_is_empty(ext));
 	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu",
 		 (unsigned long long)layer->clr_l->l_id,
 		 (unsigned long)layer->clr_idx,
@@ -2190,10 +2209,10 @@ static int ext_add_in_mem(struct m0_composite_layout *cl,
 	} m0_tl_endfor;
 	M0_ASSERT(ext_to_insert_into != NULL);
 #ifndef __KERNEL__
-	printf("ext_add_in_mem(): lid %llu, layer %lu, e_start %llu, "
-		"e_end %llu, e_state %llu, "
-		"ext_to_insert_into_start %llu, "
-		"ext_to_insert_into_end %llu\n",
+	printf("ext_add_in_mem(1): lid %llu, layer %lu, \n"
+		"\te_start %llu, e_end %llu, e_state %llu, \n"
+		"\text_to_insert_into_start %llu, \n "
+		"\text_to_insert_into_end %llu\n",
 		 (unsigned long long)layer->clr_l->l_id,
 		 (unsigned long)layer->clr_idx,
 		 (unsigned long long)ext->e_start,
@@ -2203,6 +2222,13 @@ static int ext_add_in_mem(struct m0_composite_layout *cl,
 		 (unsigned long long)ext_to_insert_into->cle_ext.e_end);
 #endif
 
+	if (ext_to_insert_into->cle_ext.e_start == ext->e_start &&
+	    ext_to_insert_into->cle_ext.e_end == ext->e_end &&
+	    ext_to_insert_into->cle_state == ext_state)
+		/* The exact extent already exists. */
+		M0_RETURN(0);
+
+	/* todo check if chunk shall not be a pointer. */
 	chunk = &ext_to_insert_into->cle_ext;
 	M0_ASSERT(m0_ext_is_in(chunk, ext->e_start));
 	M0_ASSERT(layer_invariant(layer));
@@ -2226,7 +2252,9 @@ static int ext_add_in_mem(struct m0_composite_layout *cl,
 		m0_bindex_t    bstart[3] = { 0 };
 		m0_bcount_t    consumed;
 		struct m0_ext  clip;
-#if 1
+		bool           split_required;
+		bool           delete_required;
+#if 1 //todo Probably don't need it to be a vector
 		struct m0_indexvec vec = {
 			.iv_vec = {
 				.v_nr    = 3,
@@ -2244,7 +2272,6 @@ static int ext_add_in_mem(struct m0_composite_layout *cl,
 		length[0] = clip.e_start - chunk->e_start;
 		length[1] = clip.e_end == ext->e_end ? m0_ext_length(&ext0) : 0;
 		length[2] = chunk->e_end - clip.e_end;
-		M0_ASSERT(length[0] != 0 || length[1] != 0 || length[2] != 0);
 
 		bstart[0] = ext_state;
 		ext_state_orig = ext_to_insert_into->cle_state;
@@ -2253,56 +2280,168 @@ static int ext_add_in_mem(struct m0_composite_layout *cl,
 			bstart[0] = ext_state_orig;
 		if (length[2] > 0)
 			bstart[2] = ext_state_orig;
+#ifndef __KERNEL__
+	printf("ext_add_in_mem(2): i %lu, lid %llu, layer %lu \n"
+		"\te_start %llu, e_end %llu \n"
+		"\text_to_insert_into_start %llu, \n"
+		"\text_to_insert_into_end %llu\n"
+		"\tchunk_start %llu, chunk_end %llu\n "
+		"\tclip_start %llu, clip_end %llu \n"
+		"\tlength[0] %llu, bstart[0], %llu \n"
+		"\tlength[1] %llu, bstart[1],%llu \n"
+		"\tlength[2] %llu, bstart[2] %llu \n",
+		(unsigned long)i, (unsigned long long)layer->clr_l->l_id,
+		(unsigned long)layer->clr_idx,
+		(unsigned long long)ext->e_start,
+		(unsigned long long)ext->e_end,
+		(unsigned long long)ext_to_insert_into->cle_ext.e_start,
+		(unsigned long long)ext_to_insert_into->cle_ext.e_end,
+		(unsigned long long)chunk->e_start,
+		(unsigned long long)chunk->e_end,
+		(unsigned long long)clip.e_start,
+		(unsigned long long)clip.e_end,
+		(unsigned long long)length[0], (unsigned long long)bstart[0],
+		(unsigned long long)length[1], (unsigned long long)bstart[1],
+		(unsigned long long)length[2], (unsigned long long)bstart[2]);
+#endif
 
-		if (!(length[0] == 0 && length[2] == 0)) {
-			rc = extent_split_internal(layer, ext_to_insert_into,
-						   &vec,
-						   length[0] > 0 ?
-						   chunk->e_start :
-						   ext0.e_start);
-			if (rc != 0)
-				break;
-		} else {
-			/* There is no need to split the existing extent. */
-			M0_ASSERT(length[1] ==
-				  m0_ext_length(&ext_to_insert_into->cle_ext));
-			rc = 0;
+		split_required  = true;
+		delete_required = false;
+		lr_ext_to_del   = NULL;
+		next_lr_ext     = NULL;
+		if (length[0] == 0 && length[2] == 0) {
+			//todo Feb 12 Optimize this block
+			delete_required = true;
+			lr_ext_to_del = ext_to_insert_into;
+
+			if (length[1] == 0)
+				split_required = false;
+#if 1
+			else {
+				if (ext_to_insert_into->cle_ext.e_start ==
+				    ext->e_start &&
+				    ext_to_insert_into->cle_ext.e_end ==
+				    ext->e_end)
+					split_required = false;
+					/* todo rm This is not correct
+					M0_ASSERT(length[1] ==
+						  m0_ext_length(ext));
+					*/
+				else
+					split_required = true;
+			}
+#endif
 		}
 
-		ext->e_start += consumed;
-		M0_ASSERT(ext->e_start <= ext->e_end);
-
+		/*
+		 * extent_split_internal() will replace the current
+		 * node (ext_to_insert_into) we are at, with multiple
+		 * smaller segments. Hence, store the next node before
+		 * invoking extent_split_internal().
+		 */
 		if (!m0_ext_is_empty(ext)) {
-#if 0
+			next_lr_ext = m0_composite_layer_ext_tlist_next(
+                                                        layer->clr_extents,
+                                                        ext_to_insert_into);
+
 			/*
 			 * If ext is not yet empty, ext_to_insert_into should
 			 * not be the last element of the list.
 			 */
-			M0_ASSERT(m0_tlist_tail(m0_composite_layer_ext_tlist,
-						layer->clr_extents) != NULL);
-#endif
-			ext_to_insert_into = m0_composite_layer_ext_tlist_next(
-                                                        layer->clr_extents,
-                                                        ext_to_insert_into);
+			M0_ASSERT(next_lr_ext != NULL);
+		}
+
 #ifndef __KERNEL__
-	printf("ext_add_in_mem(): i %lu, lid %llu, layer %lu, e_start %llu, "
-		"e_end %llu, ext_to_insert_into_start %llu, "
-		"ext_to_insert_into_end %llu\n",
-		 (unsigned long)i,
-		 (unsigned long long)layer->clr_l->l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end,
-		 (unsigned long long)ext_to_insert_into->cle_ext.e_start,
-		 (unsigned long long)ext_to_insert_into->cle_ext.e_end);
+		printf("ext_add_in_mem(4): i %lu, lid %llu, layer %lu, \n"
+			"\te_start %llu, e_end %llu, \n"
+			"\text_to_del_start %llu, ext_to_del_end %llu \n"
+			"\tdelete_reqd %d, split_reqd %d \n"
+			"\tnext_start %llu, next_end %llu \n",
+			(unsigned long)i,
+			(unsigned long long)layer->clr_l->l_id,
+			(unsigned long)layer->clr_idx,
+			(unsigned long long)ext->e_start,
+			(unsigned long long)ext->e_end,
+			lr_ext_to_del == NULL ? 0 :
+			(unsigned long long)lr_ext_to_del->cle_ext.e_start,
+			lr_ext_to_del == NULL ? 0 :
+			(unsigned long long)lr_ext_to_del->cle_ext.e_end,
+			delete_required, split_required,
+			next_lr_ext == NULL ? 0 :
+			(unsigned long long)next_lr_ext->cle_ext.e_start,
+			next_lr_ext == NULL ? 0 :
+			(unsigned long long)next_lr_ext->cle_ext.e_end);
 #endif
 
+		if (split_required) {
+			rc = extent_split_internal(layer, ext_to_insert_into,
+						   &vec,
+						   length[0] > 0 ?
+						   chunk->e_start :
+						   ext0.e_start);
+			if (rc != 0) //todo trace msg
+				break;
+		} else
+			rc = 0; //todo check if req'd
+
+		if (delete_required == true)
+			ext_del_internal(layer, lr_ext_to_del);
+
+		ext->e_start += consumed;
+		M0_ASSERT(ext->e_start <= ext->e_end);
+		if (!m0_ext_is_empty(ext)) {
+			ext_to_insert_into = next_lr_ext;
+			chunk = &ext_to_insert_into->cle_ext;
 			if (ext_to_insert_into == NULL)
 				break;
 		}
+
 		++i;
 	}
 
+	if (rc == 0) {
+		/*
+		 * Now that the deletion/trimming of the overlapping extents
+		 * has been handled above, let's add the ultimate whole extent.
+		 */
+		/*
+		 * This is not exactly right.
+		 * Shall query for the extent and its state and if it is inval
+		 * then add the ext
+		 * OR
+		 * change ext_in_memory_find() such that it returns ENOENT
+		 * if the ext is with the inval state
+		 */
+		rc = ext_in_memory_find(layer, &ext0, M0_CLRES_INVALID,
+					&lr_ext_to_del1);
+		// todo Feb 11 if (rc == -ENOENT) {
+		if (rc == 0) {
+			lr_ext_to_del1->cle_state = ext_state;
+#if 0
+			if (ext_state != M0_CLRES_INVALID) {
+				/* todo Refactor usage of ext_add_internal() so
+				 * that don't have to pass the adjacent ext
+				 */
+				/* todo Latest, don't add and then delete, just
+				 * change state of the existing ext.
+				 */
+				rc = ext_in_memory_add(layer, &ext0, ext_state);
+				M0_ASSERT(rc == 0);
+				ext_del_internal(layer, lr_ext_to_del1);
+				M0_ASSERT(rc == 0);
+			}
+#endif
+		} else {
+			rc1 = ext_in_memory_find(layer, &ext0, ext_state,
+						 &lr_ext_to_del1);
+			M0_ASSERT(rc1 == -ENOENT); //todo correct?
+			if (rc1 == -ENOENT) {
+				rc = ext_in_memory_add(layer, &ext0, ext_state);
+				M0_ASSERT(rc == 0);
+			}
+		}
+	}
+
 	M0_ASSERT_EX(ergo(rc == 0, layer_invariant(layer)));
 	M0_ASSERT_EX(ergo(rc == 0, composite_invariant(cl)));
 	return rc;
@@ -2399,8 +2538,8 @@ M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
 		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
 		 (unsigned long long)ext->e_end);
 #ifndef __KERNEL__
-	printf("m0_composite_layer_ext_add(): lid %llu, layer %lu, "
-		"e_start %llu, e_end %llu",
+	printf("m0_composite_layer_ext_add(): lid %llu, layer %lu \n"
+		"\te_start %llu, e_end %llu \n",
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
 		 (unsigned long long)ext->e_end);
@@ -2445,7 +2584,8 @@ M0_INTERNAL int m0_composite_layer_ext_state_update(
 		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
 		 (unsigned long long)ext->e_end, (unsigned long long)ext_state);
 #ifndef __KERNEL__
-	printf("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu\n",
+	printf("m0_composite_layer_ext_state_update(): lid %llu, layer %lu, "
+		"e_start %llu, e_end %llu, e_state %llu\n",
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
 		 (unsigned long long)ext->e_end, (unsigned long long)ext_state);
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index d1a3133..1636fa2 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -126,17 +126,6 @@ static void sublayouts_delete(struct m0_layout_domain *domain,
 	}
 }
 
-/*
- * todo due to it being approximate_end_offset and not end_offset, the boundary
- * condition of the last extent's e_end being equal to M0_BINDEX_MAX is not
- * being tested. Change accordingly.
-00000036bb:0000000000:
-	00000 [               0 .. ffffffffffffffff) (ffffffffffffffff):                0
-00000036bb:0000000001:
-	00000 [               0 .. 7fffffffffffffff) (7fffffffffffffff):                1
-	00001 [7fffffffffffffff .. fffffffffffffffe) (7fffffffffffffff):                1
-	00002 [fffffffffffffffe .. ffffffffffffffff) (               1):                0    <----
- */
 //todo rename extentmask_build()
 static void extentlist_build(struct m0_tl **extlist,
 			     uint32_t extents_nr,
@@ -150,8 +139,6 @@ static void extentlist_build(struct m0_tl **extlist,
 	m0_bindex_t                       multiplier;
 	uint32_t                          i;
 
-	if_contiguous_extents = true; //todo rm
-
 	min_start_offset = 0;
 	approximate_end_offset = M0_BINDEX_MAX + 1;
 
@@ -161,7 +148,9 @@ static void extentlist_build(struct m0_tl **extlist,
 	m0_composite_layer_ext_tlist_init(extents);
 	M0_UT_ASSERT(m0_composite_layer_ext_tlist_is_empty(extents));
 
-	multiplier = if_contiguous_extents ? 1 : 2;
+	multiplier = 1;
+	//todo Get rid of multiplier ?
+	//multiplier = if_contiguous_extents ? 1 : 2;
 	delta = (approximate_end_offset - min_start_offset) /
 		(extents_nr * multiplier);
 #if 1
@@ -182,13 +171,19 @@ static void extentlist_build(struct m0_tl **extlist,
 			extent->cle_ext.e_end = M0_BINDEX_MAX + 1;
 		else
 			extent->cle_ext.e_end = extent->cle_ext.e_start + delta;
-		extent->cle_state = M0_CLRES_VALID;
+
+		if (if_contiguous_extents || i % 2 == 0)
+			extent->cle_state = M0_CLRES_VALID;
+		else
+			/* Make every alternate extent INVALID. */
+			extent->cle_state = M0_CLRES_INVALID;
 
 #if 1
 #ifndef __KERNEL__
-	printf("ext[%u]: start %llu, end %llu \n", i,
+	printf("ext[%u]: start %llu, end %llu, state %llu \n", i,
 		(unsigned long long)extent->cle_ext.e_start,
-		(unsigned long long)extent->cle_ext.e_end);
+		(unsigned long long)extent->cle_ext.e_end,
+		(unsigned long long)extent->cle_state);
 #endif
 #endif
 		m0_composite_layer_ext_tlink_init_at_tail(extent, extents);
@@ -217,7 +212,8 @@ static void extentlist_build(struct m0_tl **extlist,
 	m0_composite_layer_ext_tlist_init(extents);
 	M0_UT_ASSERT(m0_composite_layer_ext_tlist_is_empty(extents));
 
-	multiplier = if_contiguous_extents ? 1 : 2;
+	multiplier = 1;
+	//multiplier = if_contiguous_extents ? 1 : 2;
 	delta = (approximate_end_offset - min_start_offset) /
 		(extents_nr * multiplier);
 #if 1
@@ -274,8 +270,6 @@ static void composite_layout_verify(struct m0_layout *l,
 	uint32_t                          i;
 	uint32_t                          j;
 
-	if_contiguous_extents = true; //todo rm
-
 	min_start_offset = 0;
 	approximate_end_offset = M0_BINDEX_MAX + 1;
 
@@ -288,7 +282,8 @@ static void composite_layout_verify(struct m0_layout *l,
 
 	/* Verify the composite type specific data. */
 	m0_uint128_init(&seed, "sublayouts_build");
-	multiplier = if_contiguous_extents ? 1 : 2;
+	multiplier = 1;
+	//multiplier = if_contiguous_extents ? 1 : 2;
 
 	/* Verify the layers */
 	extents_nr = min_extents_nr;
@@ -321,6 +316,12 @@ static void composite_layout_verify(struct m0_layout *l,
 				     extent->cle_ext.e_start + delta ||
 				     extent->cle_ext.e_end ==
 				     M0_BINDEX_MAX + 1);
+			if (if_contiguous_extents || j % 2 == 0)
+				M0_UT_ASSERT(extent->cle_state ==
+					     M0_CLRES_VALID);
+			else
+				M0_UT_ASSERT(extent->cle_state ==
+					     M0_CLRES_INVALID);
 			++j;
 		} m0_tl_endfor;
 		M0_UT_ASSERT(j == extents_nr);
@@ -453,7 +454,6 @@ static int composite_build_and_layers_add(uint64_t lid,
 {
 	M0_UT_ASSERT(cl != NULL);
 
-	if_contiguous_extents = true; //todo rm
 	rc = composite_build(lid, domain, min_extents_nr,
 			     min_start_offset, approximate_end_offset,
 			     if_contiguous_extents, cl, !FAILURE_TEST);
@@ -548,7 +548,7 @@ static void extent_to_be_operated(const struct m0_composite_layout *cl,
 						   CONTAINED_WITHIN)));
 
 	/* Find the layer with the specified layer id. */
-	layer = NULL;
+	layer = NULL; //todo Use layer_find() here
 	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
 		if (layer->clr_idx == layer_idx)
 			break;
@@ -575,23 +575,37 @@ static void extent_to_be_operated(const struct m0_composite_layout *cl,
 	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, extent) {
 		if (i == extent_idx) {
 			ext_idxth = extent->cle_ext;
+#if 0
 			if (kind_of_extent_to_add == EXACT_EXISTING)
 				break;
+#endif
 		} else if (i == extent_idx + 1) {
 			ext_idx_plus_oneth = extent->cle_ext;
 			break;
 		}
 		++i;
 	} m0_tl_endfor;
-
+#if 0
 	M0_UT_ASSERT(ergo(!if_contiguous_extents,
 			  ext_idxth.e_end != ext_idx_plus_oneth.e_start));
+#endif
+	M0_UT_ASSERT(ext_idxth.e_end == ext_idx_plus_oneth.e_start);
 
-	if (kind_of_extent_to_add == EXACT_EXISTING)
-		*ext = ext_idxth;
-	else if (kind_of_extent_to_add == NON_EXISTING) {
-		ext->e_start = ext_idxth.e_end;
-		ext->e_end = ext_idx_plus_oneth.e_start;
+	if (kind_of_extent_to_add == EXACT_EXISTING) {
+		if (if_contiguous_extents)
+			*ext = ext_idxth;
+		else {
+			if ((i - 1) % 2 == 0)
+				*ext = ext_idxth;
+			else
+				*ext = ext_idx_plus_oneth;
+		}
+	} else if (kind_of_extent_to_add == NON_EXISTING) {
+		M0_UT_ASSERT(!if_contiguous_extents);
+		if ((i - 1) % 2 == 0)
+			*ext = ext_idx_plus_oneth;
+		else
+			*ext = ext_idxth;
 	} else if (kind_of_extent_to_add == OVERLAPPING_LEFT) {
 		ext->e_start = ext_idxth.e_start;
 		ext->e_end = ext_idx_plus_oneth.e_start + 1;
@@ -599,8 +613,18 @@ static void extent_to_be_operated(const struct m0_composite_layout *cl,
 		ext->e_start = ext_idxth.e_end - 1;
 		ext->e_end = ext_idx_plus_oneth.e_end;
 	} else if (kind_of_extent_to_add == OVERLAPPING_COMPLETE) {
-		ext->e_start = ext_idxth.e_start - 1;
-		ext->e_end = ext_idx_plus_oneth.e_end + 1;
+		if (if_contiguous_extents) {
+			ext->e_start = ext_idxth.e_start - 1;
+			ext->e_end = ext_idxth.e_end + 1;
+		} else {
+			if ((i - 1) % 2 == 0) {
+				ext->e_start = ext_idxth.e_start - 1;
+				ext->e_end = ext_idxth.e_end + 1;
+			} else {
+				ext->e_start = ext_idx_plus_oneth.e_start - 1;
+				ext->e_end = ext_idx_plus_oneth.e_end + 1;
+			}
+		}
 	} else if (kind_of_extent_to_add == CONTAINED_WITHIN) {
 		ext->e_start = ext_idxth.e_start + 2;
 		ext->e_end = ext_idxth.e_end - 2;
@@ -615,6 +639,47 @@ static void extent_to_be_operated(const struct m0_composite_layout *cl,
 #endif
 }
 
+#ifndef __KERNEL__
+static struct m0_composite_layer *layer_find(
+					const struct m0_composite_layout *cl,
+					uint32_t layer_idx)
+{
+	struct m0_composite_layer *layer = NULL;
+
+	M0_PRE(layer_idx < cl->cl_layers_nr);
+
+	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
+		if (layer->clr_idx == layer_idx)
+			break;
+	} m0_tl_endfor;
+
+	M0_ASSERT(layer != NULL);
+	return layer;
+}
+#endif
+
+static void extlist_dump(const struct m0_composite_layout *cl,
+			 uint32_t layer_idx)
+{
+#ifndef __KERNEL__
+	struct m0_composite_layer        *layer;
+	struct m0_composite_layer_extent *lr_ext;
+	uint32_t                          i = 0;
+
+	layer = layer_find(cl, layer_idx);
+
+
+	printf("extlist_dump(): layer %lu: \n", (unsigned long)layer_idx);
+	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+		printf("\text[%lu]: start %llu, end %llu, state %llu \n",
+			(unsigned long)i,
+			(unsigned long long)lr_ext->cle_ext.e_start,
+			(unsigned long long)lr_ext->cle_ext.e_end,
+			(unsigned long long)lr_ext->cle_state);
+	} m0_tl_endfor;
+#endif
+}
+
 static void extent_to_be_operated(const struct m0_composite_layout *cl,
 				  bool if_contiguous_extents,
 				  uint32_t layer_idx,
@@ -645,6 +710,8 @@ int test_layer_op_inmem_composite(uint64_t lid,
 	M0_UT_ASSERT(rc == 0);
 	m0_fi_disable("m0_composite_layer_add", "skip_DB_sync");
 
+	extlist_dump(cl, cl->cl_layers_nr - 1);
+
 	extent_to_be_operated(cl, if_contiguous_extents, 1, 1,
 			      kind_of_extent_to_add, &ext_to_operate);
 
@@ -654,17 +721,10 @@ int test_layer_op_inmem_composite(uint64_t lid,
 	M0_UT_ASSERT(rc == 0);
 	//todo Lookup in mem to see that the ext_to_operate does exist
 
-#if 1
-	if (kind_of_extent_to_add == OVERLAPPING_LEFT)
-		M0_UT_ASSERT(0);
-#endif
-#if 0
-	if (kind_of_extent_to_add == CONTAINED_WITHIN)
-		M0_UT_ASSERT(0);
-#endif
-
 	//M0_UT_ASSERT(0); //todo rm tempo to check contents of the extlist
+
 	//todo Verify the updated extent list.
+	extlist_dump(cl, cl->cl_layers_nr - 1);
 
 	/* Delete the composite layout object. */
 	m0_layout_put(&cl->cl_base);
@@ -698,8 +758,6 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 	uint32_t                       i;
 	uint32_t                       j;
 
-	if_contiguous_extents = true; //todo rm
-
 	M0_UT_ASSERT(dcur != NULL);
 	M0_UT_ASSERT(layers_nr > 0);
 
@@ -721,7 +779,8 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 
 	M0_ASSERT(m0_bufvec_cursor_step(dcur) >= cl_header.ch_layers_nr *
 						 sizeof layer_header);
-	multiplier = if_contiguous_extents ? 1 : 2;
+	multiplier = 1;
+	//multiplier = if_contiguous_extents ? 1 : 2;
 
 #if 0
 #ifndef __KERNEL__
@@ -778,7 +837,10 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 							 sizeof ext);
 			M0_ASSERT(nbytes == sizeof ext);
 
-			ext_state = M0_CLRES_VALID;
+			if (if_contiguous_extents || j % 2 == 0)
+				ext_state = M0_CLRES_VALID;
+			else
+				ext_state = M0_CLRES_INVALID;
 			nbytes = m0_bufvec_cursor_copyto(dcur, &ext_state,
 							 sizeof ext_state);
 			M0_ASSERT(nbytes == sizeof ext_state);
@@ -885,8 +947,6 @@ static void composite_layout_buf_verify(uint64_t lid,
 	uint32_t                       i;
 	uint32_t                       j;
 
-	if_contiguous_extents = true; //todo rm
-
 	M0_UT_ASSERT(cur != NULL);
 
 	min_start_offset = 0;
@@ -905,7 +965,8 @@ static void composite_layout_buf_verify(uint64_t lid,
 
 	M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >= cl_header->ch_layers_nr *
 						   sizeof *layer_header);
-	multiplier = if_contiguous_extents ? 1 : 2;
+	multiplier = 1;
+	//multiplier = if_contiguous_extents ? 1 : 2;
 	extents_nr = min_extents_nr;
 
 	for (i = 0; i < cl_header->ch_layers_nr; ++i) {
@@ -931,7 +992,10 @@ static void composite_layout_buf_verify(uint64_t lid,
 
 			ext_state = m0_bufvec_cursor_addr(cur);
 			m0_bufvec_cursor_move(cur, sizeof *ext_state);
-			M0_UT_ASSERT(*ext_state == M0_CLRES_VALID);
+			if (if_contiguous_extents || j % 2 == 0)
+				M0_UT_ASSERT(*ext_state == M0_CLRES_VALID);
+			else
+				M0_UT_ASSERT(*ext_state == M0_CLRES_INVALID);
 		}
 		//todo enable once m0_emap_paste works ++extents_nr;
 	}
@@ -978,6 +1042,7 @@ int test_encode_composite(uint64_t lid,
 	/* Rewind the cursor. */
 	m0_bufvec_cursor_init(&cur, &bv);
 
+	extlist_dump(cl, cl->cl_layers_nr - 1); //todo temp rm
 	/* Verify the layout buffer produced by m0_layout_encode(). */
 	if (!failure_test)
 		composite_layout_buf_verify(lid, domain, layers_nr,
@@ -1734,7 +1799,6 @@ int ext_operate(enum extent_operation eop,
 	struct m0_layout           *sublayout_lookup;
 	int                         rc_tmp;
 
-	if_contiguous_extents = true; //todo remove this
 	M0_UT_ASSERT(M0_IN(eop, (EXTENT_LOOKUP, EXTENT_ADD, EXTENT_UPDATE,
 				 EXTENT_DELETE)));
 
@@ -1770,13 +1834,16 @@ int ext_operate(enum extent_operation eop,
 	rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
 	M0_UT_ASSERT(rc == 0);
 
+	extlist_dump(cl, cl->cl_layers_nr - 1); //todo
 	/* Initial lookup verifying that the result is as expected. */
 	rc = m0_composite_layer_ext_lookup(cl, offset_to_operate,
 					   &tx, &layer_id_lookup,
 					   &ext_lookup,
 					   &ext_state_lookup,
 					   &sublayout_lookup);
-	if (kind_of_extent_to_operate == NON_EXISTING)
+	if (kind_of_extent_to_operate == NON_EXISTING ||
+	    (kind_of_extent_to_operate == OVERLAPPING_LEFT &&
+	     !if_contiguous_extents))
 		M0_UT_ASSERT(rc == -ENOENT);
 	else {
 		M0_UT_ASSERT(rc == 0);
@@ -1804,6 +1871,7 @@ int ext_operate(enum extent_operation eop,
 		rc = m0_composite_layer_ext_add(cl, cl->cl_layers_nr - 1,
 						&ext_to_operate, &tx);
 		M0_UT_ASSERT(rc == 0);
+		extlist_dump(cl, cl->cl_layers_nr - 1); //todo
 
 		rc = m0_composite_layer_ext_lookup(cl, offset_to_operate,
 						   &tx, &layer_id_lookup,
@@ -1828,6 +1896,7 @@ int ext_operate(enum extent_operation eop,
 			M0_UT_ASSERT(rc == 0);
 		else
 			M0_UT_ASSERT(rc == -EINVAL);
+		extlist_dump(cl, cl->cl_layers_nr - 1); //todo
 
 		rc = m0_composite_layer_ext_lookup(cl,
 						   offset_to_operate,
@@ -1839,7 +1908,9 @@ int ext_operate(enum extent_operation eop,
 			M0_UT_ASSERT(rc == 0);
 			M0_UT_ASSERT(layer_id_lookup == cl->cl_layers_nr - 1);
 			M0_UT_ASSERT(ext_state_lookup == M0_CLRES_FLATTENING);
-		} else if (kind_of_extent_to_operate == NON_EXISTING) {
+		} else if (kind_of_extent_to_operate == NON_EXISTING ||
+			  (kind_of_extent_to_operate == OVERLAPPING_LEFT &&
+			   !if_contiguous_extents)) {
 			M0_UT_ASSERT(rc == -ENOENT);
 		} else {
 			/* The extent will be found but it won't be exact. */
@@ -1860,6 +1931,7 @@ int ext_operate(enum extent_operation eop,
 		rc = m0_composite_layer_ext_delete(cl, cl->cl_layers_nr - 1,
 						   &ext_to_operate, &tx);
 		M0_UT_ASSERT(rc == 0);
+		extlist_dump(cl, cl->cl_layers_nr - 1); //todo
 
 		rc = m0_composite_layer_ext_lookup(cl,
 						   offset_to_operate,
@@ -1867,9 +1939,11 @@ int ext_operate(enum extent_operation eop,
 						   &ext_lookup,
 						   &ext_state_lookup,
 						   &sublayout_lookup);
-		if (kind_of_extent_to_operate == NON_EXISTING)
+		if (kind_of_extent_to_operate == NON_EXISTING ||
+		    (kind_of_extent_to_operate == OVERLAPPING_LEFT &&
+		     !if_contiguous_extents)) {
 			M0_UT_ASSERT(rc == -ENOENT);
-		else {
+		} else {
 			/*
 			 * If a constraint is added that extents lists
 			 * for each layer are exclusive of each other, then,
diff --git a/layout/ut/composite.h b/layout/ut/composite.h
index e5e7628..04c00dc 100644
--- a/layout/ut/composite.h
+++ b/layout/ut/composite.h
@@ -27,6 +27,8 @@
  * Kind of the extent that 'is to be looked up from the extent list' or 'is to
  * be added to extent list' for a particular layer from a particular composite
  * layout.
+ *
+ * For example: //todo
  */
 enum {
 	NON_EXISTING,
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 230cd1e..5082e32 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -496,16 +496,6 @@ static void test_build(void)
 	m0_fi_disable("m0_composite_layer_add", "skip_DB_sync");
 
 	/* todo tempo */
-#if 0
-	lid = 1024;
-	rc = test_layer_op_inmem_composite(lid, &domain, 6, 6, //todo 100,
-					   lid * 100, lid * 100 * 100,
-					   !CONTIGUOUS_EXTENTS,
-					   NON_EXISTING,
-					   !FAILURE_TEST);
-	M0_UT_ASSERT(rc == 0);
-#endif
-
 	lid = 1025;
 	rc = test_layer_op_inmem_composite(lid, &domain, 6, 6, //todo 100,
 					   lid * 100, lid * 100 * 100,
@@ -522,8 +512,6 @@ static void test_build(void)
 					   !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-#if 0
-	//This won't work until invalid extents are store in-memory
 	lid = 1027;
 	rc = test_layer_op_inmem_composite(lid, &domain, 6, 6, //todo 100,
 					   lid * 100, lid * 100 * 100,
@@ -531,10 +519,7 @@ static void test_build(void)
 					   OVERLAPPING_LEFT,
 					   !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
-#endif
 
-#if 0
-	//todo Feb 04
 	lid = 1028;
 	rc = test_layer_op_inmem_composite(lid, &domain, 6, 6, //todo 100,
 					   lid * 100, lid * 100 * 100,
@@ -542,10 +527,7 @@ static void test_build(void)
 					   OVERLAPPING_LEFT,
 					   !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
-#endif
 
-#if 0
-	//This won't work until invalid extents are store in-memory
 	lid = 1029;
 	rc = test_layer_op_inmem_composite(lid, &domain, 6, 6, //todo 100,
 					   lid * 100, lid * 100 * 100,
@@ -553,10 +535,7 @@ static void test_build(void)
 					   OVERLAPPING_RIGHT,
 					   !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
-#endif
 
-#if 0
-	//todo Jan 30
 	lid = 1030;
 	rc = test_layer_op_inmem_composite(lid, &domain, 6, 6, //todo 100,
 					   lid * 100, lid * 100 * 100,
@@ -564,7 +543,6 @@ static void test_build(void)
 					   OVERLAPPING_RIGHT,
 					   !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
-#endif
 
 	lid = 1031; //todo
 	rc = test_layer_op_inmem_composite(lid, &domain, 6, 6, //todo 100,
@@ -962,6 +940,7 @@ static void test_decode_encode(void)
 	M0_UT_ASSERT(rc == 0);
 
 #if 1
+	//todo Get rid of this FI and test the layer_ops in user space
 	m0_fi_enable("m0_composite_layer_add", "skip_DB_sync");
 	/*
 	 * Build a layout buffer representing a layout with COMPOSITE layout
@@ -972,12 +951,7 @@ static void test_decode_encode(void)
 	 * buffer.
 	 */
 	lid = 7005;
-#if 0
-	rc = test_decode_encode_composite(lid, &domain, 11, 21,
-					  lid * 100, lid * 10 * 100,
-					  CONTIGUOUS_EXTENTS);
-#endif
-	rc = test_decode_encode_composite(lid, &domain, 5, 4,
+	rc = test_decode_encode_composite(lid, &domain, 5, 4, //todo 11, 21
 					  lid * 100, lid * 10 * 100,
 					  CONTIGUOUS_EXTENTS);
 	M0_UT_ASSERT(rc == 0);
@@ -1995,14 +1969,12 @@ static void test_composite_layer_ops(void)
 	uint64_t lid;
 
 	/* Test cases for extent lookup. */
-#if 0 //todo Feb 04 Enable this
 	lid = 22001;
 	rc = test_ext_lookup_composite(lid, &domain, 6, 4, /* todo 100, */
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS, NON_EXISTING,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
-#endif
 
 	lid = 22002;
 	rc = test_ext_lookup_composite(lid, &domain, 6, 4 /* todo 100 */,
@@ -2063,14 +2035,12 @@ static void test_composite_layer_ops(void)
 	M0_UT_ASSERT(rc == 0);
 
 	/* Test cases for extent addition. */
-#if 0 //todo Feb 04 Enable this
 	lid = 22021;
 	rc = test_ext_add_composite(lid, &domain, 6, 4,
 				    lid * 100, lid * 100 * 100,
 				    !CONTIGUOUS_EXTENTS, NON_EXISTING,
 				    !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
-#endif
 
 	lid = 22022;
 	rc = test_ext_add_composite(lid, &domain, 6, 4,
@@ -2129,7 +2099,6 @@ static void test_composite_layer_ops(void)
 	M0_UT_ASSERT(rc == 0);
 
 	/* Test cases for extent updation. */
-#if 0 //todo Feb 04 Enable this
 	lid = 22041;
 	rc = test_ext_state_update_composite(lid, &domain, 6, 4,
 					     lid * 100, lid * 100 * 100,
@@ -2137,7 +2106,6 @@ static void test_composite_layer_ops(void)
 					     NON_EXISTING,
 					     !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
-#endif
 
 	lid = 22042;
 	rc = test_ext_state_update_composite(lid, &domain, 6, 4,
@@ -2204,7 +2172,7 @@ static void test_composite_layer_ops(void)
 	M0_UT_ASSERT(rc == 0);
 
 	/* Test cases for extent deletion. */
-#if 0 //todo
+#if 1 //todo m0_composite_layer_ext_delete() shall handle EINVAL case
 	lid = 22061;
 	rc = test_ext_delete_composite(lid, &domain, 6, 4,
 				       lid * 100, lid * 100 * 100,
-- 
1.8.3.2

