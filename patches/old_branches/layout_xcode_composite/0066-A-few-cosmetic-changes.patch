From 87d681c5ad5bd8d6ac15794bbb8c8b6df4b4a1ec Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Wed, 20 Feb 2013 12:36:54 +0530
Subject: [PATCH 066/157] A few cosmetic changes

---
 layout/ut/composite.c |   5 +-
 layout/ut/composite.h |  15 +--
 layout/ut/layout.c    | 326 +++++++++++++++++++++++++++-----------------------
 layout/ut/pdclust.c   |   6 +-
 layout/ut/pdclust.h   |   6 +-
 5 files changed, 184 insertions(+), 174 deletions(-)

diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index cc5be7d..c9a4354 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -1407,9 +1407,8 @@ int test_encode_decode_composite(uint64_t lid,
 }
 
 /* Tests the APIs supported for m0_composite_instance object. */
-int test_composite_instance_obj(uint64_t lid,
-				struct m0_layout_domain *domain,
-				bool failure_test)
+int test_instance_composite(uint64_t lid, struct m0_layout_domain *domain,
+			    bool failure_test)
 {
 	struct m0_layout             *l;
 	struct m0_composite_layout   *cl;
diff --git a/layout/ut/composite.h b/layout/ut/composite.h
index ebd8576..cb35a78 100644
--- a/layout/ut/composite.h
+++ b/layout/ut/composite.h
@@ -47,15 +47,6 @@ int test_build_composite(uint64_t lid,
 			 m0_bindex_t approximate_end_address,
 			 bool if_contiguous_extents,
 			 bool failure_test);
-int test_layer_op_inmem_composite(uint64_t lid,
-				  struct m0_layout_domain *domain,
-				  uint32_t sublayouts_nr,
-				  uint32_t min_extents_nr,
-				  m0_bindex_t min_start_offset,
-				  m0_bindex_t approximate_end_address,
-				  bool if_contiguous_extents,
-				  uint32_t kind_of_extent_to_operate,
-				  bool failure_test);
 int test_decode_composite(uint64_t lid,
 			  struct m0_layout_domain *domain,
 			  uint32_t sublayouts_nr,
@@ -86,9 +77,9 @@ int test_encode_decode_composite(uint64_t lid,
 				 m0_bindex_t min_start_offset,
 				 m0_bindex_t approximate_end_offset,
 				 bool if_contiguous_extents);
-int test_composite_instance_obj(uint64_t lid,
-				struct m0_layout_domain *domain,
-				bool failure_test);
+int test_instance_composite(uint64_t lid,
+			    struct m0_layout_domain *domain,
+			    bool failure_test);
 int test_lookup_composite(uint64_t lid,
 			  struct m0_layout_domain *domain,
 			  uint32_t layers_nr,
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index f940a97..acc6801 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -631,7 +631,7 @@ static void test_decode(void)
 	 * Decode a layout object with COMPOSITE layout type and with
 	 * contiguous extents in its layers.
 	 */
-	lid = 3005;
+	lid = 3021;
 	rc = test_decode_composite(lid, &domain, 7, 10,
 				   lid * 100, lid * 100 * 100,
 				   CONTIGUOUS_EXTENTS, !FAILURE_TEST);
@@ -641,7 +641,7 @@ static void test_decode(void)
 	 * Decode a layout object with COMPOSITE layout type and with
 	 * noncontiguous extents in its layers.
 	 */
-	lid = 3006;
+	lid = 3022;
 	rc = test_decode_composite(lid, &domain, 8, 10,
 				   lid * 100, lid * 100 * 100,
 				   !CONTIGUOUS_EXTENTS, !FAILURE_TEST);
@@ -773,7 +773,7 @@ static void test_encode(void)
 	 * Encode for COMPOSITE layout type with contiguous extents in its
 	 * layers.
 	 */
-	lid = 5005;
+	lid = 5021;
 	rc = test_encode_composite(lid, &domain, 8, 25,
 				   lid * 100, lid * 100 * 100,
 				   CONTIGUOUS_EXTENTS, !FAILURE_TEST);
@@ -783,7 +783,7 @@ static void test_encode(void)
 	 * Encode for COMPOSITE layout type with contiguous extents in its
 	 * layers.
 	 */
-	lid = 5006;
+	lid = 5022;
 	rc = test_encode_composite(lid, &domain, 9, 25,
 				   lid * 100, lid * 100 * 100,
 				   !CONTIGUOUS_EXTENTS, !FAILURE_TEST);
@@ -879,7 +879,7 @@ static void test_decode_encode(void)
 	 * Then, compare the original layout buffer with the encoded layout
 	 * buffer.
 	 */
-	lid = 7005;
+	lid = 7021;
 	rc = test_decode_encode_composite(lid, &domain, 5, 10,
 					  lid * 100, lid * 10 * 100,
 					  CONTIGUOUS_EXTENTS);
@@ -951,7 +951,7 @@ static void test_encode_decode(void)
 	 * Now, compare the original layout object with the decoded layout
 	 * object.
 	 */
-	lid = 8005;
+	lid = 8021;
 	rc = test_encode_decode_composite(lid, &domain, 7, 27,
 					  lid * 100, lid * 100 * 100,
 					  CONTIGUOUS_EXTENTS);
@@ -979,6 +979,8 @@ static void test_ref_get_put(void)
 	lid = 9002;
 	rc = test_ref_get_put_pdclust(lid, &domain, LINEAR_ENUM_ID);
 	M0_UT_ASSERT(rc == 0);
+
+	//todo composite
 }
 
 /* Tests the enum operations pointed by leo_nr and leo_get. */
@@ -1170,13 +1172,15 @@ static void test_recsize(void)
 	rc = test_recsize_pdclust(lid, &domain,
 				  LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE);
 	M0_UT_ASSERT(rc == 0);
+
+	//todo composite
 }
 
 /*
  * Tests the APIs supported for m0_pdclust_instance object, for various enum
  * types.
  */
-static void test_pdclust_instance(void)
+static void test_instance(void)
 {
 	uint64_t lid;
 
@@ -1185,9 +1189,9 @@ static void test_pdclust_instance(void)
 	 * LIST enum type with a few inline entries only.
 	 */
 	lid = 12001;
-	rc = test_pdclust_instance_obj(lid, &domain,
-				       LIST_ENUM_ID, LESS_THAN_INLINE,
-				       !FAILURE_TEST);
+	rc = test_instance_pdclust(lid, &domain,
+				   LIST_ENUM_ID, LESS_THAN_INLINE,
+				   !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	/*
@@ -1196,9 +1200,9 @@ static void test_pdclust_instance(void)
 	 * LDB_MAX_INLINE_COB_ENTRIES.
 	 */
 	lid = 12002;
-	rc = test_pdclust_instance_obj(lid, &domain,
-				       LIST_ENUM_ID, EXACT_INLINE,
-				       !FAILURE_TEST);
+	rc = test_instance_pdclust(lid, &domain,
+				   LIST_ENUM_ID, EXACT_INLINE,
+				   !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	/*
@@ -1206,9 +1210,9 @@ static void test_pdclust_instance(void)
 	 * LIST enum type including noninline entries.
 	 */
 	lid = 12003;
-	rc = test_pdclust_instance_obj(lid, &domain,
-				       LIST_ENUM_ID, MORE_THAN_INLINE,
-				       !FAILURE_TEST);
+	rc = test_instance_pdclust(lid, &domain,
+				   LIST_ENUM_ID, MORE_THAN_INLINE,
+				   !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	/*
@@ -1216,30 +1220,35 @@ static void test_pdclust_instance(void)
 	 * LINEAR enum type.
 	 */
 	lid = 12004;
-	rc = test_pdclust_instance_obj(lid, &domain,
-				       LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
-				       !FAILURE_TEST);
+	rc = test_instance_pdclust(lid, &domain,
+				   LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
+				   !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+
+	/* Build a layout instance with a layout with COMPOSITE layout type. */
+	lid = 12021;
+	rc = test_instance_composite(lid, &domain, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 }
 
-static void test_pdclust_instance_failure(void)
+static void test_instance_failure(void)
 {
 	uint64_t lid;
 
 	/* Simulate memory allocation error in m0_pdclust_instance_build(). */
 	lid = 13001;
 	m0_fi_enable_once("pdclust_instance_build", "mem_err1");
-	rc = test_pdclust_instance_obj(lid, &domain,
-				       LIST_ENUM_ID, LESS_THAN_INLINE,
-				       FAILURE_TEST);
+	rc = test_instance_pdclust(lid, &domain,
+				   LIST_ENUM_ID, LESS_THAN_INLINE,
+				   FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 
 	/* Simulate memory allocation error in m0_pdclust_instance_build(). */
 	lid = 13002;
 	m0_fi_enable_once("pdclust_instance_build", "mem_err2");
-	rc = test_pdclust_instance_obj(lid, &domain,
-				       LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
-				       FAILURE_TEST);
+	rc = test_instance_pdclust(lid, &domain,
+				   LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
+				   FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 
 	/*
@@ -1248,78 +1257,67 @@ static void test_pdclust_instance_failure(void)
 	 */
 	lid = 13003;
 	m0_fi_enable_once("pdclust_instance_build", "parity_math_err");
-	rc = test_pdclust_instance_obj(lid, &domain,
-				       LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
-				       FAILURE_TEST);
+	rc = test_instance_pdclust(lid, &domain,
+				   LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
+				   FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EPROTO);
 }
 
-/* Tests the APIs supported for m0_composite_instance object. */
-static void test_composite_instance(void)
-{
-	uint64_t lid;
-
-	/* Build a layout instance with a layout with COMPOSITE layout type. */
-	lid = 12001; //todo
-	rc = test_composite_instance_obj(lid, &domain, !FAILURE_TEST);
-	M0_UT_ASSERT(rc == 0);
-}
-
 static void test_composite_layer_ops_internal(void)
 {
 	uint64_t lid;
 
 	/* Test cases for extent lookup. */
-	lid = 22001; //todo
+	lid = 14001;
 	rc = test_ext_lookup_composite(lid, &domain, 3, 4,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS, NON_EXISTING,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22002;
+	lid = 14002;
 	rc = test_ext_lookup_composite(lid, &domain, 3, 8,
 				       lid * 100, lid * 100 * 100,
 				       CONTIGUOUS_EXTENTS, EXACT_EXISTING,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22003;
+	lid = 14003;
 	rc = test_ext_lookup_composite(lid, &domain, 3, 10,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS, EXACT_EXISTING,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22004;
+	lid = 14004;
 	rc = test_ext_lookup_composite(lid, &domain, 3, 10,
 				       lid * 100, lid * 100 * 100,
 				       CONTIGUOUS_EXTENTS, OVERLAPPING_LEFT,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22005;
+	lid = 14005;
 	rc = test_ext_lookup_composite(lid, &domain, 3, 10,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS, OVERLAPPING_LEFT,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22006;
+	lid = 14006;
 	rc = test_ext_lookup_composite(lid, &domain, 3, 10,
 				       lid * 100, lid * 100 * 100,
 				       CONTIGUOUS_EXTENTS, OVERLAPPING_RIGHT,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22007;
+	lid = 14007;
 	rc = test_ext_lookup_composite(lid, &domain, 4, 10,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS, OVERLAPPING_RIGHT,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22008;
+	lid = 14008;
 	rc = test_ext_lookup_composite(lid, &domain, 4, 12,
 				       lid * 100, lid * 100 * 100,
 				       CONTIGUOUS_EXTENTS,
@@ -1327,7 +1325,7 @@ static void test_composite_layer_ops_internal(void)
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22009;
+	lid = 14009;
 	rc = test_ext_lookup_composite(lid, &domain, 4, 12,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS,
@@ -1336,63 +1334,63 @@ static void test_composite_layer_ops_internal(void)
 	M0_UT_ASSERT(rc == 0);
 
 	/* Test cases for extent addition. */
-	lid = 22021;
+	lid = 14021;
 	rc = test_ext_add_composite(lid, &domain, 4, 12,
 				    lid * 100, lid * 100 * 100,
 				    !CONTIGUOUS_EXTENTS, NON_EXISTING,
 				    !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22022;
+	lid = 14022;
 	rc = test_ext_add_composite(lid, &domain, 4, 12,
 				    lid * 100, lid * 100 * 100,
 				    CONTIGUOUS_EXTENTS, EXACT_EXISTING,
 				    !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22023;
+	lid = 14023;
 	rc = test_ext_add_composite(lid, &domain, 4, 12,
 				    lid * 100, lid * 100 * 100,
 				    !CONTIGUOUS_EXTENTS, EXACT_EXISTING,
 				    !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22024;
+	lid = 14024;
 	rc = test_ext_add_composite(lid, &domain, 4, 12,
 				    lid * 100, lid * 100 * 100,
 				    CONTIGUOUS_EXTENTS, OVERLAPPING_LEFT,
 				    !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22025;
+	lid = 14025;
 	rc = test_ext_add_composite(lid, &domain, 4, 12,
 				    lid * 100, lid * 100 * 100,
 				    !CONTIGUOUS_EXTENTS, OVERLAPPING_LEFT,
 				    !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22026;
+	lid = 14026;
 	rc = test_ext_add_composite(lid, &domain, 4, 13,
 				    lid * 100, lid * 100 * 100,
 				    CONTIGUOUS_EXTENTS, OVERLAPPING_RIGHT,
 				    !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22027;
+	lid = 14027;
 	rc = test_ext_add_composite(lid, &domain, 4, 13,
 				    lid * 100, lid * 100 * 100,
 				    CONTIGUOUS_EXTENTS, OVERLAPPING_RIGHT,
 				    !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22028;
+	lid = 14028;
 	rc = test_ext_add_composite(lid, &domain, 4, 13,
 				    lid * 100, lid * 100 * 100,
 				    CONTIGUOUS_EXTENTS, OVERLAPPING_COMPLETE,
 				    !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22029;
+	lid = 14029;
 	rc = test_ext_add_composite(lid, &domain, 4, 13,
 				    lid * 100, lid * 100 * 100,
 				    !CONTIGUOUS_EXTENTS, OVERLAPPING_COMPLETE,
@@ -1400,7 +1398,7 @@ static void test_composite_layer_ops_internal(void)
 	M0_UT_ASSERT(rc == 0);
 
 	/* Test cases for extent updation. */
-	lid = 22041;
+	lid = 14041;
 	rc = test_ext_state_update_composite(lid, &domain, 6, 13,
 					     lid * 100, lid * 100 * 100,
 					     !CONTIGUOUS_EXTENTS,
@@ -1408,7 +1406,7 @@ static void test_composite_layer_ops_internal(void)
 					     !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22042;
+	lid = 14042;
 	rc = test_ext_state_update_composite(lid, &domain, 6, 14,
 					     lid * 100, lid * 100 * 100,
 					     CONTIGUOUS_EXTENTS,
@@ -1416,7 +1414,7 @@ static void test_composite_layer_ops_internal(void)
 					     !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22043;
+	lid = 14043;
 	rc = test_ext_state_update_composite(lid, &domain, 6, 14,
 					     lid * 100, lid * 100 * 100,
 					     !CONTIGUOUS_EXTENTS,
@@ -1424,7 +1422,7 @@ static void test_composite_layer_ops_internal(void)
 					     !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22044;
+	lid = 14044;
 	rc = test_ext_state_update_composite(lid, &domain, 6, 14,
 					     lid * 100, lid * 100 * 100,
 					     CONTIGUOUS_EXTENTS,
@@ -1432,7 +1430,7 @@ static void test_composite_layer_ops_internal(void)
 					     !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22045;
+	lid = 14045;
 	rc = test_ext_state_update_composite(lid, &domain, 6, 14,
 					     lid * 100, lid * 100 * 100,
 					     !CONTIGUOUS_EXTENTS,
@@ -1440,7 +1438,7 @@ static void test_composite_layer_ops_internal(void)
 					     !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22046;
+	lid = 14046;
 	rc = test_ext_state_update_composite(lid, &domain, 6, 14,
 					     lid * 100, lid * 100 * 100,
 					     CONTIGUOUS_EXTENTS,
@@ -1448,7 +1446,7 @@ static void test_composite_layer_ops_internal(void)
 					     !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22047;
+	lid = 14047;
 	rc = test_ext_state_update_composite(lid, &domain, 6, 15,
 					     lid * 100, lid * 100 * 100,
 					     !CONTIGUOUS_EXTENTS,
@@ -1456,7 +1454,7 @@ static void test_composite_layer_ops_internal(void)
 					     !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22048;
+	lid = 14048;
 	rc = test_ext_state_update_composite(lid, &domain, 6, 15,
 					     lid * 100, lid * 100 * 100,
 					     CONTIGUOUS_EXTENTS,
@@ -1464,7 +1462,7 @@ static void test_composite_layer_ops_internal(void)
 					     !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22049;
+	lid = 14049;
 	rc = test_ext_state_update_composite(lid, &domain, 6, 15,
 					     lid * 100, lid * 100 * 100,
 					     !CONTIGUOUS_EXTENTS,
@@ -1473,56 +1471,56 @@ static void test_composite_layer_ops_internal(void)
 	M0_UT_ASSERT(rc == 0);
 
 	/* Test cases for extent deletion. */
-	lid = 22061;
+	lid = 14061;
 	rc = test_ext_delete_composite(lid, &domain, 4, 15,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS, NON_EXISTING,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22062;
+	lid = 14062;
 	rc = test_ext_delete_composite(lid, &domain, 4, 15,
 				       lid * 100, lid * 100 * 100,
 				       CONTIGUOUS_EXTENTS, EXACT_EXISTING,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22063;
+	lid = 14063;
 	rc = test_ext_delete_composite(lid, &domain, 4, 16,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS, EXACT_EXISTING,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22064;
+	lid = 14064;
 	rc = test_ext_delete_composite(lid, &domain, 4, 16,
 				       lid * 100, lid * 100 * 100,
 				       CONTIGUOUS_EXTENTS, OVERLAPPING_LEFT,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22065;
+	lid = 14065;
 	rc = test_ext_delete_composite(lid, &domain, 4, 16,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS, OVERLAPPING_LEFT,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22066;
+	lid = 14066;
 	rc = test_ext_delete_composite(lid, &domain, 4, 16,
 				       lid * 100, lid * 100 * 100,
 				       CONTIGUOUS_EXTENTS, OVERLAPPING_RIGHT,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22067;
+	lid = 14067;
 	rc = test_ext_delete_composite(lid, &domain, 4, 16,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS, OVERLAPPING_RIGHT,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22068;
+	lid = 14068;
 	rc = test_ext_delete_composite(lid, &domain, 4, 16,
 				       lid * 100, lid * 100 * 100,
 				       CONTIGUOUS_EXTENTS,
@@ -1530,7 +1528,7 @@ static void test_composite_layer_ops_internal(void)
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22069;
+	lid = 14069;
 	rc = test_ext_delete_composite(lid, &domain, 4, 17,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS,
@@ -1539,19 +1537,44 @@ static void test_composite_layer_ops_internal(void)
 	M0_UT_ASSERT(rc == 0);
 }
 
-static void test_composite_layer_ops_inmem_only(void)
+static void test_composite_layer_ops_inmem(void)
 {
 	M0_UT_ASSERT(domain.ld_is_db_available == false);
 	test_composite_layer_ops_internal();
 }
 
 #ifndef __KERNEL__
+/**
+ * Setting the ld_is_db_available flag explicitly this way is being used as
+ * a hack in this UT. Ideally, user shall never change value of this flag
+ * directly. The correct way to make use of this flag is using
+ * m0_layout_domain_init() by passing it the applicable value for this flag.
+ *
+ * The reason to use such a hack here in this UT is to avoid the following
+ * overhead:
+ * Since any layout type or enum type can be registered with only one domain at
+ * a time, if we had to initialise a new/existing domain with new value of the
+ * ld_is_db_available flag, then we will need to:
+ * - unregister the layout types and enum types registered in the first domain
+ *   say domain1,
+ * - finalise domain1,
+ * - initialise another domain say domain2
+ * - register the applicable layout types and enum types
+ * - if in the kernel mode, then the layout types and the enum types need to be
+ *   unregistered from the  m0t1fs_globals.g_layout_dom domain and then they
+ *   need to be registered back at some other point (see test_init() for
+ *   reference).
+ */
+static void domain_ldb_available_set(struct m0_layout_domain *domain, bool val)
+{
+	domain->ld_is_db_available = val;
+}
+
 static void test_composite_layer_ops_indb(void)
 {
-	/* todo Explain about this hack. */
-	domain.ld_is_db_available = true; //todo
+	domain_ldb_available_set(&domain, true);
 	test_composite_layer_ops_internal();
-	domain.ld_is_db_available = false; //todo
+	domain_ldb_available_set(&domain, false);
 }
 
 /* Tests the API m0_layout_lookup(). */
@@ -1559,13 +1582,13 @@ static void test_lookup(void)
 {
 	uint64_t lid;
 
-	domain.ld_is_db_available = true; //todo
+	domain_ldb_available_set(&domain, true);
 
 	/*
 	 * Lookup for a layout object with LIST enum type, that does not
 	 * exist in the DB.
 	 */
-	lid = 14001;
+	lid = 16001;
 	rc = test_lookup_pdclust(lid, &domain,
 				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 !EXISTING_TEST,
@@ -1576,7 +1599,7 @@ static void test_lookup(void)
 	 * Add a layout object with PDCLUST layout type, LIST enum type and
 	 * with a few inline entries only. Then perform lookup for it.
 	 */
-	lid = 14002;
+	lid = 16002;
 	rc = test_lookup_pdclust(lid, &domain,
 				 LIST_ENUM_ID, LESS_THAN_INLINE,
 				 EXISTING_TEST,
@@ -1588,7 +1611,7 @@ static void test_lookup(void)
 	 * with a number of inline entries exactly equal to
 	 * LDB_MAX_INLINE_COB_ENTRIES. Then perform lookup for it.
 	 */
-	lid = 14003;
+	lid = 16003;
 	rc = test_lookup_pdclust(lid, &domain,
 				 LIST_ENUM_ID, EXACT_INLINE,
 				 EXISTING_TEST,
@@ -1600,7 +1623,7 @@ static void test_lookup(void)
 	 * including noninline entries.
 	 * Then perform lookup for it.
 	 */
-	lid = 14004;
+	lid = 16004;
 	rc = test_lookup_pdclust(lid, &domain,
 				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 EXISTING_TEST,
@@ -1611,7 +1634,7 @@ static void test_lookup(void)
 	 * Now that a few entries are added into the DB, once again, lookup
 	 * for a layout object that does not exist in the DB.
 	 */
-	lid = 14005;
+	lid = 16005;
 	rc = test_lookup_pdclust(lid, &domain,
 				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 !EXISTING_TEST,
@@ -1622,7 +1645,7 @@ static void test_lookup(void)
 	 * Add a layout object with PDCLUST layout type and LINEAR enum type.
 	 * Then perform lookup for it.
 	 */
-	lid = 14006;
+	lid = 16006;
 	rc = test_lookup_pdclust(lid, &domain,
 				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				 EXISTING_TEST,
@@ -1634,7 +1657,7 @@ static void test_lookup(void)
 	 * created while the first layout object is being allocated by
 	 * m0_layout_lookup() with having the domain lock released.
 	 */
-	lid = 14007;
+	lid = 16007;
 	rc = test_lookup_pdclust_with_ghost_creation(lid, &domain,
 						     LINEAR_ENUM_ID,
 						     INLINE_NOT_APPLICABLE);
@@ -1644,7 +1667,7 @@ static void test_lookup(void)
 	 * Lookup for a layout object with COMPOSITE layout type, that does not
 	 * exist in the DB.
 	 */
-	lid = 14008;
+	lid = 16021;
 	rc = test_lookup_composite(lid, &domain,
 				   7, 30,
 				   lid * 100, lid * 100 * 100,
@@ -1657,7 +1680,7 @@ static void test_lookup(void)
 	 * Add a layout object with COMPOSITE layout type and with
 	 * non-contiguous extents. Then perform lookup for it.
 	 */
-	lid = 14009;
+	lid = 16022;
 	rc = test_lookup_composite(lid, &domain,
 				   2, 30,
 				   lid * 100, lid * 100 * 100,
@@ -1670,7 +1693,7 @@ static void test_lookup(void)
 	 * Add a layout object with COMPOSITE layout type and with contiguous
 	 * extents. Then perform lookup for it.
 	 */
-	lid = 14010;
+	lid = 16023;
 	rc = test_lookup_composite(lid, &domain,
 				   5, 5,
 				   lid * 100, lid * 100 * 100,
@@ -1685,7 +1708,7 @@ static void test_lookup(void)
 	 * perform lookup for it.
 	 * todo Take out such cases with M0_BINDEX_MAX range.
 	 */
-	lid = 14011;
+	lid = 16024;
 	rc = test_lookup_composite(lid, &domain,
 				   20, 5,
 				   0, M0_BINDEX_MAX,
@@ -1694,7 +1717,7 @@ static void test_lookup(void)
 				   !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	domain.ld_is_db_available = false; //todo
+	domain_ldb_available_set(&domain, false);
 }
 
 /* Tests the API m0_layout_lookup(). */
@@ -1703,13 +1726,13 @@ static void test_lookup_failure(void)
 	uint64_t          lid;
 	struct m0_layout *l;
 
-	domain.ld_is_db_available = true; //todo
+	domain_ldb_available_set(&domain, true);
 
 	/*
 	 * Lookup for a layout object with LIST enum type, that does not
 	 * exist in the DB.
 	 */
-	lid = 15001;
+	lid = 17001;
 	rc = test_lookup_pdclust(lid, &domain,
 				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 !EXISTING_TEST,
@@ -1720,7 +1743,7 @@ static void test_lookup_failure(void)
 	 * Lookup for a layout object with LINEAR enum type, that does not
 	 * exist in the DB.
 	 */
-	lid = 15002;
+	lid = 17002;
 	rc = test_lookup_pdclust(lid, &domain,
 				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				 !EXISTING_TEST,
@@ -1728,7 +1751,7 @@ static void test_lookup_failure(void)
 	M0_UT_ASSERT(rc == -ENOENT);
 
 	/* Simulate pdclust_allocate() failure in m0_layout_lookup(). */
-	lid = 15003;
+	lid = 17003;
 	m0_fi_enable_off_n_on_m("pdclust_allocate", "mem_err", 1, 1);
 	rc = test_lookup_pdclust(lid, &domain,
 				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
@@ -1738,7 +1761,7 @@ static void test_lookup_failure(void)
 	m0_fi_disable("pdclust_allocate", "mem_err");
 
 	/* Simulate m0_layout_decode() failure in m0_layout_lookup(). */
-	lid = 15004;
+	lid = 17004;
 	m0_fi_enable_once("m0_layout_decode", "lo_decode_err");
 	rc = test_lookup_pdclust(lid, &domain,
 				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
@@ -1753,7 +1776,7 @@ static void test_lookup_failure(void)
 		.lt_domain   = NULL,
 		.lt_ops      = NULL
 	};
-	lid = 15005;
+	lid = 17005;
 	rc = layout_lookup(lid, &domain, &test_layout_type, FAILURE_TEST, &l);
 	M0_UT_ASSERT(rc == -EPROTO);
 
@@ -1761,7 +1784,7 @@ static void test_lookup_failure(void)
 	 * Simulate cursor init error in noninline_read() that is in the path
 	 * of list_decode() that is in the path of m0_layout_decode().
 	 */
-	lid = 15006;
+	lid = 17006;
 	m0_fi_enable_once("noninline_read", "cursor_init_err");
 	rc = test_lookup_pdclust(lid, &domain,
 				 LIST_ENUM_ID, MORE_THAN_INLINE,
@@ -1773,7 +1796,7 @@ static void test_lookup_failure(void)
 	 * Simulate cursor get error in noninline_read() that is in the path
 	 * of list_decode() that is in the path of m0_layout_decode().
 	 */
-	lid = 15007;
+	lid = 17007;
 	m0_fi_enable_once("noninline_read", "cursor_get_err");
 	rc = test_lookup_pdclust(lid, &domain,
 				 LIST_ENUM_ID, MORE_THAN_INLINE,
@@ -1785,7 +1808,7 @@ static void test_lookup_failure(void)
 	 * Simulate invalid fid error in noninline_read() that is in the path
 	 * of list_decode() that is in the path of m0_layout_decode().
 	 */
-	lid = 15008;
+	lid = 17008;
 	m0_fi_enable_once("noninline_read", "invalid_fid_err");
 	rc = test_lookup_pdclust(lid, &domain,
 				 LIST_ENUM_ID, MORE_THAN_INLINE,
@@ -1793,7 +1816,7 @@ static void test_lookup_failure(void)
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EPROTO);
 
-	domain.ld_is_db_available = false; //todo
+	domain_ldb_available_set(&domain, false);
 }
 
 /* Tests the API m0_layout_add(). */
@@ -1801,13 +1824,13 @@ static void test_add(void)
 {
 	uint64_t lid;
 
-	domain.ld_is_db_available = true; //todo
+	domain_ldb_available_set(&domain, true);
 
 	/*
 	 * Add a layout object with PDCLUST layout type, LIST enum type and
 	 * with a few inline entries only.
 	 */
-	lid = 16001;
+	lid = 18001;
 	rc = test_add_pdclust(lid, &domain,
 			      LIST_ENUM_ID, LESS_THAN_INLINE,
 			      LAYOUT_DESTROY, NULL,
@@ -1820,7 +1843,7 @@ static void test_add(void)
 	 * with a number of inline entries exactly equal to
 	 * LDB_MAX_INLINE_COB_ENTRIES.
 	 */
-	lid = 16002;
+	lid = 18002;
 	rc = test_add_pdclust(lid, &domain,
 			      LIST_ENUM_ID, EXACT_INLINE,
 			      LAYOUT_DESTROY, NULL,
@@ -1832,7 +1855,7 @@ static void test_add(void)
 	 * Add a layout object with PDCLUST layout type and LIST enum type
 	 * including noninline entries.
 	 */
-	lid = 16003;
+	lid = 18003;
 	rc = test_add_pdclust(lid, &domain,
 			      LIST_ENUM_ID, MORE_THAN_INLINE,
 			      LAYOUT_DESTROY, NULL,
@@ -1841,7 +1864,7 @@ static void test_add(void)
 	M0_UT_ASSERT(rc == 0);
 
 	/* Add a layout object with PDCLUST layout type and LINEAR enum type. */
-	lid = 16004;
+	lid = 18004;
 	rc = test_add_pdclust(lid, &domain,
 			      LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 			      LAYOUT_DESTROY, NULL,
@@ -1850,8 +1873,7 @@ static void test_add(void)
 	M0_UT_ASSERT(rc == 0);
 
 	/* Add a layout object with COMPOSITE layout type. */
-	lid = 16005;
-	domain.ld_is_db_available = true; //todo
+	lid = 18021;
 	rc = test_add_composite(lid, &domain, 7, 50,
 				lid * 100, lid * 100 * 100,
 				!CONTIGUOUS_EXTENTS,
@@ -1862,7 +1884,7 @@ static void test_add(void)
 	M0_UT_ASSERT(rc == 0);
 
 	/* Add a layout object with COMPOSITE layout type. */
-	lid = 16006;
+	lid = 18022;
 	rc = test_add_composite(lid, &domain, 5, 25,
 				0, M0_BINDEX_MAX,
 				!CONTIGUOUS_EXTENTS,
@@ -1872,17 +1894,17 @@ static void test_add(void)
 				!LAYER_ADD_FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	domain.ld_is_db_available = false; //todo
+	domain_ldb_available_set(&domain, false);
 }
 
 static void test_add_failure(void)
 {
 	uint64_t lid;
 
-	domain.ld_is_db_available = true; //todo
+	domain_ldb_available_set(&domain, true);
 
 	/* Simulate m0_layout_encode() failure in m0_layout_add(). */
-	lid = 17001;
+	lid = 19001;
 	m0_fi_enable_once("m0_layout_encode", "lo_encode_err");
 	rc = test_add_pdclust(lid, &domain,
 			      LIST_ENUM_ID, MORE_THAN_INLINE,
@@ -1899,7 +1921,7 @@ static void test_add_failure(void)
 	 * the test intention is indicated using another separate flag as
 	 * DUPLICATE_TEST.
 	 */
-	lid = 17002;
+	lid = 19002;
 	rc = test_add_pdclust(lid, &domain,
 			      LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 			      LAYOUT_DESTROY, NULL,
@@ -1911,7 +1933,7 @@ static void test_add_failure(void)
 	 * Simulate cursor init failure in noninline_write() that is in the
 	 * path of list_encode() which is in the path of m0_layout_encode().
 	 */
-	lid = 17003;
+	lid = 19003;
 	m0_fi_enable_once("noninline_write", "cursor_init_err");
 	rc = test_add_pdclust(lid, &domain,
 			      LIST_ENUM_ID, MORE_THAN_INLINE,
@@ -1924,7 +1946,7 @@ static void test_add_failure(void)
 	 * Simulate cursor add failure in noninline_write() that is in the
 	 * path of list_encode() which is in the path of m0_layout_encode().
 	 */
-	lid = 17004;
+	lid = 19004;
 	m0_fi_enable_once("noninline_write", "cursor_add_err");
 	rc = test_add_pdclust(lid, &domain,
 			      LIST_ENUM_ID, MORE_THAN_INLINE,
@@ -1941,7 +1963,7 @@ static void test_add_failure(void)
 	 * the test intention is indicated using another separate flag as
 	 * DUPLICATE_TEST.
 	 */
-	lid = 17005;
+	lid = 19021;
 	rc = test_add_composite(lid, &domain, 4, 15,
 				lid * 100, lid * 100 * 100,
 				CONTIGUOUS_EXTENTS,
@@ -1959,7 +1981,7 @@ static void test_add_failure(void)
 
 	m0_fi_enable_off_n_on_m("sublayout_id_in_db_add", "table_insert_err",
 				1, 1);
-	lid = 17006;
+	lid = 19022;
 	rc = test_add_composite(lid, &domain, 4, 15,
 				lid * 100, lid * 100 * 100,
 				!CONTIGUOUS_EXTENTS,
@@ -1970,7 +1992,7 @@ static void test_add_failure(void)
 	M0_UT_ASSERT(rc == L_TABLE_INSERT_ERR);
 	m0_fi_disable("sublayout_id_in_db_add", "table_insert_err");
 
-	domain.ld_is_db_available = false; //todo
+	domain_ldb_available_set(&domain, false);
 }
 
 /* Tests the API m0_layout_update(). */
@@ -1978,14 +2000,14 @@ static void test_update(void)
 {
 	uint64_t lid;
 
-	domain.ld_is_db_available = true; //todo
+	domain_ldb_available_set(&domain, true);
 
 	/*
 	 * Try to update a layout object with PDCLUST layout type and LIST enum
 	 * type, that does not exist in the DB to verify that the operation
 	 * fails with the error ENOENT.
 	 */
-	lid = 18001;
+	lid = 20001;
 	rc = test_update_pdclust(lid, &domain,
 				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 !EXISTING_TEST,
@@ -1996,7 +2018,7 @@ static void test_update(void)
 	 * Update a layout object with PDCLUST layout type, LIST enum type and
 	 * with a few inline entries only.
 	 */
-	lid = 18002;
+	lid = 20002;
 	rc = test_update_pdclust(lid, &domain,
 				 LIST_ENUM_ID, LESS_THAN_INLINE,
 				 EXISTING_TEST,
@@ -2008,7 +2030,7 @@ static void test_update(void)
 	 * with number of inline entries exactly equal to
 	 * LDB_MAX_INLINE_COB_ENTRIES.
 	 */
-	lid = 18003;
+	lid = 20003;
 	rc = test_update_pdclust(lid, &domain,
 				 LIST_ENUM_ID, EXACT_INLINE,
 				 EXISTING_TEST,
@@ -2019,7 +2041,7 @@ static void test_update(void)
 	 * Update a layout object with PDCLUST layout type and LIST enum
 	 * type including noninline entries.
 	 */
-	lid = 18004;
+	lid = 20004;
 	rc = test_update_pdclust(lid, &domain,
 				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 EXISTING_TEST,
@@ -2030,7 +2052,7 @@ static void test_update(void)
 	 * Update a layout object with PDCLUST layout type and LINEAR enum
 	 * type.
 	 */
-	lid = 18005;
+	lid = 20005;
 	rc = test_update_pdclust(lid, &domain,
 				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				 EXISTING_TEST,
@@ -2039,17 +2061,17 @@ static void test_update(void)
 
 	//todo test_update_composite
 
-	domain.ld_is_db_available = false; //todo
+	domain_ldb_available_set(&domain, false);
 }
 
 static void test_update_failure(void)
 {
 	uint64_t lid;
 
-	domain.ld_is_db_available = true; //todo
+	domain_ldb_available_set(&domain, true);
 
 	/* Simulate m0_layout_encode() failure in m0_layout_update(). */
-	lid = 19001;
+	lid = 21001;
 	m0_fi_enable_off_n_on_m("m0_layout_encode", "lo_encode_err", 1, 1);
 	rc = test_update_pdclust(lid, &domain,
 				 LIST_ENUM_ID, MORE_THAN_INLINE,
@@ -2059,7 +2081,7 @@ static void test_update_failure(void)
 	m0_fi_disable("m0_layout_encode", "lo_encode_err");
 
 	/* Simulate m0_table_update() failure in m0_layout_update(). */
-	lid = 19002;
+	lid = 21002;
 	m0_fi_enable_once("m0_layout_update", "table_update_err");
 	rc = test_update_pdclust(lid, &domain,
 				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
@@ -2067,7 +2089,7 @@ static void test_update_failure(void)
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_TABLE_UPDATE_ERR);
 
-	domain.ld_is_db_available = false; //todo
+	domain_ldb_available_set(&domain, false);
 }
 
 /* Tests the API m0_layout_delete(). */
@@ -2075,13 +2097,13 @@ static void test_delete(void)
 {
 	uint64_t lid;
 
-	domain.ld_is_db_available = true; //todo
+	domain_ldb_available_set(&domain, true);
 
 	/*
 	 * Delete a layout object with PDCLUST layout type, LIST enum type and
 	 * with a few inline entries only.
 	 */
-	lid = 20001;
+	lid = 22001;
 	rc = test_delete_pdclust(lid, &domain,
 				 LIST_ENUM_ID, LESS_THAN_INLINE,
 				 EXISTING_TEST,
@@ -2093,7 +2115,7 @@ static void test_delete(void)
 	 * with a number of inline entries exactly equal to
 	 * LDB_MAX_INLINE_COB_ENTRIES.
 	 */
-	lid = 20002;
+	lid = 22002;
 	rc = test_delete_pdclust(lid, &domain,
 				 LIST_ENUM_ID, EXACT_INLINE,
 				 EXISTING_TEST,
@@ -2104,7 +2126,7 @@ static void test_delete(void)
 	 * Delete a layout object with PDCLUST layout type and LIST enum
 	 * type including noninline entries.
 	 */
-	lid = 20003;
+	lid = 22003;
 	rc = test_delete_pdclust(lid, &domain,
 				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 EXISTING_TEST,
@@ -2115,7 +2137,7 @@ static void test_delete(void)
 	 * Delete a layout object with PDCLUST layout type and LINEAR enum
 	 * type.
 	 */
-	lid = 20004;
+	lid = 22004;
 	rc = test_delete_pdclust(lid, &domain,
 				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				 EXISTING_TEST,
@@ -2123,26 +2145,26 @@ static void test_delete(void)
 	M0_UT_ASSERT(rc == 0);
 
 	/* Delete a layout object with COMPOSITE layout type. */
-	lid = 20005;
+	lid = 22021;
 	rc = test_delete_composite(lid, &domain, 4, 10,
 				   lid * 100, lid * 100 * 100,
 				   CONTIGUOUS_EXTENTS,
 				   !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	//todo Cover other cases
+	//todo Cover other composite cases
 
-	domain.ld_is_db_available = false; //todo
+	domain_ldb_available_set(&domain, false);
 }
 
 static void test_delete_failure(void)
 {
 	uint64_t lid;
 
-	domain.ld_is_db_available = true; //todo
+	domain_ldb_available_set(&domain, true);
 
 	/* Simulate m0_layout_encode() failure in m0_layout_delete(). */
-	lid = 21001;
+	lid = 23001;
 	m0_fi_enable_off_n_on_m("m0_layout_encode", "lo_encode_err", 1, 1);
 	rc = test_delete_pdclust(lid, &domain,
 				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
@@ -2156,7 +2178,7 @@ static void test_delete_failure(void)
 	 * enum type, that does not exist in the DB, to verify that it results
 	 * into the error ENOENT.
 	 */
-	lid = 21002;
+	lid = 23002;
 	rc = test_delete_pdclust(lid, &domain,
 				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				 !EXISTING_TEST,
@@ -2167,7 +2189,7 @@ static void test_delete_failure(void)
 	 * Simulate cursor get failure in noninline_write() that is in the
 	 * path of list_encode() which is in the path of m0_layout_encode().
 	 */
-	lid = 21003;
+	lid = 23003;
 	m0_fi_enable_once("noninline_write", "cursor_get_err");
 	rc = test_delete_pdclust(lid, &domain,
 				 LIST_ENUM_ID, MORE_THAN_INLINE,
@@ -2179,7 +2201,7 @@ static void test_delete_failure(void)
 	 * Simulate cursor delete failure in noninline_write() that is in the
 	 * path of list_encode() which is in the path of m0_layout_encode().
 	 */
-	lid = 21004;
+	lid = 23004;
 	m0_fi_enable_once("noninline_write", "cursor_del_err");
 	rc = test_delete_pdclust(lid, &domain,
 				 LIST_ENUM_ID, MORE_THAN_INLINE,
@@ -2192,7 +2214,7 @@ static void test_delete_failure(void)
 	 * enum type, that has non-zero user count, to verify that it results
 	 * into the error -EPROTO.
 	 */
-	lid = 21005;
+	lid = 23005;
 	m0_fi_enable_once("test_delete_pdclust", "nonzero_user_count_err");
 	rc = test_delete_pdclust(lid, &domain,
 				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
@@ -2200,7 +2222,7 @@ static void test_delete_failure(void)
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EPROTO);
 
-	domain.ld_is_db_available = false; //todo
+	domain_ldb_available_set(&domain, false);
 }
 
 #endif /* __KERNEL__ */
@@ -2230,12 +2252,10 @@ const struct m0_test_suite layout_ut = {
 		{ "layout-enum-ops", test_enum_operations },
 		{ "layout-max-recsize", test_max_recsize },
 		{ "layout-recsize", test_recsize },
-		{ "layout-pdclust-instance", test_pdclust_instance },
-		{ "layout-pdclust-instance-failure",
-					test_pdclust_instance_failure },
-		{ "layout-composite-instance", test_composite_instance },
-		{ "layout-composite-layer-ops-inmem-only",
-					test_composite_layer_ops_inmem_only }, //todo rm
+		{ "layout-instance", test_instance },
+		{ "layout-instance-failure", test_instance_failure },
+		{ "layout-composite-layer-ops-inmem",
+					test_composite_layer_ops_inmem },
 #ifndef __KERNEL__
 		{ "layout-lookup", test_lookup },
 		{ "layout-lookup-failure", test_lookup_failure },
@@ -2246,7 +2266,7 @@ const struct m0_test_suite layout_ut = {
 		{ "layout-delete", test_delete },
 		{ "layout-delete-failure", test_delete_failure },
 		{ "layout-composite-layer-ops-indb",
-					test_composite_layer_ops_indb }, //todo rm
+					test_composite_layer_ops_indb },
 #endif
 		{ NULL, NULL }
 	}
diff --git a/layout/ut/pdclust.c b/layout/ut/pdclust.c
index 9eb1a29..a7478bb 100644
--- a/layout/ut/pdclust.c
+++ b/layout/ut/pdclust.c
@@ -1262,9 +1262,9 @@ int test_recsize_pdclust(uint64_t lid, struct m0_layout_domain *domain,
 }
 
 /* Tests the APIs supported for m0_pdclust_instance object. */
-int test_pdclust_instance_obj(uint64_t lid, struct m0_layout_domain *domain,
-			      uint32_t enum_id, uint32_t inline_test,
-			      bool failure_test)
+int test_instance_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+			  uint32_t enum_id, uint32_t inline_test,
+			  bool failure_test)
 {
 	struct m0_uint128             seed;
 	uint32_t                      N;
diff --git a/layout/ut/pdclust.h b/layout/ut/pdclust.h
index 3cc02d2..a6aab7c 100644
--- a/layout/ut/pdclust.h
+++ b/layout/ut/pdclust.h
@@ -64,9 +64,9 @@ int test_enum_ops_pdclust(uint64_t lid, struct m0_layout_domain *domain,
 			  uint32_t enum_id, uint32_t inline_test);
 int test_recsize_pdclust(uint64_t lid, struct m0_layout_domain *domain,
 			  uint32_t enum_id, uint32_t inline_test);
-int test_pdclust_instance_obj(uint64_t lid, struct m0_layout_domain *domain,
-			      uint32_t enum_id, uint32_t inline_test,
-			      bool failure_test);
+int test_instance_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+			  uint32_t enum_id, uint32_t inline_test,
+			  bool failure_test);
 int test_lookup_pdclust(uint64_t lid, struct m0_layout_domain *domain,
 			uint32_t enum_id, uint32_t inline_test,
 			bool existing_test, bool failure_test);
-- 
1.8.3.2

