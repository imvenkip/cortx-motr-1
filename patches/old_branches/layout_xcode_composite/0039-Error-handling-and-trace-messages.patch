From 14d9ec21120907f21d9da729bce198db498c3cb9 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Mon, 7 Jan 2013 18:25:22 +0530
Subject: [PATCH 039/157] Error handling and trace messages

---
 addb/addb.h        |  45 ++--
 layout/composite.c | 644 +++++++++++++++++++++++++++++++++++++----------------
 layout/composite.h |  16 +-
 layout/layout.c    |   4 +
 layout/layout_db.c |   2 -
 5 files changed, 490 insertions(+), 221 deletions(-)

diff --git a/addb/addb.h b/addb/addb.h
index c202482..fdd74ce 100644
--- a/addb/addb.h
+++ b/addb/addb.h
@@ -246,28 +246,29 @@ struct m0_addb_ev_ops {
    To avoid event ID conflict, all event ID should be defined here.
 */
 enum m0_addb_event_id {
-	M0_ADDB_EVENT_OOM                   = 0x1ULL,
-	M0_ADDB_EVENT_FUNC_FAIL             = 0x2ULL,
-
-	M0_ADDB_EVENT_NET_SEND              = 0x10ULL,
-	M0_ADDB_EVENT_NET_CALL              = 0x11ULL,
-	M0_ADDB_EVENT_NET_QSTATS            = 0x12ULL,
-	M0_ADDB_EVENT_NET_LNET_OPEN         = 0x13ULL,
-	M0_ADDB_EVENT_NET_LNET_CLOSE        = 0x14ULL,
-	M0_ADDB_EVENT_NET_LNET_CLEANUP      = 0x15ULL,
-
-	M0_ADDB_EVENT_COB_MDEXISTS          = 0x21ULL,
-	M0_ADDB_EVENT_COB_MDDELETE          = 0x22ULL,
-
-	M0_ADDB_EVENT_TRACE		    = 0x30ULL,
-
-	M0_ADDB_EVENT_LAYOUT_DECODE_FAIL    = 0x41ULL,
-	M0_ADDB_EVENT_LAYOUT_ENCODE_FAIL    = 0x42ULL,
-	M0_ADDB_EVENT_LAYOUT_LOOKUP_FAIL    = 0x43ULL,
-	M0_ADDB_EVENT_LAYOUT_ADD_FAIL       = 0x44ULL,
-	M0_ADDB_EVENT_LAYOUT_UPDATE_FAIL    = 0x45ULL,
-	M0_ADDB_EVENT_LAYOUT_DELETE_FAIL    = 0x46ULL,
-	M0_ADDB_EVENT_LAYOUT_TILE_CACHE_HIT = 0x47ULL
+	M0_ADDB_EVENT_OOM                       = 0x1ULL,
+	M0_ADDB_EVENT_FUNC_FAIL                 = 0x2ULL,
+
+	M0_ADDB_EVENT_NET_SEND                  = 0x10ULL,
+	M0_ADDB_EVENT_NET_CALL                  = 0x11ULL,
+	M0_ADDB_EVENT_NET_QSTATS                = 0x12ULL,
+	M0_ADDB_EVENT_NET_LNET_OPEN             = 0x13ULL,
+	M0_ADDB_EVENT_NET_LNET_CLOSE            = 0x14ULL,
+	M0_ADDB_EVENT_NET_LNET_CLEANUP          = 0x15ULL,
+
+	M0_ADDB_EVENT_COB_MDEXISTS              = 0x21ULL,
+	M0_ADDB_EVENT_COB_MDDELETE              = 0x22ULL,
+
+	M0_ADDB_EVENT_TRACE		        = 0x30ULL,
+
+	M0_ADDB_EVENT_LAYOUT_DECODE_FAIL        = 0x41ULL,
+	M0_ADDB_EVENT_LAYOUT_ENCODE_FAIL        = 0x42ULL,
+	M0_ADDB_EVENT_LAYOUT_LOOKUP_FAIL        = 0x43ULL,
+	M0_ADDB_EVENT_LAYOUT_ADD_FAIL           = 0x44ULL,
+	M0_ADDB_EVENT_LAYOUT_UPDATE_FAIL        = 0x45ULL,
+	M0_ADDB_EVENT_LAYOUT_DELETE_FAIL        = 0x46ULL,
+	M0_ADDB_EVENT_LAYOUT_TILE_CACHE_HIT     = 0x47ULL,
+	M0_ADDB_EVENT_LAYOUT_COMP_LAYER_OP_FAIL = 0x48ULL
 };
 
 /**
diff --git a/layout/composite.c b/layout/composite.c
index 55d3243..45dfb9f 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -99,6 +99,8 @@ struct layer_sublayout_rec {
 };
 M0_BASSERT(M0_IS_8ALIGNED(sizeof(struct layer_sublayout_rec)));
 
+M0_ADDB_EV_DECLARE(comp_ext_op_fail, M0_ADDB_CALL);
+
 /**
  * Compare layer_sublayout table keys.
  * This is a 3WAY comparison.
@@ -298,12 +300,17 @@ static int layer_in_memory_write(struct m0_composite_layout *cl,
 
 	/* Zeroth layer is getting added. */
 	M0_PRE(ergo(cl->cl_layers_nr == 0,
-		    composite_allocated_invariant(cl)));
-	M0_PRE(ergo(cl->cl_layers_nr == 0, extlist == NULL && ext_nr == 0));
+		    composite_allocated_invariant(cl) &&
+		    extlist == NULL && ext_nr == 0));
 	/* Zeroth layer is already added. */
-	M0_PRE(ergo(cl->cl_layers_nr > 0, composite_invariant(cl)));
-	M0_PRE(ergo(cl->cl_layers_nr > 0, extlist != NULL && ext_nr > 0));
-
+	M0_PRE(ergo(cl->cl_layers_nr > 0,
+		    composite_invariant(cl) &&
+		    extlist != NULL && ext_nr > 0));
+
+	M0_ENTRY("lid %llu, sublayout_id %llu, extlist %p, ext_nr %lu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long long)sublayout->l_id,
+		 extlist, (unsigned long)ext_nr);
 	M0_ALLOC_PTR(layer);
 	if (layer == NULL) {
 		m0_layout__log("layer_in_memory_write",
@@ -323,8 +330,9 @@ static int layer_in_memory_write(struct m0_composite_layout *cl,
 	if (lr != NULL)
 		*lr = layer;
 	M0_POST(composite_invariant(cl));
+	M0_POST(ergo(ext_nr == 0, cl->cl_layers_nr == 1));
 	M0_POST(ergo(ext_nr > 0, cl->cl_layers_nr > 1));
-	return 0;
+	M0_RETURN(0);
 }
 
 static int composite_populate(struct m0_composite_layout *cl,
@@ -334,6 +342,8 @@ static int composite_populate(struct m0_composite_layout *cl,
 	int rc;
 
 	M0_PRE(composite_allocated_invariant(cl));
+	M0_PRE(m0_layout__invariant(oldlayout));
+
 	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 	m0_layout__populate(&cl->cl_base, user_count);
 
@@ -347,7 +357,7 @@ static int composite_populate(struct m0_composite_layout *cl,
 
 M0_INTERNAL int m0_composite_build(struct m0_layout_domain *dom,
 				   uint64_t lid,
-				   struct m0_layout *old_layout,
+				   struct m0_layout *oldlayout,
 				   struct m0_composite_layout **out)
 {
 	struct m0_layout           *l;
@@ -363,7 +373,7 @@ M0_INTERNAL int m0_composite_build(struct m0_layout_domain *dom,
 		cl = bob_of(l, struct m0_composite_layout, cl_base,
 			    &composite_bob);
 		M0_ASSERT(composite_allocated_invariant(cl));
-		rc = composite_populate(cl, 0, old_layout);
+		rc = composite_populate(cl, 0, oldlayout);
 		if (rc == 0) {
 			*out = cl;
 			m0_mutex_unlock(&l->l_lock);
@@ -405,8 +415,7 @@ static void composite_fini(struct m0_ref *ref)
 		}
 
 		/*
-		 * Release the reference acquired by
-		 * layer_in_memory_write().
+		 * Release the reference acquired by layer_in_memory_write().
 		 */
 		m0_layout_put(layer->clr_l);
 		m0_layer_tlist_del(layer);
@@ -557,6 +566,12 @@ static int extent_in_memory_add(struct m0_composite_layer *layer,
 	struct m0_composite_layer_extent *extent_to_insert;
 
 	M0_PRE(ext_state != M0_CLRES_INVALID);
+	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu",
+		 (unsigned long long)layer->clr_l->l_id,
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end,
+		 (unsigned long long)ext_state);
 
 	ext_to_insert_before = NULL;
 	ext_to_insert_after = NULL;
@@ -591,7 +606,7 @@ static int extent_in_memory_add(struct m0_composite_layer *layer,
 		m0_layer_extent_tlist_add_before(ext_to_insert_before,
 						 extent_to_insert);
 	++layer->clr_extents_nr;
-	return 0;
+	M0_RETURN(0);
 }
 
 //todo Change to ext_
@@ -603,6 +618,14 @@ static int extent_in_memory_delete(struct m0_composite_layer *layer,
 	bool                              ext1_found;
 	struct m0_composite_layer_extent *extent;
 
+	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, "
+		 "old_e_state %llu",
+		 (unsigned long long)layer->clr_l->l_id,
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end,
+		 (unsigned long long)old_ext_state);
+
 	ext1_found = false;
 	m0_tl_for(m0_layer_extent, layer->clr_extents, extent) {
 		if (ext->e_start > extent->cle_ext.e_end)
@@ -620,9 +643,9 @@ static int extent_in_memory_delete(struct m0_composite_layer *layer,
 		m0_layer_extent_tlink_fini(ext1);
 		m0_free(ext1);
 		--layer->clr_extents_nr;
-		return 0;
+		M0_RETURN(0);
 	} else
-		return -ENOENT;
+		M0_RETURN(-ENOENT);
 }
 
 static int extent_in_memory_find(struct m0_composite_layer *layer,
@@ -633,6 +656,14 @@ static int extent_in_memory_find(struct m0_composite_layer *layer,
 	struct m0_composite_layer_extent *extent;
 	bool                              extent_found = false;
 
+	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, "
+		 "expected_e_state %llu",
+		 (unsigned long long)layer->clr_l->l_id,
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end,
+		 (unsigned long long)expected_ext_state);
+
 	m0_tl_for(m0_layer_extent, layer->clr_extents, extent) {
 		if (extent->cle_ext.e_end <= ext->e_start)
 			continue;
@@ -647,9 +678,9 @@ static int extent_in_memory_find(struct m0_composite_layer *layer,
 	if (extent_found) {
 		if (lr_ext != NULL)
 			*lr_ext = extent;
-		return 0;
+		M0_RETURN(0);
 	} else
-		return -ENOENT;
+		M0_RETURN(-ENOENT);
 }
 
 static int extent_in_memory_trim(struct m0_composite_layer *layer,
@@ -661,6 +692,16 @@ static int extent_in_memory_trim(struct m0_composite_layer *layer,
 	int                               rc;
 
 	M0_PRE(M0_IN(extent_op, (CUT_LEFT, CUT_RIGHT)));
+	M0_ENTRY("lid %llu, layer %lu, extent_op %d, "
+		 "seg_e_start %llu, seg_e_end %llu, seg_val %llu, "
+		 "e_start %llu, e_end %llu",
+		 (unsigned long long)layer->clr_l->l_id,
+		 (unsigned long)layer->clr_idx, extent_op,
+		 (unsigned long long)seg->ee_ext.e_start,
+		 (unsigned long long)seg->ee_ext.e_end,
+		 (unsigned long long)seg->ee_val,
+		 (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end);
 
 	rc = extent_in_memory_find(layer, &seg->ee_ext, seg->ee_val, &lr_ext);
 	if (rc == 0) {
@@ -674,7 +715,7 @@ static int extent_in_memory_trim(struct m0_composite_layer *layer,
 			/* Retain right part of the existing segment. */
 			lr_ext->cle_ext.e_start = ext->e_end;
 	}
-	return rc;
+	M0_RETURN(rc);
 }
 
 /* todo %s/extent/ext everywhere else? */
@@ -687,15 +728,16 @@ static int ext_in_memory_adjust(struct m0_composite_layer *layer,
 
 	M0_PRE(M0_IN(extent_op, (DELETE, CUT_LEFT, CUT_RIGHT)));
 
-	M0_ENTRY("layer[%lu]: seg e_start %llu, seg e_end %llu, "
-		 "seg val %llu, e_start %llu, e_end %llu, extent_op %lu",
-		 (unsigned long)layer->clr_idx,
+	M0_ENTRY("lid %llu, layer %lu, extent_op %d, "
+		 "seg_e_start %llu, seg_e_end %llu, seg_val %llu, "
+		 "e_start %llu, e_end %llu",
+		 (unsigned long long)layer->clr_l->l_id,
+		 (unsigned long)layer->clr_idx, extent_op,
 		 (unsigned long long)seg->ee_ext.e_start,
 		 (unsigned long long)seg->ee_ext.e_end,
 		 (unsigned long long)seg->ee_val,
 		 (ext != NULL) ? (unsigned long long)ext->e_start : 0,
-		 (ext != NULL) ? (unsigned long long)ext->e_end : 0,
-		 (unsigned long)extent_op);
+		 (ext != NULL) ? (unsigned long long)ext->e_end : 0);
 
 	/*
 	 * Extents with the state M0_CLRES_INVALID are not stored in the
@@ -738,10 +780,15 @@ static int extent_in_db_write(struct m0_emap_cursor *it,
 
 	//Check about the locking
 
-	M0_LOG(M0_DEBUG, "layer idx %lu, e_start %llu, e_end %llu",
-	       (unsigned long)layer->clr_idx,
-	       (unsigned long long)ext_to_add->e_start,
-	       (unsigned long long)ext_to_add->e_end);
+	M0_ENTRY("lid %llu, layer %lu, "
+		 "e_start %llu, e_end %llu, new_e_state %llu, "
+		 "in_memory_list_update %d",
+		 (unsigned long long)layer->clr_l->l_id,
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)ext_to_add->e_start,
+		 (unsigned long long)ext_to_add->e_end,
+		 (unsigned long long)new_ext_state,
+		 in_memory_list_update);
 
 	/* LAMBDA is not available for the kernel mode. */
 
@@ -757,8 +804,8 @@ static int extent_in_db_write(struct m0_emap_cursor *it,
 	 * the extents for the specific layer.
 	 *
 	 * Each call-back takes a segment argument, seg. seg->ee_ext is an
-	 * extent associated with the specified layer (todo) and seg->ee_val
-	 * is the original state of the extent from the on-disk extent map.
+	 * extent associated with the specified layer as is stored in the
+	 * on-disk extent map and seg->ee_val is the state of that extent.
 	 *
 	 * Here is an example to illustrate the sequence of operations
 	 * performed by m0_emap_paste() and how the in-memory list of extents
@@ -818,9 +865,6 @@ static int extent_in_db_write(struct m0_emap_cursor *it,
 			      uint64_t val) {
 			/* Cut left. */
 			if (in_memory_list_update) {
-				//todo rm following
-				M0_ASSERT(extent->e_start == ext.e_start);
-				//M0_ASSERT(extent->e_end == ext.e_end);//fails
 				rc_cb = rc_cb ?: ext_in_memory_adjust(layer,
 								     CUT_LEFT,
 								     seg,
@@ -832,10 +876,6 @@ static int extent_in_db_write(struct m0_emap_cursor *it,
 			      uint64_t val) {
 			/* Cut right. */
 			if (in_memory_list_update) {
-				//todo rm following
-				M0_ASSERT(extent->e_start == ext.e_start);
-				//todo rm following
-				M0_ASSERT(extent->e_end == ext.e_end);
 				rc_cb = rc_cb ?: ext_in_memory_adjust(layer,
 								     CUT_RIGHT,
 								     seg,
@@ -848,10 +888,10 @@ static int extent_in_db_write(struct m0_emap_cursor *it,
 	if (rc == 0 && in_memory_list_update &&
 	    new_ext_state != M0_CLRES_INVALID) {
 		/*
-		 * Now that the deletion of the extents applicable from the
-		 * in-memory list of the extents has been handled through the
+		 * Now that the deletion of the extents from the in-memory list
+		 * of the extents (if appplicable) has been handled through the
 		 * usage of ext_in_memory_adjust() as above, let's add the
-		 * extent to the in-memory list of the extents, if applicable.
+		 * extent to the in-memory list of the extents (if applicable).
 		 *
 		 * Extents with the state M0_CLRES_INVALID are not stored in
 		 * the in-memory list of the extents. Hence, the latter
@@ -859,20 +899,18 @@ static int extent_in_db_write(struct m0_emap_cursor *it,
 		 */
 		rc = extent_in_memory_find(layer, ext_to_add,
 					   new_ext_state, NULL);
-		if (rc == -ENOENT) {
+		if (rc == -ENOENT)
 			rc = extent_in_memory_add(layer, ext_to_add,
 						  new_ext_state);
-			M0_ASSERT(rc == 0); //todo handle
-		}
 	}
-	return rc;
+	M0_RETURN(rc);
 #else
 	M0_ASSERT(0);
 	return -EPROTO;
 #endif /* __KERNEL__ */
 }
 
-static int sublayout_id_in_db_read(const struct m0_composite_layout *cl,
+static int sublayout_id_in_db_read(struct m0_composite_layout *cl,
 				   uint32_t layer_idx,
 				   struct m0_db_tx *tx,
 				   uint64_t *sublayout_id)
@@ -883,6 +921,11 @@ static int sublayout_id_in_db_read(const struct m0_composite_layout *cl,
 	struct layer_sublayout_rec    rec;
 	int                           rc;
 
+	M0_ENTRY("lid %llu, layer %lu, sublayout_id %llu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer_idx,
+		 (unsigned long long)sublayout_id);
+
 	csd = cl->cl_base.l_dom->ld_type_data[m0_composite_layout_type.lt_id];
 
 	key.lrsmk_comp_lid = cl->cl_base.l_id;
@@ -892,16 +935,25 @@ static int sublayout_id_in_db_read(const struct m0_composite_layout *cl,
 	m0_db_pair_setup(&pair, &csd->csd_layer_sublayout,
 			 &key, sizeof key, &rec, sizeof rec);
 	rc = m0_table_lookup(tx, &pair);
-	M0_ASSERT(rc == 0 || rc == -ENOENT); //todo Handle error
+	if (rc != 0)
+		m0_layout__log("m0_layout_lookup", "m0_table_lookup() failed",
+			       &m0_addb_func_fail, &cl->cl_base.l_addb,
+			       cl->cl_base.l_id, rc);
+	else
+		*sublayout_id = rec.lrsmr_sublayout_lid;
 	m0_db_pair_fini(&pair);
 
-	*sublayout_id = rec.lrsmr_sublayout_lid;
 	M0_POST(ergo(rc == 0, *sublayout_id > 0));
-	return rc;
+	M0_RETURN(rc);
 }
 
+/*
+ * todo If M0_ADDB_ADD() does not need the ctx to be const, then many
+ * functions like this one can accept cl as a const arg. Check once ADDB
+ * changes are in master.
+ */
 //todo change it to _add
-static int sublayout_id_in_db_write(const struct m0_composite_layout *cl,
+static int sublayout_id_in_db_write(struct m0_composite_layout *cl,
 				    const struct m0_composite_layer *layer,
 				    struct m0_db_tx *tx)
 {
@@ -912,6 +964,11 @@ static int sublayout_id_in_db_write(const struct m0_composite_layout *cl,
 	struct layer_sublayout_rec    rec;
 	int                           rc;
 
+	M0_ENTRY("lid %llu, layer %lu, sublayout_id %llu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)layer->clr_l->l_id);
+
 	if (layer->clr_idx > 0) {
 		/*
 		 * Verify that the sublayout for the zeroth layer has already
@@ -922,13 +979,13 @@ static int sublayout_id_in_db_write(const struct m0_composite_layout *cl,
 		 */
 		rc = sublayout_id_in_db_read(cl, 0, tx, &sublayout_id);
 		if (rc != 0) {
-			/*
-			 * todo ADDB rec etc, indicating the composite layout
-			 * does not seem to be added to the DB.
-			 */
+			M0_LOG(M0_ERROR, "lid %llu, The composite layout does "
+			       "not seem to be added to DB, prior to adding "
+			       "the layer %lu",
+			       (unsigned long long)cl->cl_base.l_id,
+			       (unsigned long)layer->clr_idx);
+			return rc;
 		}
-		M0_ASSERT(rc == 0); //todo rm once handled above
-		M0_ASSERT(sublayout_id > 0);
 	}
 
 	/*
@@ -944,9 +1001,13 @@ static int sublayout_id_in_db_write(const struct m0_composite_layout *cl,
 	m0_db_pair_setup(&pair, &csd->csd_layer_sublayout,
 			 &key, sizeof key, &rec, sizeof rec);
 	rc = m0_table_insert(tx, &pair);
-	M0_ASSERT(rc == 0); //todo Handle error
+	if (rc != 0)
+		m0_layout__log("sublayout_id_in_db_write",
+			       "m0_table_insert() failed",
+			       &m0_addb_func_fail, &layer->clr_l->l_addb,
+			       layer->clr_l->l_id, rc);
 	m0_db_pair_fini(&pair);
-	return rc;
+	M0_RETURN(rc);
 }
 
 static int sublayout_id_in_db_delete(const struct m0_composite_layout *cl,
@@ -959,18 +1020,26 @@ static int sublayout_id_in_db_delete(const struct m0_composite_layout *cl,
 	struct layer_sublayout_rec    rec;
 	int                           rc;
 
+	M0_ENTRY("lid %llu, layer %lu, sublayout_id %llu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)layer->clr_l->l_id);
+
 	csd = cl->cl_base.l_dom->ld_type_data[m0_composite_layout_type.lt_id];
 
 	key.lrsmk_comp_lid = cl->cl_base.l_id;
 	key.lrsmk_layer_idx = layer->clr_idx;
 	key.lrsmk_pad = 0;
-	//todo rm rec.lrsmr_sublayout_lid = layer->clr_l->l_id;
 	m0_db_pair_setup(&pair, &csd->csd_layer_sublayout,
 			 &key, sizeof key, &rec, sizeof rec);
 	rc = m0_table_delete(tx, &pair);
-	M0_ASSERT(rc == 0); //todo Handle error
+	if (rc != 0)
+		m0_layout__log("sublayout_id_in_db_delete",
+			       "m0_table_delete() failed",
+			       &m0_addb_func_fail, &layer->clr_l->l_addb,
+			       layer->clr_l->l_id, rc);
 	m0_db_pair_fini(&pair);
-	return rc;
+	M0_RETURN(rc);
 }
 
 static struct m0_emap *emap_from_cl(const struct m0_composite_layout *cl)
@@ -993,38 +1062,65 @@ static int extentmap_in_db_write(struct m0_composite_layout *cl,
 	struct layout_prefix              prefix;
 	int                               rc;
 
+	M0_ENTRY("lid %llu, layer %lu, sublayout_id %llu, "
+		 "if_extents_associated %d",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)layer->clr_l->l_id,
+		 if_extents_associated);
+
 	emap = emap_from_cl(cl);
 	prefix_set(&prefix, cl->cl_base.l_id, layer->clr_idx);
 	rc = m0_emap_obj_insert(emap, tx, (struct m0_uint128 *)&prefix,
 				M0_CLRES_INVALID);
-	if (rc == -EEXIST)
-		return rc; //todo ADDB rec etc.
-	M0_ASSERT(rc == 0); // todo || rc == -EEXIST); //todo handle err
+	if (rc != 0) {
+		m0_layout__log("extentmap_in_db_write",
+			       "m0_emap_obj_insert() failed",
+			       &m0_addb_func_fail, &cl->cl_base.l_addb,
+			       cl->cl_base.l_id, rc);
+		return rc;
+	}
 
 	if (!if_extents_associated)
-		return rc;
+		M0_RETURN(rc);
 
 	rc = m0_emap_lookup(emap, tx, (struct m0_uint128 *)&prefix, 0, &it);
-	M0_ASSERT(rc == 0); //todo handle err
+	if (rc != 0) {
+		m0_layout__log("extentmap_in_db_write",
+			       "m0_emap_lookup() failed",
+			       &m0_addb_func_fail, &cl->cl_base.l_addb,
+			       cl->cl_base.l_id, rc);
+		m0_emap_obj_delete(emap, tx, (struct m0_uint128 *)&prefix);
+		/*
+		 * If m0_emap_lookup() has failed for no apparent reason, it is
+		 * likely that m0_emap_obj_delete() too would fail. Hence,
+		 * ignoring its status.
+		 */
+		return rc;
+	}
+
 	seg = m0_emap_seg_get(&it);
 	M0_ASSERT(seg->ee_ext.e_start == 0);
 	M0_ASSERT(seg->ee_ext.e_end == M0_BINDEX_MAX + 1);
 	M0_ASSERT(seg->ee_val == M0_CLRES_INVALID);
 
-	M0_LOG(M0_DEBUG, "layer[%lu]: sublayout_lid %llu",
-	       (unsigned long)layer->clr_idx,
-	       (unsigned long long)layer->clr_l->l_id);
-
 	m0_tl_for(m0_layer_extent, layer->clr_extents, extent) {
 		M0_ASSERT(M0_IN(extent->cle_state, (M0_CLRES_VALID,
 						    M0_CLRES_FLATTENING)));
 		rc = extent_in_db_write(&it, layer, &extent->cle_ext,
 					extent->cle_state, false);
-		M0_ASSERT(rc == 0); //todo Handle
+		if (rc != 0) {
+			M0_LOG(M0_ERROR, "lid %llu, layer %lu, "
+			       "extent_in_db_write() failed, rc %d",
+			       (unsigned long long)cl->cl_base.l_id,
+			       (unsigned long)layer->clr_idx, rc);
+			m0_emap_close(&it);
+			return rc;
+		}
 	} m0_tl_endfor;
-	m0_emap_close(&it);
 
-	return rc;
+	m0_emap_close(&it);
+	M0_RETURN(rc);
 }
 
 static int layer_in_db_write(struct m0_composite_layout *cl,
@@ -1038,16 +1134,20 @@ static int layer_in_db_write(struct m0_composite_layout *cl,
 	M0_PRE(layer->clr_idx > 0);
 	M0_PRE(tx != NULL);
 
+	M0_ENTRY("lid %llu, layer %lu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer->clr_idx);
+
 	/* Write 'the extent map for this layer' to the DB. */
 	rc = extentmap_in_db_write(cl, layer, true, tx);
-	M0_ASSERT(rc == 0); //todo Handle
+	if (rc != 0)
+		M0_RETURN(rc);
 
 	/* Write 'the sublayout id for this layer' to the DB. */
 	rc = sublayout_id_in_db_write(cl, layer, tx);
-	M0_ASSERT(rc == 0); //todo Handle
 
-	M0_POST(composite_invariant(cl));
-	return rc;
+	M0_POST(ergo(rc == 0, composite_invariant(cl)));
+	M0_RETURN(rc);
 }
 
 M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
@@ -1064,14 +1164,28 @@ M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
 	M0_PRE(m0_layout__invariant(sublayout));
 	M0_PRE(extlist != NULL);
 
-	M0_ENTRY();
+	M0_ENTRY("lid %llu, sublayout_id %llu, extlist %p, ext_nr %ld",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long long)sublayout->l_id,
+		 extlist, (unsigned long)ext_nr);
+
 	if (m0_layer_extent_tlist_is_empty(extlist) || ext_nr == 0) {
-		//todo ADDB, TRACE rec etc
-		return -EINVAL;
+		rc = -EINVAL;
+		m0_layout__log("m0_composite_layer_add",
+			       "Invalid list of extents",
+			       &comp_ext_op_fail, &cl->cl_base.l_addb,
+			       cl->cl_base.l_id, rc);
+		return rc;
 	}
 
 	rc = layer_in_memory_write(cl, sublayout, extlist, ext_nr, &layer);
-	M0_ASSERT(rc == 0); //todo Handle error
+	if (rc != 0) {
+		m0_layout__log("m0_composite_layer_add",
+			       "failed to write layer in memory",
+			       &comp_ext_op_fail, &cl->cl_base.l_addb,
+			       cl->cl_base.l_id, rc);
+		return rc;
+	}
 
 	if (tx == NULL)
 		return rc; //todo Handle. What user space code shall do?
@@ -1083,10 +1197,16 @@ M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
 	 * kernel space? If not, who will sync it up into the DB and when?
 	 */
 	rc = layer_in_db_write(cl, layer, tx);
+	if (rc != 0) {
+		m0_layout__log("m0_composite_layer_add",
+			       "failed to write layer in DB",
+			       &comp_ext_op_fail, &cl->cl_base.l_addb,
+			       cl->cl_base.l_id, rc);
+		/* todo Undo Writing layer to the DB ? */
+	}
 
 	M0_POST(composite_invariant(cl));
-	M0_LEAVE(); //todo addb record
-	return rc;
+	M0_RETURN(rc);
 }
 
 static struct m0_layout *layout_find(struct m0_layout_domain *dom,
@@ -1095,7 +1215,6 @@ static struct m0_layout *layout_find(struct m0_layout_domain *dom,
 	struct m0_layout *sublayout;
 
 	sublayout = m0_layout_find(dom, lid);
-	M0_ASSERT(sublayout != NULL);
 	/**
 	 * @todo Eventually, if the layout is not found in the cache, it shall
 	 * be fetched either from the DB or over the network, as applicable.
@@ -1104,7 +1223,17 @@ static struct m0_layout *layout_find(struct m0_layout_domain *dom,
 	 *   and is_network_available.
 	 * - The layout id to be extended to 128 bit to store the layout type,
 	 *   so that the DB lookup can be performed for it.
+	 *
+	 * Until the time above changes are implemented (through the task
+	 * lined up next to the current one), the user (UT for the time being)
+	 * shall ensure that the sublayouts are cached prior to 'creating a
+	 * composite layout and adding layers to it'. The following assert
+	 * ensures the same.
+	 *
+	 * Remove the following assert once the above mentioned changes
+	 * are implemented.
 	 */
+	M0_ASSERT(sublayout != NULL);
 	return sublayout;
 }
 
@@ -1131,7 +1260,9 @@ static int composite_layout_in_buf_read(struct m0_composite_layout *cl,
 	M0_PRE(cur != NULL);
 	M0_PRE(m0_bufvec_cursor_step(cur) >= sizeof *cl_header);
 
-	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
+	M0_ENTRY("lid %llu, user_count %lu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)user_count);
 
 	cl_header = m0_bufvec_cursor_addr(cur);
 	m0_bufvec_cursor_move(cur, sizeof *cl_header);
@@ -1144,20 +1275,24 @@ static int composite_layout_in_buf_read(struct m0_composite_layout *cl,
 		sublayout = layout_find(cl->cl_base.l_dom,
 					lr_header->clh_lid);
 		if (sublayout == NULL) {
-			/**
-			 * @todo Remove this assert once the changes are
-			 * implemented to layout_find(), as noted there.
-			 * Until then, the assert in layout_find() will flag
-			 * the error if it encounters.
-			 */
-			M0_ASSERT(0);
-			return -EINVAL; //todo ADDB rec etc
+			M0_LOG(M0_ERROR, "lid %llu, sublayout with lid %llu "
+			       "does not exist",
+			       (unsigned long long)cl->cl_base.l_id,
+			       (unsigned long long)lr_header->clh_lid);
+			return -EINVAL;
 		}
 
 		M0_ASSERT(lr_header->clh_idx == i);
 		if (lr_header->clh_idx == 0) { /* Zeroth layer */
 			rc = composite_populate(cl, user_count, sublayout);
-			M0_ASSERT(rc == 0); //todo Handle error
+			if (rc != 0) {
+				/*
+				 * Release the reference added by
+				 * m0_layout_find().
+				 */
+				m0_layout_put(sublayout);
+				M0_RETURN(rc);
+			}
 		} else {
 			M0_ALLOC_PTR(extents);
 			if (extents == NULL) {
@@ -1213,7 +1348,14 @@ static int composite_layout_in_buf_read(struct m0_composite_layout *cl,
 			rc = m0_composite_layer_add(cl, sublayout, extents,
 						    lr_header->clh_extents_nr,
 						    NULL);
-			M0_ASSERT(rc == 0); //todo Handle error
+			if (rc != 0) {
+				/*
+				 * Release the reference added by
+				 * m0_layout_find().
+				 */
+				m0_layout_put(sublayout);
+				M0_RETURN(rc);
+			}
 		}
 
 		/*
@@ -1239,22 +1381,24 @@ static int extentmap_in_db_read(struct m0_composite_layout *cl,
 	struct m0_composite_layer_extent *extent;
 	int                               rc;
 
+	M0_ENTRY("lid %llu, layer %lu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer_idx);
+
 	emap = emap_from_cl(cl);
 	prefix_set(&prefix, cl->cl_base.l_id, layer_idx);
 	rc = m0_emap_lookup(emap, tx, (struct m0_uint128 *)&prefix, 0, &it);
-	if (rc != 0) {//todo Handle err
-		rc = 0; //todo Change this once all the layers'
-			// extents are written to the DB OR when
-			// layers_nr is known in advance
+	if (rc != 0) {
+		m0_layout__log("m0_layout_lookup", "m0_emap_lookup() failed",
+			       &m0_addb_func_fail, &cl->cl_base.l_addb,
+			       cl->cl_base.l_id, rc);
 		return rc;
 	}
 
 	M0_ALLOC_PTR(*extents);
 	if (*extents == NULL) {
-		m0_layout__log("extentmap_in_db_read",
-			       "M0_ALLOC_PTR() failed",
-			       &m0_addb_oom,
-			       &cl->cl_base.l_addb,
+		m0_layout__log("extentmap_in_db_read", "M0_ALLOC_PTR() failed",
+			       &m0_addb_oom, &cl->cl_base.l_addb,
 			       cl->cl_base.l_id, -ENOMEM);
 		m0_emap_close(&it);
 		return -ENOMEM;
@@ -1268,8 +1412,7 @@ static int extentmap_in_db_read(struct m0_composite_layout *cl,
 		M0_ASSERT(!m0_ext_is_empty(&seg->ee_ext));
 		M0_ASSERT(M0_IN(seg->ee_val, (M0_CLRES_INVALID,
 					      M0_CLRES_VALID,
-					      M0_CLRES_FLATTENING )));
-		//todo Handle error, applicable after every m0_emap_seg_get
+					      M0_CLRES_FLATTENING)));
 		M0_ALLOC_PTR(extent);
 		if (extent == NULL) {
 			m0_layout__log("extentmap_in_db_read",
@@ -1306,7 +1449,7 @@ static int extentmap_in_db_read(struct m0_composite_layout *cl,
 
 	M0_POST(ergo(*extents_nr > 0,
 		     !m0_layer_extent_tlist_is_empty(*extents)));
-	return 0; //todo check
+	return rc;
 }
 
 /* Reads layers from the DB, starting from the layer with index as 1. */
@@ -1317,47 +1460,63 @@ static int layers_in_db_read(struct m0_composite_layout *cl,
 	struct m0_layout *sublayout;
 	struct m0_tl     *extents;
 	uint32_t          extents_nr;
-	uint32_t          i;
+	uint32_t          i; /* layer idx */
 	int               rc;
 
+	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
+
 	i = 1;
-	//todo This fn shall accept layers_nr which is to be stored in the
-	//layouts table.
 	while (1) {
 		/* Read 'the sublayout id for this layer' from the DB. */
 		rc = sublayout_id_in_db_read(cl, i, tx, &sublayout_id);
 		if (rc == -ENOENT) {
-			//todo This is to be removed once layers_nr is known
-			rc = 0;
-			break;
+			/*
+			 * The number of layers is not known in advance. So,
+			 * break when the first -ENOENT error is encountered.
+			 */
+			M0_RETURN(0);
+		} else if (rc != 0) {
+			M0_LOG(M0_ERROR, "lid %llu, layer %lu, sublayout id "
+			       "could not be read from DB",
+			       (unsigned long long)cl->cl_base.l_id,
+			       (unsigned long)i);
+			return rc;
 		}
-		M0_ASSERT(rc == 0); /* todo Handle error */
 
 		sublayout = layout_find(cl->cl_base.l_dom, sublayout_id);
 		if (sublayout == NULL) {
-			/**
-			 * @todo Remove this assert once the changes are
-			 * implemented to layout_find(), as noted there.
-			 * Until then, the assert in layout_find() will flag
-			 * the error if it encounters.
-			 */
-			M0_ASSERT(0);
-			return -EINVAL; //todo ADDB rec etc
+			M0_LOG(M0_ERROR, "lid %llu, layer %lu, sublayout with "
+			       "lid %llu does not exist",
+			       (unsigned long long)cl->cl_base.l_id,
+			       (unsigned long)i,
+			       (unsigned long long)sublayout_id);
+			return -EINVAL;
 		}
 
-		M0_LOG(M0_DEBUG, "composite_lid %llu, layer[%lu]: "
-		       "sublayout_lid %llu",
-		       (unsigned long long)cl->cl_base.l_id, (unsigned long)i,
-		       (unsigned long long)sublayout_id);
-
 		/* Read 'the extent map for this layer' from the DB. */
 		rc = extentmap_in_db_read(cl, i, tx, &extents, &extents_nr);
-		M0_ASSERT(rc == 0); //todo Handle
+		if (rc != 0) {
+			M0_LOG(M0_ERROR, "lid %llu, layer %lu, extentmap could"
+			       "not be read from the DB",
+			       (unsigned long long)cl->cl_base.l_id,
+			       (unsigned long)i);
+			/* Release the reference added by m0_layout_find(). */
+			m0_layout_put(sublayout);
+			return rc;
+		}
 
 		/* Now, write the layer to the in-memory layout. */
 		rc = layer_in_memory_write(cl, sublayout, extents, extents_nr,
 					   NULL);
-		M0_ASSERT(rc == 0); //todo Handle error
+		if (rc != 0) {
+			M0_LOG(M0_ERROR, "lid %llu, layer %lu could not be "
+			       "written to the layout",
+			       (unsigned long long)cl->cl_base.l_id,
+			       (unsigned long)i);
+			/* Release the reference added by m0_layout_find(). */
+			m0_layout_put(sublayout);
+			return rc;
+		}
 
 		/*
 		 * Release the reference added by m0_layout_find().
@@ -1368,7 +1527,8 @@ static int layers_in_db_read(struct m0_composite_layout *cl,
 
 		++i;
 	}
-	return rc;
+
+	M0_RETURN(rc);
 }
 
 /**
@@ -1386,22 +1546,30 @@ static int composite_layout_in_db_read(struct m0_composite_layout *cl,
 	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 
 	rc = sublayout_id_in_db_read(cl, 0, tx, &sublayout_id);
-	M0_ASSERT(rc == 0); /* todo Handle error */
+	if (rc != 0) {
+		M0_LOG(M0_ERROR, "lid %llu, layer 0, sublayout id could not "
+		       "be read from DB",
+		       (unsigned long long)cl->cl_base.l_id);
+		return rc;
+	}
 
 	sublayout = layout_find(cl->cl_base.l_dom, sublayout_id);
 	if (sublayout == NULL) {
-		/**
-		 * @todo Remove this assert once the changes are
-		 * implemented to layout_find(), as noted there.
-		 * Until then, the assert in layout_find() will flag
-		 * the error if it encounters.
-		 */
-		M0_ASSERT(0);
-		return -EINVAL; //todo ADDB rec etc
+		M0_LOG(M0_ERROR, "lid %llu, layer 0, sublayout with lid "
+		       "%llu does not exist",
+		       (unsigned long long)cl->cl_base.l_id,
+		       (unsigned long long)sublayout_id);
+		return -EINVAL;
 	}
 
 	rc = composite_populate(cl, user_count, sublayout);
-	M0_ASSERT(rc == 0); //todo Handle error
+	if (rc != 0) {
+		M0_LOG(M0_ERROR, "lid %llu, composite_populate() failed",
+		       (unsigned long long)cl->cl_base.l_id);
+		/* Release the reference added by m0_layout_find(). */
+		m0_layout_put(sublayout);
+		return rc;
+	}
 
 	/*
 	 * Release the reference added by m0_layout_find().
@@ -1411,7 +1579,10 @@ static int composite_layout_in_db_read(struct m0_composite_layout *cl,
 
 	/* Now, proceed to read the subsequent layers from the DB. */
 	rc = layers_in_db_read(cl, tx);
-	return rc;
+	if (rc != 0)
+		M0_LOG(M0_ERROR, "lid %llu, layers could not be read form the "
+		       "DB", (unsigned long long)cl->cl_base.l_id);
+	M0_RETURN(rc);
 }
 
 static const struct m0_layout_ops composite_ops;
@@ -1437,10 +1608,16 @@ static int composite_decode(struct m0_layout *l,
 
 	if (op == M0_LXO_BUFFER_OP) {
 		rc = composite_layout_in_buf_read(cl, cur, user_count);
-		M0_ASSERT(rc == 0); //todo Handle error
+		if (rc != 0)
+			M0_LOG(M0_ERROR, "lid %llu, The layout could not be "
+			       "read from the buffer",
+			       (unsigned long long)cl->cl_base.l_id);
 	} else {
 		rc = composite_layout_in_db_read(cl, tx, user_count);
-		M0_ASSERT(rc == 0); //todo Handle err
+		if (rc != 0)
+			M0_LOG(M0_ERROR, "lid %llu, The layout could not be "
+			       "read from the DB",
+			       (unsigned long long)cl->cl_base.l_id);
 	}
 
 	M0_POST(ergo(rc == 0, composite_invariant(cl)));
@@ -1455,22 +1632,22 @@ static int composite_layout_in_db_add(struct m0_composite_layout *cl,
 	struct m0_composite_layer *layer;
 	int                        rc;
 
+	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
+
 	/*
-	 * Collect the old layout id by referring to the zeroth (bottom
-	 * most) layer from the in-memory layout.
+	 * Collect the old layout id by referring to the zeroth layer from
+	 * the in-memory layout.
 	 */
 	layer = m0_layer_tlist_head(cl->cl_layers);
 	M0_ASSERT(layer->clr_idx == 0);
 	M0_ASSERT(layer->clr_extents_nr == 0);
 	M0_ASSERT(layer->clr_l->l_id > 0); /* old layout id */
 
-	/* Write 'the extent map for zeroth layer' to the DB. */
+	/* Write 'the extent map for the zeroth layer' to the DB. */
 	rc = extentmap_in_db_write(cl, layer, false, tx);
-	if (rc == 0) {
-		/* Write 'the sublayout id for zeroth layer' to the DB. */
+	if (rc == 0)
+		/* Write 'the sublayout id for the zeroth layer' to the DB. */
 		rc = sublayout_id_in_db_write(cl, layer, tx);
-		//M0_ASSERT(rc == 0); //todo Handle
-	} //todo else Handle error
 
 	/**
 	 * @todo In fact, there are no valid extents associated with
@@ -1478,11 +1655,13 @@ static int composite_layout_in_db_add(struct m0_composite_layout *cl,
 	 * M0_CLRES_INVALID state to the layer_ext_map table? Probably
 	 * not unless there is a chance that zeroth layer may need to
 	 * store some extents in future. Will it?
+	 *
+	 * todo Do not write extentmap for the zeroth layer
 	 */
+	M0_LEAVE("lid %llu, rc %d", (unsigned long long)cl->cl_base.l_id, rc);
 	return rc;
 }
 
-//todo Add TC for this
 static int composite_layout_in_db_delete(struct m0_composite_layout *cl,
 					 struct m0_db_tx *tx)
 {
@@ -1497,26 +1676,25 @@ static int composite_layout_in_db_delete(struct m0_composite_layout *cl,
 	 * A composite layout can be deleted from the DB if and only if none of
 	 * its layers contain any valid extent.
 	 */
-	rc = 0;
 	m0_tl_for(m0_layer, cl->cl_layers, layer) {
 		if (layer->clr_idx > 0) { /* Except for the zeroth layer. */
 			if (!m0_layer_extent_tlist_is_empty(
 							layer->clr_extents)) {
-				rc = -EINVAL;
-				//todo ADDB msg etc
-				return rc;
+				M0_LOG(M0_ERROR, "lid %llu, layout can not be "
+				       "deleted since layer %lu still "
+				       "contains %lu extents",
+				       (unsigned long long)cl->cl_base.l_id,
+				       (unsigned long)layer->clr_idx,
+				       (unsigned long)layer->clr_extents_nr);
+				return -EINVAL;;
 			}
 		}
 	} m0_tl_endfor;
 
-	if (rc == -EINVAL) {
-		//todo ADDB etc.
-		return -EINVAL;
-	}
-
 	m0_tl_for(m0_layer, cl->cl_layers, layer) {
 		rc = sublayout_id_in_db_delete(cl, layer, tx);
-		M0_ASSERT(rc == 0); //todo handle
+		if (rc != 0)
+			break;
 
 		/*
 		 * Decrement the user count incremented while adding the
@@ -1525,6 +1703,7 @@ static int composite_layout_in_db_delete(struct m0_composite_layout *cl,
 		m0_layout_user_count_dec(layer->clr_l);
 	} m0_tl_endfor;
 
+	M0_ENTRY("lid %llu, rc %d", (unsigned long long)cl->cl_base.l_id, rc);
 	return rc;
 }
 
@@ -1590,7 +1769,10 @@ static int composite_encode(struct m0_layout *l,
 		rc = 0;
 	} else if (op == M0_LXO_DB_ADD) {
 		rc = composite_layout_in_db_add(cl, tx);
-		M0_ASSERT(rc == 0 || rc == -EEXIST); //todo Handle err
+		if (rc != 0)
+			M0_LOG(M0_ERROR, "lid %llu, layout could not be "
+			       "added to the DB",
+			       (unsigned long long)cl->cl_base.l_id);
 	} else if (op == M0_LXO_DB_UPDATE) {
 		/*
 		 * The auxiliary tables are not to be modified for a layout
@@ -1599,7 +1781,10 @@ static int composite_encode(struct m0_layout *l,
 		rc = 0;
 	} else { /* op == M0_LXO_DB_DELETE */
 		rc = composite_layout_in_db_delete(cl, tx);
-		M0_ASSERT(rc == 0 || rc == -EINVAL); //todo Handle err
+		if (rc != 0)
+			M0_LOG(M0_ERROR, "lid %llu, layout could not be "
+			       "deleted from the DB",
+			       (unsigned long long)cl->cl_base.l_id);
 	}
 
 	M0_LEAVE("lid %llu, rc %d", (unsigned long long)l->l_id, rc);
@@ -1633,14 +1818,13 @@ static struct m0_composite_layer *layer_find(
  * todo Change beahvior of this API to return zeroth layer as the default,
  * once approved in the DLDINSP.
  */
-M0_INTERNAL int m0_composite_layer_ext_lookup(
-				const struct m0_composite_layout *cl,
-				m0_bindex_t offset,
-				struct m0_db_tx *tx,
-				uint32_t *layer_idx,
-				struct m0_ext *ext,
-				uint64_t *state, //todo ext_state
-				struct m0_layout **sublayout)
+M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
+					      m0_bindex_t offset,
+					      struct m0_db_tx *tx,
+					      uint32_t *layer_idx,
+					      struct m0_ext *ext,
+					      uint64_t *ext_state,
+					      struct m0_layout **sublayout)
 {
 	struct m0_emap            *emap;
 	struct m0_emap_cursor      it;
@@ -1652,6 +1836,10 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(
 	int                        rc;
 
 	M0_PRE(composite_invariant(cl));
+	M0_ENTRY("lid %llu, offset %llu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long long)offset);
+	m0_mutex_lock(&cl->cl_base.l_lock);
 	emap = emap_from_cl(cl);
 
 	/* Start the lookup with the top-most layer. */
@@ -1662,16 +1850,22 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(
 		prefix_set(&prefix, cl->cl_base.l_id, i);
 		rc = m0_emap_lookup(emap, tx, (struct m0_uint128 *)&prefix,
 				    offset, &it);
-		M0_ASSERT(rc == 0); //todo handle err
+		if (rc != 0) {
+			m0_layout__log("m0_composite_layer_ext_lookup",
+				       "m0_emap_lookup() failed",
+				       &m0_addb_func_fail, &cl->cl_base.l_addb,
+				       cl->cl_base.l_id, rc);
+			m0_mutex_unlock(&cl->cl_base.l_lock);
+			return rc;
+		}
 
 		seg = m0_emap_seg_get(&it);
 		m0_emap_close(&it);
-
 		M0_ASSERT(seg != NULL);
 		M0_ASSERT(!m0_ext_is_empty(&seg->ee_ext));
 		M0_ASSERT(M0_IN(seg->ee_val, (M0_CLRES_INVALID,
 					      M0_CLRES_VALID,
-					      M0_CLRES_FLATTENING))); //todo handle error
+					      M0_CLRES_FLATTENING)));
 
 		if (seg->ee_val != M0_CLRES_INVALID) {
 			found = true;
@@ -1687,7 +1881,7 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(
 	if (found == true) {
 		*layer_idx = i;
 		*ext = seg->ee_ext;
-		*state = seg->ee_val;
+		*ext_state = seg->ee_val;
 		layer = layer_find(cl, *layer_idx);
 		M0_ASSERT(layer != NULL);
 		*sublayout = layer->clr_l;
@@ -1696,6 +1890,10 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(
 		//todo shall return layer 0?
 		rc = -ENOENT;
 
+	m0_mutex_unlock(&cl->cl_base.l_lock);
+	M0_LEAVE("lid %llu, offset %llu, rc %d, layer_id %lu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long long)offset, rc, (unsigned long)*layer_idx);
 	return rc;
 }
 
@@ -1710,14 +1908,28 @@ M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
 	struct layout_prefix       prefix;
 	int                        rc;
 
-	layer = layer_find(cl, layer_idx);
-	M0_ASSERT(layer != NULL);
+	M0_PRE(composite_invariant(cl));
+	M0_PRE(ext != NULL);
+	M0_PRE(tx != NULL);
+	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end);
 
+	m0_mutex_lock(&cl->cl_base.l_lock);
+	layer = layer_find(cl, layer_idx);
 	emap = emap_from_cl(cl);
 	prefix_set(&prefix, cl->cl_base.l_id, layer->clr_idx);
 	rc = m0_emap_lookup(emap, tx, (struct m0_uint128 *)&prefix,
 			    ext->e_start, &it);
-	M0_ASSERT(rc == 0); //todo handle err
+	if (rc != 0) {
+		m0_layout__log("m0_composite_layer_ext_add",
+			       "m0_emap_lookup() failed",
+			       &m0_addb_func_fail, &cl->cl_base.l_addb,
+			       cl->cl_base.l_id, rc);
+		m0_mutex_unlock(&cl->cl_base.l_lock);
+		return rc;
+	}
 
 	/**
 	 * @todo In short: Break ext into multiple, based on values (extent
@@ -1737,9 +1949,17 @@ M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
 	 */
 
 	rc = extent_in_db_write(&it, layer, ext, M0_CLRES_VALID, true);
-	M0_ASSERT(rc == 0); //todo Handle
-
+	if (rc != 0)
+		m0_layout__log("m0_composite_layer_ext_add",
+			       "extent_in_db_write() failed",
+			       &comp_ext_op_fail, &cl->cl_base.l_addb,
+			       cl->cl_base.l_id, rc);
 	m0_emap_close(&it);
+	m0_mutex_unlock(&cl->cl_base.l_lock);
+	M0_LEAVE("lid %llu, layer %lu, e_start %llu, e_end %llu, rc %d",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end, rc);
 	return rc;
 }
 
@@ -1758,32 +1978,50 @@ M0_INTERNAL int m0_composite_layer_ext_state_update(
 	int                        rc;
 
 	M0_PRE(composite_invariant(cl));
+	M0_PRE(layer_idx > 0);
+	M0_PRE(ext != NULL);
 	M0_PRE(M0_IN(ext_state, (M0_CLRES_VALID, M0_CLRES_FLATTENING)));
+	M0_PRE(tx != NULL);
 
-	layer = layer_find(cl, layer_idx);
-	M0_ASSERT(layer != NULL);
+	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end,
+		 (unsigned long long)ext_state);
 
+	m0_mutex_lock(&cl->cl_base.l_lock);
+	layer = layer_find(cl, layer_idx);
 	emap = emap_from_cl(cl);
 	prefix_set(&prefix, cl->cl_base.l_id, layer->clr_idx);
 	rc = m0_emap_lookup(emap, tx, (struct m0_uint128 *)&prefix,
 			    ext->e_start, &it);
-	M0_ASSERT(rc == 0); //todo handle err
+	if (rc != 0) {
+		m0_layout__log("m0_composite_layer_ext_state_update",
+			       "m0_emap_lookup() failed",
+			       &m0_addb_func_fail, &cl->cl_base.l_addb,
+			       cl->cl_base.l_id, rc);
+		m0_mutex_unlock(&cl->cl_base.l_lock);
+		return rc;
+	}
 
 	/*
 	 * Verify that the ext is one of the valid extents. Update operation
 	 * can not be performed on a non-existing extent.
 	 */
 	seg = m0_emap_seg_get(&it);
+	M0_ASSERT(M0_IN(seg->ee_val, (M0_CLRES_INVALID,
+				      M0_CLRES_VALID,
+				      M0_CLRES_FLATTENING)));
 	if (seg->ee_ext.e_start != ext->e_start ||
 	    seg->ee_ext.e_end != ext->e_end ||
 	    seg->ee_val == M0_CLRES_INVALID) {
-		rc = -ENOENT;
+		rc = -ENOENT; //todo Change it to -EINVAL
 		m0_layout__log("m0_composite_layer_ext_state_update",
 			       "A non-existing extent can not be updated",
-			       //todo &layout_ext_update_fail
-			       &m0_addb_func_fail, &cl->cl_base.l_addb,
+			       &comp_ext_op_fail, &cl->cl_base.l_addb,
 			       cl->cl_base.l_id, rc);
 		m0_emap_close(&it);
+		m0_mutex_unlock(&cl->cl_base.l_lock);
 		return rc;
 	}
 
@@ -1805,10 +2043,20 @@ M0_INTERNAL int m0_composite_layer_ext_state_update(
 	 */
 
 	rc = extent_in_db_write(&it, layer, ext, ext_state, true);
-	M0_ASSERT(rc == 0); //todo Handle
-
+	if (rc != 0)
+		m0_layout__log("m0_composite_layer_ext_state_update",
+			       "extent_in_db_write() failed",
+			       &comp_ext_op_fail, &cl->cl_base.l_addb,
+			       cl->cl_base.l_id, rc);
 	m0_emap_close(&it);
+	m0_mutex_unlock(&cl->cl_base.l_lock);
 	M0_POST(composite_invariant(cl));
+	M0_LEAVE("lid %llu, layer %lu, e_start %llu, e_end %llu, "
+		 "e_state %llu, rc %d",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end,
+		 (unsigned long long)ext_state, rc);
 	return rc;
 }
 
@@ -1823,14 +2071,25 @@ M0_INTERNAL int m0_composite_layer_ext_delete(struct m0_composite_layout *cl,
 	struct layout_prefix       prefix;
 	int                        rc;
 
-	layer = layer_find(cl, layer_idx);
-	M0_ASSERT(layer != NULL);
+	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end);
 
+	m0_mutex_lock(&cl->cl_base.l_lock);
+	layer = layer_find(cl, layer_idx);
 	emap = emap_from_cl(cl);
 	prefix_set(&prefix, cl->cl_base.l_id, layer->clr_idx);
 	rc = m0_emap_lookup(emap, tx, (struct m0_uint128 *)&prefix,
 			    ext->e_start, &it);
-	M0_ASSERT(rc == 0); //todo handle err
+	if (rc != 0) {
+		m0_layout__log("m0_composite_layer_ext_delete",
+			       "m0_emap_lookup() failed",
+			       &m0_addb_func_fail, &cl->cl_base.l_addb,
+			       cl->cl_base.l_id, rc);
+		m0_mutex_unlock(&cl->cl_base.l_lock);
+		return rc;
+	}
 
 	/**
 	 * @todo In short: Break ext into multiple, based on values (extent
@@ -1850,9 +2109,18 @@ M0_INTERNAL int m0_composite_layer_ext_delete(struct m0_composite_layout *cl,
 	 */
 
 	rc = extent_in_db_write(&it, layer, ext, M0_CLRES_INVALID, true);
-	M0_ASSERT(rc == 0); //todo Handle
-
+	if (rc != 0)
+		m0_layout__log("m0_composite_layer_ext_delete",
+			       "failed to write extent in memory",
+			       &comp_ext_op_fail, &cl->cl_base.l_addb,
+			       cl->cl_base.l_id, rc);
 	m0_emap_close(&it);
+	m0_mutex_unlock(&cl->cl_base.l_lock);
+
+	M0_LEAVE("lid %llu, layer %lu, e_start %llu, e_end %llu, rc %d",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end, rc);
 	return rc;
 }
 
diff --git a/layout/composite.h b/layout/composite.h
index 67ddded..93d23d3 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -156,7 +156,6 @@ enum m0_composite_layer_ext_state {
 	M0_CLRES_FLATTENING
 };
 
-
 /**
  * Extent that is part of 'a layer of a composite layout'. Any layer except
  * the zeroth one contains list of such extents.
@@ -241,14 +240,13 @@ M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
  *    available m0_emap_lookup(). Is it ok OR it should be changed to look up
  *    into the in-memory list of the extents?
  */
-M0_INTERNAL int m0_composite_layer_ext_lookup(
-				const struct m0_composite_layout *cl,
-				m0_bindex_t offset,
-				struct m0_db_tx *tx,
-				uint32_t *layer_idx,
-				struct m0_ext *ext,
-				uint64_t *ext_state,
-				struct m0_layout **sublayout);
+M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
+					      m0_bindex_t offset,
+					      struct m0_db_tx *tx,
+					      uint32_t *layer_idx,
+					      struct m0_ext *ext,
+					      uint64_t *ext_state,
+					      struct m0_layout **sublayout);
 
 /**
  * Adds an extent to the specified layer of the specified composite layout,
diff --git a/layout/layout.c b/layout/layout.c
index 8737792..7db1073 100644
--- a/layout/layout.c
+++ b/layout/layout.c
@@ -144,6 +144,9 @@ M0_ADDB_EV_DEFINE(layout_update_fail, "layout_update_fail",
 M0_ADDB_EV_DEFINE(layout_delete_fail, "layout_delete_fail",
 		  M0_ADDB_EVENT_LAYOUT_DELETE_FAIL, M0_ADDB_CALL);
 
+M0_ADDB_EV_DEFINE_PUBLIC(comp_ext_op_fail, "layout_comp_layer_op_fail",
+			 M0_ADDB_EVENT_LAYOUT_COMP_LAYER_OP_FAIL, M0_ADDB_CALL);
+
 M0_TL_DESCR_DEFINE(layout, "layout-list", static,
 		   struct m0_layout, l_list_linkage, l_magic,
 		   M0_LAYOUT_MAGIC, M0_LAYOUT_HEAD_MAGIC);
@@ -640,6 +643,7 @@ static void addb_add(struct m0_addb_ctx *ctx,
 				 layout_add_fail.ae_id,
 				 layout_update_fail.ae_id,
 				 layout_delete_fail.ae_id,
+			         comp_ext_op_fail.ae_id,
 				 m0_addb_func_fail.ae_id,
 				 m0_addb_oom.ae_id)));
 
diff --git a/layout/layout_db.c b/layout/layout_db.c
index b25c9ba..506cfc4 100644
--- a/layout/layout_db.c
+++ b/layout/layout_db.c
@@ -512,7 +512,6 @@ M0_INTERNAL int m0_layout_lookup(struct m0_layout_domain *dom,
 	M0_ASSERT(rc == 0);
 	rc = m0_table_lookup(tx, pair);
 	if (rc != 0) {
-		/* Error covered in UT. */
 		l->l_ops->lo_delete(l);
 		m0_layout__log("m0_layout_lookup", "m0_table_lookup() failed",
 			       &layout_lookup_fail, &layout_global_ctx,
@@ -525,7 +524,6 @@ M0_INTERNAL int m0_layout_lookup(struct m0_layout_domain *dom,
 	m0_bufvec_cursor_init(&cur, &bv);
 	rc = m0_layout_decode(l, &cur, M0_LXO_DB_LOOKUP, tx);
 	if (rc != 0) {
-		/* Error covered in UT. */
 		l->l_ops->lo_delete(l);
 		m0_layout__log("m0_layout_lookup", "m0_layout_decode() failed",
 			       &layout_lookup_fail, &layout_global_ctx,
-- 
1.8.3.2

