From 7efcba00b2299fbb181cce3a33354fdf6ca2ba93 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Mon, 13 May 2013 14:33:02 +0530
Subject: [PATCH 134/157] Some minor fixes (including doc and style) to the UT

---
 layout/composite.c    |   2 +-
 layout/ut/composite.c |   5 +-
 layout/ut/layout.c    | 220 +++++++++++++++++++++++++++-----------------------
 3 files changed, 122 insertions(+), 105 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index 0088b0c..d5b27e1 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -1750,7 +1750,7 @@ static m0_bcount_t composite_bufsize(const struct m0_layout *l)
 	cl = m0_layout_to_cl(l);
 	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
 		bufsize = bufsize +
-			  (layer->clr_extents_nr * sizeof(struct layer_buf_ext));
+			(layer->clr_extents_nr * sizeof(struct layer_buf_ext));
 	} m0_tl_endfor;
 
 	return sizeof(struct m0_layout_rec) +
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index 221d9c5..7d065b8 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -808,7 +808,8 @@ int test_encode_composite(uint64_t lid,
 
 	/* Build a layout object. */
 	rc = composite_build_and_layers_add(lid, domain, layers_nr, extents_nr,
-					    is_contiguous_extents, !FAILURE_TEST,
+					    is_contiguous_extents,
+					    !FAILURE_TEST,
 					    !LAYER_ADD_FAILURE_TEST, &cl);
 	M0_UT_ASSERT(rc == 0);
 
@@ -2209,7 +2210,7 @@ int test_lookup_composite(uint64_t lid,
 		rc = layout_add(&cl->cl_base, !FAILURE_TEST);
 		M0_UT_ASSERT(rc == 0);
 
-		/* todo check if shud be after layout_update()
+		/*
 		 * Lookup for the layout object to verify that the same object
 		 * is returned from the memory, not requiring a lookup from the
 		 * DB.
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 4da1a97..790c589 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -422,7 +422,7 @@ static void test_reg_unreg_failure(void)
 	M0_UT_ASSERT(rc == 0);
 }
 
-/*
+/**
  * Tests the APIs supported for enumeration object build, layout object build
  * and layout destruction that happens using m0_layout_put().
  */
@@ -472,8 +472,8 @@ static void test_build(void)
 	M0_UT_ASSERT(rc == 0);
 
 	/*
-	 * Build a layout object with COMPOSITE layout type, with contiguous
-	 * extents in its zeroth layer and destroy it.
+	 * Build a layout object with COMPOSITE layout type, associate some
+	 * contiguous extents to its zeroth layer and then destroy the layout.
 	 */
 	lid = 1021;
 	rc = test_build_composite(lid, &domain, 5, CONTIGUOUS_EXTENTS,
@@ -481,8 +481,9 @@ static void test_build(void)
 	M0_UT_ASSERT(rc == 0);
 
 	/*
-	 * Build a layout object with COMPOSITE layout type, with noncontiguous
-	 * extents in its zeroth layer and destroy it.
+	 * Build a layout object with COMPOSITE layout type, associate some
+	 * noncontiguous extents to its zeroth layer and then destroy the
+	 * layout.
 	 */
 	lid = 1022;
 	rc = test_build_composite(lid, &domain, 10, !CONTIGUOUS_EXTENTS,
@@ -490,10 +491,10 @@ static void test_build(void)
 	M0_UT_ASSERT(rc == 0);
 
 	/*
-	 * Build a layout object with COMPOSITE layout type, such that its
-	 * zeroth layer contains only 1 single extent and destroy it.
+	 * Build a layout object with COMPOSITE layout type, associate one
+	 * single extent to its zeroth layer and then destory the layout.
 	 */
-	lid = 1022;
+	lid = 1023;
 	rc = test_build_composite(lid, &domain, 1, CONTIGUOUS_EXTENTS,
 				  !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
@@ -593,7 +594,7 @@ static void test_build_failure(void)
 	M0_UT_ASSERT(rc == -ENOMEM);
 
 	/*
-	 * Simulate memory allocation failure in the first invokation of
+	 * Simulate layer memory allocation failure in the first invokation of
 	 * layer_inmem_add() that is in the path of m0_composite_build().
 	 */
 	lid = 2022;
@@ -603,7 +604,7 @@ static void test_build_failure(void)
 	M0_UT_ASSERT(rc == -ENOMEM);
 
 	/*
-	 * Simulate memory allocation failure in the first invokation of
+	 * Simulate lr_ext memory allocation failure in the first invokation of
 	 * layer_inmem_add() that is in the path of m0_composite_build().
 	 */
 	lid = 2023;
@@ -613,7 +614,7 @@ static void test_build_failure(void)
 	M0_UT_ASSERT(rc == -ENOMEM);
 }
 
-/* Tests the API m0_layout_decode(). */
+/** Tests the API m0_layout_decode(). */
 static void test_decode(void)
 {
 	uint64_t lid;
@@ -764,8 +765,9 @@ static void test_decode_failure(void)
 	M0_UT_ASSERT(rc == -EINVAL);
 
 	/*
-	 * Simulate invalid_ext_state_err error in
-	 * composite_layout_buf_build().
+	 * Simulate invalid_ext_state_err error through
+	 * composite_layout_buf_build() so that it is encountered by
+	 * composite_decode().
 	 */
 	lid = 4022;
 	m0_fi_enable_once("composite_layout_buf_build",
@@ -795,8 +797,6 @@ static void test_decode_failure(void)
 				   !CONTIGUOUS_EXTENTS, FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 
-	/* todo layer_add failure for zeroth and the next layer? */
-
 	/*
 	 * Simulate memory allocation failure for zeroth layer addition that is
 	 * in the path of composite_populate()
@@ -823,7 +823,7 @@ static void test_decode_failure(void)
 				   !CONTIGUOUS_EXTENTS, FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EINVAL);
 
-	/* Simulate sublayout find error while reading the non-zeroth layer. */
+	/* Simulate sublayout find error while reading a non-zeroth layer. */
 	lid = 4028;
 	m0_fi_enable_off_n_on_m("layout_find", "layout_find_err", 2, 1);
 	rc = test_decode_composite(lid, &domain, 5, 6,
@@ -832,7 +832,7 @@ static void test_decode_failure(void)
 	M0_UT_ASSERT(rc == -EINVAL);
 }
 
-/* Tests the API m0_layout_encode(). */
+/** Tests the API m0_layout_encode(). */
 static void test_encode(void)
 {
 	uint64_t lid;
@@ -843,8 +843,7 @@ static void test_encode(void)
 	 * with a few inline entries only.
 	 */
 	lid = 5001;
-	rc = test_encode_pdclust(lid, &domain,
-				 LIST_ENUM_ID, LESS_THAN_INLINE,
+	rc = test_encode_pdclust(lid, &domain, LIST_ENUM_ID, LESS_THAN_INLINE,
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -854,8 +853,7 @@ static void test_encode(void)
 	 * M0_LIST_INLINE_COB_ENTRIES_MAX.
 	 */
 	lid = 5002;
-	rc = test_encode_pdclust(lid, &domain,
-				 LIST_ENUM_ID, EXACT_INLINE,
+	rc = test_encode_pdclust(lid, &domain, LIST_ENUM_ID, EXACT_INLINE,
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -864,16 +862,14 @@ static void test_encode(void)
 	 * including noninline entries and then destroy it.
 	 */
 	lid = 5003;
-	rc = test_encode_pdclust(lid, &domain,
-				 LIST_ENUM_ID, MORE_THAN_INLINE,
+	rc = test_encode_pdclust(lid, &domain, LIST_ENUM_ID, MORE_THAN_INLINE,
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	/* Encode for PDCLUST layout type and LINEAR enumeration type. */
 	lid = 5004;
-	rc = test_encode_pdclust(lid, &domain,
-				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
-				 !FAILURE_TEST);
+	rc = test_encode_pdclust(lid, &domain, LINEAR_ENUM_ID,
+				 INLINE_NOT_APPLICABLE, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	/*
@@ -886,7 +882,7 @@ static void test_encode(void)
 	M0_UT_ASSERT(rc == 0);
 
 	/*
-	 * Encode for COMPOSITE layout type with contiguous extents in its
+	 * Encode for COMPOSITE layout type with noncontiguous extents in its
 	 * layers.
 	 */
 	lid = 5022;
@@ -915,9 +911,16 @@ static void test_encode_failure(void)
 				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == LO_ENCODE_ERR);
+
+	/* Simulate m0_layout_encode() failure. */
+	lid = 6021;
+	m0_fi_enable_once("m0_layout_encode", "lo_encode_err");
+	rc = test_encode_composite(lid, &domain, 4, 5,
+				   !CONTIGUOUS_EXTENTS, FAILURE_TEST);
+	M0_UT_ASSERT(rc == LO_ENCODE_ERR);
 }
 
-/* Tests the API sequence m0_layout_decode() followed by m0_layout_encode(). */
+/** Tests the API sequence m0_layout_decode() followed by m0_layout_encode(). */
 static void test_decode_encode(void)
 {
 	uint64_t lid;
@@ -978,7 +981,7 @@ static void test_decode_encode(void)
 
 	/*
 	 * Build a layout buffer representing a layout with COMPOSITE layout
-	 * type.
+	 * type, with contiguous extents.
 	 * Decode it into a layout object. Then encode that layout object again
 	 * into another layout buffer.
 	 * Then, compare the original layout buffer with the encoded layout
@@ -988,9 +991,23 @@ static void test_decode_encode(void)
 	rc = test_decode_encode_composite(lid, &domain, 5, 10,
 					  CONTIGUOUS_EXTENTS);
 	M0_UT_ASSERT(rc == 0);
+
+	/*
+	 * Build a layout buffer representing a layout with COMPOSITE layout
+	 * type, with noncontiguous extents.
+	 * Decode it into a layout object. Then encode that layout object again
+	 * into another layout buffer.
+	 * Then, compare the original layout buffer with the encoded layout
+	 * buffer.
+	 */
+	lid = 7022;
+	rc = test_decode_encode_composite(lid, &domain, 6, 11,
+					  !CONTIGUOUS_EXTENTS);
+	M0_UT_ASSERT(rc == 0);
+
 }
 
-/* Tests the API sequence m0_layout_encode() followed by m0_layout_decode(). */
+/** Tests the API sequence m0_layout_encode() followed by m0_layout_decode(). */
 static void test_encode_decode(void)
 {
 	uint64_t lid;
@@ -1049,9 +1066,10 @@ static void test_encode_decode(void)
 	M0_UT_ASSERT(rc == 0);
 
 	/*
-	 * Build a layout object with COMPOSITE layout type. Encode it into a
-	 * layout buffer. Then decode that layout buffer again into another
-	 * layout object.
+	 * Build a layout object with COMPOSITE layout type, with contiguous
+	 * extents.
+	 * Encode it into a layout buffer. Then decode that layout buffer again
+	 * into another layout object.
 	 * Now, compare the original layout object with the decoded layout
 	 * object.
 	 */
@@ -1059,9 +1077,22 @@ static void test_encode_decode(void)
 	rc = test_encode_decode_composite(lid, &domain, 7, 27,
 					  CONTIGUOUS_EXTENTS);
 	M0_UT_ASSERT(rc == 0);
+
+	/*
+	 * Build a layout object with COMPOSITE layout type, with noncontiguous
+	 * extents.
+	 * Encode it into a layout buffer. Then decode that layout buffer again
+	 * into another layout object.
+	 * Now, compare the original layout object with the decoded layout
+	 * object.
+	 */
+	lid = 8022;
+	rc = test_encode_decode_composite(lid, &domain, 8, 28,
+					  !CONTIGUOUS_EXTENTS);
+	M0_UT_ASSERT(rc == 0);
 }
 
-/* Tests the APIs m0_layout_get() and m0_layout_put(). */
+/** Tests the APIs m0_layout_get() and m0_layout_put(). */
 static void test_ref_get_put(void)
 {
 	uint64_t lid;
@@ -1086,7 +1117,7 @@ static void test_ref_get_put(void)
 	//todo composite
 }
 
-/* Tests the enum operations pointed by leo_nr and leo_get. */
+/** Tests the enum operations pointed by leo_nr and leo_get. */
 static void test_enum_operations(void)
 {
 	uint64_t lid;
@@ -1132,7 +1163,7 @@ static void test_enum_operations(void)
 	M0_UT_ASSERT(rc == 0);
 }
 
-/* Tests the API m0_layout_max_recsize(). */
+/** Tests the API m0_layout_max_recsize(). */
 static void test_max_recsize(void)
 {
 	const char              t_db_name[] = "t5-layout";
@@ -1238,7 +1269,7 @@ static void test_max_recsize(void)
 	M0_UT_ASSERT(rc == 0);
 }
 
-/* Tests the function lo_recsize(). */
+/** Tests the function lo_recsize(). */
 static void test_recsize(void)
 {
 	uint64_t lid;
@@ -1281,7 +1312,7 @@ static void test_recsize(void)
 	//todo composite
 }
 
-/*
+/**
  * Tests the APIs supported for m0_pdclust_instance object, for various enum
  * types.
  */
@@ -1375,6 +1406,10 @@ static void test_instance_failure(void)
 	M0_UT_ASSERT(rc == -ENOMEM);
 }
 
+/**
+ * Tests the layer operations, applicable specifically for the composite
+ * layout type.
+ */
 static void test_layer_ops(void)
 {
 	uint64_t lid;
@@ -1403,6 +1438,10 @@ static void test_layer_ops_failure(void)
 	m0_fi_disable("layer_inmem_add", "alloc_ptr_fail/layer");
 }
 
+/**
+ * Tests the extent operations on layers, applicable specifically for the
+ * composite layout type.
+ */
 static void test_layer_ext_ops(void)
 {
 	uint64_t lid = 16001;
@@ -1422,7 +1461,7 @@ static void test_layer_ext_ops_failure(void)
 }
 
 #ifndef __KERNEL__
-/* Tests the API m0_layout_lookup(). */
+/** Tests the API m0_layout_lookup(). */
 static void test_lookup(void)
 {
 	uint64_t lid;
@@ -1510,20 +1549,20 @@ static void test_lookup(void)
 	M0_UT_ASSERT(rc == -ENOENT);
 
 	/*
-	 * Add a layout object with COMPOSITE layout type and with
-	 * non-contiguous extents. Then perform lookup for it.
+	 * Add a layout object with COMPOSITE layout type and with contiguous
+	 * extents. Then perform lookup for it.
 	 */
 	lid = 18022;
-	rc = test_lookup_composite(lid, &domain, 2, 30, !CONTIGUOUS_EXTENTS,
+	rc = test_lookup_composite(lid, &domain, 5, 30, CONTIGUOUS_EXTENTS,
 				   EXISTING_TEST, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	/*
-	 * Add a layout object with COMPOSITE layout type and with contiguous
-	 * extents. Then perform lookup for it.
+	 * Add a layout object with COMPOSITE layout type and with
+	 * non-contiguous extents. Then perform lookup for it.
 	 */
 	lid = 18023;
-	rc = test_lookup_composite(lid, &domain, 5, 30, CONTIGUOUS_EXTENTS,
+	rc = test_lookup_composite(lid, &domain, 2, 30, !CONTIGUOUS_EXTENTS,
 				   EXISTING_TEST, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -1537,7 +1576,6 @@ static void test_lookup(void)
 	M0_UT_ASSERT(rc == 0);
 }
 
-/* Tests the API m0_layout_lookup(). */
 static void test_lookup_failure(void)
 {
 	uint64_t          lid;
@@ -1687,7 +1725,7 @@ static void test_lookup_failure(void)
 	//todo zeroth layer?
 	lid = 19026;
 	m0_fi_enable_off_n_on_m("emap_iterator_set", "emap_lookup_err",
-				5 /* layers_nr * 3 + 4 */, 1);
+				5 /* layers_nr + 1 */, 1);
 	rc = test_lookup_composite(lid, &domain, 4, 5, CONTIGUOUS_EXTENTS,
 				   EXISTING_TEST, FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_EMAP_LOOKUP_ERR);
@@ -1719,7 +1757,7 @@ static void test_lookup_failure(void)
 #endif
 }
 
-/* Tests the API m0_layout_add(). */
+/** Tests the API m0_layout_add(). */
 static void test_add(void)
 {
 	uint64_t lid;
@@ -1766,17 +1804,21 @@ static void test_add(void)
 			      !DUPLICATE_TEST, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	/* Add a layout object with COMPOSITE layout type. */
+	/*
+	 * Add a layout object with COMPOSITE layout type, with contiguous
+	 * extents.
+	 */
 	lid = 20021;
-	rc = test_add_composite(lid, &domain, 7, 50,
-				!CONTIGUOUS_EXTENTS,
+	rc = test_add_composite(lid, &domain, 5, 25, CONTIGUOUS_EXTENTS,
 				!DUPLICATE_TEST, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	/* Add a layout object with COMPOSITE layout type. */
+	/*
+	 * Add a layout object with COMPOSITE layout type, with noncontiguous
+	 * extents.
+	 */
 	lid = 20022;
-	rc = test_add_composite(lid, &domain, 5, 25,
-				CONTIGUOUS_EXTENTS,
+	rc = test_add_composite(lid, &domain, 7, 50, !CONTIGUOUS_EXTENTS,
 				!DUPLICATE_TEST, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 }
@@ -1879,7 +1921,7 @@ static void test_add_failure(void)
 	M0_UT_ASSERT(rc == L_EMAP_OBJ_INSERT_ERR);
 }
 
-/* Tests the API m0_layout_update(). */
+/** Tests the API m0_layout_update(). */
 static void test_update(void)
 {
 	uint64_t lid;
@@ -1926,8 +1968,6 @@ static void test_update(void)
 	rc = test_update_composite(lid, &domain, 4, 15, !CONTIGUOUS_EXTENTS,
 				   !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
-
-	//todo Cover other combinations for composite
 }
 
 static void test_update_failure(void)
@@ -1950,25 +1990,10 @@ static void test_update_failure(void)
 	M0_UT_ASSERT(rc == L_TABLE_UPDATE_ERR);
 
 	/*
-	 * Simulate emap iterator setting error during extents_indb_delete()
-	 * that is in the path of updating a layout.
-	 * todo check if this shall be removed since emap_iterator_set() is
-	 * not in the path of extents_indb_delete() when invoked through update
-	 * path. Mostly needs to be removed.
-	 */
-	lid = 23005;
-	m0_fi_enable_off_n_on_m("emap_iterator_set", "emap_lookup_err",
-				10, 1);
-	rc = test_update_composite(lid, &domain, 4, 7, !CONTIGUOUS_EXTENTS,
-				   FAILURE_TEST);
-	M0_UT_ASSERT(rc == L_EMAP_LOOKUP_ERR);
-	m0_fi_disable("emap_iterator_set", "emap_lookup_err");
-
-	/*
 	 * Simulate error during extents_indb_delete() that is in the path of
 	 * updating a layout.
 	 */
-	lid = 23006;
+	lid = 23003;
 	m0_fi_enable_once("single_ext_indb_write", "emap_lookup_err");
 	rc = test_update_composite(lid, &domain, 4, 7, !CONTIGUOUS_EXTENTS,
 				   FAILURE_TEST);
@@ -1978,14 +2003,14 @@ static void test_update_failure(void)
 	 * Simulate error during extents_indb_delete() that is in the path of
 	 * updating a layout.
 	 */
-	lid = 23007;
+	lid = 23004;
 	m0_fi_enable_once("single_ext_indb_write", "emap_paste_err");
 	rc = test_update_composite(lid, &domain, 4, 7, !CONTIGUOUS_EXTENTS,
 				   FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_EMAP_PASTE_ERR);
 
 	/* Simulate emap paste error while adding a non-zeroth layer. */
-	lid = 23008;
+	lid = 23005;
 	m0_fi_enable_off_n_on_m("ext_indb_write", "emap_paste_err",
 				16 /* layer_nr * extents_nr + 1 */, 1);
 	rc = test_update_composite(lid, &domain, 3, 5, !CONTIGUOUS_EXTENTS,
@@ -1993,15 +2018,18 @@ static void test_update_failure(void)
 	M0_UT_ASSERT(rc == L_EMAP_PASTE_ERR);
 	m0_fi_disable("ext_indb_write", "emap_paste_err");
 
-	/* Simulate layout find error in the path of layer deletion. */
-	lid = 25023;
+	/*
+	 * Simulate layout find error in the path of layer deletion that
+	 * happens through the update path.
+	 */
+	lid = 25006;
 	m0_fi_enable_once("layout_find", "layout_find_err");
 	rc = test_update_composite(lid, &domain, 3, 5, !CONTIGUOUS_EXTENTS,
 				   FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EINVAL);
 }
 
-/* Tests the API m0_layout_delete(). */
+/** Tests the API m0_layout_delete(). */
 static void test_delete(void)
 {
 	uint64_t lid;
@@ -2047,13 +2075,23 @@ static void test_delete(void)
 				 EXISTING_TEST, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	/* Delete a layout object with COMPOSITE layout type. */
+	/*
+	 * Delete a layout object with COMPOSITE layout type, contiguous
+	 * extents.
+	 */
 	lid = 24021;
 	rc = test_delete_composite(lid, &domain, 4, 10,
 				   CONTIGUOUS_EXTENTS, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	//todo Cover other composite cases
+	/*
+	 * Delete a layout object with COMPOSITE layout type, noncontiguous
+	 * extents.
+	 */
+	lid = 24022;
+	rc = test_delete_composite(lid, &domain, 4, 10,
+				   !CONTIGUOUS_EXTENTS, !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
 }
 
 static void test_delete_failure(void)
@@ -2134,28 +2172,6 @@ static void test_delete_failure(void)
 	M0_UT_ASSERT(rc == L_EMAP_OBJ_DEL_ERR);
 	m0_fi_disable("layer_indb_delete", "emap_obj_del_err");
 }
-
-/**
- * Setting the ld_is_db_available flag explicitly this way is being used as
- * a hack in this UT. Ideally, user shall never change value of this flag
- * directly. The correct way to make use of this flag is using
- * m0_layout_domain_init() by passing it the applicable value for this flag.
- *
- * The reason to use such a hack here in this UT is to avoid the following
- * overhead:
- * Since any layout type or enum type can be registered with only one domain at
- * a time, if we had to initialise a new/existing domain with new value of the
- * ld_is_db_available flag, then we will need to:
- * - unregister the layout types and enum types registered in the first domain
- *   say domain1,
- * - finalise domain1,
- * - initialise another domain say domain2
- * - register the applicable layout types and enum types
- * - if in the kernel mode, then the layout types and the enum types need to be
- *   unregistered from the  m0t1fs_globals.g_layout_dom domain and then they
- *   need to be registered back at some other point (see test_init() for
- *   reference).
- */
 #endif /* __KERNEL__ */
 
 const struct m0_test_suite layout_ut = {
-- 
1.8.3.2

