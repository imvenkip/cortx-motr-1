From 2b25fe43235ea18938d4d4a9331d3d846a07d556 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Mon, 22 Apr 2013 18:04:42 +0530
Subject: [PATCH 120/157] Some cleanup, some reorg

---
 layout/composite.c    | 268 +++++++++++++++++++++++++-------------------------
 layout/composite.h    |  16 +--
 layout/ut/composite.c |  43 ++++----
 3 files changed, 161 insertions(+), 166 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index 178ecd7..00f6dc3 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -100,11 +100,9 @@ enum extent_add_position {
 
 /** Flags used for better readability. */
 enum {
-	INMEM_LIST_UPDATE    = true,
 	IN_UPDATE_PATH       = true,
 	EXT_MERGE_VALIDATION = 11, /* Some random number other than 0 and 1. */
-	EXT_DEL_VALIDATION   = 12, /* Another random number. */
-	EXTLIST_FREE         = true /* Free extlist during layer delete op. */
+	EXT_DEL_VALIDATION   = 12  /* Another random number. */
 };
 
 M0_TL_DESCR_DEFINE(comp_layer, "composite-layer-list",
@@ -331,13 +329,13 @@ static int layer_inmem_add(struct m0_composite_layout *cl,
 	layer->clr_cl         = &cl->cl_base;
 	layer->clr_sl         = sublayout;
 	layer->clr_idx        = cl->cl_layers_nr;
-	layer->clr_extents_nr = 1; //todo Check this for single ext addition
+	layer->clr_extents_nr = 1;
 	m0_composite_layer_ext_tlist_init(&layer->clr_extents);
 	m0_layout_get(layer->clr_sl); /* Add a reference to the sublayout. */
 
 	/*
-	 * Add one single extent with invalid state and mapping the whole
-	 * offset space.
+	 * Add one single extent, mapping the whole offset space and with the
+	 * M0_CLRES_HOLE state, thus making the layer empty.
 	 */
 	M0_ALLOC_PTR(lr_ext);
 	if (lr_ext == NULL) {
@@ -353,7 +351,7 @@ static int layer_inmem_add(struct m0_composite_layout *cl,
 	}
 	lr_ext->cle_ext.e_start = 0;
 	lr_ext->cle_ext.e_end   = M0_BINDEX_MAX + 1;
-	lr_ext->cle_state       = M0_CLRES_INVALID;
+	lr_ext->cle_state       = M0_CLRES_HOLE;
 	m0_composite_layer_ext_tlink_init_at_tail(lr_ext, &layer->clr_extents);
 
 	comp_layer_tlink_init_at_tail(layer, &cl->cl_layers);
@@ -469,8 +467,8 @@ static void layers_inmem_delete(struct m0_composite_layout *cl)
 	struct m0_composite_layer *layer_prev;
 	/*
 	 * Start deleting layers from the top-most layer so that the check from
-	 * layer_inmem_delete() that 'it is the top-most layer being
-	 * deleted' remains intact.
+	 * layer_inmem_delete() that 'it is the top-most layer being deleted'
+	 * remains intact.
 	 */
 	layer = comp_layer_tlist_tail(&cl->cl_layers);
 	while (layer != NULL) {
@@ -510,10 +508,10 @@ M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
 	M0_PRE(cl->cl_layers_nr >= 1);
 	M0_PRE(m0_layout__invariant(sublayout));
 
-	M0_ENTRY("lid %llu, sublayout_id %llu",
+	M0_ENTRY("lid %llu, sublayout_id %llu, existing_layers_nr %lu",
 		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long long)sublayout->l_id);
-
+		 (unsigned long long)sublayout->l_id,
+		 (unsigned long)cl->cl_layers_nr);
 	m0_mutex_lock(&cl->cl_base.l_lock);
 	rc = layer_inmem_add(cl, sublayout, &layer);
 	if (rc != 0) {
@@ -563,15 +561,14 @@ M0_INTERNAL int m0_composite_layer_delete(struct m0_composite_layout *cl)
 
 	M0_PRE(composite_invariant(cl));
 	M0_PRE(cl->cl_layers_nr > 1);
+
 	M0_ENTRY("lid %llu, layers_nr %lu",
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)cl->cl_layers_nr);
-
 	m0_mutex_lock(&cl->cl_base.l_lock);
 	layer = layer_find(cl, cl->cl_layers_nr - 1);
 	M0_PRE(m0_tl_forall(m0_composite_layer_ext, lr_ext, &layer->clr_extents,
-			    lr_ext->cle_state == M0_CLRES_INVALID));
-
+			    lr_ext->cle_state == M0_CLRES_HOLE));
 	layer_inmem_delete(cl, layer);
 	m0_mutex_unlock(&cl->cl_base.l_lock);
 	M0_POST(composite_invariant(cl));
@@ -585,7 +582,6 @@ static struct m0_layout *layout_find(struct m0_layout_domain *dom,
 
 	if (M0_FI_ENABLED("layout_find_err"))
 		{ sublayout = NULL; goto err1_injected; }
-
 	sublayout = m0_layout_find(dom, lid);
 	/**
 	 * @todo Eventually, if the sublayout is not found in the cache, it
@@ -614,6 +610,66 @@ err1_injected:
 	return sublayout;
 }
 
+/**
+ * Sublayout identifiers for all the layers are stored in the primary table.
+ *
+ * This routine reads the sublayout identifiers for all the layers for a
+ * composite layout, from a buffer provided and stores those in the sl_id_list
+ * array.
+ *
+ * @post Memory is allocated for the array sl_id_list and it shall be freed by
+ * the caller.
+ */
+static int sublayout_ids_inbuf_read(struct m0_composite_layout *cl,
+				    struct m0_bufvec_cursor *cur,
+				    uint32_t *layers_nr,
+				    uint64_t **sl_id_list)
+{
+	struct m0_layout_composite_rec *cl_rec;
+	uint64_t                       *sublayout_id_list;
+	uint64_t                       *sublayout_id;
+	uint32_t                        i;
+
+	M0_PRE(cur != NULL);
+	M0_PRE(m0_bufvec_cursor_step(cur) >= sizeof *cl_rec);
+
+	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
+
+	/*
+	 * Read the composite layout type specific part of the record from the
+	 * buffer.
+	 */
+	cl_rec = m0_bufvec_cursor_addr(cur);
+	m0_bufvec_cursor_move(cur, sizeof *cl_rec);
+	*layers_nr = cl_rec->cr_layers_nr;
+
+	M0_ALLOC_ARR(sublayout_id_list, *layers_nr);
+	if (sublayout_id_list == NULL) {
+		m0_layout__log("sublayout_ids_inbuf_read",
+			       "failed to allocate sublayout_id_list",
+			       M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD_INTERNAL,
+			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id,
+			       -ENOMEM);
+		M0_RETURN(-ENOMEM);
+	}
+
+	/* Read the sublayout ids from the buffer. */
+	M0_ASSERT(m0_bufvec_cursor_step(cur) >=
+		  *layers_nr * sizeof sublayout_id_list[0]);
+	for (i = 0; i < cl_rec->cr_layers_nr; ++i) {
+		sublayout_id = m0_bufvec_cursor_addr(cur);
+		m0_bufvec_cursor_move(cur, sizeof *sublayout_id);
+		sublayout_id_list[i] = *sublayout_id;
+	}
+
+	*sl_id_list = sublayout_id_list;
+	M0_POST(*layers_nr > 0);
+	M0_LEAVE("lid %llu, layers_nr %lu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)*layers_nr);
+	return 0;
+}
+
 //todo loc
 static int ext_inmem_add_internal(struct m0_composite_layer *layer,
 				  struct m0_layout *l,
@@ -624,6 +680,14 @@ static int ext_inmem_add_internal(struct m0_composite_layer *layer,
 				  struct m0_composite_layer_extent *
 							adjacent_lr_ext);
 
+/*
+ * Extent lists are stored in the auxiliary table for the composite layout viz.
+ * "layer_emap".
+ *
+ * This routine reads the extent list associated with each layer for a
+ * composite layout, from the buffer provided and stores those in the extlist
+ * array provided.
+ */
 static int extlist_inbuf_read(struct m0_composite_layout *cl,
 			      struct m0_bufvec_cursor *cur,
 			      uint32_t extents_nr,
@@ -647,8 +711,7 @@ static int extlist_inbuf_read(struct m0_composite_layout *cl,
 		m0_bufvec_cursor_move(cur, sizeof *ext_state);
 
 		if (m0_ext_is_empty(ext) ||
-		    !M0_IN(*ext_state, (M0_CLRES_INVALID,
-					M0_CLRES_VALID,
+		    !M0_IN(*ext_state, (M0_CLRES_HOLE, M0_CLRES_VALID,
 				        M0_CLRES_FLATTENING))) {
 			m0_layout__log("extlist_inbuf_read",
 				       "Invalid extent found in the buffer",
@@ -672,60 +735,6 @@ static int extlist_inbuf_read(struct m0_composite_layout *cl,
 	M0_RETURN(rc);
 }
 
-/**
- * @post Memory is allocated for the array sl_id_list and it shall be freed by
- * the caller.
- */
-static int sublayout_ids_inbuf_read(struct m0_composite_layout *cl,
-				    struct m0_bufvec_cursor *cur,
-				    uint32_t *layers_nr,
-				    uint64_t **sl_id_list)
-{
-	struct m0_layout_composite_rec *cl_rec;
-	uint64_t                       *sublayout_id_list;
-	uint64_t                       *sublayout_id;
-	uint32_t                        i;
-
-	M0_PRE(cur != NULL);
-	M0_PRE(m0_bufvec_cursor_step(cur) >= sizeof *cl_rec);
-
-	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
-
-	/*
-	 * Read the composite layout type specific part of the record from the
-	 * buffer.
-	 */
-	cl_rec = m0_bufvec_cursor_addr(cur);
-	m0_bufvec_cursor_move(cur, sizeof *cl_rec);
-	*layers_nr = cl_rec->cr_layers_nr;
-
-	M0_ALLOC_ARR(sublayout_id_list, *layers_nr);
-	if (sublayout_id_list == NULL) {
-		m0_layout__log("sublayout_ids_inbuf_read",
-			       "failed to allocate sublayout_id_list",
-			       M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD_INTERNAL,
-			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id,
-			       -ENOMEM);
-		M0_RETURN(-ENOMEM);
-	}
-
-	/* Read the sublayout ids from the buffer. */
-	M0_ASSERT(m0_bufvec_cursor_step(cur) >=
-		  *layers_nr * sizeof sublayout_id_list[0]);
-	for (i = 0; i < cl_rec->cr_layers_nr; ++i) {
-		sublayout_id = m0_bufvec_cursor_addr(cur);
-		m0_bufvec_cursor_move(cur, sizeof *sublayout_id);
-		sublayout_id_list[i] = *sublayout_id;
-	}
-
-	*sl_id_list = sublayout_id_list;
-	M0_POST(*layers_nr > 0);
-	M0_LEAVE("lid %llu, layers_nr %lu",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long)*layers_nr);
-	return 0;
-}
-
 //todo check position of the following
 static int ext_inmem_write(struct m0_composite_layout *cl,
 			   struct m0_composite_layer *layer,
@@ -816,7 +825,7 @@ static int layers_inbuf_read(struct m0_composite_layout *cl,
 						     EXT_MERGE_VALIDATION);
 				M0_ASSERT(rc == 0); //todo
 			} m0_tl_endfor;
-			extlist_free(&extlist); //todo Org and it shall be simple tlist
+			extlist_free(&extlist);
 		} else {
 			extlist_free(&extlist);
 			break;
@@ -844,10 +853,9 @@ static int layer_indb_add(struct m0_composite_layout *cl,
 			  struct m0_composite_layer *layer,
 			  struct m0_db_tx *tx);
 static int layer_indb_delete(struct m0_composite_layout *cl,
-			     struct m0_emap *emap,
 			     uint32_t layer_idx,
-			     uint64_t sl_id,       /* sublayout_id */
-			     struct m0_layout *sl, /* sublayout */
+			     uint64_t sublayout_id,
+			     struct m0_layout *sublayout,
 			     struct m0_db_tx *tx,
 			     bool in_update_path);
 static int comp_layout_indb_read(struct m0_composite_layout *cl,
@@ -1015,12 +1023,9 @@ static int composite_encode(struct m0_layout *l,
 		}
 	} else if (op == M0_LXO_DB_UPDATE) {
 		/*
-		 * To a composite layout, layers and extents can be added,
-		 * deleted by the client to whom the DB is not accessible and
-		 * then the layout is asked to be updated in the DB at a later
-		 * point. For this reason, as a part of the layout update for
-		 * a composite layout, all the existing layers and their
-		 * extents are first deleted and then they are added newly by
+		 * As a part of the layout update for a composite layout, all
+		 * the existing layers and their associated extents are first
+		 * deleted from the DB and then they are added newly by
 		 * referring to the current in-memory layout.
 		 */
 		rc = comp_layout_indb_delete(cl, tx, IN_UPDATE_PATH);
@@ -1028,7 +1033,7 @@ static int composite_encode(struct m0_layout *l,
 			/*
 			 * It is possible that the layout did not exist in
 			 * the DB until the point it is asked to be updated
-			 * directly. Hence the later condition above.
+			 * directly. Hence the later condition above. todo?
 			 */
 			rc = comp_layout_indb_add(cl, tx);
 			if (rc == 0) {
@@ -1115,7 +1120,7 @@ static int ext_inmem_add_internal(struct m0_composite_layer *layer,
 	M0_PRE(ergo(layer == NULL, l != NULL && extlist != NULL));
 	M0_PRE(ergo(layer != NULL, l == NULL && extlist == NULL));
 	M0_PRE(!m0_ext_is_empty(ext));
-	M0_PRE(M0_IN(ext_state, (M0_CLRES_INVALID, M0_CLRES_VALID,
+	M0_PRE(M0_IN(ext_state, (M0_CLRES_HOLE, M0_CLRES_VALID,
 				 M0_CLRES_FLATTENING)));
 	M0_PRE(M0_IN(add_position, (ADD_AFTER, ADD_BEFORE, ADD_AT_TAIL)));
 	M0_PRE(ergo(M0_IN(add_position, (ADD_AFTER, ADD_BEFORE)),
@@ -1252,7 +1257,7 @@ static int ext_inmem_lookup(struct m0_composite_layout *cl,
 			else {
 				M0_ASSERT(offset >= lr_ext->cle_ext.e_start);
 				M0_ASSERT(offset < lr_ext->cle_ext.e_end);
-				if (lr_ext->cle_state != M0_CLRES_INVALID)
+				if (lr_ext->cle_state != M0_CLRES_HOLE)
 					found = true;
 				break;
 			}
@@ -1393,13 +1398,13 @@ static int ext_split_internal(struct m0_composite_layer *layer,
  * the newer extent into it.
  *
  * Overlapping extents can be merged if and only if they are with
- * the state M0_CLRES_INVALID or with the state same as ext_state.
+ * the state M0_CLRES_HOLE or with the state same as ext_state.
  *
  * Overlapping extents can be deleted if and only if they are:
- * - all with the state M0_CLRES_INVALID OR
- * - all with only one state other than M0_CLRES_INVALID OR
- * - all with the mixture of some with the state M0_CLRES_INVALID and some with
- *   one single state other than M0_CLRES_INVALID.
+ * - all with the state M0_CLRES_HOLE OR
+ * - all with only one state other than M0_CLRES_HOLE OR
+ * - all with the mixture of some with the state M0_CLRES_HOLE and some with
+ *   one single state other than M0_CLRES_HOLE.
  */
 static int ext_inmem_validate(struct m0_composite_layout *cl,
 			      struct m0_composite_layer *layer,
@@ -1409,7 +1414,7 @@ static int ext_inmem_validate(struct m0_composite_layout *cl,
 			      struct m0_composite_layer_extent **lr_ext_nearest)
 {
 	struct m0_composite_layer_extent *lr_ext;
-	uint64_t                          first_noninvalid_state;
+	uint64_t                          first_nonhole_state;
 	int                               rc;
 
 	M0_PRE(M0_IN(ext_validation_kind, (EXT_MERGE_VALIDATION,
@@ -1417,7 +1422,7 @@ static int ext_inmem_validate(struct m0_composite_layout *cl,
 
 	rc = 0;
 	*lr_ext_nearest = NULL;
-	first_noninvalid_state = M0_CLRES_INVALID;
+	first_nonhole_state = M0_CLRES_HOLE;
 	m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
 		/* Nearest extent from the list. */
 		if (ext->e_start >= lr_ext->cle_ext.e_start)
@@ -1427,7 +1432,7 @@ static int ext_inmem_validate(struct m0_composite_layout *cl,
 			continue;
 		/* For overlapping extents. */
 		if (ext_validation_kind == EXT_MERGE_VALIDATION) {
-			if (lr_ext->cle_state != M0_CLRES_INVALID &&
+			if (lr_ext->cle_state != M0_CLRES_HOLE &&
 			    lr_ext->cle_state != new_ext_state) {
 				rc = -EINVAL;
 				M0_LOG(M0_ERROR, "lid %llu, layer %lu, "
@@ -1450,9 +1455,9 @@ static int ext_inmem_validate(struct m0_composite_layout *cl,
 				break;
 			}
 		} else { /* ext_validation_kind == EXT_DEL_VALIDATION */
-			if (lr_ext->cle_state != M0_CLRES_INVALID &&
-			     (first_noninvalid_state != M0_CLRES_INVALID &&
-			      lr_ext->cle_state != first_noninvalid_state)) {
+			if (lr_ext->cle_state != M0_CLRES_HOLE &&
+			     (first_nonhole_state != M0_CLRES_HOLE &&
+			      lr_ext->cle_state != first_nonhole_state)) {
 				rc = -EINVAL;
 				M0_LOG(M0_ERROR, "lid %llu, layer %lu, "
 				       "Overlapping extent can not be deleted "
@@ -1461,7 +1466,7 @@ static int ext_inmem_validate(struct m0_composite_layout *cl,
 				       "existing_e_start %llu, "
 				       "existing_e_end %llu, "
 				       "existing_state %llu, "
-				       "first_non_invalid_state %llu",
+				       "first_nonhole_state %llu",
 				       (unsigned long long) layer->clr_cl->l_id,
 				       (unsigned long)layer->clr_idx,
 				       (unsigned long long)ext->e_start,
@@ -1473,11 +1478,11 @@ static int ext_inmem_validate(struct m0_composite_layout *cl,
 						lr_ext->cle_ext.e_end,
 				       (unsigned long long)lr_ext->cle_state,
 				       (unsigned long long)
-						first_noninvalid_state);
+						first_nonhole_state);
 			}
-			if (lr_ext->cle_state != M0_CLRES_INVALID &&
-			    first_noninvalid_state == M0_CLRES_INVALID)
-				first_noninvalid_state = lr_ext->cle_state;
+			if (lr_ext->cle_state != M0_CLRES_HOLE &&
+			    first_nonhole_state == M0_CLRES_HOLE)
+				first_nonhole_state = lr_ext->cle_state;
 			if (rc != 0)
 				break;
 		}
@@ -1701,7 +1706,7 @@ M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
 	M0_PRE(ext != NULL);
 	M0_PRE(!m0_ext_is_empty(ext));
 	//todo M0_PRE(M0_IN(ext_state, (M0_CLRES_VALID, M0_CLRES_FLATTENING)));
-	M0_PRE(M0_IN(ext_state, (M0_CLRES_INVALID, M0_CLRES_VALID,
+	M0_PRE(M0_IN(ext_state, (M0_CLRES_HOLE, M0_CLRES_VALID,
 				 M0_CLRES_FLATTENING)));
 
 	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu",
@@ -1785,8 +1790,7 @@ M0_INTERNAL int m0_composite_layer_ext_delete(struct m0_composite_layout *cl,
 	m0_mutex_lock(&cl->cl_base.l_lock);
 	layer = layer_find(cl, layer_idx);
 
-	rc = ext_inmem_write(cl, layer, ext, M0_CLRES_INVALID,
-			     EXT_DEL_VALIDATION);
+	rc = ext_inmem_write(cl, layer, ext, M0_CLRES_HOLE, EXT_DEL_VALIDATION);
 	if (rc != 0)
 		m0_layout__log("m0_composite_layer_ext_delete",
 			       "failed to write extent",
@@ -1943,7 +1947,7 @@ static int extmap_indb_add(struct m0_composite_layout *cl,
 	if (M0_FI_ENABLED("emap_obj_insert_err"))
 		{ rc = L_EMAP_OBJ_INSERT_ERR; goto err1_injected; }
 	rc = m0_emap_obj_insert(emap, tx, (struct m0_uint128 *)&prefix,
-				M0_CLRES_INVALID);
+				M0_CLRES_HOLE);
 err1_injected:
 	if (rc != 0) {
 		m0_layout__log("extmap_indb_add",
@@ -1972,10 +1976,10 @@ err1_injected:
 	seg = m0_emap_seg_get(&it);
 	M0_ASSERT(seg->ee_ext.e_start == 0);
 	M0_ASSERT(seg->ee_ext.e_end == M0_BINDEX_MAX + 1);
-	M0_ASSERT(seg->ee_val == M0_CLRES_INVALID);
+	M0_ASSERT(seg->ee_val == M0_CLRES_HOLE);
 
 	m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
-		M0_ASSERT(M0_IN(lr_ext->cle_state, (M0_CLRES_INVALID,
+		M0_ASSERT(M0_IN(lr_ext->cle_state, (M0_CLRES_HOLE,
 						    M0_CLRES_VALID,
 						    M0_CLRES_FLATTENING)));
 		rc = ext_indb_write_internal(&it, layer,
@@ -2041,7 +2045,7 @@ static int extentmap_indb_read(struct m0_composite_layout *cl,
 		if (M0_FI_ENABLED("invalid_ext_state_err"))
 			seg->ee_val = 222; /* Some random number. */
 		if (m0_ext_is_empty(&seg->ee_ext) ||
-		    !M0_IN(seg->ee_val, (M0_CLRES_INVALID, M0_CLRES_VALID,
+		    !M0_IN(seg->ee_val, (M0_CLRES_HOLE, M0_CLRES_VALID,
 					 M0_CLRES_FLATTENING))) {
 			rc = -EINVAL;
 			m0_layout__log("extentmap_indb_read",
@@ -2183,7 +2187,7 @@ static int comp_layout_indb_add(struct m0_composite_layout *cl,
  * Adds a single extent spanning the whole offset space.
  * m0_emap_obj_delete() requires that the map consists of only one single
  * extent. Hence, this function is used in the situations where the map is to
- * be deleted and may contain multiple invalid extents.
+ * be deleted and may contain multiple extents with M0_CLRES_HOLE state.
  */
 static int single_ext_indb_write(struct m0_composite_layout *cl,
 				 uint32_t layer_idx, struct m0_db_tx *tx)
@@ -2218,7 +2222,7 @@ err1_injected:
 	//todo Change m0_emap_paste() such that it accepts NULL cb pointers
 	if (M0_FI_ENABLED("emap_paste_err"))
 		{ rc = L_EMAP_PASTE_ERR; goto err2_injected; }
-	rc = m0_emap_paste(&it, &ext, M0_CLRES_INVALID,
+	rc = m0_emap_paste(&it, &ext, M0_CLRES_HOLE,
 			   NULL, NULL, NULL, NULL);
 err2_injected:
 	if (rc != 0)
@@ -2256,7 +2260,7 @@ static int layer_indb_delete_verify(struct m0_composite_layout *cl,
 	 * composite layout due to its possibly large size. If it is planned
 	 * that in any case, a layer is fetched as a whole or not, then this
 	 * exception will not be hit even in the future. In that case, the
-	 * condition "if (seg->ee_val != M0_CLRES_INVALID)" below shall not
+	 * condition "if (seg->ee_val != M0_CLRES_HOLE)" below shall not
 	 * be handled but instead shall be converted into an assert.
 	 */
 	rc = 0;
@@ -2273,7 +2277,7 @@ static int layer_indb_delete_verify(struct m0_composite_layout *cl,
 		while (1) {
 			M0_ASSERT(seg != NULL);
 			M0_ASSERT(!m0_ext_is_empty(&seg->ee_ext));
-			M0_ASSERT(seg->ee_val == M0_CLRES_INVALID);
+			M0_ASSERT(seg->ee_val == M0_CLRES_HOLE);
 			if (m0_emap_ext_is_last(&seg->ee_ext))
 				break;
 			m0_emap_next(&it);
@@ -2284,33 +2288,33 @@ static int layer_indb_delete_verify(struct m0_composite_layout *cl,
 	M0_RETURN(rc);
 }
 
-//todo Make it not accept emap but to find it
 static int layer_indb_delete(struct m0_composite_layout *cl,
-			     struct m0_emap *emap,
 			     uint32_t layer_idx,
-			     uint64_t sl_id,       /* sublayout_id */
-			     struct m0_layout *sl, /* sublayout */
+			     uint64_t sublayout_id,
+			     struct m0_layout *sublayout,
 			     struct m0_db_tx *tx,
 			     bool in_update_path)
 {
-	struct layout_prefix prefix;
-	int                  rc;
+	struct m0_emap       *emap;
+	struct layout_prefix  prefix;
+	int                   rc;
+
+	M0_PRE(sublayout_id > 0);
+	M0_PRE(ergo(in_update_path, sublayout == NULL));
+	M0_PRE(ergo(!in_update_path, sublayout != NULL));
 
-	M0_PRE(sl_id > 0);
-	M0_PRE(ergo(in_update_path, sl == NULL));
-	M0_PRE(ergo(!in_update_path, sl != NULL));
 	M0_ENTRY("lid %llu, layer_idx %lu, in_update_path %d",
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer_idx, in_update_path ? 1 : 0);
-
+	emap = emap_from_cl(cl);
 	if (in_update_path) {
-		sl = layout_find(cl->cl_base.l_dom, sl_id);
-		if (sl == NULL) {
+		sublayout = layout_find(cl->cl_base.l_dom, sublayout_id);
+		if (sublayout == NULL) {
 			rc = -EINVAL;
 			M0_LOG(M0_ERROR, "lid %llu, sublayout with lid %llu "
 			       "does not exist",
 			       (unsigned long long)cl->cl_base.l_id,
-			       (unsigned long long)sl_id);
+			       (unsigned long long)sublayout_id);
 			M0_RETURN(-EINVAL);
 		}
 	} else {
@@ -2329,11 +2333,11 @@ static int layer_indb_delete(struct m0_composite_layout *cl,
 err1_injected:
 	if (rc == 0) {
 		/* Decrement the user count of the sublayout. */
-		m0_layout_user_count_dec(sl);
+		m0_layout_user_count_dec(sublayout);
 
 		if (in_update_path)
 			/* Release the reference added by m0_layout_find(). */
-			m0_layout_put(sl);
+			m0_layout_put(sublayout);
 	} else
 		m0_layout__log("layer_indb_delete",
 			       "failed to delete from layer_emap",
@@ -2409,7 +2413,7 @@ static int comp_layout_indb_delete(struct m0_composite_layout *cl,
 				  m0_tl_forall(m0_composite_layer_ext, lr_ext,
 					       &lr->clr_extents,
 					       lr_ext->cle_state ==
-					       M0_CLRES_INVALID))));
+					       M0_CLRES_HOLE))));
 	M0_ENTRY("lid %llu, layers_nr %lu",
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)cl->cl_layers_nr);
@@ -2423,7 +2427,7 @@ static int comp_layout_indb_delete(struct m0_composite_layout *cl,
 		M0_ASSERT(rc == 0 || rc == -ENOENT); //todo
 		if (rc == 0) {
 			for (i = existing_layers_nr - 1; i >= 0; --i) {
-				rc = layer_indb_delete(cl, emap, i,
+				rc = layer_indb_delete(cl, i,
 						       existing_sl_id_list[i],
 						       NULL, tx,
 						       in_update_path);
@@ -2436,7 +2440,7 @@ static int comp_layout_indb_delete(struct m0_composite_layout *cl,
 			rc = 0;
 	} else {
 		m0_tl_for(comp_layer, &cl->cl_layers, layer) {
-			rc = layer_indb_delete(cl, emap, layer->clr_idx,
+			rc = layer_indb_delete(cl, layer->clr_idx,
 					       layer->clr_sl->l_id,
 					       layer->clr_sl, tx,
 					       in_update_path);
@@ -2490,10 +2494,10 @@ static int ext_indb_lookup(struct m0_composite_layout *cl,
 		m0_emap_close(&it);
 		M0_ASSERT(seg != NULL);
 		M0_ASSERT(!m0_ext_is_empty(&seg->ee_ext));
-		M0_ASSERT(M0_IN(seg->ee_val, (M0_CLRES_INVALID, M0_CLRES_VALID,
+		M0_ASSERT(M0_IN(seg->ee_val, (M0_CLRES_HOLE, M0_CLRES_VALID,
 					      M0_CLRES_FLATTENING)));
 
-		if (seg->ee_val != M0_CLRES_INVALID) {
+		if (seg->ee_val != M0_CLRES_HOLE) {
 			found = true;
 			break;
 		}
diff --git a/layout/composite.h b/layout/composite.h
index 0286974..19f7889 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -159,14 +159,14 @@ enum m0_composite_layer_ext_state {
 	/**
 	 * This value is used to tag an extent that does not belong to the
 	 * layer.
-	 * For example, an extent [0, X) would be with M0_CLRES_INVALID state
+	 * For example, an extent [0, X) would be with M0_CLRES_HOLE state
 	 * for a layer 'that has a single extent [X, M0_BINDEX_MAX + 1) with
 	 * M0_CLRES_VALID state, associated with it'.
 	 *
 	 * This relates to the implementation of the m0_emap that by default
 	 * has the offset space from 0 to M0_BINDEX_MAX.
 	 */
-	M0_CLRES_INVALID,
+	M0_CLRES_HOLE,
 
 	/**
 	 * This value is used to tag a normal extent belonging to a particular
@@ -331,7 +331,7 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
  *
  * It internally overwrites or truncates the overlapping extents as necessary.
  * The overlapping extents can be merged if and only if they are with the state
- * M0_CLRES_INVALID or with the state same as ext_state. If this criterion is
+ * M0_CLRES_HOLE or with the state same as ext_state. If this criterion is
  * not satisfied, the error -EINVAL is returned.
  *
  * @note After this API has been used, the user needs to explicitly invoke
@@ -348,7 +348,7 @@ M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
  *
  * It internally overwrites or truncates the overlapping extents as necessary.
  * The overlapping extents can be merged if and only if they are with the state
- * M0_CLRES_INVALID or with the state same as ext_state. If this criterion is
+ * M0_CLRES_HOLE or with the state same as ext_state. If this criterion is
  * not satisfied, the error -EINVAL is returned.
  *
  * @note After this API has been used, the user needs to explicitly invoke
@@ -365,10 +365,10 @@ M0_INTERNAL int m0_composite_layer_ext_state_update(
  * layout.
  * It internally overwrites or truncates the overlapping extents as necessary.
  * The overlapping extents can be deleted if and only if they are:
- * - all with the state M0_CLRES_INVALID OR
- * - all with only one state other than M0_CLRES_INVALID OR
- * - all with mixture of some with the state M0_CLRES_INVALID and some with one
- *   single state other than M0_CLRES_INVALID.
+ * - all with the state M0_CLRES_HOLE OR
+ * - all with only one state other than M0_CLRES_HOLE OR
+ * - all with mixture of some with the state M0_CLRES_HOLE and some with one
+ *   single state other than M0_CLRES_HOLE.
  * If this criterion is not satisfied, the error -EINVAL is returned.
  *
  * @note After this API has been used, the user needs to explicitly invoke
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index ddcf3c7..0f372c3 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -159,8 +159,8 @@ static void extentlist_build(struct m0_tl *extents,
 		if (if_contiguous_extents || i % 2 == 0)
 			lr_ext->cle_state = M0_CLRES_VALID;
 		else
-			/* Make every alternate extent INVALID. */
-			lr_ext->cle_state = M0_CLRES_INVALID;
+			/* Make every alternate extent a hole. */
+			lr_ext->cle_state = M0_CLRES_HOLE;
 
 		m0_composite_layer_ext_tlink_init_at_tail(lr_ext, extents);
 	}
@@ -244,7 +244,7 @@ static void composite_layout_verify(struct m0_layout *l,
 					     M0_CLRES_VALID);
 			else
 				M0_UT_ASSERT(lr_ext->cle_state ==
-					     M0_CLRES_INVALID);
+					     M0_CLRES_HOLE);
 			++j;
 		} m0_tl_endfor;
 		M0_UT_ASSERT(j == extents_nr);
@@ -683,18 +683,14 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 		//todo Assert everywhere applicable that extents_nr >= 2
 		for (j = 0; j < layer_header.clh_extents_nr; ++j) {
 			ext.e_start = START_OFFSET + j * delta;
-			if (j == layer_header.clh_extents_nr - 1)
-				ext.e_end = END_OFFSET;
-			else
-				ext.e_end = ext.e_start + delta;
+			ext.e_end = (j == layer_header.clh_extents_nr - 1) ?
+				END_OFFSET : ext.e_start + delta;
 			nbytes = m0_bufvec_cursor_copyto(dcur, &ext,
 							 sizeof ext);
 			M0_UT_ASSERT(nbytes == sizeof ext);
 
-			if (if_contiguous_extents || j % 2 == 0)
-				ext_state = M0_CLRES_VALID;
-			else
-				ext_state = M0_CLRES_INVALID;
+			ext_state = (if_contiguous_extents || j % 2 == 0) ?
+				M0_CLRES_VALID : M0_CLRES_HOLE;
 
 			if (M0_FI_ENABLED("invalid_ext_state_err"))
 				ext_state = 111;
@@ -837,7 +833,7 @@ static void composite_layout_buf_verify(uint64_t lid,
 			if (if_contiguous_extents || j % 2 == 0)
 				M0_UT_ASSERT(*ext_state == M0_CLRES_VALID);
 			else
-				M0_UT_ASSERT(*ext_state == M0_CLRES_INVALID);
+				M0_UT_ASSERT(*ext_state == M0_CLRES_HOLE);
 		}
 		//todo enable once m0_emap_paste works ++extents_nr;
 	}
@@ -1440,17 +1436,12 @@ static void extent_to_be_operated(const struct m0_composite_layout *cl,
 		if (if_contiguous_extents)
 			*ext = ext_idxth;
 		else {
-			if ((i - 1) % 2 == 0)
-				*ext = ext_idxth;
-			else
-				*ext = ext_idx_plus_oneth;
+			*ext = ((i - 1) % 2 == 0) ?
+				ext_idxth : ext_idx_plus_oneth;
 		}
 	} else if (extent_kind == NON_EXISTING) {
 		M0_UT_ASSERT(!if_contiguous_extents);
-		if ((i - 1) % 2 == 0)
-			*ext = ext_idx_plus_oneth;
-		else
-			*ext = ext_idxth;
+		*ext = ((i - 1) % 2 == 0) ? ext_idx_plus_oneth : ext_idxth;
 	} else if (extent_kind == OVERLAPPING_LEFT) {
 		ext->e_start = ext_idxth.e_start;
 		ext->e_end = ext_idx_plus_oneth.e_start + 1;
@@ -1582,8 +1573,8 @@ static int ext_op_pre(enum extent_operation eop,
 					       &sublayout_lookup);
 	//todo Check if the following cond shud be based on failure_test
 #if 1
-	if (extent_kind == NON_EXISTING || (extent_kind == OVERLAPPING_LEFT &&
-	    !if_contiguous_extents)) {
+	if (extent_kind == NON_EXISTING ||
+	    (extent_kind == OVERLAPPING_LEFT && !if_contiguous_extents)) {
 		//todo check if the later cond below is reqd
 		M0_UT_ASSERT(rc_tmp == -ENOENT || rc_tmp == L_EMAP_LOOKUP_ERR);
 		if (eop == EXTENT_LOOKUP)
@@ -1895,7 +1886,7 @@ static int test_ext_lookup(uint64_t lid,
 
 	rc = ext_op_pre(EXTENT_LOOKUP, lid, domain, layers_nr, min_extents_nr,
 			if_contiguous_extents, extent_kind,
-			M0_CLRES_INVALID, /* todo */
+			M0_CLRES_HOLE, /* todo */
 			failure_test, &cl, &ext_to_operate, &offset_to_operate,
 			&ext_state_lookup, &l_copy_orig);
 	if (failure_test)
@@ -2041,7 +2032,7 @@ static int test_ext_delete(uint64_t lid,
 	int                         rc;
 
 	rc = ext_op_pre(EXTENT_DELETE, lid, domain, layers_nr, min_extents_nr,
-			if_contiguous_extents, extent_kind, M0_CLRES_INVALID,
+			if_contiguous_extents, extent_kind, M0_CLRES_HOLE,
 			failure_test, &cl, &ext_to_operate, &offset_to_operate,
 			&ext_state_lookup, &l_copy_orig);
 	M0_ASSERT(rc == 0);
@@ -2284,7 +2275,7 @@ void test_layer_ext_ops_composite_failure(uint64_t base_lid,
 	/*
 	 * Simulate extent validation error by trying to update an extent with
 	 * the M0_CLRES_FLATTENING state that at least partially overlaps with
-	 * two existing extents - one with the M0_CLRES_INVALID state and the
+	 * two existing extents - one with the M0_CLRES_HOLE state and the
 	 * other with M0_CLRES_VALID state..
 	 */
 	lid = base_lid + 41;
@@ -2296,7 +2287,7 @@ void test_layer_ext_ops_composite_failure(uint64_t base_lid,
 	/*
 	 * Simulate extent validation error by trying to delete an extent
 	 * that overlaps with multiple extents while at least two of those are
-	 * with two different states other than M0_CLRES_INVALID.
+	 * with two different states other than M0_CLRES_HOLE.
 	 */
 	lid = base_lid + 61;
 	m0_fi_enable_once("test_ext_delete", "ext_del_validation_err");
-- 
1.8.3.2

