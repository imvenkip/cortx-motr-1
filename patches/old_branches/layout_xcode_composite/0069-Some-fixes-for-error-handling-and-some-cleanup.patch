From 1d37494ec01c150fced98836c9fbd1d57e83c4b2 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Tue, 26 Feb 2013 14:50:24 +0530
Subject: [PATCH 069/157] Some fixes for error handling and some cleanup

---
 layout/composite.c    | 461 +++++++++++++++++++++++++++++---------------------
 layout/composite.h    |  14 +-
 layout/layout.h       |   6 +-
 layout/layout_addb.h  |  47 +++--
 layout/ut/composite.c |  11 +-
 layout/ut/layout.c    |   8 +
 6 files changed, 324 insertions(+), 223 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index 174d251..633b0c4 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -446,6 +446,7 @@ static void extlist_free(struct m0_tl *extlist)
 }
 
 /**
+ * todo Top-most or the second-from-top layer can be deleted.
  * Deletes a layer from the in-memory layout.
  *
  * In regular course, a layer never explicitly gets deleted from the layout.
@@ -565,9 +566,42 @@ static void composite_fini(struct m0_ref *ref)
 	M0_LEAVE();
 }
 
+static int ext_inmem_add_internal(struct m0_composite_layer *layer,
+				  struct m0_layout *l,
+				  struct m0_tl *extlist,
+				  const struct m0_ext *ext,
+				  uint64_t ext_state,
+				  uint32_t add_position,
+				  struct m0_composite_layer_extent *
+							adjacent_lr_ext);
 static int layer_indb_add(struct m0_composite_layout *cl,
 			  struct m0_composite_layer *layer,
 			  struct m0_db_tx *tx);
+static int comp_layout_indb_read(struct m0_composite_layout *cl,
+				 struct m0_db_tx *tx,
+				 uint32_t user_count);
+static int comp_layout_indb_add(struct m0_composite_layout *cl,
+				struct m0_db_tx *tx);
+static int comp_layout_indb_delete(struct m0_composite_layout *cl,
+				   struct m0_db_tx *tx);
+static int ext_indb_lookup(struct m0_composite_layout *cl,
+			   m0_bindex_t offset,
+			   struct m0_db_tx *tx,
+			   struct m0_ext *ext,
+			   uint32_t *layer_idx,
+			   uint64_t *ext_state,
+			   struct m0_layout **sublayout);
+static int emap_iterator_set(struct m0_composite_layout *cl,
+			     uint32_t layer_idx,
+			     const struct m0_ext *ext,
+			     struct m0_db_tx *tx,
+			     bool ext_validate,
+			     struct m0_emap_cursor *it);
+static int ext_indb_write(struct m0_emap_cursor *it,
+			  struct m0_composite_layer *layer,
+			  const struct m0_ext *ext,
+			  uint64_t new_ext_state,
+			  bool in_mem_list_update);
 
 M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
 				       struct m0_layout *sublayout,
@@ -636,9 +670,9 @@ static struct m0_layout *layout_find(struct m0_layout_domain *dom,
 	 * shall be fetched either from the DB or over the network, as
 	 * applicable.
 	 * This requiress:
-	 * - The m0_layout_domain to include the flag indicating if the network
+	 * - The m0_layout_domain to include a flag indicating if the network
 	 *   is available viz. ld_is_network_available along with the flag
-	 *   ld_is_db_available that is being added through the current patch.
+	 *   ld_is_db_available that is being added through the current patch,
 	 * - The layout id to be extended to 128 bit to store the layout type,
 	 *   so that the DB lookup can be performed for it.
 	 *
@@ -654,40 +688,6 @@ static struct m0_layout *layout_find(struct m0_layout_domain *dom,
 	return sublayout;
 }
 
-static int ext_inmem_add_internal(struct m0_composite_layer *layer,
-				  struct m0_layout *l,
-				  struct m0_tl *extlist,
-				  const struct m0_ext *ext,
-				  uint64_t ext_state,
-				  uint32_t add_position,
-				  struct m0_composite_layer_extent *
-							adjacent_lr_ext);
-static int comp_layout_indb_read(struct m0_composite_layout *cl,
-				 struct m0_db_tx *tx,
-				 uint32_t user_count);
-static int comp_layout_indb_add(struct m0_composite_layout *cl,
-				struct m0_db_tx *tx);
-static int comp_layout_indb_delete(struct m0_composite_layout *cl,
-				   struct m0_db_tx *tx);
-static int ext_indb_lookup(struct m0_composite_layout *cl,
-			   m0_bindex_t offset,
-			   struct m0_db_tx *tx,
-			   struct m0_ext *ext,
-			   uint32_t *layer_idx,
-			   uint64_t *ext_state,
-			   struct m0_layout **sublayout);
-static int emap_iterator_set(struct m0_composite_layout *cl,
-			     uint32_t layer_idx,
-			     const struct m0_ext *ext,
-			     struct m0_db_tx *tx,
-			     bool ext_validate,
-			     struct m0_emap_cursor *it);
-static int ext_indb_write(struct m0_emap_cursor *it,
-			  struct m0_composite_layer *layer,
-			  const struct m0_ext *ext,
-			  uint64_t new_ext_state,
-			  bool in_mem_list_update);
-
 static int extlist_inbuf_read(struct m0_composite_layout *cl,
 			      struct m0_bufvec_cursor *cur,
 			      uint32_t extents_nr,
@@ -726,7 +726,7 @@ static int extlist_inbuf_read(struct m0_composite_layout *cl,
 				        M0_CLRES_FLATTENING))) {
 			m0_layout__log("extlist_inbuf_read",
 				       "Invalid extent found in the buffer",
-				       M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_3,
+				       M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_2,
 				       &cl->cl_base.l_addb_ctx,
 				       cl->cl_base.l_id, -ENOMEM);
 			extlist_free(extlist);
@@ -735,9 +735,10 @@ static int extlist_inbuf_read(struct m0_composite_layout *cl,
 		rc = ext_inmem_add_internal(NULL, &cl->cl_base, extlist,
 					    ext, *ext_state,
 					    ADD_AT_TAIL, NULL);
-		M0_ASSERT(rc == 0); //todo rm
 		if (rc != 0) {
-			//todo M0_LOG
+			M0_LOG(M0_ERROR, "lid %llu, Extent could not be "
+			       "added to the list",
+			       (unsigned long long)cl->cl_base.l_id);
 			extlist_free(extlist);
 			return rc;
 		}
@@ -874,8 +875,7 @@ static void comp_layout_inbuf_write(const struct m0_composite_layout *cl,
 	M0_ASSERT(nbytes == sizeof cl_header);
 
 	/*
-	 * Read layers information from the composite layout and store
-	 * it in the buffer.
+	 * Read layers information from the layout and store it in the buffer.
 	 */
 	M0_ASSERT(m0_bufvec_cursor_step(out) >= cl->cl_layers_nr *
 		  sizeof lr_header);
@@ -1005,10 +1005,10 @@ static int ext_inmem_find(struct m0_composite_layer *layer,
 }
 
 /**
- * If the layer is provided, then add an extent to the extent list associated
+ * If the layer is provided, then adds an extent to the extent list associated
  * with the provided layer.
  * If the layer is not provided (in cases where layer is yet to be created),
- * then add the extent directly to the extlist provided.
+ * then adds the extent directly to the extlist provided.
  */
 static int ext_inmem_add_internal(struct m0_composite_layer *layer,
 				  struct m0_layout *l,
@@ -1032,7 +1032,21 @@ static int ext_inmem_add_internal(struct m0_composite_layer *layer,
 		    m0_composite_layer_ext_tlink_is_in(adjacent_lr_ext)));
 	M0_PRE(ergo(add_position == ADD_AT_TAIL, adjacent_lr_ext == NULL));
 
-#if 1
+	M0_ENTRY("lid %llu, layer_idx %lu , e_start %llu, e_end %llu, "
+		 "e_state %llu, add_position %lu, "
+		 "adjacent_ext_start %llu, adjacent_ext_end %llu",
+		 (layer == NULL) ? (unsigned long long)l->l_id :
+		 (unsigned long long)layer->clr_l->l_id,
+		 (layer == NULL) ? 0 : (unsigned long)layer->clr_idx,
+		 (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end, (unsigned long long)ext_state,
+		 (unsigned long)add_position,
+		 (adjacent_lr_ext == NULL) ? 0 :
+		 (unsigned long long)adjacent_lr_ext->cle_ext.e_start,
+		 (adjacent_lr_ext == NULL) ? 0 :
+		 (unsigned long long)adjacent_lr_ext->cle_ext.e_end);
+
+#if 0
 #ifndef __KERNEL__
 	//todo Make this M0_DEBUG, not M0_ENTRY
 	printf("ext_inmem_add_internal(1): e_start %llu, e_end %llu, ext %p, "
@@ -1053,9 +1067,9 @@ static int ext_inmem_add_internal(struct m0_composite_layer *layer,
 
 	M0_ALLOC_PTR(lr_ext);
 	if (lr_ext == NULL) {
-		m0_layout__log("extlist_inbuf_read",
+		m0_layout__log("ext_inmem_add_internal",
 			       "failed to allocate composite extent",
-			       M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_2,
+			       M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD_INTERNAL,
 			       &l->l_addb_ctx, l->l_id, -ENOMEM);
 		return -ENOMEM;
 	}
@@ -1091,14 +1105,19 @@ static int ext_inmem_add(struct m0_composite_layer *layer,
 	struct m0_composite_layer_extent *lr_ext;
 	int                               rc;
 
-	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, "
-		 "e_state %llu, ext %p ",
+	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu ",
 		 (unsigned long long)layer->clr_l->l_id,
 		 (unsigned long)layer->clr_idx,
 		 (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end,
-		 (unsigned long long)ext_state,
-		 ext);
+		 (unsigned long long)ext->e_end, (unsigned long long)ext_state);
+#ifndef __KERNEL__
+	printf("ext_inmem_add(): lid %llu, layer %lu, "
+		"e_start %llu, e_end %llu, e_state %llu\n",
+		 (unsigned long long)layer->clr_l->l_id,
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end, (unsigned long long)ext_state);
+#endif
 
 	ext_to_insert_before = NULL;
 	ext_to_insert_after = NULL;
@@ -1112,28 +1131,6 @@ static int ext_inmem_add(struct m0_composite_layer *layer,
 	} m0_tl_endfor;
 	M0_ASSERT(ext_to_insert_before != NULL || ext_to_insert_after != NULL);
 
-#ifndef __KERNEL__
-	printf("ext_inmem_add(): lid %llu, layer %lu, "
-		"e_start %llu, e_end %llu, "
-		"e_state %llu, "
-		"ext_to_insert_after %p, ext_to_insert_before %p\n",
-		 (unsigned long long)layer->clr_l->l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end,
-		 (unsigned long long)ext_state,
-		 ext_to_insert_after, ext_to_insert_before);
-#endif
-	M0_LOG(M0_DEBUG, "ext_inmem_add(): lid %llu, layer %lu, "
-		"e_start %llu, e_end %llu, e_state %llu, "
-		"ext_to_insert_after %p, ext_to_insert_before %p",
-		 (unsigned long long)layer->clr_l->l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end,
-		 (unsigned long long)ext_state,
-		 ext_to_insert_after, ext_to_insert_before);
-
 	if (ext_to_insert_after != NULL)
 		rc = ext_inmem_add_internal(layer, NULL, NULL,
 					    ext, ext_state, ADD_AFTER,
@@ -1142,7 +1139,9 @@ static int ext_inmem_add(struct m0_composite_layer *layer,
 		rc = ext_inmem_add_internal(layer, NULL, NULL,
 					    ext, ext_state, ADD_BEFORE,
 					    ext_to_insert_before);
-	M0_ASSERT(rc == 0); //handle
+	if (rc != 0)
+		M0_LOG(M0_ERROR, "lid %llu, extent could not be added to "
+		       "memory", (unsigned long long)layer->clr_l->l_id);
 	M0_RETURN(rc);
 }
 
@@ -1150,17 +1149,15 @@ static struct m0_composite_layer *layer_find(
 					const struct m0_composite_layout *cl,
 					uint32_t layer_idx)
 {
-	struct m0_composite_layer *layer;
+	struct m0_composite_layer *layer = NULL;
 
 	M0_PRE(layer_idx < cl->cl_layers_nr);
-
-	layer = NULL;
 	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
 		if (layer->clr_idx == layer_idx)
 			break;
 	} m0_tl_endfor;
 
-	M0_POST(layer != NULL && layer_invariant(layer));
+	M0_POST(layer->clr_idx == layer_idx && layer_invariant(layer));
 	return layer;
 }
 
@@ -1189,7 +1186,6 @@ static int ext_inmem_lookup(struct m0_composite_layout *cl,
 		 (unsigned long long)offset);
 #endif
 
-
 	/* Start the lookup with the top-most layer. */
 	layer = comp_layer_tlist_tail(&cl->cl_layers);
 	M0_ASSERT(layer != NULL);
@@ -1232,7 +1228,10 @@ static int ext_inmem_lookup(struct m0_composite_layout *cl,
 		(unsigned long long)cl->cl_base.l_id,
 		(unsigned long long)offset, rc, (unsigned long)*layer_idx);
 #endif
-	M0_RETURN(rc);
+	M0_LEAVE("lid %llu, offset %llu, rc %d, layer_id %lu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long long)offset, rc, (unsigned long)*layer_idx);
+	return rc;
 }
 
 M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
@@ -1267,25 +1266,30 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
 	else
 		rc = ext_indb_lookup(cl, offset, tx, ext,
 				     layer_idx, ext_state, sublayout);
-	M0_ASSERT(rc == 0 || rc == -ENOENT); //todo Handle, log etc
-
 	m0_mutex_unlock(&cl->cl_base.l_lock);
-	M0_LEAVE("lid %llu, offset %llu, rc %d, layer_id %lu",
-		 (unsigned long long)cl->cl_base.l_id,
-		 (unsigned long long)offset, rc, (unsigned long)*layer_idx);
 #ifndef __KERNEL__
 	printf("m0_composite_layer_ext_lookup(): lid %llu, offset %llu, "
 		"rc %d, layer_id %lu\n",
 		(unsigned long long)cl->cl_base.l_id,
 		(unsigned long long)offset, rc, (unsigned long)*layer_idx);
 #endif
-	M0_PRE(composite_invariant(cl));
+	M0_LEAVE("lid %llu, offset %llu, rc %d, layer_id %lu",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long long)offset, rc, (unsigned long)*layer_idx);
+	M0_POST(composite_invariant(cl));
 	return rc;
 }
 
 static void ext_inmem_del_internal(struct m0_composite_layer *layer,
 				   struct m0_composite_layer_extent *lr_ext)
 {
+	M0_LOG(M0_DEBUG, "lid %llu, layer_idx %lu, e_start %llu, e_end %llu, "
+	       "e_state %llu", (unsigned long long)layer->clr_l->l_id,
+	       (unsigned long)layer->clr_idx,
+	       (unsigned long long)lr_ext->cle_ext.e_start,
+	       (unsigned long long)lr_ext->cle_ext.e_end,
+	       (unsigned long long)lr_ext->cle_state);
+
 #ifndef __KERNEL__
 	printf("ext_inmem_del_internal(): lid %llu, layer %lu, \n"
 		"\te_start %llu, e_end %llu, \n",
@@ -1311,7 +1315,15 @@ static int ext_split_internal(struct m0_composite_layer *layer,
 	int           rc;
 
 	M0_PRE(m0_composite_layer_ext_tlink_is_in(lr_ext));
+	M0_PRE(vec->iv_vec.v_nr == 3);
+	M0_PRE(vec->iv_vec.v_count[0] != 0 || vec->iv_vec.v_count[1] != 0 ||
+	       vec->iv_vec.v_count[2] != 0);
 
+	M0_ENTRY("lid %llu, len0 %llu, len1 %llu, len2 %llu\n",
+		 (unsigned long long)layer->clr_l->l_id,
+		 (unsigned long long)vec->iv_vec.v_count[0],
+		 (unsigned long long)vec->iv_vec.v_count[1],
+		 (unsigned long long)vec->iv_vec.v_count[2]);
 #ifndef __KERNEL__
 	printf("ext_split_internal(): len0 %llu, len1 %llu, len2 %llu\n",
 		(unsigned long long)vec->iv_vec.v_count[0],
@@ -1319,7 +1331,6 @@ static int ext_split_internal(struct m0_composite_layer *layer,
 		(unsigned long long)vec->iv_vec.v_count[2]);
 #endif
 
-	rc = -EINVAL; /* Just to ensure that this gets overwritten. */
 	for (i = 0; i < vec->iv_vec.v_nr; ++i) {
 		len = vec->iv_vec.v_count[i];
 		if (len != 0) {
@@ -1328,15 +1339,23 @@ static int ext_split_internal(struct m0_composite_layer *layer,
 			rc = ext_inmem_add_internal(layer, NULL, NULL,
 						    &ext, vec->iv_index[i],
 						    ADD_BEFORE, lr_ext);
-			M0_ASSERT(rc == 0); //todo Handle
-			if (rc != 0)
+			if (rc != 0) {
+				M0_LOG(M0_ERROR, "lid %llu, Extent could not "
+				       "be added to the memory",
+				       (unsigned long long)layer->clr_l->l_id);
 				break;
+			}
 		}
 	}
 	ext_inmem_del_internal(layer, lr_ext);
-	return rc;
+	M0_RETURN(rc);
 }
 
+/**
+ * Pastes an extent with the specified state into the in-memory extent list
+ * associated with the specified layer'. It internally deletes or truncates
+ * the overlappping extents as necessary.
+ */
 static int ext_inmem_write(struct m0_composite_layout *cl,
 			   struct m0_composite_layer *layer,
 			   const struct m0_ext *ext,
@@ -1355,12 +1374,6 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 
 	M0_PRE(layer_invariant(layer));
 	M0_PRE(!m0_ext_is_empty(ext));
-	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu",
-		 (unsigned long long)layer->clr_l->l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end,
-		 (unsigned long long)ext_state);
 
 	/* Find the first nearest in-memory extent. */
 	ext_to_insert_into = NULL;
@@ -1369,6 +1382,7 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 			ext_to_insert_into = lr_ext;
 	} m0_tl_endfor;
 	M0_ASSERT(ext_to_insert_into != NULL);
+
 #ifndef __KERNEL__
 	printf("ext_inmem_write(1): lid %llu, layer %lu, \n"
 		"\te_start %llu, e_end %llu, e_state %llu, \n"
@@ -1382,6 +1396,14 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 		 (unsigned long long)ext_to_insert_into->cle_ext.e_start,
 		 (unsigned long long)ext_to_insert_into->cle_ext.e_end);
 #endif
+	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu "
+		 "ext_to_insert_into_start %llu, ext_to_insert_into_end %llu",
+		 (unsigned long long)layer->clr_l->l_id,
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end, (unsigned long long)ext_state,
+		 (unsigned long long)ext_to_insert_into->cle_ext.e_start,
+		 (unsigned long long)ext_to_insert_into->cle_ext.e_end);
 
 	if (ext_validate) {
 		M0_ASSERT(M0_IN(ext_to_insert_into->cle_state,
@@ -1391,29 +1413,40 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 		    ext_to_insert_into->cle_ext.e_end != ext->e_end ||
 		    ext_to_insert_into->cle_state == M0_CLRES_INVALID) {
 			rc = -EINVAL;
-			//todo M0_LOG?
-			m0_layout__log("ext_inmem_write",
-				       "A non-existing extent can not be "
-				       "updated or deleted",
-				       M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE_2, //todo
-				       &cl->cl_base.l_addb_ctx,
-				       cl->cl_base.l_id, rc);
+			M0_LOG(M0_ERROR, "lid %llu, A non-existing "
+			       "extent can not be updated or deleted, "
+			       "layer %lu, e_start %llu, e_end %llu, "
+			       "e_state %llu, rc %d",
+			       (unsigned long long)cl->cl_base.l_id,
+			       (unsigned long)layer->clr_idx,
+			       (unsigned long long)ext->e_start,
+			       (unsigned long long)ext->e_end,
+			       (unsigned long long)ext_state, rc);
 			return rc;
 		}
 	}
 
 	if (ext_to_insert_into->cle_ext.e_start == ext->e_start &&
 	    ext_to_insert_into->cle_ext.e_end == ext->e_end &&
-	    ext_to_insert_into->cle_state == ext_state)
+	    ext_to_insert_into->cle_state == ext_state) {
 		/* The exact extent already exists. So, nothing to be done. */
-		M0_RETURN(0);
+		rc = 0;
+		M0_LEAVE("lid %llu, layer %lu, rc %d",
+			 (unsigned long long)cl->cl_base.l_id,
+			 (unsigned long)layer->clr_idx, rc);
+		return rc;
+	}
 
 	if (ext_to_insert_into->cle_ext.e_start == ext->e_start &&
 	    ext_to_insert_into->cle_ext.e_end == ext->e_end &&
 	    ext_to_insert_into->cle_state != ext_state) {
-		ext_to_insert_into->cle_state = ext_state;
 		/* The exact extent already exists but with different state. */
-		M0_RETURN(0);
+		ext_to_insert_into->cle_state = ext_state;
+		rc = 0;
+		M0_LEAVE("lid %llu, layer %lu, rc %d",
+			 (unsigned long long)cl->cl_base.l_id,
+			 (unsigned long)layer->clr_idx, rc);
+		return rc;
 	}
 
 	chunk = &ext_to_insert_into->cle_ext;
@@ -1423,17 +1456,16 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 	 * Iterate over existing extents overlapping with the new one,
 	 * calculating for each, what parts have to be deleted and what remains.
 	 *
-	 * In the worst case, an existing extent can split into three
-	 * parts.
+	 * In the worst case, an existing extent can split into three parts.
 	 *
-	 * Note that the "whole" new segment is inserted after all the
+	 * Note that the "whole" new extent is inserted after all the
 	 * iterations of the following loop complete (see length[1]
 	 * assignment), thus violating the layer invariant until that point
-	 * (the map is "porous" during that time).
+	 * (the extent mask is "porous" during that time).
 	 *
 	 * This logic for extent addition has been inherited from
 	 * m0_emap_paste() that has been exercised for some time now and is
-	 * understood to be concrete! To look at an example illustrating the
+	 * understood to be efficient! To look at an example illustrating the
 	 * functioning of m0_emap_paste(), see the note added in
 	 * ext_indb_write().
 	 */
@@ -1550,8 +1582,12 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 						&vec,
 						length[0] > 0 ?
 						chunk->e_start : ext->e_start);
-			if (rc != 0) //todo trace msg
+			if (rc != 0) {
+				M0_LOG(M0_ERROR, "lid %llu, Extent could not "
+				       "be split",
+				       (unsigned long long)layer->clr_l->l_id);
 				break;
+			}
 		} else
 			rc = 0;
 
@@ -1587,13 +1623,16 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 		M0_POST(rc1 == 0);
 	}
 	M0_POST(layer_invariant(layer));
+	M0_LEAVE("lid %llu, layer %lu, rc %d",
+		 (unsigned long long)cl->cl_base.l_id,
+		 (unsigned long)layer->clr_idx, rc);
 	return rc;
 }
 
-// todo this one shall accept new_state which shall never be INVALID
 M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
 					   uint32_t layer_idx,
 					   const struct m0_ext *ext,
+					   uint64_t ext_state,
 					   struct m0_db_tx *tx)
 {
 	struct m0_composite_layer *layer;
@@ -1602,33 +1641,33 @@ M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
 
 	M0_PRE(composite_invariant(cl));
 	M0_PRE(ext != NULL);
-	/* todo
-	 * M0_PRE(M0_IN(new_state, (M0_CLRES_VALID, M0_CLRES_FLATTENING))); */
+	M0_PRE(M0_IN(ext_state, (M0_CLRES_VALID, M0_CLRES_FLATTENING)));
 	M0_PRE(ergo(cl->cl_base.l_dom->ld_is_db_available, tx != NULL));
 
-	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu",
+	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, e_state %llu",
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end);
+		 (unsigned long long)ext->e_end,
+		 (unsigned long long)ext_state);
 #ifndef __KERNEL__
 	printf("m0_composite_layer_ext_add(): lid %llu, layer %lu \n"
-		"\te_start %llu, e_end %llu \n",
+		"\te_start %llu, e_end %llu, e_state %llu \n",
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end);
+		 (unsigned long long)ext->e_end,
+		 (unsigned long long)ext_state);
 #endif
 
 	m0_mutex_lock(&cl->cl_base.l_lock);
 	layer = layer_find(cl, layer_idx);
 
 	if (!cl->cl_base.l_dom->ld_is_db_available)
-		rc = ext_inmem_write(cl, layer, ext, M0_CLRES_VALID,
+		rc = ext_inmem_write(cl, layer, ext, ext_state,
+				//todo rm M0_CLRES_VALID,
 				     !EXT_VALIDATE);
 	else {
-		rc = emap_iterator_set(cl, layer_idx, ext, tx,
-				       !EXT_VALIDATE, &it);
-		M0_ASSERT(rc == 0 || rc == -EINVAL); //todo Handle
-
+		rc = emap_iterator_set(cl, layer_idx, ext, tx, !EXT_VALIDATE,
+				       &it);
 		if (rc == 0) {
 			//todo Check the following comment
 			/**
@@ -1650,26 +1689,25 @@ M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
 			 * agreed upon during CINSP_PREUT.
 			 */
 
-			rc = ext_indb_write(&it, layer, ext, //new_state,
-					    M0_CLRES_VALID,
+			rc = ext_indb_write(&it, layer, ext, ext_state,
 					    INMEM_LIST_UPDATE);
-			if (rc != 0)
-				m0_layout__log("m0_composite_layer_ext_add",
-					       "failed to write extent",
-					       M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE_3, //todo
-					       &cl->cl_base.l_addb_ctx,
-					       cl->cl_base.l_id, rc);
 			m0_emap_close(&it);
 		}
 	}
+	if (rc != 0)
+		m0_layout__log("m0_composite_layer_ext_add",
+			       "failed to add extent",
+			       M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD,
+			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
 
 	m0_mutex_unlock(&cl->cl_base.l_lock);
 	M0_POST(layer_invariant(layer));
 	M0_POST(composite_invariant(cl));
-	M0_LEAVE("lid %llu, layer %lu, e_start %llu, e_end %llu, rc %d",
-		 (unsigned long long)cl->cl_base.l_id,
+	M0_LEAVE("lid %llu, layer %lu, e_start %llu, e_end %llu, "
+		 "e_state %llu, rc %d", (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer_idx, (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end, rc);
+		 (unsigned long long)ext->e_end, (unsigned long long)ext_state,
+		 rc);
 	return rc;
 }
 
@@ -1709,21 +1747,18 @@ M0_INTERNAL int m0_composite_layer_ext_state_update(
 	} else {
 		rc = emap_iterator_set(cl, layer_idx, ext, tx,
 				       EXT_VALIDATE, &it);
-		M0_ASSERT(rc == 0 || rc == -EINVAL); //todo Handle
-
 		if (rc == 0) {
 			rc = ext_indb_write(&it, layer, ext, new_state,
 					    INMEM_LIST_UPDATE);
-			if (rc != 0)
-				//todo Make this M0_LOG??
-				m0_layout__log("m0_composite_layer_ext_state_update",
-					       "failed to write extent",
-					       M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE_3, //todo
-					       &cl->cl_base.l_addb_ctx,
-					       cl->cl_base.l_id, rc);
 			m0_emap_close(&it);
 		}
 	}
+	if (rc != 0)
+		m0_layout__log("m0_composite_layer_ext_add",
+			       "failed to update extent state",
+			       M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE,
+			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
+
 	m0_mutex_unlock(&cl->cl_base.l_lock);
 	M0_POST(layer_invariant(layer));
 	M0_POST(composite_invariant(cl));
@@ -1770,20 +1805,17 @@ M0_INTERNAL int m0_composite_layer_ext_delete(struct m0_composite_layout *cl,
 	else {
 		rc = emap_iterator_set(cl, layer_idx, ext, tx,
 				       EXT_VALIDATE, &it);
-		M0_ASSERT(rc == 0 || rc == -EINVAL); //todo Handle
-
 		if (rc == 0) {
 			rc = ext_indb_write(&it, layer, ext, M0_CLRES_INVALID,
 					    INMEM_LIST_UPDATE);
-			if (rc != 0)
-				m0_layout__log("m0_composite_layer_ext_delete",
-					       "failed to write extent",
-					       M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE_3, //todo
-					       &cl->cl_base.l_addb_ctx,
-					       cl->cl_base.l_id, rc);
-			m0_emap_close(&it);
+					m0_emap_close(&it);
 		}
 	}
+	if (rc != 0)
+		m0_layout__log("m0_composite_layer_ext_delete",
+			       "failed to write extent",
+			       M0_LAYOUT_ADDB_LOC_COMP_EXT_DELETE,
+			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
 
 	m0_mutex_unlock(&cl->cl_base.l_lock);
 	M0_POST(layer_invariant(layer));
@@ -1802,18 +1834,11 @@ M0_INTERNAL int m0_composite_layer_ext_delete(struct m0_composite_layout *cl,
 	return rc;
 }
 
-
-
-
-
-
-
-
 /**
  * @todo It is now understood that the recsize related APIs and functions,
- * specifically their organization and documentation about their purpose have
- * become a little bit confusing. Their cleanup will be taken up as a part of
- * the subsequent task that is 'adding composite layout type support to
+ * specifically their organisation and the documentation about their purpose
+ * have become a little bit confusing. Their cleanup will be taken up as a part
+ * of the subsequent task that is 'adding composite layout type support to
  * getattr'. With the addition of m0_layout_size() to be made with this
  * subsequent task may possibly rule out the need to expose the API
  * m0_layout_max_recsize().
@@ -1854,7 +1879,6 @@ static int ext_inmem_delete(struct m0_composite_layer *layer,
 	bool                              lr_ext_to_delete_found;
 	int                               rc;
 
-	//todo rm M0_PRE(old_ext_state != M0_CLRES_INVALID);
 #ifndef __KERNEL__
 	printf("ext_inmem_delete(): lid %llu, layer %lu, "
 		"e_start %llu, e_end %llu, old_e_state %llu, ext %p\n",
@@ -1942,7 +1966,6 @@ static int ext_inmem_trim(struct m0_composite_layer *layer,
 #endif
 
 	rc = ext_inmem_find(layer, ext_to_trim, ext_state, &lr_ext);
-	M0_ASSERT(rc == 0); //todo rm
 	if (rc == 0) {
 		M0_ASSERT(lr_ext->cle_ext.e_start <=
 			  trim_reference_ext->e_start);
@@ -2024,7 +2047,6 @@ static int ext_indb_write(struct m0_emap_cursor *it,
 			  uint64_t new_ext_state,
 			  bool in_mem_list_update)
 {
-
 	/* LAMBDA is not defined for the kernel space. */
 #ifndef __KERNEL__
 	struct m0_ext ext0 = *ext; /* A read-write copy. */
@@ -2131,7 +2153,16 @@ static int ext_indb_write(struct m0_emap_cursor *it,
 			}
 		}));
 
-	//todo If rc != 0, add m0_layout__log here.
+	if (rc != 0)
+		m0_layout__log("ext_indb_write",
+			       "failed to paste an extent into emap",
+			       M0_LAYOUT_ADDB_LOC_COMP_EXT_PASTE,
+			       &layer->clr_l->l_addb_ctx, layer->clr_l->l_id,
+			       rc);
+
+	if (rc_cb != 0)
+		M0_LOG(M0_ERROR, "lid %llu, Extent could not be adjustted "
+		       "in memory", (unsigned long long)layer->clr_l->l_id);
 
 	rc = rc ?: rc_cb;
 
@@ -2141,13 +2172,17 @@ static int ext_indb_write(struct m0_emap_cursor *it,
 		 * from the in-memory list of the extents has been
 		 * handled above, let's add the ultimate whole extent.
 		 */
-		/*
-		 * todo Handle the case that there may be existing INVALID ext.
-		 * Refer to ext_inmem_write().
-		 */
 		rc = ext_inmem_find(layer, ext, new_ext_state, NULL);
-		if (rc == -ENOENT)
-			rc = ext_inmem_add(layer, ext, new_ext_state);
+		M0_ASSERT(rc == -ENOENT);
+		rc = ext_inmem_add(layer, ext, new_ext_state);
+		if (rc != 0)
+			M0_LOG(M0_ERROR, "lid %llu, Ultimate extent could not "
+			       "be added to memory, layer %lu, e_start %llu, "
+			       "e_end %llu",
+			       (unsigned long long)layer->clr_l->l_id,
+			       (unsigned long)layer->clr_idx,
+			       (unsigned long long)ext->e_start,
+			       (unsigned long long)ext->e_end);
 	}
 	M0_RETURN(rc);
 #else
@@ -2199,9 +2234,6 @@ static int sublayout_id_indb_lookup(struct m0_composite_layout *cl,
 		/**
 		 * The later condition is since the number of layers is not
 		 * known in advance while reading the layers from the DB.
-		 * Reference layers_indb_read().
-		 * @todo If the number of layers is written to the primary
-		 * table, then get rid of the later condition here.
 		 */
 		m0_layout__log("sublayout_id_indb_lookup",
 			       "failed to lookup into layer_sublayout table",
@@ -2460,7 +2492,6 @@ static int extentmap_indb_read(struct m0_composite_layout *cl,
 					    &seg->ee_ext, seg->ee_val,
 					    ADD_AT_TAIL, NULL);
 		if (rc != 0) {
-			//todo M0_LOG
 			extlist_free(*extlist);
 			m0_emap_close(&it);
 			return rc;
@@ -2605,28 +2636,74 @@ static int comp_layout_indb_delete(struct m0_composite_layout *cl,
 {
 	struct m0_composite_layer        *layer;
 	struct m0_composite_layer_extent *lr_ext;
+	struct m0_emap                   *emap;
+	struct m0_emap_cursor             it;
+	struct layout_prefix              prefix;
+	struct m0_emap_seg               *seg;
 	int                               rc;
 
 	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 
+	emap = emap_from_cl(cl);
+
 	/*
 	 * A composite layout can be deleted from the DB if and only if none of
 	 * its layers contain any valid extents.
 	 */
 	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
+		/* In-memory layer verification. */
 		m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
 			if (lr_ext->cle_state != M0_CLRES_INVALID) {
 				M0_LOG(M0_ERROR, "lid %llu, layout can not be "
-				       "deleted since layer %lu still "
-				       "contains at least one valid extent",
+				       "deleted since in-memory layer %lu "
+				       "still contains at least one valid "
+				       "extent, e_start %llu, e_end %llu",
 				       (unsigned long long)cl->cl_base.l_id,
-				       (unsigned long)layer->clr_idx);
-				return -EINVAL;;
+				       (unsigned long)layer->clr_idx,
+				       (unsigned long long)
+						lr_ext->cle_ext.e_start,
+				       (unsigned long long)
+						lr_ext->cle_ext.e_end);
+				return -EINVAL;
 			}
 		} m0_tl_endfor;
-	} m0_tl_endfor;
 
-	/* todo Confirm check similar to the above for indb extent list per layer */
+		/* In-DB layer verification. */
+		prefix_set(&prefix, cl->cl_base.l_id, layer->clr_idx);
+		rc = m0_emap_lookup(emap, tx, (struct m0_uint128 *)&prefix,
+				    0, &it);
+		if (rc != 0) {
+			m0_layout__log("comp_layout_indb_delete",
+				       "failed to lookup into layer_emap",
+				       M0_LAYOUT_ADDB_LOC_COMP_LAYOUT_DEL,
+				       &cl->cl_base.l_addb_ctx,
+				       cl->cl_base.l_id, rc);
+			return rc;
+		}
+		seg = m0_emap_seg_get(&it);
+		while (1) {
+			M0_ASSERT(seg != NULL);
+			M0_ASSERT(!m0_ext_is_empty(&seg->ee_ext));
+			if (seg->ee_val != M0_CLRES_INVALID) {
+				M0_LOG(M0_ERROR, "lid %llu, layout can not be "
+				       "deleted since in-db layer %lu "
+				       "still contains at least one valid "
+				       "extent, e_start %llu, e_end %llu",
+				       (unsigned long long)cl->cl_base.l_id,
+				       (unsigned long)layer->clr_idx,
+				       (unsigned long long)
+						lr_ext->cle_ext.e_start,
+				       (unsigned long long)
+						lr_ext->cle_ext.e_end);
+				return -EINVAL;
+			}
+			if (m0_emap_ext_is_last(&seg->ee_ext))
+				break;
+			m0_emap_next(&it);
+			seg = m0_emap_seg_get(&it);
+		}
+		m0_emap_close(&it);
+	} m0_tl_endfor;
 
 	rc = 0; /* To keep the compiler happy. */
 	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
@@ -2749,7 +2826,7 @@ static int emap_iterator_set(struct m0_composite_layout *cl,
 	if (rc != 0) {
 		m0_layout__log("emap_iterator_set",
 			       "failed to lookup into layer_emap",
-			       M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE_1, //todo
+			       M0_LAYOUT_ADDB_LOC_COMP_EMAP_IT_SET,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
 		m0_mutex_unlock(&cl->cl_base.l_lock);
 		return rc;
@@ -2768,13 +2845,13 @@ static int emap_iterator_set(struct m0_composite_layout *cl,
 		    seg->ee_ext.e_end != ext->e_end ||
 		    seg->ee_val == M0_CLRES_INVALID) {
 			rc = -EINVAL;
-			//todo M0_LOG ??
-			m0_layout__log("emap_iterator_set",
-				       "A non-existing extent can not be "
-				       "updated or deleted",
-				       M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE_2, //todo
-				       &cl->cl_base.l_addb_ctx,
-				       cl->cl_base.l_id, rc);
+			M0_LOG(M0_ERROR, "lid %llu, A non-existing extent "
+			       "can not be updated or deleted, layer %lu, "
+			       "e_start %llu, e_end %llu",
+			       (unsigned long long)cl->cl_base.l_id,
+			       (unsigned long)layer_idx,
+			       (unsigned long long)ext->e_start,
+			       (unsigned long long)ext->e_end);
 			m0_emap_close(it);
 		}
 	}
diff --git a/layout/composite.h b/layout/composite.h
index e555a1c..b292034 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -316,7 +316,8 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
 					      struct m0_layout **sublayout);
 
 /**
- * Adds an extent to the specified layer of the specified composite layout.
+ * Adds an extent with the specified state to the specified layer of the
+ * specified composite layout.
  * If the layout DB is available, updates the layer information in the DB.
  *
  * @pre The exact extent supplied as an argument 'ext' is not owned by the
@@ -325,6 +326,7 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
 M0_INTERNAL int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
 					   uint32_t layer_idx,
 					   const struct m0_ext *ext,
+					   uint64_t ext_state,
 					   struct m0_db_tx *tx);
 
 /**
@@ -367,13 +369,19 @@ M0_INTERNAL struct m0_composite_instance *m0_layout_instance_to_ci(
 extern struct m0_layout_type m0_composite_layout_type;
 
 /**
- * @todo
+ * @todo Consolidated list
+ * (Some of these items are mentioned inline too where they are applicable.
+ * This list is for mainitaining a consolidated view as what all is to be
+ * covered during the next task.)
  * 1) The network request for 'data that fits within the limits and otherwise'
  *    will be taken care of during the subsequent task that is 'adding
  *    composite layout type support to getattr'.
  * 2) Addition of m0_layout_size() API and cleanup around recsize related
  *    APIs which seem unncessary to be exposed.
- * 3)
+ * 3) Extending layout id to 128 bit to store layout type as well.
+ * 4) layout_find() in composite.c shall be extended to fetch layout either
+ *    from the DB or over the network as applicable.
+ *
  */
 
 /** @} end group composite */
diff --git a/layout/layout.h b/layout/layout.h
index 26cfd56..47b0f86 100644
--- a/layout/layout.h
+++ b/layout/layout.h
@@ -240,8 +240,10 @@ struct m0_layout {
 	uint32_t                     l_user_count;
 
 	/**
-	 * Lock to protect a m0_layout instance, including all its direct and
-	 * indirect members.
+	 * Lock to protect an instance of m0_layout, including all its direct
+	 * and indirect members.
+	 * This lock is also used to serialise the data-base operations for a
+	 * particular layout. See @ref layout-thread.
 	 */
 	struct m0_mutex              l_lock;
 
diff --git a/layout/layout_addb.h b/layout/layout_addb.h
index e228816..8b49041 100644
--- a/layout/layout_addb.h
+++ b/layout/layout_addb.h
@@ -90,31 +90,28 @@ enum {
 	M0_LAYOUT_ADDB_LOC_COMP_REG_3              = 202,
 	M0_LAYOUT_ADDB_LOC_COMP_ALLOC              = 210,
 	M0_LAYOUT_ADDB_LOC_COMP_LAYER_ALLOC        = 220,
-	M0_LAYOUT_ADDB_LOC_COMP_LAYER_EXT_ALLOC    = 230,
-	M0_LAYOUT_ADDB_LOC_COMP_SUBLAYOUT_READ     = 240,
-	M0_LAYOUT_ADDB_LOC_COMP_SUBLAYOUT_ADD      = 250,
-	M0_LAYOUT_ADDB_LOC_COMP_SUBLAYOUT_DEL      = 260,
-	M0_LAYOUT_ADDB_LOC_COMP_LAYER_EMAP_ADD_1   = 270,
-	M0_LAYOUT_ADDB_LOC_COMP_LAYER_EMAP_ADD_2   = 271,
-	M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_1        = 280,
-	M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_2        = 281,
-	M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_3        = 282,
-	M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_1       = 290,
-	M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_2       = 291,
-	M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_3       = 292,
-	M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_1        = 300,
-	M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_2        = 301,
-	M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_3        = 302,
-	M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_4        = 303,
-	M0_LAYOUT_ADDB_LOC_COMP_EXT_LOOKUP         = 310,
-	M0_LAYOUT_ADDB_LOC_COMP_EXT_WRITE_1        = 320,
-	M0_LAYOUT_ADDB_LOC_COMP_EXT_WRITE_2        = 321,
-	M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE_1       = 330,
-	M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE_2       = 331,
-	M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE_3       = 332,
-	M0_LAYOUT_ADDB_LOC_COMP_EXT_DEL_1          = 330,
-	M0_LAYOUT_ADDB_LOC_COMP_EXT_DEL_2          = 331,
-	M0_LAYOUT_ADDB_LOC_COMP_INST_BUILD         = 340,
+	M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_1        = 230,
+	M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_2        = 231,
+	M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_3        = 232,
+	M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_1       = 240,
+	M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_2       = 241,
+	M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD_INTERNAL   = 250,
+	M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD            = 360,
+	M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE         = 370,
+	M0_LAYOUT_ADDB_LOC_COMP_EXT_DELETE         = 380,
+	M0_LAYOUT_ADDB_LOC_COMP_EXT_PASTE          = 390,
+	M0_LAYOUT_ADDB_LOC_COMP_SUBLAYOUT_READ     = 400,
+	M0_LAYOUT_ADDB_LOC_COMP_SUBLAYOUT_ADD      = 410,
+	M0_LAYOUT_ADDB_LOC_COMP_SUBLAYOUT_DEL      = 420,
+	M0_LAYOUT_ADDB_LOC_COMP_LAYER_EMAP_ADD_1   = 430,
+	M0_LAYOUT_ADDB_LOC_COMP_LAYER_EMAP_ADD_2   = 431,
+	M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_1        = 440,
+	M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_2        = 441,
+	M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_3        = 442,
+	M0_LAYOUT_ADDB_LOC_COMP_LAYOUT_DEL         = 450,
+	M0_LAYOUT_ADDB_LOC_COMP_EXT_LOOKUP         = 460,
+	M0_LAYOUT_ADDB_LOC_COMP_EMAP_IT_SET        = 470,
+	M0_LAYOUT_ADDB_LOC_COMP_INST_BUILD         = 480,
 
 	M0_LAYOUT_ADDB_LOC_NR
 };
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index 9d0e87c..b5fa3f5 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -1562,6 +1562,7 @@ static int ext_operate(enum extent_operation eop,
 		       m0_bindex_t approximate_end_offset,
 		       bool if_contiguous_extents,
 		       uint32_t kind_of_extent_to_operate,
+			//todo This shud accept ext_state to use for add/update
 		       bool failure_test)
 {
 	struct m0_layout           *l;
@@ -1582,6 +1583,13 @@ static int ext_operate(enum extent_operation eop,
 
 	M0_UT_ASSERT(M0_IN(eop, (EXTENT_LOOKUP, EXTENT_ADD, EXTENT_UPDATE,
 				 EXTENT_DELETE)));
+#if 0
+	M0_UT_ASSERT(ergo(M0_IN(eop, (EXTENT_LOOKUP, EXTENT_DELETE),
+			  ext_state == M0_CLRES_INVALID)));
+	M0_UT_ASSERT(ergo(M0_IN(eop, (EXTENT_ADD, EXTENT_UPDATE)),
+		          M0_IN(ext_state, (M0_CLRES_VALID,
+					    M0_CLRES_FLATTENING))));
+#endif
 
 	if (!domain->ld_is_db_available) {
 	//todo Check possibilities for better code org / avoid code dup
@@ -1671,7 +1679,8 @@ static int ext_operate(enum extent_operation eop,
 	} else if (eop == EXTENT_ADD) {
 		/* Add the extent. */
 		rc = m0_composite_layer_ext_add(cl, cl->cl_layers_nr - 1,
-						&ext_to_operate, txptr);
+						&ext_to_operate,
+						M0_CLRES_VALID, txptr);
 		M0_UT_ASSERT(rc == 0);
 		extlist_dump(cl, cl->cl_layers_nr - 1); //todo
 
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 3926f2f..a7e3d6c 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -1397,6 +1397,14 @@ static void test_composite_layer_ext_ops_internal(void)
 				    !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
+	lid = 14030; //todo Add extent with the flattening state
+	rc = test_ext_add_composite(lid, &domain, 4, 12,
+				    lid * 100, lid * 100 * 100,
+				    !CONTIGUOUS_EXTENTS, NON_EXISTING,
+				    !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+
+
 	/* Test cases for extent updation. */
 	lid = 14041;
 	rc = test_ext_state_update_composite(lid, &domain, 6, 13,
-- 
1.8.3.2

