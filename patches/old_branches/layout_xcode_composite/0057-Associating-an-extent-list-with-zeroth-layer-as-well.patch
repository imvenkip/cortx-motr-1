From 4af356733407f2d28f7eda8ba872c55b81ccc7fd Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Mon, 21 Jan 2013 16:47:43 +0530
Subject: [PATCH 057/157] Associating an extent list with zeroth layer as well

---
 layout/composite.c    | 194 ++++++++++++++++++--------------------------------
 layout/composite.h    |  90 +++++++++++------------
 layout/layout.c       |   2 +-
 layout/layout.h       |   2 +-
 layout/ut/composite.c | 164 +++++++++++++++++++-----------------------
 5 files changed, 186 insertions(+), 266 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index 4854fbe..b05ef04 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -144,14 +144,14 @@ struct layout_prefix {
 
 M0_TL_DESCR_DEFINE(comp_layer, "composite-layer-list",
 		   M0_INTERNAL, struct m0_composite_layer,
-		   clr_list_linkage, clr_magic,
+		   clr_linkage, clr_magic,
 		   M0_LAYOUT_COMPOSITE_LAYER_MAGIC,
 		   LAYER_LIST_HEAD_MAGIC);
 M0_TL_DEFINE(comp_layer, M0_INTERNAL, struct m0_composite_layer);
 
 M0_TL_DESCR_DEFINE(m0_composite_layer_ext, "composite-layer-extent-list",
 		   M0_INTERNAL, struct m0_composite_layer_extent,
-		   cle_list_linkage, cle_magic,
+		   cle_linkage, cle_magic,
 		   M0_LAYOUT_COMPOSITE_LAYER_EXTENT_MAGIC,
 		   M0_LAYOUT_COMPOSITE_LAYER_EXTENT_HEAD_MAGIC);
 M0_TL_DEFINE(m0_composite_layer_ext, M0_INTERNAL,
@@ -182,20 +182,16 @@ static bool composite_invariant(const struct m0_composite_layout *cl)
 		m0_tl_forall(comp_layer, layer, cl->cl_layers,
 			     m0_layout__invariant(layer->clr_l) &&
 			     layer->clr_idx == i++ &&
-			     ergo(layer->clr_idx == 0,
-				  layer->clr_extents_nr == 0 &&
-				  layer->clr_extents == NULL) &&
-			     ergo(layer->clr_idx > 0,
-				  layer->clr_extents != NULL &&
-			          layer->clr_extents_nr ==
-			          m0_composite_layer_ext_tlist_length(
-							layer->clr_extents)));
+			     layer->clr_extents != NULL &&
+			     layer->clr_extents_nr ==
+			     m0_composite_layer_ext_tlist_length(
+							layer->clr_extents));
 }
 
 /*
  * todo Once confirmed through the open DLDINSP, add a layer invariant that
  * should check that extents are listed in the ascending order of the offsets
- * involved. This will require changes to UT.
+ * involved.
  */
 #if 0
 		m0_tl_forall(comp_layer, layer, cl->cl_layers,
@@ -367,20 +363,17 @@ static void composite_delete(struct m0_layout *l)
 /** Adds a layer to the in-memory layout. */
 static int layer_in_memory_add(struct m0_composite_layout *cl,
 			       struct m0_layout *sublayout,
-			       const struct m0_tl *extlist,
+			       struct m0_tl *extlist,
 			       uint32_t ext_nr,
 			       struct m0_composite_layer **lr)
 {
 	struct m0_composite_layer *layer;
 
 	/* Zeroth layer is getting added. */
-	M0_PRE(ergo(cl->cl_layers_nr == 0,
-		    composite_allocated_invariant(cl) &&
-		    extlist == NULL && ext_nr == 0));
+	M0_PRE(ergo(cl->cl_layers_nr == 0, composite_allocated_invariant(cl)));
 	/* Zeroth layer is already added. */
-	M0_PRE(ergo(cl->cl_layers_nr > 0,
-		    composite_invariant(cl) &&
-		    extlist != NULL && ext_nr > 0));
+	M0_PRE(ergo(cl->cl_layers_nr > 0, composite_invariant(cl)));
+	M0_PRE(extlist != NULL && ext_nr > 0);
 
 	M0_ENTRY("lid %llu, sublayout_id %llu, extlist %p, ext_nr %lu",
 		 (unsigned long long)cl->cl_base.l_id,
@@ -399,15 +392,13 @@ static int layer_in_memory_add(struct m0_composite_layout *cl,
 	layer->clr_l = sublayout;
 	layer->clr_idx = cl->cl_layers_nr;
 	layer->clr_extents_nr = ext_nr;
-	layer->clr_extents = (struct m0_tl *)extlist;
+	layer->clr_extents = extlist;
 	m0_layout_get(layer->clr_l);
 	m0_layout_user_count_inc(layer->clr_l);
 	comp_layer_tlink_init_at_tail(layer, cl->cl_layers);
 	M0_CNT_INC(cl->cl_layers_nr);
 	*lr = layer;
 	M0_POST(composite_invariant(cl));
-	M0_POST(ergo(ext_nr == 0, cl->cl_layers_nr == 1));
-	M0_POST(ergo(ext_nr > 0, cl->cl_layers_nr > 1));
 	M0_LEAVE("lid %llu, layer %lu", (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)layer->clr_idx);
 	return 0;
@@ -447,8 +438,7 @@ static void layer_in_memory_delete(struct m0_composite_layout *cl,
 	comp_layer_tlink_del_fini(layer);
 	m0_layout_user_count_dec(layer->clr_l);
 	m0_layout_put(layer->clr_l);
-	if (layer->clr_idx > 0) /* Except for the zeroth layer. */
-		extlist_free(layer->clr_extents);
+	extlist_free(layer->clr_extents);
 	M0_POST(layer->clr_idx == cl->cl_layers_nr);
 	m0_free(layer);
 	M0_POST(composite_invariant(cl));
@@ -457,7 +447,9 @@ static void layer_in_memory_delete(struct m0_composite_layout *cl,
 
 static int composite_populate(struct m0_composite_layout *cl,
 			      uint32_t user_count,
-			      struct m0_layout *oldlayout)
+			      struct m0_layout *oldlayout,
+			      struct m0_tl *extlist,
+			      uint32_t ext_nr)
 {
 	struct m0_composite_layer *layer;
 	int                        rc;
@@ -468,7 +460,7 @@ static int composite_populate(struct m0_composite_layout *cl,
 	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 	m0_layout__populate(&cl->cl_base, user_count);
 
-	rc = layer_in_memory_add(cl, oldlayout, NULL, 0, &layer);
+	rc = layer_in_memory_add(cl, oldlayout, extlist, ext_nr, &layer);
 	M0_ASSERT(layer->clr_idx == 0);
 
 	M0_POST(composite_invariant(cl));
@@ -480,6 +472,8 @@ static int composite_populate(struct m0_composite_layout *cl,
 M0_INTERNAL int m0_composite_build(struct m0_layout_domain *dom,
 				   uint64_t lid,
 				   struct m0_layout *oldlayout,
+				   struct m0_tl *extlist,
+				   uint32_t ext_nr,
 				   struct m0_composite_layout **out)
 {
 	struct m0_layout           *l;
@@ -495,7 +489,7 @@ M0_INTERNAL int m0_composite_build(struct m0_layout_domain *dom,
 		cl = bob_of(l, struct m0_composite_layout, cl_base,
 			    &composite_bob);
 		M0_ASSERT(composite_allocated_invariant(cl));
-		rc = composite_populate(cl, 0, oldlayout);
+		rc = composite_populate(cl, 0, oldlayout, extlist, ext_nr);
 		if (rc == 0) {
 			*out = cl;
 			m0_mutex_unlock(&l->l_lock);
@@ -525,8 +519,7 @@ static void composite_fini(struct m0_ref *ref)
 	m0_composite_layout_bob_fini(cl);
 
 	m0_tl_for(comp_layer, cl->cl_layers, layer) {
-		if (layer->clr_idx > 0) /* Except for the zeroth layer. */
-			extlist_free(layer->clr_extents);
+		extlist_free(layer->clr_extents);
 		comp_layer_tlink_del_fini(layer);
 		/* Release the reference acquired by layer_in_memory_add(). */
 		m0_layout_put(layer->clr_l);
@@ -1201,7 +1194,7 @@ static int layer_in_db_add(struct m0_composite_layout *cl,
 
 M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
 				       struct m0_layout *sublayout,
-				       const struct m0_tl *extlist,
+				       struct m0_tl *extlist,
 				       uint32_t ext_nr,
 				       struct m0_db_tx *tx)
 {
@@ -1392,19 +1385,20 @@ static int comp_layout_in_buf_read(struct m0_composite_layout *cl,
 		}
 
 		M0_ASSERT(lr_header->clh_idx == i);
-		if (lr_header->clh_idx == 0) /* Zeroth layer */
-			rc = composite_populate(cl, user_count, sublayout);
-		else {
-			rc = extlist_in_buf_read(cl, cur,
-						 lr_header->clh_extents_nr,
-						 &extlist);
-			if (rc == 0)
-				rc = m0_composite_layer_add(cl, sublayout,
-						extlist,
-						lr_header->clh_extents_nr,
-						NULL);
-		}
+		rc = extlist_in_buf_read(cl, cur,
+					 lr_header->clh_extents_nr,
+					 &extlist);
+		M0_ASSERT(rc == 0);
 
+		if (lr_header->clh_idx == 0) /* Zeroth layer */
+			rc = composite_populate(cl, user_count, sublayout,
+					        extlist,
+						lr_header->clh_extents_nr);
+		else
+			rc = m0_composite_layer_add(cl, sublayout,
+						    extlist,
+						    lr_header->clh_extents_nr,
+						    NULL);
 		/*
 		 * Release the reference added by m0_layout_find(). In case of
 		 * success, m0_composite_layer_add() has added a reference on
@@ -1513,9 +1507,13 @@ static int extentmap_in_db_read(struct m0_composite_layout *cl,
 	M0_RETURN(rc);
 }
 
-/* Reads layers from the DB, starting from the layer with index as 1. */
-static int layers_in_db_read(struct m0_composite_layout *cl,
-			     struct m0_db_tx *tx)
+/**
+ * Reads 'the composite layout type specific information including all the
+ * layers' from the DB and adds it to the in-memory layout.
+ */
+static int comp_layout_in_db_read(struct m0_composite_layout *cl,
+				  struct m0_db_tx *tx,
+				  uint32_t user_count)
 {
 	uint64_t                   sublayout_id;
 	struct m0_layout          *sublayout;
@@ -1527,11 +1525,12 @@ static int layers_in_db_read(struct m0_composite_layout *cl,
 
 	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 
-	i = 1;
+	i = 0;
 	while (1) {
 		/* Read 'the sublayout id for this layer' from the DB. */
 		rc = sublayout_id_in_db_read(cl, i, tx, &sublayout_id);
 		if (rc != 0) {
+			M0_ASSERT(i > 0);
 			if (rc == -ENOENT)
 				/*
 				 * The number of layers is not known in
@@ -1571,10 +1570,16 @@ static int layers_in_db_read(struct m0_composite_layout *cl,
 			break;
 		}
 
-		/* Now, write the layer to the in-memory layout. */
-		rc = layer_in_memory_add(cl, sublayout, extents, extents_nr,
-					 &layer);
+		if (i == 0)
+			rc = composite_populate(cl, user_count, sublayout,
+						extents, extents_nr);
+		else
+			/* Now, write the layer to the in-memory layout. */
+			//todo Check if layer is needed to be obtained back
+			rc = layer_in_memory_add(cl, sublayout, extents,
+						 extents_nr, &layer);
 		if (rc != 0) {
+			//todo Check the msg
 			M0_LOG(M0_ERROR, "lid %llu, layer %lu could not be "
 			       "written to the layout",
 			       (unsigned long long)cl->cl_base.l_id,
@@ -1583,74 +1588,20 @@ static int layers_in_db_read(struct m0_composite_layout *cl,
 			m0_layout_put(sublayout);
 			break;
 		}
-		M0_ASSERT(layer->clr_idx > 0);
 
 		/*
 		 * Release the reference added by m0_layout_find().
 		 * layer_in_memory_add() has now added a reference on this
 		 * sublayout.
 		 */
-		M0_ASSERT(rc ==0);
+		M0_ASSERT(rc == 0);
 		m0_layout_put(sublayout);
 
 		++i;
 	}
 
 	M0_RETURN(rc);
-}
-
-/**
- * Reads 'the composite layout type specific information including all the
- * layers' from the DB and adds it to the in-memory layout.
- */
-static int comp_layout_in_db_read(struct m0_composite_layout *cl,
-				  struct m0_db_tx *tx,
-				  uint32_t user_count)
-{
-	uint64_t          sublayout_id;
-	struct m0_layout *sublayout;
-	int               rc;
 
-	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
-
-	rc = sublayout_id_in_db_read(cl, 0, tx, &sublayout_id);
-	if (rc != 0) {
-		M0_LOG(M0_ERROR, "lid %llu, layer 0, sublayout id could not "
-		       "be read from DB",
-		       (unsigned long long)cl->cl_base.l_id);
-		return rc;
-	}
-
-	sublayout = layout_find(cl->cl_base.l_dom, sublayout_id);
-	if (sublayout == NULL) {
-		M0_LOG(M0_ERROR, "lid %llu, layer 0, sublayout with lid "
-		       "%llu does not exist",
-		       (unsigned long long)cl->cl_base.l_id,
-		       (unsigned long long)sublayout_id);
-		return -EINVAL;
-	}
-
-	rc = composite_populate(cl, user_count, sublayout);
-	if (rc != 0) {
-		M0_LOG(M0_ERROR, "lid %llu, failed to populate composite "
-		       "layout", (unsigned long long)cl->cl_base.l_id);
-		/* Release the reference added by m0_layout_find(). */
-		m0_layout_put(sublayout);
-		return rc;
-	}
-
-	/*
-	 * Release the reference added by m0_layout_find().
-	 * composite_populate() has now added a reference on this sublayout.
-	 */
-	m0_layout_put(sublayout);
-
-	/* Now, proceed to read the subsequent layers from the DB. */
-	rc = layers_in_db_read(cl, tx);
-	if (rc != 0)
-		M0_LOG(M0_ERROR, "lid %llu, failed to read layers from the DB",
-		       (unsigned long long)cl->cl_base.l_id);
-	M0_RETURN(rc);
 }
 
 static const struct m0_layout_ops composite_ops;
@@ -1710,6 +1661,10 @@ static int comp_layout_in_db_add(struct m0_composite_layout *cl,
 	layer = comp_layer_tlist_head(cl->cl_layers);
 	M0_ASSERT(layer->clr_idx == 0);
 	rc = sublayout_id_in_db_add(cl, layer, tx);
+	if (rc == 0)
+		/* Add 'the extent map for this layer' to the DB. */
+		rc = extmap_in_db_add(cl, layer, tx);
+	//todo Err handling
 	M0_LEAVE("lid %llu, rc %d", (unsigned long long)cl->cl_base.l_id, rc);
 	return rc;
 }
@@ -1727,17 +1682,15 @@ static int comp_layout_in_db_delete(struct m0_composite_layout *cl,
 	 * its layers contain any valid extent.
 	 */
 	m0_tl_for(comp_layer, cl->cl_layers, layer) {
-		if (layer->clr_idx > 0) { /* Except for the zeroth layer. */
-			if (!m0_composite_layer_ext_tlist_is_empty(
-							layer->clr_extents)) {
-				M0_LOG(M0_ERROR, "lid %llu, layout can not be "
-				       "deleted since layer %lu still "
-				       "contains %lu extents",
-				       (unsigned long long)cl->cl_base.l_id,
-				       (unsigned long)layer->clr_idx,
-				       (unsigned long)layer->clr_extents_nr);
-				return -EINVAL;;
-			}
+		if (!m0_composite_layer_ext_tlist_is_empty(
+						layer->clr_extents)) {
+			M0_LOG(M0_ERROR, "lid %llu, layout can not be "
+			       "deleted since layer %lu still "
+			       "contains %lu extents",
+			       (unsigned long long)cl->cl_base.l_id,
+			       (unsigned long)layer->clr_idx,
+			       (unsigned long)layer->clr_extents_nr);
+			return -EINVAL;;
 		}
 	} m0_tl_endfor;
 
@@ -1786,9 +1739,6 @@ static void comp_layout_in_buf_write(const struct m0_composite_layout *cl,
 		lr_header.clh_extents_nr = layer->clr_extents_nr;
 		nbytes = m0_bufvec_cursor_copyto(out, &lr_header,
 						 sizeof lr_header);
-		/* Zeroth layer does not contain any extents. */
-		if (lr_header.clh_idx == 0)
-			continue;
 		m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
 			nbytes = m0_bufvec_cursor_copyto(out,
 							&lr_ext->cle_ext,
@@ -1874,10 +1824,6 @@ static struct m0_composite_layer *layer_find(
  * contain same list of extents. So traversing layers part is not being
  * verified.
  */
-/*
- * todo Change beahvior of this API to return zeroth layer as the default,
- * once approved in the DLDINSP.
- */
 M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
 					      m0_bindex_t offset,
 					      struct m0_db_tx *tx,
@@ -1927,8 +1873,7 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
 		 * against, but shall be handled.
 		 */
 		M0_ASSERT(!m0_ext_is_empty(&seg->ee_ext));
-		M0_ASSERT(M0_IN(seg->ee_val, (M0_CLRES_INVALID,
-					      M0_CLRES_VALID,
+		M0_ASSERT(M0_IN(seg->ee_val, (M0_CLRES_INVALID, M0_CLRES_VALID,
 					      M0_CLRES_FLATTENING)));
 
 		if (seg->ee_val != M0_CLRES_INVALID) {
@@ -1936,7 +1881,7 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
 			break;
 		}
 
-		if (i > 1)
+		if (i > 0)
 			--i;
 		else
 			break;
@@ -1951,7 +1896,6 @@ M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
 		*sublayout = layer->clr_l;
 		rc = 0;
 	} else
-		//todo shall return layer 0?
 		rc = -ENOENT;
 
 	m0_mutex_unlock(&cl->cl_base.l_lock);
diff --git a/layout/composite.h b/layout/composite.h
index 1726ea2..9f19656 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -26,30 +26,35 @@
 /**
  * @defgroup composite Composite Layout Type.
  *
- * Composite layout is made up of multiple layers.
+ * A composite layout consists of a sequence of "sub-layouts". With each
+ * sub-layout is associated a "mask", which is a collection of extents in file
+ * offset space. A sublayout and its associated mask are collectively called
+ * as a layer.
  *
- * Each layer except the zeroth one, constitutes of a sublayout and a list of
- * extents associated with that layer.
+ * To apply a composite layout to a particular offset, the sequence of layouts
+ * is scanned from top to bottom, until the first sub-layout containing the
+ * given offset in its mask is found. This sub-layout is applied to the offset.
  *
- * Zeroth layer is a special layer which contains a sublayout that in fact is
- * the old layout. Zeroth layer does not contain any list of extents.
+ * A new sub-layout with a given mask can be added at the top of the sequence.
+ * The mask of the top-most sub-layout can be enlarged.
  *
- * By default, a composite layout is created with the zeroth layer being
- * mandatory part of it. And typically, one layer gets added to the composite
- * layout with each failure.
+ * A "flattening" operation (to be implemented in the future) merges 2 topmost
+ * layouts into one.
  *
  * Composite Layout Use Case Example - NBA
- * 1) Revoke old layout from all the clients.
- * 2) Send a new composite layout.
+ * 1) The zeroth layer points to the old layout and one layer gets added with
+ *    each failure encountered.
+ * 2) When a failure occurs, the server revokes the old layout from all the
+ *    clients.
+ * 3) The server send a new composite layout.
  *    (i)  New writes are directed into new sublayouts, extents are associated
  *         with the new sublayout as they are writtent to.
  *    (ii) Reads from not-yet-migrated will be directed to old sublayout.
  * 4) Recoverable data is migrated from old server to new.
- * 5) Eventually, “layout flattening” will be invoked that will convert
- *    composite layouts to new non-composite layouts. (Future)
+ * 5) Eventually, flattening operation will convert composite layouts to new
+ *    non-composite layouts.
  *
- * @todo Understanding is that the extents owned by various layers are
- * exclusive of each other. Shall this be enforced through the invariants?
+ * Composite Layout Use Case Example - Small file on flash - todo
  *
  * @{
  */
@@ -109,7 +114,7 @@ struct m0_composite_layer {
 	 * Linkage used for maintaining a list of the layers owned by a
 	 * particular composite layout.
 	 */
-	struct m0_tlink   clr_list_linkage;
+	struct m0_tlink   clr_linkage;
 };
 
 /**
@@ -157,10 +162,7 @@ enum m0_composite_layer_ext_state {
 	M0_CLRES_FLATTENING
 };
 
-/**
- * Extent that is part of 'a layer of a composite layout'. Any layer except
- * the zeroth one contains list of such extents.
- */
+/** Extent that is part of 'a layer of a composite layout'. */
 struct m0_composite_layer_extent {
 	/** Extent being represented. */
 	struct m0_ext    cle_ext;
@@ -178,7 +180,7 @@ struct m0_composite_layer_extent {
 	 * Linkage used for maintaining a list of the extents owned by a
 	 * particular layer.
 	 */
-	struct m0_tlink  cle_list_linkage;
+	struct m0_tlink  cle_linkage;
 };
 
 M0_TL_DECLARE(m0_composite_layer_ext, M0_INTERNAL,
@@ -198,8 +200,8 @@ struct m0_composite_instance {
 
 /**
  * Allocates and builds a layout object with the composite layout type,
- * by setting its initial ref count to 1. It contains zeroth layer by
- * default that 'points to the supplied old layout and contains no extents'.
+ * by setting its initial ref count to 1. It contains the zeroth layer by
+ * default that 'points to the supplied sublayout and extent list'.
  *
  * Multiple layers can be subsequently added to this layout, by explicitly
  * using the API m0_composite_layer_add().
@@ -215,11 +217,13 @@ struct m0_composite_instance {
  * Dual to m0_layout_put() when it is the last reference being released.
  *
  * @note Until the time layout is integrated with RM, it is the responsibilty
- * of the user to ensure that the lid is unique.
+ * of the user to ensure that the supplied lid is unique.
  */
 M0_INTERNAL int m0_composite_build(struct m0_layout_domain *dom,
 				   uint64_t lid,
-				   struct m0_layout *old_layout,
+				   struct m0_layout *oldlayout,
+				   struct m0_tl *extlist,
+				   uint32_t ext_nr,
 				   struct m0_composite_layout **out);
 
 /**
@@ -239,41 +243,29 @@ M0_INTERNAL int m0_composite_build(struct m0_layout_domain *dom,
  */
 M0_INTERNAL int m0_composite_layer_add(struct m0_composite_layout *cl,
 				       struct m0_layout *sublayout,
-				       const struct m0_tl *extlist,
+				       struct m0_tl *extlist,
 				       uint32_t ext_nr,
 				       struct m0_db_tx *tx);
 
 /**
  * Looks up for the layer that owns the extent containing the supplied
- * offset. Also, returns the state of the extent and the sublayout owned by
- * the specific layer.
+ * offset. Also, returns 'the state of the extent' and 'the sublayout owned by
+ * the specific layer'.
  *
- * @param offset In paramemer to specify the offset to be looked up.
- * @param layer_idx Out parameter to report back the layer the extent belongs
+ * @param offset 'In' paramemer to specify the offset to be looked up.
+ * @param layer_idx 'Out' parameter to report back the layer the extent belongs
  * to.
- * @param ext Out parameter to report back the extent the offset belongs to.
- * @param ext_state Out parameter to report back the state of the extent being
- * returned.
- * @param sublayout Out parameter to report back the sublayout owned by the
+ * @param ext 'Out' parameter to report back the extent the offset belongs to.
+ * @param ext_state 'Out' parameter to report back the state of the extent
+ * being returned.
+ * @param sublayout 'Out' parameter to report back the sublayout owned by the
  * layer being returned.
  *
- * The lookup starts with the top-most layer and goes upto the first layer.
- * If the extent containing the offset is not found upto the first layer, then
- * (the layer id of) the zeroth layer is returned. Zeroth layer does not
- * have any extents associated with it.
+ * The lookup starts with the top-most layer and goes upto the bottom-most
+ * layer. If an extent containing the offset is not found upto the bottom-most
+ * layer, then the error ENOENT is returned.
  *
- * @todo
- * 1) There are no extents associated with the zeroth layer. In case an offset
- *    is not found with any of the layers, should the layer zero be reported
- *    back (so that the user can start referring to the sublayout associated
- *    with the layer zero, for that offset)?
- * 2) This API is planned to return the sublayout right away so that the
- *    user does not have to send another query to fetch the sublayout. Does
- *    that seem fine?
- * 3) This API currently directly looks up into the DB using the readily
- *    available m0_emap_lookup(). Is it ok OR it should be changed to look up
- *    into the in-memory list of the extents? In other words, is this API
- *    required for the kernel space code?
+ * @todo Change to look up into the in-memory list first
  */
 M0_INTERNAL int m0_composite_layer_ext_lookup(struct m0_composite_layout *cl,
 					      m0_bindex_t offset,
diff --git a/layout/layout.c b/layout/layout.c
index 67c9f98..bf19a07 100644
--- a/layout/layout.c
+++ b/layout/layout.c
@@ -128,7 +128,7 @@ static const struct m0_bob_type layout_instance_bob = {
 M0_BOB_DEFINE(static, &layout_instance_bob, m0_layout_instance);
 
 M0_TL_DESCR_DEFINE(layout, "layout-list", static,
-		   struct m0_layout, l_list_linkage, l_magic,
+		   struct m0_layout, l_linkage, l_magic,
 		   M0_LAYOUT_MAGIC, LAYOUT_LIST_HEAD_MAGIC);
 M0_TL_DEFINE(layout, static, struct m0_layout);
 
diff --git a/layout/layout.h b/layout/layout.h
index 5164415..591499a 100644
--- a/layout/layout.h
+++ b/layout/layout.h
@@ -238,7 +238,7 @@ struct m0_layout {
 	 * Linkage used for maintaining list of the layout objects stored in
 	 * the m0_layout_domain object.
 	 */
-	struct m0_tlink              l_list_linkage;
+	struct m0_tlink              l_linkage;
 };
 
 struct m0_layout_ops {
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index 7e29eeb..ffc755b 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -237,28 +237,23 @@ static void composite_layout_verify(struct m0_layout *l,
 		M0_UT_ASSERT(layer->clr_l->l_user_count == 1);
 		M0_UT_ASSERT(layer->clr_idx == i);
 
-		if (layer->clr_idx == 0) {
-			M0_UT_ASSERT(layer->clr_extents_nr == 0);
-			M0_UT_ASSERT(layer->clr_extents == NULL);
-		} else {
-			M0_UT_ASSERT(layer->clr_extents_nr == extents_nr);
-
-			/* Verify the extents. */
-			j = 0;
-			delta = (approximate_end_offset - min_start_offset) /
-				(extents_nr * multiplier);
-			m0_tl_for(m0_composite_layer_ext, layer->clr_extents,
-				  extent) {
-				M0_UT_ASSERT(extent->cle_ext.e_start ==
-					     min_start_offset +
-					     (multiplier * j * delta));
-				M0_UT_ASSERT(extent->cle_ext.e_end ==
-					     extent->cle_ext.e_start + delta);
-				++j;
-			} m0_tl_endfor;
-			M0_UT_ASSERT(j == extents_nr);
-			//todo Enable once m0_emap_paste works  ++extents_nr;
-		}
+		M0_UT_ASSERT(layer->clr_extents_nr == extents_nr);
+
+		/* Verify the extents. */
+		j = 0;
+		delta = (approximate_end_offset - min_start_offset) /
+			(extents_nr * multiplier);
+		m0_tl_for(m0_composite_layer_ext, layer->clr_extents,
+			  extent) {
+			M0_UT_ASSERT(extent->cle_ext.e_start ==
+				     min_start_offset +
+				     (multiplier * j * delta));
+			M0_UT_ASSERT(extent->cle_ext.e_end ==
+				     extent->cle_ext.e_start + delta);
+			++j;
+		} m0_tl_endfor;
+		M0_UT_ASSERT(j == extents_nr);
+		//todo Enable once m0_emap_paste works  ++extents_nr;
 		++i;
         } m0_tl_endfor;
 }
@@ -266,21 +261,33 @@ static void composite_layout_verify(struct m0_layout *l,
 /* Builds a layout object with COMPOSITE layout type. */
 static int composite_build(uint64_t lid,
 			   struct m0_layout_domain *domain,
+			   uint32_t min_extents_nr,
+			   m0_bindex_t min_start_offset,
+			   m0_bindex_t approximate_end_offset,
+			   bool if_contiguous_extents,
 			   struct m0_composite_layout **cl,
 			   bool failure_test)
 {
-	struct m0_layout *l_from_cl;
 	struct m0_layout *sublayout;
 	uint64_t          sublayout_id;
+	struct m0_tl     *extents;
+	struct m0_layout *l_from_cl;
 
 	/* Pre-create the sublayout to be used as the original layout. */
 	sublayout_id = lid * 100;
 	sublayout_build(sublayout_id, domain, &sublayout);
 
+	/* Build an extent list to be associated with the sublayout. */
+	extentlist_build(&extents, min_extents_nr,
+			 min_start_offset, approximate_end_offset,
+			 if_contiguous_extents);
+
 	/* Build a composite layout. */
-	rc = m0_composite_build(domain, lid, sublayout, cl);
+	rc = m0_composite_build(domain, lid, sublayout,
+				extents, min_extents_nr, cl);
 	if (failure_test) {
 		M0_UT_ASSERT(rc == -ENOMEM);
+		//todo shall get rid of the extentlist built
 		sublayout_delete(domain, sublayout_id);
 		return rc;
 	}
@@ -291,8 +298,9 @@ static int composite_build(uint64_t lid,
 	M0_UT_ASSERT(l_from_cl == &(*cl)->cl_base);
 
 	/* Verify the composite layout object contents. */
-	composite_layout_verify(l_from_cl, lid, 1, 0, 0, 0,
-				!CONTIGUOUS_EXTENTS);
+	composite_layout_verify(l_from_cl, lid, 1, min_extents_nr,
+				min_start_offset, approximate_end_offset,
+				if_contiguous_extents);
 	return 0;
 }
 
@@ -338,6 +346,7 @@ static int composite_layers_add(struct m0_composite_layout *cl,
 					    tx);
 		if (layer_add_failure_test) {
 			M0_UT_ASSERT(rc == L_TABLE_INSERT_ERR);
+			//todo get rid of extentlist build and sublayout precr
 			break;
 		} else
 			M0_UT_ASSERT(rc == 0);
@@ -373,7 +382,9 @@ static int composite_build_and_layers_add(uint64_t lid,
 {
 	M0_UT_ASSERT(cl != NULL);
 
-	rc = composite_build(lid, domain, cl, !FAILURE_TEST);
+	rc = composite_build(lid, domain, min_extents_nr,
+			     min_start_offset, approximate_end_offset,
+			     if_contiguous_extents, cl, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	rc = composite_layers_add(*cl, tx, layers_nr, min_extents_nr,
@@ -504,17 +515,11 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 
 		layer_header.clh_lid = sublayout_id;
 		layer_header.clh_idx = i;
-		if (i == 0)
-			layer_header.clh_extents_nr = 0;
-		else
-			layer_header.clh_extents_nr = extents_nr;
+		layer_header.clh_extents_nr = extents_nr;
 		nbytes = m0_bufvec_cursor_copyto(dcur, &layer_header,
 						 sizeof layer_header);
 		M0_ASSERT(nbytes == sizeof layer_header);
 
-		if (i == 0) /* Zeroth layer does not contain any extents. */
-			continue;
-
 		delta = (approximate_end_offset - min_start_offset) /
 			(extents_nr * multiplier);
 #if 0
@@ -664,15 +669,7 @@ static void composite_layout_buf_verify(uint64_t lid,
 		m0_bufvec_cursor_move(cur, sizeof *layer_header);
 		M0_UT_ASSERT(layer_header->clh_lid == lid * 100 + i);
 		M0_UT_ASSERT(layer_header->clh_idx == i);
-		if (i == 0) /* Zeroth layer. */
-			M0_UT_ASSERT(layer_header->clh_extents_nr == 0);
-		else
-			M0_UT_ASSERT(layer_header->clh_extents_nr ==
-				     extents_nr);
-
-		if (i == 0) /* Zeroth layer does not contain any extents. */
-			continue;
-
+		M0_UT_ASSERT(layer_header->clh_extents_nr == extents_nr);
 		M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >=
 			     layer_header->clh_extents_nr * sizeof ext);
 		delta = (approximate_end_offset - min_start_offset) /
@@ -922,23 +919,19 @@ static void composite_layout_compare(const struct m0_layout *l1,
 	m0_tl_for(comp_layer, cl1->cl_layers, layer1) {
 		M0_UT_ASSERT(layer1->clr_l == layer2->clr_l);
 		M0_UT_ASSERT(layer1->clr_extents_nr == layer2->clr_extents_nr);
-		/* Zeroth layer does not contain any extents. */
-		if (layer1->clr_idx > 0) {
-			extent2 = m0_composite_layer_ext_tlist_head(
+		extent2 = m0_composite_layer_ext_tlist_head(
 							layer2->clr_extents);
-			m0_tl_for(m0_composite_layer_ext, layer1->clr_extents,
-				  extent1) {
-				M0_UT_ASSERT(extent1->cle_ext.e_start ==
-					     extent2->cle_ext.e_start);
-				M0_UT_ASSERT(extent1->cle_ext.e_end ==
-					     extent2->cle_ext.e_end);
-				M0_UT_ASSERT(extent1->cle_state ==
-					     extent2->cle_state);
-				extent2 = m0_composite_layer_ext_tlist_next(
+		m0_tl_for(m0_composite_layer_ext, layer1->clr_extents,
+			  extent1) {
+			M0_UT_ASSERT(extent1->cle_ext.e_start ==
+				     extent2->cle_ext.e_start);
+			M0_UT_ASSERT(extent1->cle_ext.e_end ==
+				     extent2->cle_ext.e_end);
+			M0_UT_ASSERT(extent1->cle_state == extent2->cle_state);
+			extent2 = m0_composite_layer_ext_tlist_next(
 							layer2->clr_extents,
 							extent2);
-			} m0_tl_endfor;
-		}
+		} m0_tl_endfor;
 		layer2 = comp_layer_tlist_next(cl2->cl_layers, layer2);
 	} m0_tl_endfor;
 }
@@ -979,27 +972,20 @@ static void composite_layout_copy(const struct m0_layout *l_src,
 		layer_dest->clr_idx = layer_src->clr_idx;
 		layer_dest->clr_extents_nr = layer_src->clr_extents_nr;
 
-		if (layer_src->clr_idx == 0) {
-			/* Zeroth layer does not contain any extents. */
-			M0_UT_ASSERT(layer_src->clr_extents == NULL);
-			layer_dest->clr_extents = layer_src->clr_extents;
-		} else {
-			M0_ALLOC_PTR(layer_dest->clr_extents);
-			M0_UT_ASSERT(layer_dest->clr_extents != NULL);
-			m0_composite_layer_ext_tlist_init(
-						layer_dest->clr_extents);
-
-			m0_tl_for(m0_composite_layer_ext,
-				  layer_src->clr_extents, extent_src) {
-				M0_ALLOC_PTR(extent_dest);
-				M0_UT_ASSERT(extent_dest != NULL);
-				extent_dest->cle_ext = extent_src->cle_ext;
-				extent_dest->cle_state = extent_src->cle_state;
-				m0_composite_layer_ext_tlink_init_at_tail(
+		M0_ALLOC_PTR(layer_dest->clr_extents);
+		M0_UT_ASSERT(layer_dest->clr_extents != NULL);
+		m0_composite_layer_ext_tlist_init(layer_dest->clr_extents);
+
+		m0_tl_for(m0_composite_layer_ext, layer_src->clr_extents,
+			  extent_src) {
+			M0_ALLOC_PTR(extent_dest);
+			M0_UT_ASSERT(extent_dest != NULL);
+			extent_dest->cle_ext = extent_src->cle_ext;
+			extent_dest->cle_state = extent_src->cle_state;
+			m0_composite_layer_ext_tlink_init_at_tail(
 						extent_dest,
 						layer_dest->clr_extents);
-			} m0_tl_endfor;
-		}
+		} m0_tl_endfor;
 		comp_layer_tlink_init_at_tail(layer_dest, cl_dest->cl_layers);
 	} m0_tl_endfor;
 
@@ -1016,16 +1002,12 @@ static void composite_layout_copy_delete(struct m0_layout *l)
 
 	cl = container_of(l, struct m0_composite_layout, cl_base);
 	m0_tl_for(comp_layer, cl->cl_layers, layer) {
-		/* Zeroth layer does not contain any extents. */
-		if (layer->clr_idx > 0) {
-			m0_tl_for(m0_composite_layer_ext, layer->clr_extents,
-				  extent) {
-				m0_composite_layer_ext_tlist_del(extent);
-				m0_composite_layer_ext_tlink_fini(extent);
-				m0_free(extent);
-			} m0_tl_endfor;
-			m0_free(layer->clr_extents);
-		}
+		m0_tl_for(m0_composite_layer_ext, layer->clr_extents, extent) {
+			m0_composite_layer_ext_tlist_del(extent);
+			m0_composite_layer_ext_tlink_fini(extent);
+			m0_free(extent);
+		} m0_tl_endfor;
+		m0_free(layer->clr_extents);
 		comp_layer_tlist_del(layer);
 		comp_layer_tlink_fini(layer);
 		m0_free(layer);
@@ -1275,7 +1257,9 @@ int test_add_composite(uint64_t lid,
 	allocate_area(domain, ADDITIONAL_BYTES_NONE, &num_bytes, &area);
 
 	/* Build a layout object. */
-	rc = composite_build(lid, domain, &cl, !FAILURE_TEST);
+	rc = composite_build(lid, domain, min_extents_nr,
+			     min_start_offset, approximate_end_offset,
+			     if_contiguous_extents, &cl, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	/* Add the layout object to the DB. */
@@ -1364,7 +1348,9 @@ int test_delete_composite(uint64_t lid,
 	allocate_area(domain, ADDITIONAL_BYTES_NONE, &num_bytes, &area);
 
 	/* Build a layout object. */
-	rc = composite_build(lid, domain, &cl, !FAILURE_TEST);
+	rc = composite_build(lid, domain, min_extents_nr,
+			     min_start_offset, approximate_end_offset,
+			     if_contiguous_extents, &cl, !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 	M0_UT_ASSERT(list_lookup(domain, lid) == &cl->cl_base);
 
@@ -1408,8 +1394,6 @@ int test_delete_composite(uint64_t lid,
 	rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
 	M0_UT_ASSERT(rc == 0);
 	m0_tl_for(comp_layer, cl->cl_layers, layer) {
-		if (layer->clr_idx == 0)
-			continue;
 		m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
 			rc = m0_composite_layer_ext_delete(cl,
 							   layer->clr_idx,
-- 
1.8.3.2

