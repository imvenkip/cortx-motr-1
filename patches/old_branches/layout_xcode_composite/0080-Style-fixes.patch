From ae0032b4be22af5b17c60be15546df7bc68bb456 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Sun, 10 Mar 2013 18:54:28 +0530
Subject: [PATCH 080/157] Style fixes

---
 layout/composite.c          | 14 ++++++--------
 layout/composite.h          |  5 +++--
 layout/composite_internal.h |  5 ++++-
 layout/layout.c             |  7 ++-----
 layout/layout.h             |  8 ++++----
 layout/layout_db.c          | 11 +++++++----
 layout/layout_db.h          |  2 +-
 lib/tlist.c                 |  6 +++---
 8 files changed, 30 insertions(+), 28 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index aa66dd3..3840022 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -138,8 +138,8 @@ struct layout_prefix {
 	/**
 	 * Filler since prefix shall be a 128 bit field; currently un-used.
 	 *
-	 * @todo It looks like even when the layout id is extended to be 128
-	 * bit, only the 64 bits which will identify the layout identifier may
+	 * @todo Even when the layout id is extended to be 128 bit, only the
+	 * first 64 bits which will identify the layout identifier may
 	 * be stored in the prefix thus excluding the lid part which will
 	 * identify the layout type.
 	 */
@@ -799,7 +799,7 @@ static struct m0_layout *layout_find(struct m0_layout_domain *dom,
 	 * @todo Eventually, if the sublayout is not found in the cache, it
 	 * shall be fetched either from the DB or over the network, as
 	 * applicable.
-	 * This requiress:
+	 * This requires:
 	 * - The m0_layout_domain to include a flag indicating if the network
 	 *   is available viz. ld_is_network_available along with the flag
 	 *   ld_is_db_available that is being added through the current patch,
@@ -829,7 +829,7 @@ static int extlist_inbuf_read(struct m0_composite_layout *cl,
 	struct m0_ext *ext;
 	uint64_t      *ext_state;
 	uint32_t       i;
-	int            rc;
+	int            rc = 0;
 
 	M0_PRE(m0_bufvec_cursor_step(cur) >= extents_nr * sizeof *ext);
 
@@ -837,7 +837,6 @@ static int extlist_inbuf_read(struct m0_composite_layout *cl,
 		 (unsigned long long)cl->cl_base.l_id,
 		 (unsigned long)extents_nr);
 	m0_composite_layer_ext_tlist_init(extlist);
-	rc = 0;
 	for (i = 0; i < extents_nr; ++i) {
 		ext = m0_bufvec_cursor_addr(cur);
 		m0_bufvec_cursor_move(cur, sizeof *ext);
@@ -2719,9 +2718,8 @@ static int single_ext_indb_write(struct m0_emap_cursor *it,
 	}
 	ext.e_start = 0;
 	ext.e_end = M0_BINDEX_MAX + 1;
-	rc = ext_indb_write_internal(it, layer, &ext, M0_CLRES_INVALID,
-				     !INMEM_LIST_UPDATE);
-	return rc;
+	return ext_indb_write_internal(it, layer, &ext, M0_CLRES_INVALID,
+				       !INMEM_LIST_UPDATE);
 }
 
 static int layer_delete_verify(struct m0_composite_layout *cl,
diff --git a/layout/composite.h b/layout/composite.h
index 30e029b..508c68e 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -60,8 +60,9 @@
  *        - The zeroth layer points to the old layout and one layer gets added
  *          with each failure encountered.
  *    (2) New writes are directed into new sub-layouts, extents are
- *        associated with the new sub-layout as they are writtent to.
- *    (3) Reads from not-yet-migrated will be directed to the old sublayout.
+ *        associated with the new sub-layout as they are written to.
+ *    (3) Reads from not-yet-migrated data will be directed to the old
+ *        sublayout.
  *    (4) Recoverable data is migrated from the old server to the new one.
  *    (5) Eventually, flattening operation will convert composite layouts to
  *       new non-composite layouts.
diff --git a/layout/composite_internal.h b/layout/composite_internal.h
index fb71add..f129d49 100644
--- a/layout/composite_internal.h
+++ b/layout/composite_internal.h
@@ -69,7 +69,10 @@ struct composite_layer_header {
 	/** Index of this layer into its owner composite layout. */
 	uint32_t clh_idx;
 
-	/** Number of extents belonging to this layer. */
+	/**
+	 * Number of extents belonging to the layer corresponding to this
+	 * header.
+	 */
 	uint32_t clh_extents_nr;
 
 	/** Padding to make the structure 8 bytes aligned. */
diff --git a/layout/layout.c b/layout/layout.c
index 6efdeda..892dc3f 100644
--- a/layout/layout.c
+++ b/layout/layout.c
@@ -1163,11 +1163,8 @@ M0_INTERNAL struct m0_layout_enum *m0_layout_instance_to_enum(
 					const struct m0_layout_instance *li)
 {
 	M0_PRE(m0_layout__instance_invariant(li));
-
-	if (li->li_ops->lio_to_enum != NULL)
-		return li->li_ops->lio_to_enum(li);
-	else
-		return NULL;
+	return li->li_ops->lio_to_enum == NULL ? NULL :
+		li->li_ops->lio_to_enum(li);
 }
 
 M0_INTERNAL uint32_t m0_layout_enum_find(const struct m0_layout_enum *e,
diff --git a/layout/layout.h b/layout/layout.h
index 4ddda39..308a300 100644
--- a/layout/layout.h
+++ b/layout/layout.h
@@ -87,7 +87,7 @@
  * - A layout can be assigned to a file both by the server and the client.
  *
  * @section layout-operations-sequence Sequence Of Layout Operation
- * The sequence of operation related to domain initialisation/finalisation,
+ * The sequence of operations related to domain initialisation/finalisation,
  * layout type and enum type registration and unregistration is as follows:
  * - Initialise m0_layout_domain object.
  * - Register layout types and enum types using
@@ -830,7 +830,7 @@ M0_INTERNAL void m0_layout_user_count_dec(struct m0_layout *l);
  *   M0_LXO_DB_LOOKUP.
  *
  * @post Layout object is fully built (along with enumeration object being
- * built if applicable) along with its ref count being initialised to 1. User
+ * built, if applicable) along with its ref count being initialised to 1. User
  * needs to explicitly release this reference so as to delete this in-memory
  * layout.
  * - ergo(rc == 0, m0_layout__invariant(l))
@@ -901,8 +901,8 @@ M0_INTERNAL m0_bcount_t m0_layout_max_recsize(
 
 /**
  * @todo Addition of m0_layout_size() API and cleanup around recsize related
- * APIs/functions. m0_layout_max_recsize() will probably not be required to be
- * exposed once m0_layout_size() is added.
+ * APIs/functions. m0_layout_max_recsize() may not be required to be exposed
+ * once m0_layout_size() is added.
  * This item will be cleared with the subsequent task to add
  * 'the composite layout type support to getattr'.
  */
diff --git a/layout/layout_db.c b/layout/layout_db.c
index c61b0b6..c49a362 100644
--- a/layout/layout_db.c
+++ b/layout/layout_db.c
@@ -247,12 +247,15 @@
  * specific layer from a specific composite layout. The lower 32 bits are
  * currently unused (fillers).
  *
- * The comp_layout_layer_emap table stores the segments from all the layers
+ * The comp_layout_layer_emap table stores all the segments covering the
+ * complete offset space viz. [0, M0_BINDEX_MAX] for all the layers
  * from all the composite layouts.
  * These segments are stored in the form of ([A, B), V) where:
- * - A is the start offset from a layer
- * - B is the end offset from that layer
- * - V is the state of the segment indicating whether the extent is valid.
+ * - A is the start offset for a segment from a layer
+ * - B is the end offset for that segment
+ * - V is the state of the segment indicating whether the extent is valid,
+ *   with one of the value from the enum m0_composite_layer_ext_state.
+ * @see extmap.h for more details on the extmap.
  *
  * An example:
  *
diff --git a/layout/layout_db.h b/layout/layout_db.h
index 57ed1b4..7b6d7e8 100644
--- a/layout/layout_db.h
+++ b/layout/layout_db.h
@@ -127,7 +127,7 @@ int m0_layout_delete(struct m0_layout *l, struct m0_db_tx *tx, struct m0_db_pair
  * - In case of successful return, an additional reference is acquired on
  *   the layout object returned in the variable "out".
  *
- * @todo Extend layout id to 128 bit to store layout type as well so that the
+ * @todo Extend layout id to 128 bit, to store layout type as well so that the
  * layout type will not be required to be sent as an argument to this API.
  * This item will be cleared with the subsequent task to add
  * 'the composite layout type support to getattr'.
diff --git a/lib/tlist.c b/lib/tlist.c
index dd589bb..a6ffd54 100644
--- a/lib/tlist.c
+++ b/lib/tlist.c
@@ -119,9 +119,9 @@ M0_INTERNAL size_t m0_tlist_length(const struct m0_tl_descr *d,
 }
 M0_EXPORTED(m0_tlist_length);
 
-M0_INTERNAL void  m0_tlist_splice(const struct m0_tl_descr *d,
-				  struct m0_tl *list,
-				  const struct m0_tl *list_to_add)
+M0_INTERNAL void m0_tlist_splice(const struct m0_tl_descr *d,
+				 struct m0_tl *list,
+				 const struct m0_tl *list_to_add)
 {
 	M0_INVARIANT_EX(m0_tlist_invariant(d, list));
 	M0_INVARIANT_EX(m0_tlist_invariant(d, list_to_add));
-- 
1.8.3.2

