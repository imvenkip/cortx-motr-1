From 97c5ff200f08f95481099085d7160b642cbf2ccc Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Thu, 27 Dec 2012 22:30:51 +0530
Subject: [PATCH 035/157] Updating a few comments, adding some TCs

---
 layout/composite.c    |  28 ++++++++------
 layout/composite.h    |  21 +++++++++--
 layout/ut/composite.c |  74 +++++++++++++++++++++++++-----------
 layout/ut/layout.c    | 102 ++++++++++++++++++++++++++++++++++++++++++--------
 4 files changed, 173 insertions(+), 52 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index cd78a54..fc0b562 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -207,7 +207,7 @@ static bool composite_invariant(const struct m0_composite_layout *cl)
 		cl->cl_layers_nr == m0_layer_tlist_length(cl->cl_layers) &&
 		m0_tl_forall(m0_layer, layer, cl->cl_layers,
 			     m0_layout__invariant(layer->clr_l) &&
-			     layer->clr_idx == i++ && //todo rm
+			     layer->clr_idx == i++ &&
 			     ergo(layer->clr_idx == 0,
 				  layer->clr_extents_nr == 0 &&
 				  layer->clr_extents == NULL) &&
@@ -571,7 +571,7 @@ static int extent_in_memory_add(struct m0_composite_layer *layer,
 		m0_layer_extent_tlist_add_before(ext_to_insert_before,
 						 extent_to_insert);
 	++layer->clr_extents_nr;
-	return 0; //todo void ??
+	return 0;
 }
 
 static int extent_in_memory_delete(struct m0_composite_layer *layer,
@@ -582,7 +582,6 @@ static int extent_in_memory_delete(struct m0_composite_layer *layer,
 	bool                              ext1_found;
 	struct m0_composite_layer_extent *extent;
 
-	/* todo refactor the code with extent_in_memory_add() */
 	ext1_found = false;
 	m0_tl_for(m0_layer_extent, layer->clr_extents, extent) {
 		if (ext->e_start > extent->cle_ext.e_end)
@@ -613,7 +612,8 @@ static int extent_in_memory_delete(struct m0_composite_layer *layer,
 //todo Check probably new_state is not req'd as an arg
 static int extent_in_memory_find(struct m0_composite_layer *layer,
 				 const struct m0_ext *ext,
-				 enum m0_composite_layer_ext_state new_state,
+				 enum m0_composite_layer_ext_state
+					expected_state,
 				 struct m0_composite_layer_extent **lr_ext)
 {
 	struct m0_composite_layer_extent *extent;
@@ -624,7 +624,7 @@ static int extent_in_memory_find(struct m0_composite_layer *layer,
 			continue;
 		else if (extent->cle_ext.e_start == ext->e_start &&
 			 extent->cle_ext.e_end == ext->e_end) {
-			M0_ASSERT(extent->cle_state == new_state);
+			M0_ASSERT(extent->cle_state == expected_state);
 			extent_found = true;
 			break;
 		}
@@ -719,7 +719,7 @@ static int ext_inmemory_adjust(struct m0_composite_layer *layer,
 static int extent_in_db_write(struct m0_emap_cursor *it,
 			      struct m0_composite_layer *layer,
 			      const struct m0_ext *ext_to_add,
-			      uint64_t estate,
+			      uint64_t ext_new_state,
 			      bool inmemory_list_update)
 {
 #ifndef __KERNEL__
@@ -770,7 +770,7 @@ static int extent_in_db_write(struct m0_emap_cursor *it,
 	 *
 	 * The sequence goes as follows:
 	 * 1) From the extent [2200700, 56668025), its left part that is
-	 *    [[2200700, 56668023) is retained, using the extent_op CUT_LEFT.
+	 *    [2200700, 56668023) is retained, using the extent_op CUT_LEFT.
 	 * 2) From the extent list, the extent [56668025, 111135350) is
 	 *    deleted using the extent_op DELETE.
 	 * 3) From the extent list, the extent [111135350, 165602675) is
@@ -781,7 +781,7 @@ static int extent_in_db_write(struct m0_emap_cursor *it,
 	 *    [56668023, 165602677) is added into the in-memory list of the
 	 *    extents.
 	 *
-	 * When initial list of extents is added to some layer, the list is
+	 * When initial list of the extents is added to some layer, the list is
 	 * expected to be non-overlapping. And in that case, the list is first
 	 * stored into the in-memory list of the extents and then it is asked
 	 * to be adjusted in the DB version of it, using m0_emap_paste here.
@@ -793,7 +793,7 @@ static int extent_in_db_write(struct m0_emap_cursor *it,
 
 	ext = *ext_to_add;
 	rc_cb = 0;
-	rc = m0_emap_paste(it, &ext, estate,
+	rc = m0_emap_paste(it, &ext, ext_new_state,
 		LAMBDA(void, (struct m0_emap_seg *seg) {
 			/* Extent deletion. */
 			if (inmemory_list_update) {
@@ -835,7 +835,8 @@ static int extent_in_db_write(struct m0_emap_cursor *it,
 
 	rc = rc ?: rc_cb;
 
-	if (rc == 0 && inmemory_list_update && estate != M0_CLRES_INVALID) {
+	if (rc == 0 && inmemory_list_update &&
+	    ext_new_state != M0_CLRES_INVALID) {
 		/*
 		 * Now that the deletion of the extents applicable from the
 		 * in-memory list of the extents has been handled through the
@@ -846,9 +847,11 @@ static int extent_in_db_write(struct m0_emap_cursor *it,
 		 * the in-memory list of the extents. Hence, the latter
 		 * condition above.
 		 */
-		rc = extent_in_memory_find(layer, ext_to_add, estate, NULL);
+		rc = extent_in_memory_find(layer, ext_to_add,
+					   ext_new_state, NULL);
 		if (rc == -ENOENT) {
-			rc = extent_in_memory_add(layer, ext_to_add, estate);
+			rc = extent_in_memory_add(layer, ext_to_add,
+						  ext_new_state);
 			M0_ASSERT(rc == 0); //todo handle
 		}
 	}
@@ -1541,6 +1544,7 @@ int m0_composite_layer_ext_lookup(const struct m0_composite_layout *cl,
 		*sublayout = layer->clr_l;
 		rc = 0;
 	} else
+		//todo shall return layer 0?
 		rc = -ENOENT;
 
 	return rc;
diff --git a/layout/composite.h b/layout/composite.h
index d30a44e..494a164 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -229,9 +229,17 @@ int m0_composite_layer_add(struct m0_composite_layout *cl,
  * (the layer id of) the zeroth layer is returned. Zeroth layer does not
  * have any extents associated with it.
  *
- * @todo This API currently directly looks up into the DB using the readily
- * available m0_emap_lookup(). Is it ok OR it should be changed to look up
- * into the in-memory list of the extents?
+ * @todo
+ * 1) There are no extents associated with the zeroth layer. In case an offset
+ *    is not found with any of the layers, should the layer zero be reported
+ *    back (so that the user can start referring to the sublayout associated
+ *    with the layer zero, for that offset)?
+ * 2) This API is planned to return the sublayout right away so that the
+ *    user does not have to send another query to fetch the sublayout. Does
+ *    that seem fine?
+ * 3) This API currently directly looks up into the DB using the readily
+ *    available m0_emap_lookup(). Is it ok OR it should be changed to look up
+ *    into the in-memory list of the extents?
  */
 int m0_composite_layer_ext_lookup(const struct m0_composite_layout *cl,
 				  m0_bindex_t offset,
@@ -259,6 +267,13 @@ int m0_composite_layer_ext_add(struct m0_composite_layout *cl,
 /**
  * Updates state of an extent owned by a specified layer of a specified
  * composite layout, by right away updating it in the DB.
+ *
+ * @todo Since user is not expected to update an existing extent but is
+ * expected to update state of an existing extent, this API is named as
+ * m0_composite_layer_ext_state_update() and not m0_composite_layer_update.
+ * Is that fine?
+ * (The existing extents are expected to be updated using
+ * m0_composite_layer_ext_add() and m0_composite_layer_ext_delete().)
  */
 int
 m0_composite_layer_ext_state_update(struct m0_composite_layout *cl,
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index 5bef81c..3040398 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -1426,8 +1426,8 @@ static void extent_to_be_operated(const struct m0_composite_layout *cl,
 		ext->e_end = ext_idx_plus_oneth.e_end;
 	} else if (kind_of_extent_to_add == OVERLAPPING_COMPLETE) {
 #if 1
-		ext->e_start = ext_idxth.e_start - 2;
-		ext->e_end = ext_idx_plus_oneth.e_end + 2;
+		ext->e_start = ext_idxth.e_start - 1;
+		ext->e_end = ext_idx_plus_oneth.e_end + 1;
 #endif
 #if 0
 		ext->e_start = ext_idxth.e_start - 1;
@@ -1447,12 +1447,7 @@ static void extent_to_be_operated(const struct m0_composite_layout *cl,
 
 }
 
-/* todo
- * Tests the APIs supported for layout object build and layout destruction
- * that happens using m0_layout_put(). Verifies that the newly built layout
- * object is added to the list of layout objects maintained in the domain
- * object and that m0_layout_find() returns the same object.
- */
+/* Tests the API for extent lookup. */
 int test_ext_lookup_composite(uint64_t lid,
 			      struct m0_layout_domain *domain,
 			      uint32_t layers_nr,
@@ -1508,10 +1503,18 @@ int test_ext_lookup_composite(uint64_t lid,
 	} else if (kind_of_extent_to_lookup == NON_EXISTING) {
 		M0_UT_ASSERT(rc == -ENOENT);
 		rc = 0;
+	} else {
+		M0_UT_ASSERT(rc == 0);
+		/*
+		 * While the extent list was set to be the same for each
+		 * layer initially, the following ensures that the extent is
+		 * found with the top-most layer. This shall change if the
+		 * extents lists are set to be exclusive of each other for each
+		 * layer.
+		 */
+		M0_UT_ASSERT(layer_idx == cl->cl_layers_nr - 1);
 	}
 
-	//todo Cover the other cases with kind_of_extent_to_lookup
-
 	/* Delete the composite layout object. */
 	m0_layout_put(&cl->cl_base);
 	M0_UT_ASSERT(m0_layout_find(domain, lid) == NULL);
@@ -1665,44 +1668,55 @@ int ext_operate(enum extent_op eop,
 		M0_UT_ASSERT(sublayout_lookup->l_id == lid * 100 +
 			     layer_id_lookup);
 	} else if (eop == EXTENT_UPDATE) {
+		/* todo Dec 27 Continue from here. */
 		M0_ASSERT(0);
 	} else if (eop == EXTENT_DELETE) {
-		rc = m0_composite_layer_ext_lookup(cl, ext_to_operate.e_start,
+		rc = m0_composite_layer_ext_lookup(cl,
+						   ext_to_operate.e_start + 1,
 						   &tx, &layer_id_lookup,
 						   &ext_lookup,
 						   &ext_state_lookup,
 						   &sublayout_lookup);
 		if (kind_of_extent_to_operate == NON_EXISTING ||
-		    kind_of_extent_to_operate == OVERLAPPING_RIGHT)
+		    (kind_of_extent_to_operate == OVERLAPPING_RIGHT &&
+		     !if_contiguous_extents))
 			M0_UT_ASSERT(rc == -ENOENT);
 		else
 			/* todo Other validation. */
 			M0_UT_ASSERT(rc == 0);
 
-		rc = m0_composite_layer_ext_delete(cl, 1, &ext_to_operate,
-						   &tx);
+		rc = m0_composite_layer_ext_delete(cl, cl->cl_layers_nr - 1,
+						   &ext_to_operate, &tx);
 		M0_UT_ASSERT(rc == 0);
 
-		rc = m0_composite_layer_ext_lookup(cl, ext_to_operate.e_start,
+		rc = m0_composite_layer_ext_lookup(cl,
+						   ext_to_operate.e_start + 1,
 						   &tx, &layer_id_lookup,
 						   &ext_lookup,
 						   &ext_state_lookup,
 						   &sublayout_lookup);
-		//todo devise the ext_del TCs more accurately
 		if (kind_of_extent_to_operate == NON_EXISTING ||
-		    kind_of_extent_to_operate == OVERLAPPING_RIGHT)
-		//todo ext_delete does not yet seem to be working
+		    (kind_of_extent_to_operate == OVERLAPPING_RIGHT &&
+		     !if_contiguous_extents))
 			M0_UT_ASSERT(rc == -ENOENT);
 		else {
-			/* todo Ideally shud get ENOENT for each case. */
+			/*
+			 * If a constraint is added that extents lists
+			 * for each layer are exclusive of each other, then,
+			 * ideally should get -ENOENT for each case. As of now,
+			 * the same extent is being found with the subsequent
+			 * layer.
+			 */
 			M0_UT_ASSERT(M0_IN(kind_of_extent_to_operate,
 					   (EXACT_EXISTING,
 					    OVERLAPPING_LEFT,
+					    OVERLAPPING_RIGHT,
 					    OVERLAPPING_COMPLETE)));
+
 			/* todo Other validation. */
 			M0_UT_ASSERT(rc == 0);
+			M0_UT_ASSERT(layer_id_lookup == cl->cl_layers_nr - 2);
 		}
-		//todo M0_UT_ASSERT(rc == -ENOENT);
 	}
 
 	rc_tmp = m0_db_tx_commit(&tx);
@@ -1711,7 +1725,6 @@ int ext_operate(enum extent_op eop,
 	composite_layout_copy(l, &l_copy_updated);
 
 	/* Verify the extent list in the in-memory layout. */
-	//todo Adjust these based on whether it is ADD or DELETE
 	if (kind_of_extent_to_operate == EXACT_EXISTING &&
 	    eop == EXTENT_ADD) {
 		composite_layout_compare(l_copy_orig, l_copy_updated, false);
@@ -1771,6 +1784,25 @@ int test_ext_add_composite(uint64_t lid,
 	return rc;
 }
 
+int test_ext_state_update_composite(uint64_t lid,
+				    struct m0_layout_domain *domain,
+				    uint32_t layers_nr,
+				    uint32_t min_extents_nr,
+				    m0_bindex_t min_start_offset,
+				    m0_bindex_t approximate_end_offset,
+				    bool if_contiguous_extents,
+				    uint32_t kind_of_extent_to_operate,
+				    bool failure_test)
+{
+	rc = ext_operate(EXTENT_UPDATE, lid, domain,
+			 layers_nr, min_extents_nr,
+			 min_start_offset, approximate_end_offset,
+			 if_contiguous_extents,
+			 kind_of_extent_to_operate,
+			 failure_test);
+	return rc;
+}
+
 int test_ext_delete_composite(uint64_t lid,
 			      struct m0_layout_domain *domain,
 			      uint32_t layers_nr,
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 1cb1db1..f04053a 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -3862,28 +3862,61 @@ static void test_composite_layer_ops(void)
 	//if_contigous
 
 #if 1
-	/* todo
-	 * Build a layout object with COMPOSITE layout type, with noncontiguous
-	 * extents in its layers and with the extents with the range from 0 to
-	 * M0_BINDEX_MAX and destroy it.
-	 */
+	/* todo Dec 27 Continue to cover all the cases with the lookup. */
 	lid = 22001;
 	rc = test_ext_lookup_composite(lid, &domain, 6, 4 /* todo 100 */,
 				       lid * 100, lid * 100 * 100,
-				       !CONTIGUOUS_EXTENTS, EXACT_EXISTING,
+				       CONTIGUOUS_EXTENTS, EXACT_EXISTING,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
+
 	lid = 22002;
+	rc = test_ext_lookup_composite(lid, &domain, 6, 4 /* todo 100 */,
+				       lid * 100, lid * 100 * 100,
+				       !CONTIGUOUS_EXTENTS, EXACT_EXISTING,
+				       !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+
+	lid = 22003;
 	rc = test_ext_lookup_composite(lid, &domain, 6, 4, /* todo 100, */
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS, NON_EXISTING,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
+	lid = 22004;
+	rc = test_ext_lookup_composite(lid, &domain, 6, 4, /* todo 100, */
+				       lid * 100, lid * 100 * 100,
+				       CONTIGUOUS_EXTENTS, OVERLAPPING_LEFT,
+				       !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+
+	lid = 22005;
+	rc = test_ext_lookup_composite(lid, &domain, 6, 4, /* todo 100, */
+				       lid * 100, lid * 100 * 100,
+				       !CONTIGUOUS_EXTENTS, OVERLAPPING_LEFT,
+				       !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+
+	lid = 22006;
+	rc = test_ext_lookup_composite(lid, &domain, 6, 4, /* todo 100, */
+				       lid * 100, lid * 100 * 100,
+				       CONTIGUOUS_EXTENTS, OVERLAPPING_RIGHT,
+				       !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+
 	/* todo Shall cover the other cases of extent type to be looked up. */
+#if 0
+	lid = 22007;
+	rc = test_ext_lookup_composite(lid, &domain, 6, 4, /* todo 100, */
+				       lid * 100, lid * 100 * 100,
+				       !CONTIGUOUS_EXTENTS, OVERLAPPING_RIGHT,
+				       !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+#endif
 
-	lid = 22003;
+	lid = 22021;
 	rc = test_ext_add_composite(lid, &domain, 6, 4,
 				    lid * 100, lid * 100 * 100,
 				    !CONTIGUOUS_EXTENTS, EXACT_EXISTING,
@@ -3891,21 +3924,21 @@ static void test_composite_layer_ops(void)
 	M0_UT_ASSERT(rc == 0);
 
 	/* todo The following seem to have added to the mem leak. */
-	lid = 22004;
+	lid = 22022;
 	rc = test_ext_add_composite(lid, &domain, 6, 4,
 				    lid * 100, lid * 100 * 100,
 				    !CONTIGUOUS_EXTENTS, NON_EXISTING,
 				    !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22005;
+	lid = 22023;
 	rc = test_ext_add_composite(lid, &domain, 6, 4,
 				    lid * 100, lid * 100 * 100,
 				    !CONTIGUOUS_EXTENTS, OVERLAPPING_LEFT,
 				    !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22006;
+	lid = 22024;
 	rc = test_ext_add_composite(lid, &domain, 6, 4,
 				    lid * 100, lid * 100 * 100,
 				    !CONTIGUOUS_EXTENTS, OVERLAPPING_RIGHT,
@@ -3913,7 +3946,7 @@ static void test_composite_layer_ops(void)
 	M0_UT_ASSERT(rc == 0);
 
 #endif
-	lid = 22007;
+	lid = 22025;
 	rc = test_ext_add_composite(lid, &domain, 6, 4,
 				    lid * 100, lid * 100 * 100,
 				    !CONTIGUOUS_EXTENTS, OVERLAPPING_COMPLETE,
@@ -3921,7 +3954,7 @@ static void test_composite_layer_ops(void)
 	M0_UT_ASSERT(rc == 0);
 
 
-	lid = 22008;
+	lid = 22026;
 	rc = test_ext_add_composite(lid, &domain, 6, 4,
 				    lid * 100, lid * 100 * 100,
 				    CONTIGUOUS_EXTENTS, OVERLAPPING_COMPLETE,
@@ -3931,33 +3964,70 @@ static void test_composite_layer_ops(void)
 
 	/* todo Shall cover the other cases of extent type to be added. */
 
-	lid = 22009;
+	lid = 22081;
+	rc = test_ext_delete_composite(lid, &domain, 6, 4,
+				       lid * 100, lid * 100 * 100,
+				       CONTIGUOUS_EXTENTS, EXACT_EXISTING,
+				       !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+
+	lid = 22032;
 	rc = test_ext_delete_composite(lid, &domain, 6, 4,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS, EXACT_EXISTING,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22010;
+	lid = 22033;
 	rc = test_ext_delete_composite(lid, &domain, 6, 4,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS, NON_EXISTING,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22011;
+	lid = 22034;
+	rc = test_ext_delete_composite(lid, &domain, 6, 4,
+				       lid * 100, lid * 100 * 100,
+				       CONTIGUOUS_EXTENTS, OVERLAPPING_LEFT,
+				       !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+
+	lid = 22035;
 	rc = test_ext_delete_composite(lid, &domain, 6, 4,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS, OVERLAPPING_LEFT,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
-	lid = 22012;
+	lid = 22036;
+	rc = test_ext_delete_composite(lid, &domain, 6, 4,
+				       lid * 100, lid * 100 * 100,
+				       CONTIGUOUS_EXTENTS, OVERLAPPING_RIGHT,
+				       !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+
+	lid = 22037;
 	rc = test_ext_delete_composite(lid, &domain, 6, 4,
 				       lid * 100, lid * 100 * 100,
 				       !CONTIGUOUS_EXTENTS, OVERLAPPING_RIGHT,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
+
+	lid = 22038;
+	rc = test_ext_delete_composite(lid, &domain, 6, 4,
+				       lid * 100, lid * 100 * 100,
+				       CONTIGUOUS_EXTENTS,
+				       OVERLAPPING_COMPLETE,
+				       !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+
+	lid = 22039;
+	rc = test_ext_delete_composite(lid, &domain, 6, 4,
+				       lid * 100, lid * 100 * 100,
+				       !CONTIGUOUS_EXTENTS,
+				       OVERLAPPING_COMPLETE,
+				       !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
 }
 
 #endif /* __KERNEL__ */
-- 
1.8.3.2

