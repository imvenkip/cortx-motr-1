From eac25dc59ccbc65e57cfc6a8f2169071803e91ef Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Fri, 8 Mar 2013 12:18:04 +0530
Subject: [PATCH 077/157] Updating the documentation

---
 layout/composite.c   | 352 ++++++++++++++++++++++++++-------------------------
 layout/layout_addb.h |  45 ++++---
 layout/layout_db.c   |  81 ++++++++----
 3 files changed, 264 insertions(+), 214 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index de6fabd..aa66dd3 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -747,10 +747,11 @@ M0_INTERNAL int m0_composite_layer_delete(struct m0_composite_layout *cl,
 
 	m0_mutex_lock(&cl->cl_base.l_lock);
 	if (cl->cl_layers_nr == 1) {
+		rc = -EINVAL;
 		m0_layout__log("m0_composite_layer_delete",
 			       "The top-most layer being the zeroth one can "
 			       "not be deleted",
-			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_1, //todo
+			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_DEL_1,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
 		m0_mutex_unlock(&cl->cl_base.l_lock);
 		return rc;
@@ -764,7 +765,7 @@ M0_INTERNAL int m0_composite_layer_delete(struct m0_composite_layout *cl,
 		m0_layout__log("m0_composite_layer_delete",
 			       "Extent list for The top-most layer not "
 			       "qualified for deletion",
-			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_1, //todo
+			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_DEL_2,
 			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id, rc);
 		m0_mutex_unlock(&cl->cl_base.l_lock);
 		return rc;
@@ -776,7 +777,7 @@ M0_INTERNAL int m0_composite_layer_delete(struct m0_composite_layout *cl,
 			m0_layout__log("m0_composite_layer_delete",
 				       "Failed to delete the top-most layer "
 				       "from DB",
-				       M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_1, //todo
+				       M0_LAYOUT_ADDB_LOC_COMP_LAYER_DEL_3,
 				       &cl->cl_base.l_addb_ctx,
 				       cl->cl_base.l_id, rc);
 		}
@@ -1899,6 +1900,7 @@ static m0_bcount_t composite_max_recsize(struct m0_layout_domain *dom)
 	return 0;
 }
 
+/* DB related routines start here. */
 static void prefix_set(struct layout_prefix *prefix,
 		       uint64_t composite_lid,
 		       uint32_t layer_idx)
@@ -1908,155 +1910,23 @@ static void prefix_set(struct layout_prefix *prefix,
 	prefix->lp_filler = 0;
 }
 
-//todo Check location of the following fns
-#ifndef __KERNEL__
-static int ext_inmem_delete(struct m0_composite_layer *layer,
-			    const struct m0_ext *ext,
-			    uint64_t old_ext_state)
-{
-	struct m0_composite_layer_extent *lr_ext;
-	struct m0_composite_layer_extent *lr_ext_to_delete;
-	bool                              lr_ext_to_delete_found;
-	int                               rc;
-
-	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, "
-		 "old_e_state %llu",
-		 (unsigned long long)layer->clr_cl->l_id,
-		 (unsigned long)layer->clr_idx,
-		 (unsigned long long)ext->e_start,
-		 (unsigned long long)ext->e_end,
-		 (unsigned long long)old_ext_state);
-
-	lr_ext_to_delete_found = false;
-	m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
-		if (ext->e_start > lr_ext->cle_ext.e_end)
-			continue;
-		if (ext->e_start == lr_ext->cle_ext.e_start) {
-			if (ext->e_end == lr_ext->cle_ext.e_end) {
-				lr_ext_to_delete = lr_ext;
-				lr_ext_to_delete_found = true;
-				break;
-			} else
-				/*
-				 * It is only during the process of an extent
-				 * getting added by splitting some existing
-				 * extent, when there could be two extents
-				 * starting with the same offset. So, this
-				 * 'continue' is to find that other exact
-				 * matching extent.
-				 */
-				continue;
-		}
-	} m0_tl_endfor;
-
-	if (lr_ext_to_delete_found && ext->e_end == lr_ext->cle_ext.e_end) {
-		M0_ASSERT(lr_ext_to_delete->cle_state == old_ext_state);
-		ext_inmem_del_internal(layer, lr_ext_to_delete);
-		rc = 0;
-	} else
-		rc = -ENOENT;
-	M0_RETURN(rc);
-}
-
-/** Trims the existing extent as requested. */
-static int ext_inmem_trim(struct m0_composite_layer *layer,
-			  enum extent_op extent_op,
-			  const struct m0_ext *ext_to_trim,
-			  uint64_t ext_state,
-			  const struct m0_ext *trim_reference_ext)
-{
-	struct m0_composite_layer_extent *lr_ext;
-	struct m0_composite_layer_extent *lr_ext_left;
-	struct m0_ext                     ext_left;
-	struct m0_ext                     ext_to_insert;
-	int                               rc;
-
-	M0_PRE(M0_IN(extent_op, (CUT_LEFT, CUT_RIGHT)));
-	M0_ENTRY("lid %llu, layer %lu, extent_op %d, "
-		 "ext_to_trim_start %llu, ext_to_trim_end %llu, "
-		 "ext_state %llu, "
-		 "trim_ref_ext_start %llu, trim_ref_ext_end %llu",
-		 (unsigned long long)layer->clr_cl->l_id,
-		 (unsigned long)layer->clr_idx, extent_op,
-		 (unsigned long long)ext_to_trim->e_start,
-		 (unsigned long long)ext_to_trim->e_end,
-		 (unsigned long long)ext_state,
-		 (unsigned long long)trim_reference_ext->e_start,
-		 (unsigned long long)trim_reference_ext->e_end);
-	rc = ext_inmem_find(layer, ext_to_trim, ext_state, &lr_ext);
-	if (rc == 0) {
-		M0_ASSERT(lr_ext->cle_ext.e_start <=
-			  trim_reference_ext->e_start);
-		M0_ASSERT(lr_ext->cle_ext.e_end >= trim_reference_ext->e_end);
-
-		if (extent_op == CUT_LEFT)
-			/* Retain left part of the existing extent. */
-			lr_ext->cle_ext.e_end = trim_reference_ext->e_start;
-		else
-			/* Retain right part of the existing extent. */
-			lr_ext->cle_ext.e_start = trim_reference_ext->e_end;
-	} else if (extent_op == CUT_RIGHT) {
-		/*
-		 * It is possible that CUT_LEFT has already been performed
-		 * on the same extent. So, the extent ext_to_trim does not
-		 * exist there as a whole but its left part does.
-		 */
-		M0_ASSERT(rc == -ENOENT);
-		ext_left = *ext_to_trim;
-		ext_left.e_end = trim_reference_ext->e_start;
-		rc = ext_inmem_find(layer, &ext_left, ext_state, &lr_ext_left);
-		if (rc == 0) {
-			ext_to_insert = *ext_to_trim;
-			ext_to_insert.e_start = trim_reference_ext->e_end;
-			rc = ext_inmem_add_internal(layer, NULL, NULL,
-						    &ext_to_insert, ext_state,
-						    ADD_AFTER, lr_ext_left);
-			if (rc != 0)
-				M0_LOG(M0_ERROR, "lid %llu, Extent could not "
-				       "be added to the list",
-				       (unsigned long long)layer->clr_cl->l_id);
-		}
-	} else
-		/*
-		 * Since m0_emap_paste() first sends cut_left callback and then
-		 * the cut_right callback, it is not possible that CUT_RIGHT
-		 * has been performed before CUT_LEFT.
-		 */
-		M0_ASSERT(0);
-	M0_RETURN(rc);
-}
-
-static int ext_inmem_adjust(struct m0_composite_layer *layer,
-			    enum extent_op extent_op,
-			    const struct m0_emap_seg *seg,
-			    const struct m0_ext *ext)
+static void pair_set(struct m0_db_pair *pair,
+		     struct layer_sublayout_key *key,
+		     struct layer_sublayout_rec *rec,
+		     const struct m0_composite_layout *cl,
+		     uint32_t layer_idx,
+		     uint64_t sublayout_id)
 {
-	int rc;
-
-	M0_PRE(M0_IN(extent_op, (DELETE, CUT_LEFT, CUT_RIGHT)));
-	M0_ENTRY("lid %llu, layer %lu, extent_op %d, "
-		 "seg_e_start %llu, seg_e_end %llu, seg_val %llu, "
-		 "e_start %llu, e_end %llu",
-		 (unsigned long long)layer->clr_cl->l_id,
-		 (unsigned long)layer->clr_idx, extent_op,
-		 (unsigned long long)seg->ee_ext.e_start,
-		 (unsigned long long)seg->ee_ext.e_end,
-		 (unsigned long long)seg->ee_val,
-		 (ext != NULL) ? (unsigned long long)ext->e_start : 0,
-		 (ext != NULL) ? (unsigned long long)ext->e_end : 0);
+	struct composite_schema_data *csd;
 
-	if (extent_op == DELETE)
-		/*
-		 * The extent seg->ee_ext is replaced by some newer extent.
-		 * Hence, seg->ee_ext is asked to be deleted.
-		 */
-		rc = ext_inmem_delete(layer, &seg->ee_ext, seg->ee_val);
-	else
-		rc = ext_inmem_trim(layer, extent_op, &seg->ee_ext,
-				    seg->ee_val, ext);
-	M0_RETURN(rc);
+	key->lrsmk_comp_lid      = cl->cl_base.l_id;
+	key->lrsmk_layer_idx     = layer_idx;
+	key->lrsmk_pad           = 0;
+	rec->lrsmr_sublayout_lid = sublayout_id;
+	csd = cl->cl_base.l_dom->ld_type_data[m0_composite_layout_type.lt_id];
+	m0_db_pair_setup(pair, &csd->csd_layer_sublayout,
+			 key, sizeof *key, rec, sizeof *rec);
 }
-#endif /* __KERNEL__ */
 
 static int emap_iterator_set(struct m0_composite_layout *cl,
 			     uint32_t layer_idx,
@@ -2088,6 +1958,12 @@ static int ext_indb_write_internal(struct m0_emap_cursor *it,
 				   const struct m0_ext *ext,
 				   uint64_t new_ext_state,
 				   bool in_mem_list_update);
+#ifndef __KERNEL__
+static int ext_inmem_adjust(struct m0_composite_layer *layer,
+			    enum extent_op extent_op,
+			    const struct m0_emap_seg *seg,
+			    const struct m0_ext *ext);
+#endif
 
 /**
  * Pastes an extent with the specified state into the on-disk extent map
@@ -2125,7 +2001,6 @@ static int ext_indb_write(struct m0_composite_layout *cl,
 		 (unsigned long long)ext->e_end,
 		 (unsigned long long)new_ext_state);
 
-	//In the DB path, just assert on the right overlapping states
 	rc = ext_inmem_validate(cl, layer, ext, new_ext_state,
 			        ext_validation_kind,
 				&lr_ext_nearest /* Ignored in this case. */);
@@ -2281,23 +2156,154 @@ static int ext_indb_write_internal(struct m0_emap_cursor *it,
 #endif /* __KERNEL__ */
 }
 
-static void pair_set(struct m0_db_pair *pair,
-		     struct layer_sublayout_key *key,
-		     struct layer_sublayout_rec *rec,
-		     const struct m0_composite_layout *cl,
-		     uint32_t layer_idx,
-		     uint64_t sublayout_id)
+#ifndef __KERNEL__
+static int ext_inmem_delete(struct m0_composite_layer *layer,
+			    const struct m0_ext *ext,
+			    uint64_t old_ext_state)
 {
-	struct composite_schema_data *csd;
+	struct m0_composite_layer_extent *lr_ext;
+	struct m0_composite_layer_extent *lr_ext_to_delete;
+	bool                              lr_ext_to_delete_found;
+	int                               rc;
 
-	key->lrsmk_comp_lid      = cl->cl_base.l_id;
-	key->lrsmk_layer_idx     = layer_idx;
-	key->lrsmk_pad           = 0;
-	rec->lrsmr_sublayout_lid = sublayout_id;
-	csd = cl->cl_base.l_dom->ld_type_data[m0_composite_layout_type.lt_id];
-	m0_db_pair_setup(pair, &csd->csd_layer_sublayout,
-			 key, sizeof *key, rec, sizeof *rec);
+	M0_ENTRY("lid %llu, layer %lu, e_start %llu, e_end %llu, "
+		 "old_e_state %llu",
+		 (unsigned long long)layer->clr_cl->l_id,
+		 (unsigned long)layer->clr_idx,
+		 (unsigned long long)ext->e_start,
+		 (unsigned long long)ext->e_end,
+		 (unsigned long long)old_ext_state);
+
+	lr_ext_to_delete_found = false;
+	m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
+		if (ext->e_start > lr_ext->cle_ext.e_end)
+			continue;
+		if (ext->e_start == lr_ext->cle_ext.e_start) {
+			if (ext->e_end == lr_ext->cle_ext.e_end) {
+				lr_ext_to_delete = lr_ext;
+				lr_ext_to_delete_found = true;
+				break;
+			} else
+				/*
+				 * It is only during the process of an extent
+				 * getting added by splitting some existing
+				 * extent, when there could be two extents
+				 * starting with the same offset. So, this
+				 * 'continue' is to find that other exact
+				 * matching extent.
+				 */
+				continue;
+		}
+	} m0_tl_endfor;
+
+	if (lr_ext_to_delete_found && ext->e_end == lr_ext->cle_ext.e_end) {
+		M0_ASSERT(lr_ext_to_delete->cle_state == old_ext_state);
+		ext_inmem_del_internal(layer, lr_ext_to_delete);
+		rc = 0;
+	} else
+		rc = -ENOENT;
+	M0_RETURN(rc);
+}
+
+/** Trims the existing extent as requested. */
+static int ext_inmem_trim(struct m0_composite_layer *layer,
+			  enum extent_op extent_op,
+			  const struct m0_ext *ext_to_trim,
+			  uint64_t ext_state,
+			  const struct m0_ext *trim_reference_ext)
+{
+	struct m0_composite_layer_extent *lr_ext;
+	struct m0_composite_layer_extent *lr_ext_left;
+	struct m0_ext                     ext_left;
+	struct m0_ext                     ext_to_insert;
+	int                               rc;
+
+	M0_PRE(M0_IN(extent_op, (CUT_LEFT, CUT_RIGHT)));
+	M0_ENTRY("lid %llu, layer %lu, extent_op %d, "
+		 "ext_to_trim_start %llu, ext_to_trim_end %llu, "
+		 "ext_state %llu, "
+		 "trim_ref_ext_start %llu, trim_ref_ext_end %llu",
+		 (unsigned long long)layer->clr_cl->l_id,
+		 (unsigned long)layer->clr_idx, extent_op,
+		 (unsigned long long)ext_to_trim->e_start,
+		 (unsigned long long)ext_to_trim->e_end,
+		 (unsigned long long)ext_state,
+		 (unsigned long long)trim_reference_ext->e_start,
+		 (unsigned long long)trim_reference_ext->e_end);
+	rc = ext_inmem_find(layer, ext_to_trim, ext_state, &lr_ext);
+	if (rc == 0) {
+		M0_ASSERT(lr_ext->cle_ext.e_start <=
+			  trim_reference_ext->e_start);
+		M0_ASSERT(lr_ext->cle_ext.e_end >= trim_reference_ext->e_end);
+
+		if (extent_op == CUT_LEFT)
+			/* Retain left part of the existing extent. */
+			lr_ext->cle_ext.e_end = trim_reference_ext->e_start;
+		else
+			/* Retain right part of the existing extent. */
+			lr_ext->cle_ext.e_start = trim_reference_ext->e_end;
+	} else if (extent_op == CUT_RIGHT) {
+		/*
+		 * It is possible that CUT_LEFT has already been performed
+		 * on the same extent. So, the extent ext_to_trim does not
+		 * exist there as a whole but its left part does.
+		 */
+		M0_ASSERT(rc == -ENOENT);
+		ext_left = *ext_to_trim;
+		ext_left.e_end = trim_reference_ext->e_start;
+		rc = ext_inmem_find(layer, &ext_left, ext_state, &lr_ext_left);
+		if (rc == 0) {
+			ext_to_insert = *ext_to_trim;
+			ext_to_insert.e_start = trim_reference_ext->e_end;
+			rc = ext_inmem_add_internal(layer, NULL, NULL,
+						    &ext_to_insert, ext_state,
+						    ADD_AFTER, lr_ext_left);
+			if (rc != 0)
+				M0_LOG(M0_ERROR, "lid %llu, Extent could not "
+				       "be added to the list",
+				       (unsigned long long)layer->clr_cl->l_id);
+		}
+	} else
+		/*
+		 * Since m0_emap_paste() first sends cut_left callback and then
+		 * the cut_right callback, it is not possible that CUT_RIGHT
+		 * has been performed before CUT_LEFT.
+		 */
+		M0_ASSERT(0);
+	M0_RETURN(rc);
+}
+
+static int ext_inmem_adjust(struct m0_composite_layer *layer,
+			    enum extent_op extent_op,
+			    const struct m0_emap_seg *seg,
+			    const struct m0_ext *ext)
+{
+	int rc;
+
+	M0_PRE(M0_IN(extent_op, (DELETE, CUT_LEFT, CUT_RIGHT)));
+	M0_ENTRY("lid %llu, layer %lu, extent_op %d, "
+		 "seg_e_start %llu, seg_e_end %llu, seg_val %llu, "
+		 "e_start %llu, e_end %llu",
+		 (unsigned long long)layer->clr_cl->l_id,
+		 (unsigned long)layer->clr_idx, extent_op,
+		 (unsigned long long)seg->ee_ext.e_start,
+		 (unsigned long long)seg->ee_ext.e_end,
+		 (unsigned long long)seg->ee_val,
+		 (ext != NULL) ? (unsigned long long)ext->e_start : 0,
+		 (ext != NULL) ? (unsigned long long)ext->e_end : 0);
+
+	if (extent_op == DELETE)
+		/*
+		 * The extent seg->ee_ext is replaced by some newer extent.
+		 * Hence, seg->ee_ext is asked to be deleted.
+		 */
+		rc = ext_inmem_delete(layer, &seg->ee_ext, seg->ee_val);
+	else
+		rc = ext_inmem_trim(layer, extent_op, &seg->ee_ext,
+				    seg->ee_val, ext);
+	M0_RETURN(rc);
 }
+#endif /* __KERNEL__ */
 
 static int sublayout_id_indb_lookup(struct m0_composite_layout *cl,
 				    uint32_t layer_idx,
@@ -2598,15 +2604,15 @@ static int comp_layout_indb_read(struct m0_composite_layout *cl,
 		/* Read 'the sublayout id for this layer' from the DB. */
 		rc = sublayout_id_indb_lookup(cl, i, tx, &sublayout_id);
 		if (rc != 0) {
-			M0_ASSERT(i > 0);
-			if (rc == -ENOENT)
+			if (rc == -ENOENT) {
 				/*
 				 * The number of layers is not known in
 				 * advance. Hence, break when the first
 				 * -ENOENT error is encountered.
 				 */
+				M0_ASSERT(i > 0);
 				rc = 0;
-			else
+			} else
 				M0_LOG(M0_ERROR, "lid %llu, layer %lu, "
 				       "sublayout id could not be read from "
 				       "the DB",
@@ -2659,8 +2665,8 @@ static int comp_layout_indb_read(struct m0_composite_layout *cl,
 
 		/*
 		 * Release the reference added by m0_layout_find().
-		 * layer_inmem_add() has now added a reference on this
-		 * sublayout.
+		 * composite_populate() or layer_inmem_add() has now added a
+		 * reference on this sublayout.
 		 */
 		M0_ASSERT(rc == 0);
 		m0_layout_put(sublayout);
@@ -2688,6 +2694,12 @@ static int comp_layout_indb_add(struct m0_composite_layout *cl,
 	return rc;
 }
 
+/**
+ * Adds a single extent spanning the whole offset space.
+ * m0_emap_obj_delete() requires that the map consists of only one single
+ * extent. Hence, this function is used in the situations where the map is to
+ * be deleted and may contain multiple invalid extents.
+ */
 static int single_ext_indb_write(struct m0_emap_cursor *it,
 				 struct m0_composite_layer *layer)
 {
@@ -2897,7 +2909,7 @@ static int layer_indb_delete(struct m0_composite_layout *cl,
 	if (rc != 0) {
 		m0_layout__log("layer_indb_delete",
 			       "failed to delete from layer_emap",
-			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_EMAP_DEL, //todo
+			       M0_LAYOUT_ADDB_LOC_COMP_LAYER_INDB_DEL,
 			       &cl->cl_base.l_addb_ctx,
 			       cl->cl_base.l_id, rc);
 			/*
diff --git a/layout/layout_addb.h b/layout/layout_addb.h
index dfcca93..c863142 100644
--- a/layout/layout_addb.h
+++ b/layout/layout_addb.h
@@ -92,27 +92,30 @@ enum {
 	M0_LAYOUT_ADDB_LOC_COMP_LAYER_ALLOC        = 220,
 	M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_1        = 230,
 	M0_LAYOUT_ADDB_LOC_COMP_LAYER_ADD_2        = 231,
-	M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_1       = 240,
-	M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_2       = 241,
-	M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD_INTERNAL   = 250,
-	M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD            = 360,
-	M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE         = 370,
-	M0_LAYOUT_ADDB_LOC_COMP_EXT_DELETE         = 380,
-	M0_LAYOUT_ADDB_LOC_COMP_EXT_PASTE          = 390,
-	M0_LAYOUT_ADDB_LOC_COMP_SUBLAYOUT_READ     = 400,
-	M0_LAYOUT_ADDB_LOC_COMP_SUBLAYOUT_ADD      = 410,
-	M0_LAYOUT_ADDB_LOC_COMP_SUBLAYOUT_DEL      = 420,
-	M0_LAYOUT_ADDB_LOC_COMP_LAYER_EMAP_ADD_1   = 430,
-	M0_LAYOUT_ADDB_LOC_COMP_LAYER_EMAP_ADD_2   = 431,
-	M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_1        = 440,
-	M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_2        = 441,
-	M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_3        = 442,
-	M0_LAYOUT_ADDB_LOC_COMP_EXT_WRITE          = 450,
-	M0_LAYOUT_ADDB_LOC_COMP_LAYOUT_DEL         = 460,
-	M0_LAYOUT_ADDB_LOC_COMP_LAYER_EMAP_DEL     = 470,
-	M0_LAYOUT_ADDB_LOC_COMP_EXT_LOOKUP         = 480,
-	M0_LAYOUT_ADDB_LOC_COMP_EMAP_IT_SET        = 490,
-	M0_LAYOUT_ADDB_LOC_COMP_INST_BUILD         = 500,
+	M0_LAYOUT_ADDB_LOC_COMP_LAYER_DEL_1        = 240,
+	M0_LAYOUT_ADDB_LOC_COMP_LAYER_DEL_2        = 241,
+	M0_LAYOUT_ADDB_LOC_COMP_LAYER_DEL_3        = 242,
+	M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_1       = 250,
+	M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_2       = 251,
+	M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD_INTERNAL   = 260,
+	M0_LAYOUT_ADDB_LOC_COMP_EXT_ADD            = 370,
+	M0_LAYOUT_ADDB_LOC_COMP_EXT_UPDATE         = 380,
+	M0_LAYOUT_ADDB_LOC_COMP_EXT_DELETE         = 390,
+	M0_LAYOUT_ADDB_LOC_COMP_EXT_PASTE          = 400,
+	M0_LAYOUT_ADDB_LOC_COMP_SUBLAYOUT_READ     = 410,
+	M0_LAYOUT_ADDB_LOC_COMP_SUBLAYOUT_ADD      = 420,
+	M0_LAYOUT_ADDB_LOC_COMP_SUBLAYOUT_DEL      = 430,
+	M0_LAYOUT_ADDB_LOC_COMP_LAYER_EMAP_ADD_1   = 440,
+	M0_LAYOUT_ADDB_LOC_COMP_LAYER_EMAP_ADD_2   = 441,
+	M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_1        = 450,
+	M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_2        = 451,
+	M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_3        = 452,
+	M0_LAYOUT_ADDB_LOC_COMP_EXT_WRITE          = 460,
+	M0_LAYOUT_ADDB_LOC_COMP_LAYOUT_DEL         = 470,
+	M0_LAYOUT_ADDB_LOC_COMP_LAYER_INDB_DEL     = 480,
+	M0_LAYOUT_ADDB_LOC_COMP_EXT_LOOKUP         = 490,
+	M0_LAYOUT_ADDB_LOC_COMP_EMAP_IT_SET        = 500,
+	M0_LAYOUT_ADDB_LOC_COMP_INST_BUILD         = 510,
 
 	M0_LAYOUT_ADDB_LOC_NR
 };
diff --git a/layout/layout_db.c b/layout/layout_db.c
index fcf9653..c61b0b6 100644
--- a/layout/layout_db.c
+++ b/layout/layout_db.c
@@ -153,7 +153,8 @@
  * The layout schema for the Layout DB module consists of the following tables.
  * - @ref Layout-DB-lspec-schema-layouts
  * - @ref Layout-DB-lspec-schema-cob_lists
- * - @ref Layout-DB-lspec-schema-comp_layout_ext_map
+ * - @ref Layout-DB-lspec-schema-comp_layout_layer_sublayout
+ * - @ref Layout-DB-lspec-schema-comp_layout_layer_emap
  *
  * Key-Record structures for these tables are described below.
  *
@@ -200,48 +201,82 @@
  * index from the array of m0_fid structures stored inline in the layouts
  * table.
  *
- * @subsection Layout-DB-lspec-schema-comp_layout_ext_map
- * Table comp_layout_ext_map      todo Update this
+ * @subsection Layout-DB-lspec-schema-comp_layout_layer_sublayout
+ * Table comp_layout_layer_sublayout
  *
  * @verbatim
- * Table Name: comp_layout_ext_map
+ * Table Name: comp_layout_layer_sublayout
  * Key
  *    - composite_layout_id
- *    - last_offset_of_segment
+ *    - composite_layer_index
  * Record
- *    - start_offset_of_segment
- *    - layout_id
+ *    - sublayout_id
  *
  * @endverbatim
  *
  * composite_layout_id is the layout_id for the COMPOSITE type of a layout,
  * stored as a key in the layouts table.
  *
- * layout_id is a foreign key referring record, in the layouts table.
+ * @subsection Layout-DB-lspec-schema-comp_layout_layer_emap
+ * Table comp_layout_layer_emap
+ *
+ * @verbatim
+ * Table Name: comp_layout_layer_emap
+ * Key
+ *    - composite_layout_id
+ *    - composite_layer_index
+ *    - last_offset_of_segment
+ * Record
+ *    - start_offset_of_segment
+ *    - state_of_segment
+ *
+ * @endverbatim
+ *
+ * Value of state_of_segment is one of the values from the enum
+ * m0_composite_layer_ext_state.
  *
  * Layout DB uses a single m0_emap instance to implement the composite layout
- * extent map viz. comp_layout_ext_map. This table stores the "layout segment
- * to sub-layout id mappings" for each composite layout.
+ * extent map viz. comp_layout_layer_emap. This table stores the "layout
+ * segments along with their respective states" for all the layers of all the
+ * composite layouts.
  *
  * Since prefix (an element of the key for m0_emap) is required to be 128 bit
- * in size, layout id (unit64_t) of the composite layout is used as a part of
- * the prefix (struct layout_prefix) to identify an extent map belonging to one
- * specific composite layout. The lower 64 bits are currently unused (fillers).
+ * in size, 'layout id (unit64_t) of the composite layout' and 'layer index
+ * (uint32_t) for the layer from the composite layout' are used as a part of
+ * the prefix (struct layout_prefix) to identify an extent map belonging to a
+ * specific layer from a specific composite layout. The lower 32 bits are
+ * currently unused (fillers).
+ *
+ * The comp_layout_layer_emap table stores the segments from all the layers
+ * from all the composite layouts.
+ * These segments are stored in the form of ([A, B), V) where:
+ * - A is the start offset from a layer
+ * - B is the end offset from that layer
+ * - V is the state of the segment indicating whether the extent is valid.
  *
  * An example:
  *
- * Suppose a layout L1 is of the type composite and constitutes of 3
- * sub-layouts say S1, S2, S3. These sub-layouts S1, S2 and S3 use
- * the layouts with layout id L11, L12 and L13 respectively.
+ * Suppose a layout CL1 is of the type composite and constitutes of 3
+ * layers with the three sub-layouts say S1, S2, S3 respectively.
  *
- * In this example, for the composite layout L1, the comp_layout_ext_map
- * table stores 3 layout segments viz. S1, S2 and S3. All these 3 segments
- * are stored in the form of ([A, B), V) where:
- * - A is the start offset from the layout L1
- * - B is the end offset from the layout L1
- * - V is the layout id for the layout used by the respective segment and
- *   is either of L11, L12 or L13 as applicable.
+ * These sub-layouts S1, S2 and S3 use the layouts with layout id L11, L12 and
+ * L13 respectively.
  *
+ * In this example, for the composite layout CL1, the
+ * comp_layout_layer_sublayout table stores following three entries:
+ * key: (L1, 0), rec: L11
+ * key: (L1, 1), rec: L12
+ * key: (L1, 2), rec: L13
+ *
+ * The comp_layout_layer_emap may have entries indicating information like the
+ * following:
+ * key: (CL1, LAYER0, segment0 [0, x)),                 rec state_of_segment0
+ * key: (CL1, LAYER0, segment1 [x, y)),                 rec state_of_segment1
+ * key: (CL1, LAYER0, segment2 [y, M0_BINDEX_MAX + 1)), rec state_of_segment2
+ * key: (CL1, LAYER1, segment0 [0, m)),                 rec state_of_segment0
+ * key: (CL1, LAYER1, segment1 [m, M0_BINDEX_MAX + 1)), rec state_of_segment1
+ * key: (CL1, LAYER2, segment0 [0, M0_BINDEX_MAX + 1)), rec state_of_segment0
+
  * @subsubsection Layout-DB-lspec-ds1 Subcomponent Data Structures
  * See @ref LayoutDBDFSInternal for internal data structures.
  *
-- 
1.8.3.2

