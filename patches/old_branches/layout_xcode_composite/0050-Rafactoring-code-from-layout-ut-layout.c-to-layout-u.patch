From 214e2140e6e7d8530b458943be19aedef360b726 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Tue, 15 Jan 2013 17:41:19 +0530
Subject: [PATCH 050/157] Rafactoring code from layout/ut/layout.c to
 layout/ut/pdclust.c

---
 build_kernel_modules/Makefile.in |    2 +-
 layout/ut/Makefile.sub           |    4 +-
 layout/ut/composite.c            |   49 +-
 layout/ut/layout.c               | 2197 ++++----------------------------------
 layout/ut/layout.h               |   63 +-
 layout/ut/pdclust.c              | 1834 +++++++++++++++++++++++++++++++
 layout/ut/pdclust.h              |  103 ++
 7 files changed, 2170 insertions(+), 2082 deletions(-)
 create mode 100644 layout/ut/pdclust.c
 create mode 100644 layout/ut/pdclust.h

diff --git a/build_kernel_modules/Makefile.in b/build_kernel_modules/Makefile.in
index c5c3e79..6a37ce7 100644
--- a/build_kernel_modules/Makefile.in
+++ b/build_kernel_modules/Makefile.in
@@ -121,7 +121,7 @@ ioservice_ut_SOURCES            := bulkio_client.c
 layout_SOURCES                  := layout.c layout_db.c pdclust.c composite.c \
                                    list_enum.c linear_enum.c
 
-layout_ut_SOURCES               := layout.c composite.c
+layout_ut_SOURCES               := layout.c pdclust.c composite.c
 
 lib_SOURCES                     := bitstring.c getopts.c vec.c list.c queue.c \
                                    refs.c time.c bitmap.c chan.c misc.c buf.c \
diff --git a/layout/ut/Makefile.sub b/layout/ut/Makefile.sub
index e23e4d7..83f8aab 100644
--- a/layout/ut/Makefile.sub
+++ b/layout/ut/Makefile.sub
@@ -1,7 +1,7 @@
 ut_libmero_ut_la_SOURCES += layout/ut/layout.c \
-                            layout/ut/layout.h \
+                            layout/ut/pdclust.c \
                             layout/ut/composite.c
 
 layout_ut_m0layout_SOURCES = layout/ut/ldemo.c
 
-EXTRA_DIST += layout/ut/layout.h layout/ut/ldemo_internal.c
+EXTRA_DIST += layout/ut/layout.h layout/ut/ldemo_internal.c layout/ut/pdclust.h
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index 509a407..3fbab26 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -18,23 +18,26 @@
  * Original creation date: 11/05/2012
  */
 
-#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_LAYOUT
-#include "lib/trace.h"              /* M0_LOG */
 #include "lib/ut.h"                 /* M0_UT_ASSERT() */
+#include "lib/memory.h"             /* M0_ALLOC_PTR() */
+#include "lib/misc.h"               /* M0_IN() */
 
 #include "layout/layout.h"
-#include "layout/layout_internal.h" /* LDB_MAX_INLINE_COB_ENTRIES, *_ERR */
+#include "layout/layout_internal.h" /* *_ERR */
 #include "layout/layout_db.h"
 #include "layout/pdclust.h"         /* m0_pdl_to_layout() */
 #include "layout/composite.h"
 #include "layout/composite_internal.h"
+
 #include "layout/ut/layout.h"
+#include "layout/ut/pdclust.h"
 
 M0_TL_DESCR_DECLARE(comp_layer, extern);
 M0_TL_DESCR_DECLARE(m0_composite_layer_ext, extern);
 static int rc;
 
-static void sublayout_build(uint64_t lid, struct m0_layout **sublayout)
+static void sublayout_build(uint64_t lid, struct m0_layout_domain *domain,
+			    struct m0_layout **sublayout)
 {
 	bool                          inline_test;
 	uint32_t                      enum_id;
@@ -50,7 +53,7 @@ static void sublayout_build(uint64_t lid, struct m0_layout **sublayout)
 	enum_id = lid % 2 ? LIST_ENUM_ID : LINEAR_ENUM_ID;
 	inline_test = lid % 5 ? LESS_THAN_INLINE : MORE_THAN_INLINE;
 	NKP_assign(enum_id, inline_test, 9, 109, 1200, &N, &K, &P);
-	rc = pdclust_layout_build(enum_id, lid,
+	rc = pdclust_layout_build(lid, domain, enum_id,
 				  N, K, P, &seed,
 				  10, 20,
 				  &pl, &list_enum, &lin_enum,
@@ -72,6 +75,7 @@ static void sublayout_build(uint64_t lid, struct m0_layout **sublayout)
  *   layer_idx'th layer.
  */
 static void sublayouts_precreate(uint64_t composite_lid,
+				 struct m0_layout_domain *domain,
 				 uint32_t layers_nr)
 {
 	uint64_t          sublayout_id;
@@ -80,7 +84,7 @@ static void sublayouts_precreate(uint64_t composite_lid,
 
 	for (i = 1; i < layers_nr; ++i) {
 		sublayout_id = composite_lid * 100 + i;
-		sublayout_build(sublayout_id, &sublayout);
+		sublayout_build(sublayout_id, domain, &sublayout);
 	}
 }
 
@@ -220,7 +224,7 @@ static void composite_layout_verify(struct m0_layout *l,
 		inline_test = sublayout_id % 5 ? LESS_THAN_INLINE :
 						  MORE_THAN_INLINE;
 		NKP_assign(enum_id, inline_test, 9, 109, 1200, &N, &K, &P);
-		pdclust_layout_verify(enum_id, layer->clr_l, sublayout_id,
+		pdclust_layout_verify(layer->clr_l, sublayout_id, enum_id,
 				      N, K, P, &seed, 10, 20,
 				      USER_COUNT_INCREMENTED);
 		M0_UT_ASSERT(layer->clr_l->l_user_count == 1);
@@ -264,7 +268,7 @@ static int composite_build(uint64_t lid,
 
 	/* Pre-create the sublayout to be used as the original layout. */
 	sublayout_id = lid * 100;
-	sublayout_build(sublayout_id, &sublayout);
+	sublayout_build(sublayout_id, domain, &sublayout);
 
 	/* Build a composite layout. */
 	rc = m0_composite_build(domain, lid, sublayout, cl);
@@ -307,7 +311,7 @@ static int composite_layers_add(struct m0_composite_layout *cl,
 	uint32_t          i;
 
 	/* Pre-create the sublayouts to be used for the layer 1 and above. */
-	sublayouts_precreate(cl->cl_base.l_id, layers_nr);
+	sublayouts_precreate(cl->cl_base.l_id, cl->cl_base.l_dom, layers_nr);
 
 	m0_mutex_lock(&cl->cl_base.l_lock);
 	extents_nr = min_extents_nr;
@@ -477,9 +481,9 @@ static void composite_layout_buf_build(uint64_t composite_lid,
 #endif
 
 	/* Pre-create the sublayout to be used as the original layout. */
-	sublayout_build(composite_lid * 100, &sublayout);
+	sublayout_build(composite_lid * 100, domain, &sublayout);
 	/* Pre-create the sublayouts to be used for layer 1 and above. */
-	sublayouts_precreate(composite_lid, layers_nr);
+	sublayouts_precreate(composite_lid, domain, layers_nr);
 
 	extents_nr = min_extents_nr;
 	for (i = 0; i < layers_nr; ++i) {
@@ -552,8 +556,6 @@ int test_decode_composite(uint64_t lid,
 	struct m0_layout        *l;
 	struct m0_layout_type   *lt;
 
-	M0_ENTRY();
-
 	/* Build a layout buffer. */
 	allocate_area(&area, ADDITIONAL_BYTES_DEFAULT * 4, &num_bytes);
 	bv = (struct m0_bufvec) M0_BUFVEC_INIT_BUF(&area, &num_bytes);
@@ -602,7 +604,6 @@ int test_decode_composite(uint64_t lid,
 	sublayouts_delete(domain, lid, layers_nr);
 
 	m0_free(area);
-	M0_LEAVE();
 	return rc;
 }
 
@@ -694,8 +695,6 @@ int test_encode_composite(uint64_t lid,
 	struct m0_bufvec            bv;
 	struct m0_bufvec_cursor     cur;
 
-	M0_ENTRY("lid %llu", (unsigned long long)lid);
-
 	/* Build a layout object. */
 	rc = composite_build_and_layers_add(lid, domain, NULL, &cl, layers_nr,
 					    min_extents_nr, min_start_offset,
@@ -736,7 +735,6 @@ int test_encode_composite(uint64_t lid,
 	sublayouts_delete(domain, lid, layers_nr);
 
 	m0_free(area);
-	M0_LEAVE();
 	return rc;
 }
 
@@ -819,8 +817,6 @@ int test_decode_encode_composite(uint64_t lid,
 	struct m0_layout        *l;
 	struct m0_layout_type   *lt;
 
-	M0_ENTRY();
-
 	/* Build a layout buffer. */
 	allocate_area(&area1, ADDITIONAL_BYTES_DEFAULT * 4 /* todo */, &num_bytes);
 	bv1 = (struct m0_bufvec) M0_BUFVEC_INIT_BUF(&area1, &num_bytes);
@@ -881,7 +877,6 @@ int test_decode_encode_composite(uint64_t lid,
 
 	m0_free(area1);
 	m0_free(area2);
-	M0_LEAVE();
 	return rc;
 }
 
@@ -1048,8 +1043,6 @@ int test_encode_decode_composite(uint64_t lid,
 	struct m0_layout           *l_copy;
 	struct m0_layout_type      *lt;
 
-	M0_ENTRY("lid %llu", (unsigned long long)lid);
-
 	/* Build a layout object. */
 	rc = composite_build_and_layers_add(lid, domain, NULL, &cl, layers_nr,
 					    min_extents_nr, min_start_offset,
@@ -1107,7 +1100,6 @@ int test_encode_decode_composite(uint64_t lid,
 	sublayouts_delete(domain, lid, layers_nr);
 
 	m0_free(area);
-	M0_LEAVE();
 	return rc;
 }
 
@@ -1187,12 +1179,9 @@ int test_lookup_composite(uint64_t lid,
 	struct m0_db_tx    tx;
 	int                rc_tmp;
 
-	M0_ENTRY();
 	M0_UT_ASSERT(ergo(!existing_test, failure_test));
 
-	/*
-	 * If existing_test is true, then first add a layout object to the DB.
-	 */
+	/* If existing_test is true, first add a layout object to the DB. */
 	if (existing_test) {
 		rc = test_add_composite(lid, domain, layers_nr,
 					min_extents_nr, min_start_offset,
@@ -1258,7 +1247,6 @@ int test_lookup_composite(uint64_t lid,
 		sublayouts_delete(domain, lid, layers_nr);
 
 	m0_free(area);
-	M0_LEAVE();
 	return rc;
 }
 
@@ -1282,7 +1270,6 @@ int test_add_composite(uint64_t lid,
 	struct m0_db_tx             tx;
 	int                         rc_tmp;
 
-	M0_ENTRY("lid %llu", (unsigned long long)lid);
 	M0_UT_ASSERT(ergo(layout_destroy, l_obj == NULL));
 	M0_UT_ASSERT(ergo(!layout_destroy, l_obj != NULL));
 	M0_UT_ASSERT(ergo(duplicate_test, !failure_test));
@@ -1353,7 +1340,6 @@ int test_add_composite(uint64_t lid,
 		*l_obj = &cl->cl_base;
 
 	m0_free(area);
-	M0_LEAVE("lid %llu", (unsigned long long)lid);
 	return rc;
 }
 
@@ -1377,8 +1363,6 @@ int test_delete_composite(uint64_t lid,
 	struct m0_composite_layer_extent *lr_ext;
 	int                               rc_tmp;
 
-	M0_ENTRY("lid %llu", (unsigned long long)lid);
-
 	allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
 
 	/* Build a layout object. */
@@ -1489,7 +1473,6 @@ int test_delete_composite(uint64_t lid,
 	}
 
 	m0_free(area);
-	M0_LEAVE("lid %llu", (unsigned long long)lid);
 	return rc;
 }
 
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index ac9bdb3..9da094f 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -20,29 +20,24 @@
 
 #include "lib/ut.h"
 #include "lib/ub.h"
-#include "lib/memory.h"
-#include "lib/misc.h"                    /* M0_SET0 */
-#include "lib/bitstring.h"
-#include "lib/vec.h"
-
-#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_LAYOUT
-#include "lib/trace.h"                   /* M0_LOG */
+#include "lib/memory.h"                  /* m0_alloc() */
+#include "lib/vec.h"                     /* m0_bufvec_cursor_*() */
+#include "lib/finject.h"
 
 #ifdef __KERNEL__
 # include "m0t1fs/linux_kernel/m0t1fs.h" /* m0t1fs_globals */
 #endif
 
-#include "lib/finject.h"
-
 #include "fid/fid.h"                     /* m0_fid_set() */
 #include "layout/layout.h"
-#include "layout/layout_internal.h"      /* LDB_MAX_INLINE_COB_ENTRIES, *_ERR */
-#include "layout/layout_db.h"
-#include "layout/pdclust.h"
-#include "layout/list_enum.h"
-#include "layout/linear_enum.h"
-#include "layout/ut/ldemo_internal.c"    /* layout_demo() */
+#include "layout/layout_internal.h"      /* *_ERR */
+#include "layout/layout_db.h"            /* m0_layout_lookup() */
+#include "layout/pdclust.h"              /* m0_layout_pdclust_rec */
+#include "layout/list_enum.h"            /* cob_entries_header */
+#include "layout/linear_enum.h"          /* m0_layout_linear_enum */
+
 #include "layout/ut/layout.h"
+#include "layout/ut/pdclust.h"
 
 static struct m0_dbenv         dbenv;
 static const char              db_name[] = "ut-layout";
@@ -111,8 +106,6 @@ static void test_domain_init_fini(void)
 	struct m0_layout_domain t_domain;
 	struct m0_dbenv         t_dbenv;
 
-	M0_ENTRY();
-
 	rc = m0_dbenv_init(&t_dbenv, t_db_name, DBFLAGS);
 	M0_UT_ASSERT(rc == 0);
 
@@ -131,8 +124,6 @@ static void test_domain_init_fini(void)
 	m0_layout_domain_fini(&t_domain);
 
 	m0_dbenv_fini(&t_dbenv);
-
-	M0_LEAVE();
 }
 
 static void test_domain_init_fini_failure(void)
@@ -141,7 +132,6 @@ static void test_domain_init_fini_failure(void)
 	struct m0_layout_domain t_domain;
 	struct m0_dbenv         t_dbenv;
 
-	M0_ENTRY();
 	rc = m0_dbenv_init(&t_dbenv, t_db_name, DBFLAGS);
 	M0_UT_ASSERT(rc == 0);
 
@@ -150,7 +140,6 @@ static void test_domain_init_fini_failure(void)
 	M0_UT_ASSERT(rc == L_TABLE_INIT_ERR);
 
 	m0_dbenv_fini(&t_dbenv);
-	M0_LEAVE();
 }
 
 static int t_register(struct m0_layout_domain *dom,
@@ -184,8 +173,6 @@ struct m0_layout_type test_layout_type = {
 
 static void test_type_reg_unreg(void)
 {
-	M0_ENTRY();
-
 	/* Register a layout type. */
 	rc = m0_layout_type_register(&domain, &test_layout_type);
 	M0_UT_ASSERT(rc == 0);
@@ -195,8 +182,6 @@ static void test_type_reg_unreg(void)
 	/* Unregister it. */
 	m0_layout_type_unregister(&domain, &test_layout_type);
 	M0_UT_ASSERT(domain.ld_type[test_layout_type.lt_id] == NULL);
-
-	M0_LEAVE();
 }
 
 static int t_enum_register(struct m0_layout_domain *dom,
@@ -229,8 +214,6 @@ struct m0_layout_enum_type test_enum_type = {
 
 static void test_etype_reg_unreg(void)
 {
-	M0_ENTRY();
-
 	/* Register a layout enum type. */
 	rc = m0_layout_enum_type_register(&domain, &test_enum_type);
 	M0_UT_ASSERT(rc == 0);
@@ -240,8 +223,6 @@ static void test_etype_reg_unreg(void)
 	/* Unregister it. */
 	m0_layout_enum_type_unregister(&domain, &test_enum_type);
 	M0_UT_ASSERT(domain.ld_enum[test_enum_type.let_id] == NULL);
-
-	M0_LEAVE();
 }
 
 static void test_reg_unreg(void)
@@ -250,8 +231,6 @@ static void test_reg_unreg(void)
 	struct m0_dbenv         t_dbenv;
 	struct m0_layout_domain t_domain;
 
-	M0_ENTRY();
-
 	/*
 	 * A layout type can be registered with only one domain at a time.
 	 * Hence, unregister all the available layout types and enum types from
@@ -322,8 +301,6 @@ static void test_reg_unreg(void)
 	 */
 	rc = m0_layout_standard_types_register(&domain);
 	M0_ASSERT(rc == 0);
-
-	M0_LEAVE();
 }
 
 static void confirm_nothing_is_registered(struct m0_layout_domain *t_domain)
@@ -340,8 +317,6 @@ static void test_reg_unreg_failure(void)
 	struct m0_dbenv         t_dbenv;
 	struct m0_layout_domain t_domain;
 
-	M0_ENTRY();
-
 	/*
 	 * A layout type can be registered with only one domain at a time.
 	 * Hence, unregister all the available layout types and enum types from
@@ -431,8 +406,6 @@ static void test_reg_unreg_failure(void)
 	 */
 	rc = m0_layout_standard_types_register(&domain);
 	M0_ASSERT(rc == 0);
-
-	M0_LEAVE();
 }
 
 struct m0_layout *list_lookup(uint64_t lid)
@@ -445,124 +418,6 @@ struct m0_layout *list_lookup(uint64_t lid)
 	return l;
 }
 
-/*
- * Builds a layout object with PDCLUST layout type and using the provided
- * enumeration object.
- */
-static int pdclust_l_build(uint64_t lid, uint32_t N, uint32_t K, uint32_t P,
-			   struct m0_uint128 *seed,
-			   struct m0_layout_enum *le,
-			   struct m0_pdclust_layout **pl,
-			   bool failure_test)
-{
-	struct m0_layout_type  *lt;
-	struct m0_pdclust_attr  attr;
-
-	lt = &m0_pdclust_layout_type;
-
-	M0_UT_ASSERT(le != NULL);
-	M0_UT_ASSERT(pl != NULL);
-
-	attr.pa_N         = N;
-	attr.pa_K         = K;
-	attr.pa_P         = P;
-	attr.pa_unit_size = UNIT_SIZE;
-	attr.pa_seed      = *seed;
-
-	if (M0_FI_ENABLED("attr_err")) { attr.pa_P = 1; }
-	rc = m0_pdclust_build(&domain, lid, &attr, le, pl);
-	if (failure_test)
-		M0_UT_ASSERT(rc == -ENOMEM || rc == -EPROTO);
-	else {
-		M0_UT_ASSERT(rc == 0);
-		M0_UT_ASSERT(list_lookup(lid) == &(*pl)->pl_base.sl_base);
-		M0_UT_ASSERT(m0_ref_read(&(*pl)->pl_base.sl_base.l_ref) == 1);
-		M0_UT_ASSERT((*pl)->pl_base.sl_base.l_user_count == 0);
-	}
-
-	return rc;
-}
-
-/*
- * Builds a layout object with PDCLUST layout type, by first building an
- * enumeration object with the specified enumeration type.
- */
-int pdclust_layout_build(uint32_t enum_id,
-			 uint64_t lid,
-			 uint32_t N, uint32_t K, uint32_t P,
-			 struct m0_uint128 *seed,
-			 uint32_t A, uint32_t B,
-			 struct m0_pdclust_layout **pl,
-			 struct m0_layout_list_enum **list_enum,
-			 struct m0_layout_linear_enum **lin_enum,
-			 bool failure_test)
-{
-	struct m0_fid                *cob_list = NULL; /* to keep gcc happy. */
-	int                           i;
-	struct m0_layout_enum        *e;
-	struct m0_layout_linear_attr  lin_attr;
-	struct m0_layout             *l_from_pl;
-	struct m0_layout_enum        *e_from_layout;
-
-	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
-	M0_UT_ASSERT(pl != NULL);
-
-	/* Build an enumeration object with the specified enum type. */
-	if (enum_id == LIST_ENUM_ID) {
-		M0_ALLOC_ARR(cob_list, P);
-		M0_UT_ASSERT(cob_list != NULL);
-
-		for (i = 0; i < P; ++i)
-			m0_fid_set(&cob_list[i], i * 100 + 1, i + 1);
-
-		if (M0_FI_ENABLED("list_attr_err")) { P = 0; }
-		rc = m0_list_enum_build(&domain, cob_list, P, list_enum);
-		M0_UT_ASSERT(rc == 0 || rc == -ENOMEM || rc == -EPROTO);
-
-		e = &(*list_enum)->lle_base;
-
-	} else { /* LINEAR_ENUM_ID */
-		lin_attr.lla_nr = P;
-		lin_attr.lla_A  = A;
-		lin_attr.lla_B  = B;
-		if (M0_FI_ENABLED("lin_attr_err")) { lin_attr.lla_nr = 0; }
-		rc = m0_linear_enum_build(&domain, &lin_attr, lin_enum);
-		M0_UT_ASSERT(rc == 0 || rc == -ENOMEM || rc == -EPROTO);
-
-		e = &(*lin_enum)->lle_base;
-	}
-	if (rc != 0) {
-		M0_UT_ASSERT(failure_test);
-		if (enum_id == LIST_ENUM_ID)
-			m0_free(cob_list);
-		return rc;
-	}
-
-	/*
-	 * Build a layout object with PDCLUST layout type and using the
-	 * enumeration object built earlier here.
-	 */
-	rc = pdclust_l_build(lid, N, K, P, seed, e, pl, failure_test);
-	if (failure_test) {
-		M0_UT_ASSERT(rc == -ENOMEM || rc == -EPROTO);
-		m0_layout_enum_fini(e);
-		return rc;
-	}
-	else {
-		M0_UT_ASSERT(rc == 0);
-		M0_UT_ASSERT(list_lookup(lid) == &(*pl)->pl_base.sl_base);
-	}
-
-	/* Verify m0_pdl_to_layout(). */
-	l_from_pl = m0_pdl_to_layout(*pl);
-	M0_UT_ASSERT(l_from_pl == &(*pl)->pl_base.sl_base);
-
-	/* Verify m0_layout_to_enum(). */
-	e_from_layout = m0_layout_to_enum(l_from_pl);
-	M0_UT_ASSERT(e_from_layout == e);
-	return rc;
-}
-
 /* Verifies generic part of the layout object. */
 void l_verify(struct m0_layout *l,
 	      uint64_t lid,
@@ -576,184 +431,6 @@ void l_verify(struct m0_layout *l,
 }
 
 /*
- * Verifies generic part of the layout object and the PDCLUST layout type
- * specific part of it.
- */
-static void pdclust_l_verify(struct m0_pdclust_layout *pl,
-			     uint64_t lid,
-			     uint32_t N, uint32_t K, uint32_t P,
-			     struct m0_uint128 *seed,
-			     bool if_user_count_incremented)
-{
-	/* Verify generic part of the layout object. */
-	l_verify(&pl->pl_base.sl_base, lid, if_user_count_incremented);
-
-	/* Verify PDCLUST layout type specific part of the layout object. */
-	M0_UT_ASSERT(pl->pl_base.sl_base.l_type == &m0_pdclust_layout_type);
-	M0_UT_ASSERT(pl->pl_attr.pa_N == N);
-	M0_UT_ASSERT(pl->pl_attr.pa_K == K);
-	M0_UT_ASSERT(pl->pl_attr.pa_P == P);
-	M0_UT_ASSERT(pl->pl_attr.pa_unit_size == UNIT_SIZE);
-	M0_UT_ASSERT(m0_uint128_eq(&pl->pl_attr.pa_seed, seed));
-}
-
-/* Verifies the layout object against the various input arguments. */
-void pdclust_layout_verify(uint32_t enum_id,
-			   struct m0_layout *l, uint64_t lid,
-			   uint32_t N, uint32_t K, uint32_t P,
-			   struct m0_uint128 *seed,
-			   uint32_t A, uint32_t B,
-			   bool if_user_count_incremented)
-{
-	struct m0_pdclust_layout     *pl;
-	struct m0_layout_list_enum   *list_enum;
-	struct m0_layout_linear_enum *lin_enum;
-	int                           i;
-	struct m0_fid                 cob_id;
-
-	M0_UT_ASSERT(l != NULL);
-	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
-	M0_UT_ASSERT(l->l_type == &m0_pdclust_layout_type);
-
-	pl = container_of(l, struct m0_pdclust_layout, pl_base.sl_base);
-
-	/*
-	 * Verify generic and PDCLUST layout type specific parts of the
-	 * layout object.
-	 */
-	pdclust_l_verify(pl, lid, N, K, P, seed, if_user_count_incremented);
-
-	/* Verify enum type specific part of the layout object. */
-	M0_UT_ASSERT(pl->pl_base.sl_enum != NULL);
-
-	if (enum_id == LIST_ENUM_ID) {
-		list_enum = container_of(pl->pl_base.sl_enum,
-					 struct m0_layout_list_enum, lle_base);
-		for(i = 0; i < list_enum->lle_nr; ++i) {
-			m0_fid_set(&cob_id, i * 100 + 1, i + 1);
-			M0_UT_ASSERT(m0_fid_eq(&cob_id,
-					      &list_enum->lle_list_of_cobs[i]));
-		}
-		M0_UT_ASSERT(list_enum->lle_nr == P);
-	} else {
-		lin_enum = container_of(pl->pl_base.sl_enum,
-					struct m0_layout_linear_enum, lle_base);
-		M0_UT_ASSERT(lin_enum->lle_attr.lla_nr == P);
-		M0_UT_ASSERT(lin_enum->lle_attr.lla_A == A);
-		M0_UT_ASSERT(lin_enum->lle_attr.lla_B == B);
-	}
-}
-
-void NKP_assign(uint32_t enum_id,
-		uint32_t inline_test,
-		uint32_t list_nr_less,
-		uint32_t list_nr_more,
-		uint32_t linear_nr,
-		uint32_t *N, uint32_t *K, uint32_t *P)
-{
-	M0_UT_ASSERT(ergo(enum_id == LIST_ENUM_ID,
-			  list_nr_less < LDB_MAX_INLINE_COB_ENTRIES &&
-			  list_nr_more > LDB_MAX_INLINE_COB_ENTRIES));
-
-	if (enum_id == LIST_ENUM_ID) {
-		switch (inline_test) {
-		case LESS_THAN_INLINE:
-			*P = list_nr_less;
-			break;
-		case EXACT_INLINE:
-			*P = LDB_MAX_INLINE_COB_ENTRIES;
-			break;
-		case MORE_THAN_INLINE:
-			*P = list_nr_more;
-			break;
-		default:
-			M0_ASSERT(0);
-		}
-	} else
-		*P = linear_nr;
-
-	if (*P <= 20)
-		*K = 1;
-	else if (*P <= 50)
-		*K = 2;
-	else if (*P <= 200)
-		*K = 6;
-	else if (*P <= 500)
-		*K = 12;
-	else if (*P <= 1000)
-		*K = 100;
-	else
-		*K = 200;
-
-	if (*P <= 20)
-		*N = *P - (2 * (*K));
-	else if (*P <= 100)
-		*N = *P - (2 * (*K)) - 10;
-	else if (*P <= 1000)
-		*N = *P - (2 * (*K)) - 12;
-	else
-		*N = *P - (2 * (*K)) - 100;
-}
-
-/*
- * Tests the APIs supported for enumeration object build, layout object build
- * and layout destruction that happens using m0_layout_put(). Verifies that the
- * newly built layout object is added to the list of layout objects maintained
- * in the domain object and that m0_layout_find() returns the same object.
- */
-static int test_build_pdclust(uint32_t enum_id, uint64_t lid,
-			      uint32_t inline_test,
-			      bool failure_test)
-{
-	struct m0_uint128             seed;
-	uint32_t                      N;
-	uint32_t                      K;
-	uint32_t                      P;
-	struct m0_pdclust_layout     *pl;
-	struct m0_layout_list_enum   *list_enum;
-	struct m0_layout_linear_enum *lin_enum;
-	struct m0_layout             *l;
-
-	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
-
-	m0_uint128_init(&seed, "buildpdclustlayo");
-
-	NKP_assign(enum_id,
-		   inline_test, 9, 109, 12000,
-		   &N, &K, &P);
-
-	rc = pdclust_layout_build(enum_id, lid,
-				  N, K, P, &seed,
-				  10, 20,
-				  &pl, &list_enum, &lin_enum,
-				  failure_test);
-	if (failure_test)
-		M0_UT_ASSERT(rc == -ENOMEM || rc == -EPROTO);
-	else {
-		M0_UT_ASSERT(rc == 0);
-		/*
-		 * Verify that m0_layout_find() returns the same object by
-		 * reading it from the memory.
-		 */
-		l = m0_layout_find(&domain, lid);
-		M0_UT_ASSERT(l == &pl->pl_base.sl_base);
-
-		/* Verify the layout object built earlier here. */
-		pdclust_layout_verify(enum_id, &pl->pl_base.sl_base, lid,
-				      N, K, P, &seed,
-				      10, 20, !USER_COUNT_INCREMENTED);
-		/* Release the reference that m0_layout_find() has acquired. */
-		m0_layout_put(&pl->pl_base.sl_base);
-
-		/* Delete the layout object by reducing its last reference. */
-		m0_layout_put(&pl->pl_base.sl_base);
-		M0_UT_ASSERT(list_lookup(lid) == NULL);
-	}
-
-	return rc;
-}
-
-/*
  * Tests the APIs supported for enumeration object build, layout object build
  * and layout destruction that happens using m0_layout_put().
  */
@@ -766,7 +443,8 @@ static void test_build(void)
 	 * with a few inline entries only and then destroy it.
 	 */
 	lid = 1001;
-	rc = test_build_pdclust(LIST_ENUM_ID, lid, LESS_THAN_INLINE,
+	rc = test_build_pdclust(lid, &domain,
+				LIST_ENUM_ID, LESS_THAN_INLINE,
 				!FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -776,7 +454,8 @@ static void test_build(void)
 	 * LDB_MAX_INLINE_COB_ENTRIES and then destroy it.
 	 */
 	lid = 1002;
-	rc = test_build_pdclust(LIST_ENUM_ID, lid, EXACT_INLINE,
+	rc = test_build_pdclust(lid, &domain,
+				LIST_ENUM_ID, EXACT_INLINE,
 				!FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -785,7 +464,8 @@ static void test_build(void)
 	 * including noninline entries and then destroy it.
 	 */
 	lid = 1003;
-	rc = test_build_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
+	rc = test_build_pdclust(lid, &domain,
+				LIST_ENUM_ID, MORE_THAN_INLINE,
 				!FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -794,7 +474,8 @@ static void test_build(void)
 	 * type and then destroy it.
 	 */
 	lid = 1004;
-	rc = test_build_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE,
+	rc = test_build_pdclust(lid, &domain,
+				LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				!FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -844,7 +525,8 @@ static void test_build_failure(void)
 	 */
 	lid = 2001;
 	m0_fi_enable_once("pdclust_allocate", "mem_err");
-	rc = test_build_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
+	rc = test_build_pdclust(lid, &domain,
+				LIST_ENUM_ID, MORE_THAN_INLINE,
 				FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 
@@ -854,7 +536,8 @@ static void test_build_failure(void)
 	 */
 	lid = 2002;
 	m0_fi_enable_once("pdclust_allocate", "mem_err");
-	rc = test_build_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE,
+	rc = test_build_pdclust(lid, &domain,
+				LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 
@@ -864,7 +547,8 @@ static void test_build_failure(void)
 	 */
 	lid = 2003;
 	m0_fi_enable_once("pdclust_l_build", "attr_err");
-	rc = test_build_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
+	rc = test_build_pdclust(lid, &domain,
+				LIST_ENUM_ID, MORE_THAN_INLINE,
 				FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EPROTO);
 
@@ -874,7 +558,8 @@ static void test_build_failure(void)
 	 */
 	lid = 2004;
 	m0_fi_enable_once("list_allocate", "mem_err");
-	rc = test_build_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
+	rc = test_build_pdclust(lid, &domain,
+				LIST_ENUM_ID, MORE_THAN_INLINE,
 				FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 
@@ -884,28 +569,32 @@ static void test_build_failure(void)
 	 */
 	lid = 2005;
 	m0_fi_enable_once("linear_allocate", "mem_err");
-	rc = test_build_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE,
+	rc = test_build_pdclust(lid, &domain,
+				LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 
 	/* Simulate attributes invalid error in m0_list_enum_build(). */
 	lid = 2006;
 	m0_fi_enable_once("pdclust_layout_build", "list_attr_err");
-	rc = test_build_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
+	rc = test_build_pdclust(lid, &domain,
+				LIST_ENUM_ID, MORE_THAN_INLINE,
 				FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EPROTO);
 
 	/* Simulate attributes invalid error in m0_linear_enum_build(). */
 	lid = 2007;
 	m0_fi_enable_once("pdclust_layout_build", "lin_attr_err");
-	rc = test_build_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE,
+	rc = test_build_pdclust(lid, &domain,
+				LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EPROTO);
 
 	/* Simulate fid invalid error in m0_list_enum_build(). */
 	lid = 2008;
 	m0_fi_enable_once("m0_list_enum_build", "fid_invalid_err");
-	rc = test_build_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
+	rc = test_build_pdclust(lid, &domain,
+				LIST_ENUM_ID, MORE_THAN_INLINE,
 				FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EPROTO);
 }
@@ -924,85 +613,6 @@ void generic_buf_build(uint32_t lt_id, struct m0_bufvec_cursor *dcur)
 }
 
 /*
- * Builds part of the buffer representing generic and PDCLUST layout type
- * specific parts of the layout object.
- */
-static void pdclust_buf_build(uint32_t let_id, uint64_t lid,
-			      uint32_t N, uint32_t K, uint32_t P,
-			      struct m0_uint128 *seed,
-			      struct m0_bufvec_cursor *dcur)
-{
-	struct m0_layout_pdclust_rec pl_rec;
-	m0_bcount_t                  nbytes_copied;
-
-	generic_buf_build(m0_pdclust_layout_type.lt_id, dcur);
-
-	pl_rec.pr_let_id            = let_id;
-	pl_rec.pr_attr.pa_N         = N;
-	pl_rec.pr_attr.pa_K         = K;
-	pl_rec.pr_attr.pa_P         = P;
-	pl_rec.pr_attr.pa_unit_size = UNIT_SIZE;
-	pl_rec.pr_attr.pa_seed      = *seed;
-
-	nbytes_copied = m0_bufvec_cursor_copyto(dcur, &pl_rec, sizeof pl_rec);
-	M0_UT_ASSERT(nbytes_copied == sizeof pl_rec);
-}
-
-/* Builds a buffer containing serialised representation of a layout object. */
-static int pdclust_layout_buf_build(uint32_t enum_id, uint64_t lid,
-				    uint32_t N, uint32_t K, uint32_t P,
-				    struct m0_uint128 *seed,
-				    uint32_t A, uint32_t B,
-				    struct m0_bufvec_cursor *dcur)
-{
-	uint32_t                     let_id;
-	m0_bcount_t                  nbytes_copied;
-	struct cob_entries_header    ce_header;
-	struct m0_fid                cob_id;
-	uint32_t                     i;
-	struct m0_layout_linear_attr lin_rec;
-
-	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
-	M0_UT_ASSERT(dcur != NULL);
-
-	/*
-	 * Build part of the buffer representing generic and the PDCLUST layout
-	 * type specific parts of the layout object.
-	 */
-	let_id = enum_id == LIST_ENUM_ID ? m0_list_enum_type.let_id :
-					   m0_linear_enum_type.let_id;
-	pdclust_buf_build(let_id, lid, N, K, P, seed, dcur);
-
-	/*
-	 * Build part of the buffer representing enum type specific part of
-	 * the layout object.
-	 */
-	if (enum_id == LIST_ENUM_ID) {
-		ce_header.ces_nr = P;
-		nbytes_copied = m0_bufvec_cursor_copyto(dcur, &ce_header,
-							sizeof ce_header);
-		M0_UT_ASSERT(nbytes_copied == sizeof ce_header);
-
-		for (i = 0; i < ce_header.ces_nr; ++i) {
-			m0_fid_set(&cob_id, i * 100 + 1, i + 1);
-			nbytes_copied = m0_bufvec_cursor_copyto(dcur, &cob_id,
-								sizeof cob_id);
-			M0_UT_ASSERT(nbytes_copied == sizeof cob_id);
-		}
-	} else {
-		lin_rec.lla_nr = P;
-		lin_rec.lla_A  = A;
-		lin_rec.lla_B  = B;
-
-		nbytes_copied = m0_bufvec_cursor_copyto(dcur, &lin_rec,
-							sizeof lin_rec);
-		M0_UT_ASSERT(nbytes_copied == sizeof lin_rec);
-	}
-
-	return 0;
-}
-
-/*
  * Allocates area with size returned by m0_layout_max_recsize() and with
  * additional_bytes required if any.
  * For example, additional_bytes are required for LIST enumeration type, and
@@ -1022,81 +632,6 @@ void allocate_area(void **area,
 	M0_UT_ASSERT(*area != NULL);
 }
 
-/* Tests the API m0_layout_decode() for PDCLUST layout type. */
-static int test_decode_pdclust(uint32_t enum_id, uint64_t lid,
-			       uint32_t inline_test,
-			       bool failure_test)
-{
-	void                    *area;
-	m0_bcount_t              num_bytes;
-	struct m0_bufvec         bv;
-	struct m0_bufvec_cursor  cur;
-	struct m0_layout        *l;
-	struct m0_uint128        seed;
-	uint32_t                 N;
-	uint32_t                 K;
-	uint32_t                 P;
-	struct m0_layout_type   *lt;
-
-	M0_ENTRY();
-	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
-
-	m0_uint128_init(&seed, "decodepdclustlay");
-
-	/* Build a layout buffer. */
-	if (enum_id == LIST_ENUM_ID)
-		allocate_area(&area, ADDITIONAL_BYTES_DEFAULT, &num_bytes);
-	else
-		allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
-
-	bv = (struct m0_bufvec) M0_BUFVEC_INIT_BUF(&area, &num_bytes);
-	m0_bufvec_cursor_init(&cur, &bv);
-
-	NKP_assign(enum_id,
-		   inline_test, 5, 125, 1500,
-		   &N, &K, &P);
-
-	rc = pdclust_layout_buf_build(enum_id, lid,
-				      N, K, P, &seed,
-				      777, 888, &cur);
-	M0_UT_ASSERT(rc == 0);
-
-	/* Rewind the cursor. */
-	m0_bufvec_cursor_init(&cur, &bv);
-
-	lt = &m0_pdclust_layout_type;
-	rc = lt->lt_ops->lto_allocate(&domain, lid, &l);
-	M0_UT_ASSERT(rc == 0);
-
-	/* Decode the layout buffer into a layout object. */
-	rc = m0_layout_decode(l, &cur, M0_LXO_BUFFER_OP, NULL);
-	if (failure_test)
-		M0_UT_ASSERT(rc == -ENOMEM || rc == -EPROTO);
-	else {
-		M0_UT_ASSERT(rc == 0);
-		M0_UT_ASSERT(list_lookup(lid) == l);
-
-		/* Verify the layout object built by m0_layout_decode(). */
-		pdclust_layout_verify(enum_id, l, lid,
-				      N, K, P, &seed,
-				      777, 888, !USER_COUNT_INCREMENTED);
-	}
-
-	/* Destroy the layout object. */
-	if (failure_test)
-		l->l_ops->lo_delete(l);
-	else {
-		/* Unlock the layout, locked by lto_allocate() */
-		m0_mutex_unlock(&l->l_lock);
-		m0_layout_put(l);
-	}
-	M0_UT_ASSERT(list_lookup(lid) == NULL);
-
-	m0_free(area);
-	M0_LEAVE();
-	return rc;
-}
-
 /* Tests the API m0_layout_decode(). */
 static void test_decode(void)
 {
@@ -1107,7 +642,8 @@ static void test_decode(void)
 	 * with a few inline entries only.
 	 */
 	lid = 3001;
-	rc = test_decode_pdclust(LIST_ENUM_ID, lid, LESS_THAN_INLINE,
+	rc = test_decode_pdclust(lid, &domain,
+				 LIST_ENUM_ID, LESS_THAN_INLINE,
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -1117,7 +653,8 @@ static void test_decode(void)
 	 * LDB_MAX_INLINE_COB_ENTRIES and then destroy it.
 	 */
 	lid = 3002;
-	rc = test_decode_pdclust(LIST_ENUM_ID, lid, EXACT_INLINE,
+	rc = test_decode_pdclust(lid, &domain,
+				 LIST_ENUM_ID, EXACT_INLINE,
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -1126,7 +663,8 @@ static void test_decode(void)
 	 * including noninline entries and then destroy it.
 	 */
 	lid = 3003;
-	rc = test_decode_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
+	rc = test_decode_pdclust(lid, &domain,
+				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -1135,7 +673,8 @@ static void test_decode(void)
 	 * type.
 	 */
 	lid = 3004;
-	rc = test_decode_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE,
+	rc = test_decode_pdclust(lid, &domain,
+				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -1172,63 +711,72 @@ static void test_decode_failure(void)
 	/* Simulate invalid attributes error in m0_layout_decode(). */
 	lid = 4001;
 	m0_fi_enable_once("m0_layout_decode", "attr_err");
-	rc = test_decode_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
+	rc = test_decode_pdclust(lid, &domain,
+				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EPROTO);
 
 	/* Simulate invalid attributes error in pdclust_decode(). */
 	lid = 4002;
 	m0_fi_enable_once("pdclust_decode", "attr_err1");
-	rc = test_decode_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
+	rc = test_decode_pdclust(lid, &domain,
+				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EPROTO);
 
 	/* Simulate invalid attributes error in pdclust_decode(). */
 	lid = 4003;
 	m0_fi_enable_once("pdclust_decode", "attr_err2");
-	rc = test_decode_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
+	rc = test_decode_pdclust(lid, &domain,
+				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EPROTO);
 
 	/* Simulate invalid attributes error in list_populate(). */
 	lid = 4004;
 	m0_fi_enable_once("list_decode", "attr_err");
-	rc = test_decode_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
+	rc = test_decode_pdclust(lid, &domain,
+				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EPROTO);
 
 	/* Simulate invalid attributes error in linear_populate(). */
 	lid = 4005;
 	m0_fi_enable_once("linear_decode", "attr_err");
-	rc = test_decode_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE,
+	rc = test_decode_pdclust(lid, &domain,
+				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EPROTO);
 
 	/* Simulate memory allocation failure in list_decode(). */
 	lid = 4006;
 	m0_fi_enable_once("list_decode", "mem_err");
-	rc = test_decode_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
+	rc = test_decode_pdclust(lid, &domain,
+				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 
 	/* Simulate fid invalid error in list_decode(). */
 	lid = 4007;
 	m0_fi_enable_once("list_decode", "fid_invalid_err");
-	rc = test_decode_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
+	rc = test_decode_pdclust(lid, &domain,
+				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EPROTO);
 
 	/* Simulate leto_allocate() failure in pdclust_decode(). */
 	lid = 4008;
 	m0_fi_enable_once("linear_allocate", "mem_err");
-	rc = test_decode_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE,
+	rc = test_decode_pdclust(lid, &domain,
+				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 
 	/* Simulate pdclust_populate() failure in pdclust_decode(). */
 	lid = 4009;
 	m0_fi_enable_once("pdclust_decode", "attr_err3");
-	rc = test_decode_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE,
+	rc = test_decode_pdclust(lid, &domain,
+				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EPROTO);
 }
@@ -1253,159 +801,6 @@ void lbuf_verify(struct m0_bufvec_cursor *cur, uint32_t *lt_id)
 	m0_bufvec_cursor_move(cur, sizeof *rec);
 }
 
-/*
- * Verifies part of the layout buffer representing PDCLUST layout type specific
- * part of the layout object.
- */
-static void pdclust_lbuf_verify(uint32_t N, uint32_t K, uint32_t P,
-				struct m0_uint128 *seed,
-				struct m0_bufvec_cursor *cur,
-				uint32_t *let_id)
-{
-	struct m0_layout_pdclust_rec *pl_rec;
-
-	M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >= sizeof *pl_rec);
-
-	pl_rec = m0_bufvec_cursor_addr(cur);
-
-	M0_UT_ASSERT(pl_rec->pr_attr.pa_N == N);
-	M0_UT_ASSERT(pl_rec->pr_attr.pa_K == K);
-	M0_UT_ASSERT(pl_rec->pr_attr.pa_P == P);
-	M0_UT_ASSERT(m0_uint128_eq(&pl_rec->pr_attr.pa_seed, seed));
-	M0_UT_ASSERT(pl_rec->pr_attr.pa_unit_size == UNIT_SIZE);
-
-	*let_id = pl_rec->pr_let_id;
-	m0_bufvec_cursor_move(cur, sizeof *pl_rec);
-}
-
-/* Verifies layout buffer against the various input arguments. */
-static void pdclust_layout_buf_verify(uint32_t enum_id, uint64_t lid,
-				      uint32_t N, uint32_t K, uint32_t P,
-				      struct m0_uint128 *seed,
-				      uint32_t A, uint32_t B,
-				      struct m0_bufvec_cursor *cur)
-{
-	uint32_t                      lt_id;
-	uint32_t                      let_id;
-	uint32_t                      i;
-	struct cob_entries_header    *ce_header;
-	struct m0_fid                *cob_id_from_layout;
-	struct m0_fid                 cob_id_calculated;
-	struct m0_layout_linear_attr *lin_attr;
-
-	M0_UT_ASSERT(cur != NULL);
-	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
-
-	/* Verify generic part of the layout buffer. */
-	lbuf_verify(cur, &lt_id);
-	M0_UT_ASSERT(lt_id == m0_pdclust_layout_type.lt_id);
-
-	/* Verify PDCLUST layout type specific part of the layout buffer. */
-	pdclust_lbuf_verify(N, K, P, seed, cur, &let_id);
-
-	/* Verify enum type specific part of the layout buffer. */
-	if (enum_id == LIST_ENUM_ID) {
-		M0_UT_ASSERT(let_id == m0_list_enum_type.let_id);
-
-		M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >= sizeof *ce_header);
-
-		ce_header = m0_bufvec_cursor_addr(cur);
-		M0_UT_ASSERT(ce_header != NULL);
-		m0_bufvec_cursor_move(cur, sizeof *ce_header);
-
-		M0_UT_ASSERT(ce_header->ces_nr == P);
-		M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >=
-			     ce_header->ces_nr * sizeof *cob_id_from_layout);
-
-		for (i = 0; i < ce_header->ces_nr; ++i) {
-			cob_id_from_layout = m0_bufvec_cursor_addr(cur);
-			M0_UT_ASSERT(cob_id_from_layout != NULL);
-
-			m0_fid_set(&cob_id_calculated, i * 100 + 1, i + 1);
-			M0_UT_ASSERT(m0_fid_eq(cob_id_from_layout,
-					       &cob_id_calculated));
-
-			m0_bufvec_cursor_move(cur, sizeof *cob_id_from_layout);
-		}
-	} else {
-		M0_UT_ASSERT(let_id == m0_linear_enum_type.let_id);
-
-		M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >= sizeof *lin_attr);
-
-		lin_attr = m0_bufvec_cursor_addr(cur);
-		M0_UT_ASSERT(lin_attr->lla_nr == P);
-		M0_UT_ASSERT(lin_attr->lla_A == A);
-		M0_UT_ASSERT(lin_attr->lla_B == B);
-	}
-}
-
-/* Tests the API m0_layout_encode() for PDCLUST layout type. */
-static int test_encode_pdclust(uint32_t enum_id, uint64_t lid,
-			       uint32_t inline_test,
-			       bool failure_test)
-{
-	struct m0_pdclust_layout     *pl;
-	void                         *area;
-	m0_bcount_t                   num_bytes;
-	struct m0_bufvec              bv;
-	struct m0_bufvec_cursor       cur;
-	struct m0_uint128             seed;
-	uint32_t                      N;
-	uint32_t                      K;
-	uint32_t                      P;
-	struct m0_layout_list_enum   *list_enum;
-	struct m0_layout_linear_enum *lin_enum;
-
-	M0_ENTRY("lid %llu", (unsigned long long)lid);
-	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
-
-	m0_uint128_init(&seed, "encodepdclustlay");
-
-	/* Build a layout object. */
-	NKP_assign(enum_id,
-		   inline_test, 10, 120, 120,
-		   &N, &K, &P);
-	rc = pdclust_layout_build(enum_id, lid,
-				  N, K, P, &seed,
-				  11, 21,
-				  &pl, &list_enum, &lin_enum,
-				  !FAILURE_TEST);
-	M0_UT_ASSERT(rc == 0);
-
-	/* Encode the layout object into a layout buffer. */
-	if (enum_id == LIST_ENUM_ID)
-		allocate_area(&area, ADDITIONAL_BYTES_DEFAULT, &num_bytes);
-	else
-		allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
-	bv = (struct m0_bufvec) M0_BUFVEC_INIT_BUF(&area, &num_bytes);
-	m0_bufvec_cursor_init(&cur, &bv);
-
-	m0_mutex_lock(&pl->pl_base.sl_base.l_lock);
-	rc  = m0_layout_encode(&pl->pl_base.sl_base, M0_LXO_BUFFER_OP,
-			       NULL, &cur);
-	m0_mutex_unlock(&pl->pl_base.sl_base.l_lock);
-	if (failure_test)
-		M0_UT_ASSERT(rc == LO_ENCODE_ERR);
-	else
-		M0_UT_ASSERT(rc == 0);
-
-	/* Rewind the cursor. */
-	m0_bufvec_cursor_init(&cur, &bv);
-
-	/* Verify the layout buffer produced by m0_layout_encode(). */
-	if (!failure_test)
-		pdclust_layout_buf_verify(enum_id, lid,
-					  N, K, P, &seed,
-					  11, 21, &cur);
-
-	/* Delete the layout object. */
-	m0_layout_put(&pl->pl_base.sl_base);
-	M0_UT_ASSERT(list_lookup(lid) == NULL);
-	m0_free(area);
-	M0_LEAVE();
-	return rc;
-}
-
 /* Tests the API m0_layout_encode(). */
 static void test_encode(void)
 {
@@ -1417,7 +812,8 @@ static void test_encode(void)
 	 * with a few inline entries only.
 	 */
 	lid = 5001;
-	rc = test_encode_pdclust(LIST_ENUM_ID, lid, LESS_THAN_INLINE,
+	rc = test_encode_pdclust(lid, &domain,
+				 LIST_ENUM_ID, LESS_THAN_INLINE,
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -1427,7 +823,8 @@ static void test_encode(void)
 	 * LDB_MAX_INLINE_COB_ENTRIES.
 	 */
 	lid = 5002;
-	rc = test_encode_pdclust(LIST_ENUM_ID, lid, EXACT_INLINE,
+	rc = test_encode_pdclust(lid, &domain,
+				 LIST_ENUM_ID, EXACT_INLINE,
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -1436,13 +833,15 @@ static void test_encode(void)
 	 * including noninline entries and then destroy it.
 	 */
 	lid = 5003;
-	rc = test_encode_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
+	rc = test_encode_pdclust(lid, &domain,
+				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	/* Encode for PDCLUST layout type and LINEAR enumeration type. */
 	lid = 5004;
-	rc = test_encode_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE,
+	rc = test_encode_pdclust(lid, &domain,
+				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -1480,14 +879,16 @@ static void test_encode_failure(void)
 	/* Simulate m0_layout_encode() failure. */
 	lid = 6001;
 	m0_fi_enable_once("m0_layout_encode", "lo_encode_err");
-	rc = test_encode_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
+	rc = test_encode_pdclust(lid, &domain,
+				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == LO_ENCODE_ERR);
 
 	/* Simulate m0_layout_encode() failure. */
 	lid = 6002;
 	m0_fi_enable_once("m0_layout_encode", "lo_encode_err");
-	rc = test_encode_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE,
+	rc = test_encode_pdclust(lid, &domain,
+				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == LO_ENCODE_ERR);
 }
@@ -1512,191 +913,6 @@ void lbuf_compare(struct m0_bufvec_cursor *cur1,
 	m0_bufvec_cursor_move(cur2, sizeof *rec2);
 }
 
-/* Compares PDCLUST layout type specific part of the layout buffers. */
-static void pdclust_lbuf_compare(struct m0_bufvec_cursor *cur1,
-				 struct m0_bufvec_cursor *cur2)
-{
-	struct m0_layout_pdclust_rec *pl_rec1;
-	struct m0_layout_pdclust_rec *pl_rec2;
-
-	M0_UT_ASSERT(m0_bufvec_cursor_step(cur1) >= sizeof *pl_rec1);
-	M0_UT_ASSERT(m0_bufvec_cursor_step(cur2) >= sizeof *pl_rec2);
-
-	pl_rec1 = m0_bufvec_cursor_addr(cur1);
-	pl_rec2 = m0_bufvec_cursor_addr(cur2);
-
-	M0_UT_ASSERT(pl_rec1->pr_attr.pa_N == pl_rec2->pr_attr.pa_N);
-	M0_UT_ASSERT(pl_rec1->pr_attr.pa_K == pl_rec2->pr_attr.pa_K);
-	M0_UT_ASSERT(pl_rec1->pr_attr.pa_P == pl_rec2->pr_attr.pa_P);
-	M0_UT_ASSERT(m0_uint128_eq(&pl_rec1->pr_attr.pa_seed,
-				   &pl_rec2->pr_attr.pa_seed));
-	M0_UT_ASSERT(pl_rec1->pr_attr.pa_unit_size ==
-		     pl_rec2->pr_attr.pa_unit_size);
-
-	m0_bufvec_cursor_move(cur1, sizeof *pl_rec1);
-	m0_bufvec_cursor_move(cur2, sizeof *pl_rec2);
-}
-
-/* Compares two layout buffers provided as input arguments. */
-static void pdclust_layout_buf_compare(uint32_t enum_id,
-				       struct m0_bufvec_cursor *cur1,
-				       struct m0_bufvec_cursor *cur2)
-{
-	struct cob_entries_header    *ce_header1;
-	struct cob_entries_header    *ce_header2;
-	struct m0_fid                *cob_id1;
-	struct m0_fid                *cob_id2;
-	struct m0_layout_linear_attr *lin_attr1;
-	struct m0_layout_linear_attr *lin_attr2;
-	uint32_t                      i;
-
-	M0_UT_ASSERT(cur1 != NULL);
-	M0_UT_ASSERT(cur2 != NULL);
-	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
-
-	/* Compare generic part of the layout buffers. */
-	lbuf_compare(cur1, cur2);
-
-	/* Compare PDCLUST layout type specific part of the layout buffers. */
-	pdclust_lbuf_compare(cur1, cur2);
-
-	/* Compare enumeration type specific part of the layout buffers. */
-	if (enum_id == LIST_ENUM_ID) {
-		M0_UT_ASSERT(m0_bufvec_cursor_step(cur1) >= sizeof *ce_header1);
-		M0_UT_ASSERT(m0_bufvec_cursor_step(cur2) >= sizeof *ce_header2);
-
-		ce_header1 = m0_bufvec_cursor_addr(cur1);
-		ce_header2 = m0_bufvec_cursor_addr(cur2);
-
-		m0_bufvec_cursor_move(cur1, sizeof *ce_header1);
-		m0_bufvec_cursor_move(cur2, sizeof *ce_header2);
-
-		M0_UT_ASSERT(ce_header1->ces_nr == ce_header2->ces_nr);
-
-		M0_UT_ASSERT(m0_bufvec_cursor_step(cur1) >=
-			     ce_header1->ces_nr * sizeof *cob_id1);
-		M0_UT_ASSERT(m0_bufvec_cursor_step(cur2) >=
-			     ce_header2->ces_nr * sizeof *cob_id2);
-
-		for (i = 0; i < ce_header1->ces_nr; ++i) {
-			cob_id1 = m0_bufvec_cursor_addr(cur1);
-			cob_id2 = m0_bufvec_cursor_addr(cur2);
-
-			M0_UT_ASSERT(m0_fid_eq(cob_id1, cob_id2));
-
-			m0_bufvec_cursor_move(cur1, sizeof *cob_id1);
-			m0_bufvec_cursor_move(cur2, sizeof *cob_id2);
-		}
-	} else {
-		M0_UT_ASSERT(m0_bufvec_cursor_step(cur1) >= sizeof *lin_attr1);
-		M0_UT_ASSERT(m0_bufvec_cursor_step(cur2) >= sizeof *lin_attr2);
-
-		lin_attr1 = m0_bufvec_cursor_addr(cur1);
-		lin_attr2 = m0_bufvec_cursor_addr(cur2);
-
-		M0_UT_ASSERT(lin_attr1->lla_nr == lin_attr2->lla_nr);
-		M0_UT_ASSERT(lin_attr1->lla_A == lin_attr2->lla_A);
-		M0_UT_ASSERT(lin_attr1->lla_B == lin_attr2->lla_B);
-	}
-}
-
-/*
- * Tests the API sequence m0_layout_decode() followed by m0_layout_encode(),
- * for the PDCLUST layout type.
- */
-static int test_decode_encode_pdclust(uint32_t enum_id, uint64_t lid,
-				      uint32_t inline_test)
-{
-	void                    *area1;
-	struct m0_bufvec         bv1;
-	struct m0_bufvec_cursor  cur1;
-	void                    *area2;
-	struct m0_bufvec         bv2;
-	struct m0_bufvec_cursor  cur2;
-	m0_bcount_t              num_bytes;
-	uint32_t                 N;
-	uint32_t                 K;
-	uint32_t                 P;
-	struct m0_uint128        seed;
-	struct m0_layout        *l;
-	struct m0_layout_type   *lt;
-
-	M0_ENTRY();
-	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
-
-	m0_uint128_init(&seed, "decodeencodepdcl");
-
-	/* Build a layout buffer. */
-	if (enum_id == LIST_ENUM_ID)
-		allocate_area(&area1, ADDITIONAL_BYTES_DEFAULT, &num_bytes);
-	else
-		allocate_area(&area1, ADDITIONAL_BYTES_NONE, &num_bytes);
-
-	bv1 = (struct m0_bufvec) M0_BUFVEC_INIT_BUF(&area1, &num_bytes);
-	m0_bufvec_cursor_init(&cur1, &bv1);
-
-	NKP_assign(enum_id,
-		   inline_test, 3, 103, 1510,
-		   &N, &K, &P);
-
-	rc = pdclust_layout_buf_build(LINEAR_ENUM_ID, lid,
-				      N, K, P, &seed,
-				      777, 888, &cur1);
-	M0_UT_ASSERT(rc == 0);
-
-	/* Rewind the cursor. */
-	m0_bufvec_cursor_init(&cur1, &bv1);
-
-	lt = &m0_pdclust_layout_type;
-	rc = lt->lt_ops->lto_allocate(&domain, lid, &l);
-	M0_UT_ASSERT(rc == 0);
-
-	/* Decode the layout buffer into a layout object. */
-	rc = m0_layout_decode(l, &cur1, M0_LXO_BUFFER_OP, NULL);
-	M0_UT_ASSERT(rc == 0);
-
-	/* Unlock the layout, locked by lto_allocate() */
-	m0_mutex_unlock(&l->l_lock);
-
-	/* Rewind the cursor. */
-	m0_bufvec_cursor_init(&cur1, &bv1);
-
-	/*
-	 * Encode the layout object produced by m0_layout_decode() into
-	 * another layout buffer.
-	 */
-	if (enum_id == LIST_ENUM_ID)
-		allocate_area(&area2, ADDITIONAL_BYTES_DEFAULT, &num_bytes);
-	else
-		allocate_area(&area2, ADDITIONAL_BYTES_NONE, &num_bytes);
-
-	bv2 = (struct m0_bufvec) M0_BUFVEC_INIT_BUF(&area2, &num_bytes);
-	m0_bufvec_cursor_init(&cur2, &bv2);
-
-	m0_mutex_lock(&l->l_lock);
-	rc = m0_layout_encode(l, M0_LXO_BUFFER_OP, NULL, &cur2);
-	m0_mutex_unlock(&l->l_lock);
-	M0_UT_ASSERT(rc == 0);
-
-	/* Rewind the cursor. */
-	m0_bufvec_cursor_init(&cur2, &bv2);
-
-	/*
-	 * Compare the two layout buffers - one created earlier here and
-	 * the one that is produced by m0_layout_encode().
-	 */
-	pdclust_layout_buf_compare(enum_id, &cur1, &cur2);
-
-	/* Destroy the layout. */
-	m0_layout_put(l);
-	M0_UT_ASSERT(list_lookup(lid) == NULL);
-
-	m0_free(area1);
-	m0_free(area2);
-	M0_LEAVE();
-	return rc;
-}
-
 /* Tests the API sequence m0_layout_decode() followed by m0_layout_encode(). */
 static void test_decode_encode(void)
 {
@@ -1712,7 +928,8 @@ static void test_decode_encode(void)
 	 * buffer.
 	 */
 	lid = 7001;
-	rc = test_decode_encode_pdclust(LIST_ENUM_ID, lid, LESS_THAN_INLINE);
+	rc = test_decode_encode_pdclust(lid, &domain,
+					LIST_ENUM_ID, LESS_THAN_INLINE);
 	M0_UT_ASSERT(rc == 0);
 
 	/*
@@ -1725,7 +942,8 @@ static void test_decode_encode(void)
 	 * buffer.
 	 */
 	lid = 7002;
-	rc = test_decode_encode_pdclust(LIST_ENUM_ID, lid, EXACT_INLINE);
+	rc = test_decode_encode_pdclust(lid, &domain,
+					LIST_ENUM_ID, EXACT_INLINE);
 	M0_UT_ASSERT(rc == 0);
 
 	/*
@@ -1737,7 +955,8 @@ static void test_decode_encode(void)
 	 * buffer.
 	 */
 	lid = 7003;
-	rc = test_decode_encode_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE);
+	rc = test_decode_encode_pdclust(lid, &domain,
+					LIST_ENUM_ID, MORE_THAN_INLINE);
 	M0_UT_ASSERT(rc == 0);
 
 	/*
@@ -1749,8 +968,8 @@ static void test_decode_encode(void)
 	 * buffer.
 	 */
 	lid = 7004;
-	rc = test_decode_encode_pdclust(LINEAR_ENUM_ID, lid,
-					INLINE_NOT_APPLICABLE);
+	rc = test_decode_encode_pdclust(lid, &domain,
+					LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE);
 	M0_UT_ASSERT(rc == 0);
 
 	m0_fi_enable("m0_composite_layer_add", "skip_DB_sync");
@@ -1789,73 +1008,6 @@ void layout_compare(const struct m0_layout *l1,
 	M0_UT_ASSERT(l1->l_ops == l2->l_ops);
 }
 
-/*
- * Compares two layout objects with PDCLUST layout type, provided as input
- * arguments.
- */
-static void pdclust_layout_compare(uint32_t enum_id,
-				   const struct m0_layout *l1,
-				   const struct m0_layout *l2,
-				   bool l2_ref_elevated)
-{
-	struct m0_pdclust_layout     *pl1;
-	struct m0_pdclust_layout     *pl2;
-	struct m0_layout_list_enum   *list_e1;
-	struct m0_layout_list_enum   *list_e2;
-	struct m0_layout_linear_enum *lin_e1;
-	struct m0_layout_linear_enum *lin_e2;
-	uint32_t                      i;
-
-	M0_UT_ASSERT(l1 != NULL && l2 != NULL);
-	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
-
-	/* Compare generic part of the layout objects. */
-	layout_compare(l1, l2, l2_ref_elevated);
-
-	/* Compare PDCLUST layout type specific part of the layout objects. */
-	pl1 = container_of(l1, struct m0_pdclust_layout, pl_base.sl_base);
-	pl2 = container_of(l2, struct m0_pdclust_layout, pl_base.sl_base);
-
-	M0_UT_ASSERT(pl1->pl_attr.pa_N == pl2->pl_attr.pa_N);
-	M0_UT_ASSERT(pl1->pl_attr.pa_K == pl2->pl_attr.pa_K);
-	M0_UT_ASSERT(pl1->pl_attr.pa_P == pl2->pl_attr.pa_P);
-	M0_UT_ASSERT(m0_uint128_eq(&pl1->pl_attr.pa_seed,
-				   &pl2->pl_attr.pa_seed));
-
-	/* Compare enumeration specific part of the layout objects. */
-	M0_UT_ASSERT(pl1->pl_base.sl_enum->le_type ==
-		     pl2->pl_base.sl_enum->le_type);
-	M0_UT_ASSERT(pl1->pl_base.sl_enum->le_sl == &pl1->pl_base);
-	M0_UT_ASSERT(pl1->pl_base.sl_enum->le_sl->sl_base.l_id ==
-		     pl2->pl_base.sl_enum->le_sl->sl_base.l_id);
-	M0_UT_ASSERT(pl1->pl_base.sl_enum->le_ops ==
-		     pl2->pl_base.sl_enum->le_ops);
-
-	/* Compare enumeration type specific part of the layout objects. */
-	if (enum_id == LIST_ENUM_ID) {
-		list_e1 = container_of(pl1->pl_base.sl_enum,
-				       struct m0_layout_list_enum, lle_base);
-		list_e2 = container_of(pl2->pl_base.sl_enum,
-				       struct m0_layout_list_enum, lle_base);
-
-		M0_UT_ASSERT(list_e1->lle_nr == list_e2->lle_nr);
-
-		for (i = 0; i < list_e1->lle_nr; ++i)
-			M0_UT_ASSERT(m0_fid_eq(&list_e1->lle_list_of_cobs[i],
-					       &list_e2->lle_list_of_cobs[i]));
-	} else { /* LINEAR_ENUM_ID */
-		lin_e1 = container_of(pl1->pl_base.sl_enum,
-				      struct m0_layout_linear_enum, lle_base);
-		lin_e2 = container_of(pl2->pl_base.sl_enum,
-				      struct m0_layout_linear_enum, lle_base);
-
-		M0_UT_ASSERT(lin_e1->lle_attr.lla_nr ==
-			     lin_e2->lle_attr.lla_nr);
-		M0_UT_ASSERT(lin_e1->lle_attr.lla_A == lin_e2->lle_attr.lla_A);
-		M0_UT_ASSERT(lin_e1->lle_attr.lla_B == lin_e2->lle_attr.lla_B);
-	}
-}
-
 /* Copies generic part of the layout object. */
 void layout_copy(const struct m0_layout *l_src,
 		 struct m0_layout *l_dest)
@@ -1868,184 +1020,6 @@ void layout_copy(const struct m0_layout *l_src,
 	m0_ref_init(&l_dest->l_ref, 1, l_src->l_ops->lo_fini);
 }
 
-/* Copies contents of one layout object to the other. */
-static void pdclust_layout_copy(uint32_t enum_id,
-				const struct m0_layout *l_src,
-				struct m0_layout **l_dest)
-{
-	struct m0_pdclust_layout     *pl_src;
-	struct m0_pdclust_layout     *pl_dest;
-	struct m0_layout_list_enum   *list_src;
-	struct m0_layout_list_enum   *list_dest;
-	struct m0_layout_linear_enum *lin_src;
-	struct m0_layout_linear_enum *lin_dest;
-	uint32_t                      i;
-
-	M0_UT_ASSERT(l_src != NULL && l_dest != NULL);
-	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
-
-	pl_src = container_of(l_src, struct m0_pdclust_layout,
-			      pl_base.sl_base);
-	M0_ALLOC_PTR(pl_dest);
-	M0_UT_ASSERT(pl_dest != NULL);
-	*l_dest = &pl_dest->pl_base.sl_base;
-
-	/* Copy generic part of the layout object. */
-	layout_copy(l_src, *l_dest);
-
-	/* Copy PDCLUST layout type specific part of the layout objects. */
-	pl_dest->pl_attr = pl_src->pl_attr;
-
-	/* Copy enumeration type specific part of the layout objects. */
-	if (enum_id == LIST_ENUM_ID) {
-		list_src = container_of(pl_src->pl_base.sl_enum,
-					struct m0_layout_list_enum, lle_base);
-		list_dest = m0_alloc(sizeof *list_src);
-		M0_UT_ASSERT(list_src != NULL);
-
-		list_dest->lle_nr = list_src->lle_nr;
-		M0_ALLOC_ARR(list_dest->lle_list_of_cobs, list_dest->lle_nr);
-
-		for (i = 0; i < list_src->lle_nr; ++i)
-			list_dest->lle_list_of_cobs[i] =
-					       list_src->lle_list_of_cobs[i];
-
-		pl_dest->pl_base.sl_enum = &list_dest->lle_base;
-	} else { /* LINEAR_ENUM_ID */
-		lin_src = container_of(pl_src->pl_base.sl_enum,
-				       struct m0_layout_linear_enum, lle_base);
-		lin_dest = m0_alloc(sizeof *lin_src);
-		M0_UT_ASSERT(lin_src != NULL);
-
-		lin_dest->lle_attr = lin_src->lle_attr;
-		pl_dest->pl_base.sl_enum = &lin_dest->lle_base;
-	}
-
-	/* Copy enumeration specific part of the layout objects. */
-	pl_dest->pl_base.sl_enum->le_type = pl_src->pl_base.sl_enum->le_type;
-	pl_dest->pl_base.sl_enum->le_ops = pl_src->pl_base.sl_enum->le_ops;
-	pl_dest->pl_base.sl_enum->le_sl = &pl_dest->pl_base;
-
-	pdclust_layout_compare(enum_id, &pl_src->pl_base.sl_base,
-			       &pl_dest->pl_base.sl_base, false);
-}
-
-static void pdclust_layout_copy_delete(uint32_t enum_id, struct m0_layout *l)
-{
-	struct m0_pdclust_layout     *pl;
-	struct m0_layout_list_enum   *list_enum;
-	struct m0_layout_linear_enum *lin_enum;
-
-	M0_UT_ASSERT(l != NULL);
-	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
-
-	pl = container_of(l, struct m0_pdclust_layout, pl_base.sl_base);
-	if (enum_id == LIST_ENUM_ID) {
-		list_enum = container_of(pl->pl_base.sl_enum,
-					struct m0_layout_list_enum, lle_base);
-		m0_free(list_enum->lle_list_of_cobs);
-		m0_free(list_enum);
-	} else { /* LINEAR_ENUM_ID */
-		lin_enum = container_of(pl->pl_base.sl_enum,
-				        struct m0_layout_linear_enum, lle_base);
-		m0_free(lin_enum);
-	}
-
-	m0_free(pl);
-}
-
-/*
- * Tests the API sequence m0_layout_encode() followed by m0_layout_decode(),
- * for the PDCLUST layout type.
- */
-static int test_encode_decode_pdclust(uint32_t enum_id, uint64_t lid,
-				      uint32_t inline_test)
-{
-	struct m0_pdclust_layout     *pl;
-	void                         *area;
-	m0_bcount_t                   num_bytes;
-	struct m0_bufvec              bv;
-	struct m0_bufvec_cursor       cur;
-	struct m0_uint128             seed;
-	uint32_t                      N;
-	uint32_t                      K;
-	uint32_t                      P;
-	struct m0_layout_list_enum   *list_enum;
-	struct m0_layout_linear_enum *lin_enum;
-	struct m0_layout             *l;
-	struct m0_layout             *l_copy;
-	struct m0_layout_type        *lt;
-
-	M0_ENTRY("lid %llu", (unsigned long long)lid);
-	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
-
-	m0_uint128_init(&seed, "encodedecodepdcl");
-
-	/* Build a layout object. */
-	NKP_assign(enum_id,
-		   inline_test, 13, 113, 1130,
-		   &N, &K, &P);
-	rc = pdclust_layout_build(enum_id, lid,
-				  N, K, P, &seed,
-				  10, 20,
-				  &pl, &list_enum, &lin_enum,
-				  !FAILURE_TEST);
-	M0_UT_ASSERT(rc == 0);
-
-	pdclust_layout_copy(enum_id, &pl->pl_base.sl_base, &l_copy);
-	M0_UT_ASSERT(l_copy != NULL);
-
-	/* Encode the layout object into a layout buffer. */
-	if (enum_id == LIST_ENUM_ID)
-		allocate_area(&area, ADDITIONAL_BYTES_DEFAULT, &num_bytes);
-	else
-		allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
-	bv = (struct m0_bufvec) M0_BUFVEC_INIT_BUF(&area, &num_bytes);
-	m0_bufvec_cursor_init(&cur, &bv);
-
-	m0_mutex_lock(&pl->pl_base.sl_base.l_lock);
-	rc = m0_layout_encode(&pl->pl_base.sl_base, M0_LXO_BUFFER_OP,
-			      NULL, &cur);
-	m0_mutex_unlock(&pl->pl_base.sl_base.l_lock);
-	M0_UT_ASSERT(rc == 0);
-
-	/* Destroy the layout. */
-	m0_layout_put(&pl->pl_base.sl_base);
-	M0_UT_ASSERT(list_lookup(lid) == NULL);
-
-	/* Rewind the cursor. */
-	m0_bufvec_cursor_init(&cur, &bv);
-
-	lt = &m0_pdclust_layout_type;
-	rc = lt->lt_ops->lto_allocate(&domain, lid, &l);
-	M0_UT_ASSERT(rc == 0);
-
-	/*
-	 * Decode the layout buffer produced by m0_layout_encode() into another
-	 * layout object.
-	 */
-	rc = m0_layout_decode(l, &cur, M0_LXO_BUFFER_OP, NULL);
-	M0_UT_ASSERT(rc == 0);
-
-	/*
-	 * Comapre the two layout objects - one created earlier here and the
-	 * one that is produced by m0_layout_decode().
-	 */
-	pdclust_layout_compare(enum_id, l_copy, l, false);
-	pdclust_layout_copy_delete(enum_id, l_copy);
-
-	/* Unlock the layout, locked by lto_allocate() */
-	m0_mutex_unlock(&l->l_lock);
-
-	/* Destroy the layout. */
-	m0_layout_put(l);
-	M0_UT_ASSERT(list_lookup(lid) == NULL);
-
-	m0_free(area);
-	M0_LEAVE();
-	return rc;
-}
-
 /* Tests the API sequence m0_layout_encode() followed by m0_layout_decode(). */
 static void test_encode_decode(void)
 {
@@ -2061,7 +1035,8 @@ static void test_encode_decode(void)
 	 * object.
 	 */
 	lid = 8001;
-	rc = test_encode_decode_pdclust(LIST_ENUM_ID, lid, LESS_THAN_INLINE);
+	rc = test_encode_decode_pdclust(lid, &domain,
+					LIST_ENUM_ID, LESS_THAN_INLINE);
 	M0_UT_ASSERT(rc == 0);
 
 	/*
@@ -2074,7 +1049,8 @@ static void test_encode_decode(void)
 	 * object.
 	 */
 	lid = 8002;
-	rc = test_encode_decode_pdclust(LIST_ENUM_ID, lid, EXACT_INLINE);
+	rc = test_encode_decode_pdclust(lid, &domain,
+					LIST_ENUM_ID, EXACT_INLINE);
 	M0_UT_ASSERT(rc == 0);
 
 	/*
@@ -2086,7 +1062,8 @@ static void test_encode_decode(void)
 	 * object.
 	 */
 	lid = 8003;
-	rc = test_encode_decode_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE);
+	rc = test_encode_decode_pdclust(lid, &domain,
+					LIST_ENUM_ID, MORE_THAN_INLINE);
 	M0_UT_ASSERT(rc == 0);
 
 	/*
@@ -2097,8 +1074,8 @@ static void test_encode_decode(void)
 	 * object.
 	 */
 	lid = 8004;
-	rc = test_encode_decode_pdclust(LINEAR_ENUM_ID, lid,
-					INLINE_NOT_APPLICABLE);
+	rc = test_encode_decode_pdclust(lid, &domain,
+					LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE);
 	M0_UT_ASSERT(rc == 0);
 
 	m0_fi_enable("m0_composite_layer_add", "skip_DB_sync");
@@ -2118,59 +1095,6 @@ static void test_encode_decode(void)
 	m0_fi_disable("m0_composite_layer_add", "skip_DB_sync");
 }
 
-/*
- * Tests the API m0_layout_get() and m0_layout_put(), for the PDCLUST layout
- * type.
- */
-static int test_ref_get_put_pdclust(uint32_t enum_id, uint64_t lid)
-{
-	struct m0_pdclust_layout     *pl;
-	struct m0_uint128             seed;
-	uint32_t                      N;
-	uint32_t                      K;
-	uint32_t                      P;
-	struct m0_layout_list_enum   *list_enum;
-	struct m0_layout_linear_enum *lin_enum;
-	uint32_t                      i;
-
-	M0_ENTRY("lid %llu", (unsigned long long)lid);
-	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
-
-	m0_uint128_init(&seed, "refgetputpdclust");
-
-	/* Build a layout object. */
-	NKP_assign(enum_id, MORE_THAN_INLINE,
-		   10, 1212, 1212,
-		   &N, &K, &P);
-
-	rc = pdclust_layout_build(LIST_ENUM_ID, lid,
-				  N, K, P, &seed,
-				  10, 20,
-				  &pl, &list_enum, &lin_enum,
-				  !FAILURE_TEST);
-	M0_UT_ASSERT(rc == 0);
-
-	/* Verify that the ref count is set to 1. */
-	M0_UT_ASSERT(m0_ref_read(&pl->pl_base.sl_base.l_ref) == 1);
-
-	/* Add multiple references on the layout object. */
-	for (i = 0; i < 123; ++i)
-		m0_layout_get(&pl->pl_base.sl_base);
-	M0_UT_ASSERT(m0_ref_read(&pl->pl_base.sl_base.l_ref) == 1 + 123);
-
-	/* Release multiple references on the layout object. */
-	for (i = 0; i < 123; ++i)
-		m0_layout_put(&pl->pl_base.sl_base);
-	M0_UT_ASSERT(m0_ref_read(&pl->pl_base.sl_base.l_ref) == 1);
-
-	/* Release the last reference so as to delete the layout. */
-	m0_layout_put(&pl->pl_base.sl_base);
-	M0_UT_ASSERT(list_lookup(lid) == NULL);
-
-	M0_LEAVE();
-	return rc;
-}
-
 /* Tests the APIs m0_layout_get() and m0_layout_put(). */
 static void test_ref_get_put(void)
 {
@@ -2182,7 +1106,7 @@ static void test_ref_get_put(void)
 	 * enumeration type.
 	 */
 	lid = 9001;
-	rc = test_ref_get_put_pdclust(LIST_ENUM_ID, lid);
+	rc = test_ref_get_put_pdclust(lid, &domain, LIST_ENUM_ID);
 	M0_UT_ASSERT(rc == 0);
 
 	/*
@@ -2190,13 +1114,13 @@ static void test_ref_get_put(void)
 	 * enumeration type.
 	 */
 	lid = 9002;
-	rc = test_ref_get_put_pdclust(LINEAR_ENUM_ID, lid);
+	rc = test_ref_get_put_pdclust(lid, &domain, LINEAR_ENUM_ID);
 	M0_UT_ASSERT(rc == 0);
 }
 
 /* Verifies the enum operations pointed by leo_nr and leo_get. */
-static void enum_op_verify(uint32_t enum_id, uint64_t lid,
-			   uint32_t nr, struct m0_layout *l)
+void enum_op_verify(struct m0_layout *l, uint64_t lid,
+		    uint32_t enum_id, uint32_t nr)
 {
 	struct m0_striped_layout     *stl;
 	struct m0_layout_enum        *e;
@@ -2236,49 +1160,6 @@ static void enum_op_verify(uint32_t enum_id, uint64_t lid,
 	}
 }
 
-/*
- * Tests the enum operations pointed by leo_nr and leo_get, for the PDCLUST
- * layout type.
- */
-static int test_enum_ops_pdclust(uint32_t enum_id, uint64_t lid,
-				 uint32_t inline_test)
-{
-	struct m0_uint128             seed;
-	uint32_t                      N;
-	uint32_t                      K;
-	uint32_t                      P;
-	struct m0_pdclust_layout     *pl;
-	struct m0_layout_list_enum   *list_enum;
-	struct m0_layout_linear_enum *lin_enum;
-
-	M0_ENTRY();
-	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
-
-	/* Build a layout object. */
-	m0_uint128_init(&seed, "enumopspdclustla");
-
-	NKP_assign(enum_id,
-		   inline_test, 14, 1014, 1014,
-		   &N, &K, &P);
-
-	rc = pdclust_layout_build(enum_id, lid,
-				  N, K, P, &seed,
-				  777, 888,
-				  &pl, &list_enum, &lin_enum,
-				  !FAILURE_TEST);
-	M0_UT_ASSERT(rc == 0);
-
-	/* Verify enum operations. */
-	enum_op_verify(enum_id, lid, P, &pl->pl_base.sl_base);
-
-	/* Destroy the layout object. */
-	m0_layout_put(&pl->pl_base.sl_base);
-	M0_UT_ASSERT(list_lookup(lid) == NULL);
-
-	M0_LEAVE();
-	return rc;
-}
-
 /* Tests the enum operations pointed by leo_nr and leo_get. */
 static void test_enum_operations(void)
 {
@@ -2290,7 +1171,8 @@ static void test_enum_operations(void)
 	 * And then verify its enum ops.
 	 */
 	lid = 10001;
-	rc = test_enum_ops_pdclust(LIST_ENUM_ID, lid, LESS_THAN_INLINE);
+	rc = test_enum_ops_pdclust(lid, &domain,
+				   LIST_ENUM_ID, LESS_THAN_INLINE);
 	M0_UT_ASSERT(rc == 0);
 
 	/*
@@ -2300,7 +1182,8 @@ static void test_enum_operations(void)
 	 * And then verify its enum ops.
 	 */
 	lid = 10002;
-	rc = test_enum_ops_pdclust(LIST_ENUM_ID, lid, EXACT_INLINE);
+	rc = test_enum_ops_pdclust(lid, &domain,
+				   LIST_ENUM_ID, EXACT_INLINE);
 	M0_UT_ASSERT(rc == 0);
 
 	/*
@@ -2309,7 +1192,8 @@ static void test_enum_operations(void)
 	 * And then verify its enum ops.
 	 */
 	lid = 10003;
-	rc = test_enum_ops_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE);
+	rc = test_enum_ops_pdclust(lid, &domain,
+				   LIST_ENUM_ID, MORE_THAN_INLINE);
 	M0_UT_ASSERT(rc == 0);
 
 	/*
@@ -2317,7 +1201,8 @@ static void test_enum_operations(void)
 	 * And then verify its enum ops.
 	 */
 	lid = 10004;
-	rc = test_enum_ops_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE);
+	rc = test_enum_ops_pdclust(lid, &domain,
+				   LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE);
 	M0_UT_ASSERT(rc == 0);
 }
 
@@ -2330,8 +1215,6 @@ static void test_max_recsize(void)
 	m0_bcount_t             max_size_from_api;
 	m0_bcount_t             max_size_calculated;
 
-	M0_ENTRY();
-
 	/*
 	 * A layout type can be registered with only one domain at a time.
 	 * Hence, unregister all the available layout types and enum types from
@@ -2425,97 +1308,6 @@ static void test_max_recsize(void)
 	 */
 	rc = m0_layout_standard_types_register(&domain);
 	M0_ASSERT(rc == 0);
-
-	M0_LEAVE();
-}
-
-/*
- * Calculates the recsize by considering the sizes of the internal data
- * structures and their values, as applicable. Then verifies that the recsize
- * provided as an argument matches the calcualted one.
- */
-static void pdclust_recsize_verify(uint32_t enum_id,
-				   struct m0_layout *l,
-				   m0_bcount_t recsize_to_verify)
-{
-	struct m0_pdclust_layout    *pl;
-	struct m0_layout_list_enum  *list_enum;
-	m0_bcount_t                  recsize;
-
-	M0_UT_ASSERT(l != NULL);
-	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
-	M0_UT_ASSERT(l->l_type == &m0_pdclust_layout_type);
-
-	pl = container_of(l, struct m0_pdclust_layout, pl_base.sl_base);
-
-	/* Account for the enum type specific recsize. */
-	if (enum_id == LIST_ENUM_ID) {
-		list_enum = container_of(pl->pl_base.sl_enum,
-					 struct m0_layout_list_enum, lle_base);
-		if (list_enum->lle_nr < LDB_MAX_INLINE_COB_ENTRIES)
-			recsize = sizeof(struct cob_entries_header) +
-				  list_enum->lle_nr * sizeof(struct m0_fid);
-		else
-			recsize = sizeof(struct cob_entries_header) +
-				  LDB_MAX_INLINE_COB_ENTRIES *
-				  sizeof(struct m0_fid);
-	} else
-		recsize = sizeof(struct m0_layout_linear_attr);
-
-	/*
-	 * Account for the recsize for the generic part of the layout object
-	 * and for the PDCLUST layout type specific part of it.
-	 */
-	recsize = sizeof(struct m0_layout_rec) +
-		  sizeof(struct m0_layout_pdclust_rec) + recsize;
-
-	/* Compare the two sizes. */
-	M0_UT_ASSERT(recsize == recsize_to_verify);
-}
-
-/* Tests the function lo_recsize(), for the PDCLUST layout type. */
-static int test_recsize_pdclust(uint32_t enum_id, uint64_t lid,
-				uint32_t inline_test)
-{
-	struct m0_pdclust_layout     *pl;
-	struct m0_layout             *l;
-	struct m0_uint128             seed;
-	uint32_t                      N;
-	uint32_t                      K;
-	uint32_t                      P;
-	struct m0_layout_list_enum   *list_enum;
-	struct m0_layout_linear_enum *lin_enum;
-	m0_bcount_t                   recsize;
-
-	M0_ENTRY("lid %llu", (unsigned long long)lid);
-	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
-
-	m0_uint128_init(&seed, "recsizepdclustla");
-
-	/* Build a layout object. */
-	NKP_assign(enum_id,
-		   inline_test, 1, 1200, 1111,
-		   &N, &K, &P);
-
-	rc = pdclust_layout_build(enum_id, lid,
-				  N, K, P, &seed,
-				  10, 20,
-				  &pl, &list_enum, &lin_enum,
-				  !FAILURE_TEST);
-	M0_UT_ASSERT(rc == 0);
-
-	/* Obtain the recsize by using the internal function lo_recsize(). */
-	l = &pl->pl_base.sl_base;
-	recsize = l->l_ops->lo_recsize(l);
-
-	/* Verify the recsize returned by lo_recsize(). */
-	pdclust_recsize_verify(enum_id, &pl->pl_base.sl_base, recsize);
-
-	/* Destroy the layout object. */
-	m0_layout_put(l);
-	M0_UT_ASSERT(list_lookup(lid) == NULL);
-	M0_LEAVE();
-	return rc;
 }
 
 /* Tests the function lo_recsize(). */
@@ -2529,7 +1321,8 @@ static void test_recsize(void)
 	 * with a few inline entries only.
 	 */
 	lid = 11001;
-	rc = test_recsize_pdclust(LIST_ENUM_ID, lid, LESS_THAN_INLINE);
+	rc = test_recsize_pdclust(lid, &domain,
+				  LIST_ENUM_ID, LESS_THAN_INLINE);
 	M0_UT_ASSERT(rc == 0);
 
 	/*
@@ -2538,7 +1331,8 @@ static void test_recsize(void)
 	 * LDB_MAX_INLINE_COB_ENTRIES
 	 */
 	lid = 11002;
-	rc = test_recsize_pdclust(LIST_ENUM_ID, lid, EXACT_INLINE);
+	rc = test_recsize_pdclust(lid, &domain,
+				  LIST_ENUM_ID, EXACT_INLINE);
 	M0_UT_ASSERT(rc == 0);
 
 	/*
@@ -2546,92 +1340,17 @@ static void test_recsize(void)
 	 * including noninline entries.
 	 */
 	lid = 11003;
-	rc = test_recsize_pdclust(LIST_ENUM_ID, lid, MORE_THAN_INLINE);
+	rc = test_recsize_pdclust(lid, &domain,
+				  LIST_ENUM_ID, MORE_THAN_INLINE);
 	M0_UT_ASSERT(rc == 0);
 
 	/* lo_recsize() for PDCLUST layout type and LINEAR enumeration type. */
 	lid = 11004;
-	rc = test_recsize_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE);
+	rc = test_recsize_pdclust(lid, &domain,
+				  LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE);
 	M0_UT_ASSERT(rc == 0);
 }
 
-/* Tests the APIs supported for m0_pdclust_instance object. */
-static int test_pdclust_instance_obj(uint32_t enum_id, uint64_t lid,
-				     bool inline_test, bool failure_test)
-{
-	struct m0_uint128             seed;
-	uint32_t                      N;
-	uint32_t                      K;
-	uint32_t                      P;
-	struct m0_layout             *l;
-	struct m0_pdclust_layout     *pl;
-	struct m0_layout_list_enum   *list_enum;
-	struct m0_layout_linear_enum *lin_enum;
-	struct m0_pdclust_instance   *pi;
-	struct m0_fid                 gfid;
-	struct m0_layout_instance    *li;
-
-	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
-
-	m0_uint128_init(&seed, "buildpdclustlayo");
-
-	NKP_assign(enum_id,
-		   inline_test, 14, 30, 30,
-		   &N, &K, &P);
-
-	rc = pdclust_layout_build(enum_id, lid,
-				  N, K, P, &seed,
-				  10, 20,
-				  &pl, &list_enum, &lin_enum,
-				  !FAILURE_TEST);
-	M0_UT_ASSERT(rc == 0);
-
-	/* Verify some pdclust APIs. */
-	M0_UT_ASSERT(m0_pdclust_N(pl) == N);
-	M0_UT_ASSERT(m0_pdclust_K(pl) == K);
-	M0_UT_ASSERT(m0_pdclust_P(pl) == P);
-	M0_UT_ASSERT(m0_pdclust_unit_size(pl) == UNIT_SIZE);
-
-	M0_UT_ASSERT(m0_pdclust_unit_classify(pl, N - 1) == M0_PUT_DATA);
-	M0_UT_ASSERT(m0_pdclust_unit_classify(pl, N) == M0_PUT_PARITY);
-	M0_UT_ASSERT(m0_pdclust_unit_classify(pl, N + 2 * K ) == M0_PUT_SPARE);
-
-	/* Build pdclust instance. */
-	m0_fid_set(&gfid, 0, 999);
-	l = m0_pdl_to_layout(pl);
-	M0_UT_ASSERT(m0_ref_read(&l->l_ref) == 1);
-	rc = m0_layout_instance_build(l, &gfid, &li);
-	if (failure_test)
-		M0_UT_ASSERT(rc == -ENOMEM || rc == -EPROTO);
-	else {
-		M0_UT_ASSERT(rc == 0);
-		M0_UT_ASSERT(m0_ref_read(&l->l_ref) == 2);
-		pi = m0_layout_instance_to_pdi(li);
-		layout_demo(pi, pl, 1, 1, false);
-
-		/* Verify m0_layout_instance_to_pdi(). */
-		li = &pi->pi_base;
-		M0_UT_ASSERT(m0_layout_instance_to_pdi(li) == pi);
-
-		/* Verify m0_layout_instance_to_enum */
-		if (enum_id == LIST_ENUM_ID)
-			M0_UT_ASSERT(m0_layout_instance_to_enum(li) ==
-				     &list_enum->lle_base);
-		else
-			M0_UT_ASSERT(m0_layout_instance_to_enum(li) ==
-				     &lin_enum->lle_base);
-
-		/* Delete the pdclust instance object. */
-		m0_layout_instance_fini(&pi->pi_base);
-		M0_UT_ASSERT(m0_ref_read(&l->l_ref) == 1);
-	}
-
-	/* Delete the layout object. */
-	m0_layout_put(m0_pdl_to_layout(pl)); //todo l
-	M0_UT_ASSERT(list_lookup(lid) == NULL);
-	return rc;
-}
-
 /*
  * Tests the APIs supported for m0_pdclust_instance object, for various enum
  * types.
@@ -2645,7 +1364,8 @@ static void test_pdclust_instance(void)
 	 * LIST enum type with a few inline entries only.
 	 */
 	lid = 12001;
-	rc = test_pdclust_instance_obj(LIST_ENUM_ID, lid, LESS_THAN_INLINE,
+	rc = test_pdclust_instance_obj(lid, &domain,
+				       LIST_ENUM_ID, LESS_THAN_INLINE,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -2655,7 +1375,8 @@ static void test_pdclust_instance(void)
 	 * LDB_MAX_INLINE_COB_ENTRIES.
 	 */
 	lid = 12002;
-	rc = test_pdclust_instance_obj(LIST_ENUM_ID, lid, EXACT_INLINE,
+	rc = test_pdclust_instance_obj(lid, &domain,
+				       LIST_ENUM_ID, EXACT_INLINE,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -2664,7 +1385,8 @@ static void test_pdclust_instance(void)
 	 * LIST enum type including noninline entries.
 	 */
 	lid = 12003;
-	rc = test_pdclust_instance_obj(LIST_ENUM_ID, lid, MORE_THAN_INLINE,
+	rc = test_pdclust_instance_obj(lid, &domain,
+				       LIST_ENUM_ID, MORE_THAN_INLINE,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -2673,8 +1395,8 @@ static void test_pdclust_instance(void)
 	 * LINEAR enum type.
 	 */
 	lid = 12004;
-	rc = test_pdclust_instance_obj(LINEAR_ENUM_ID, lid,
-				       INLINE_NOT_APPLICABLE,
+	rc = test_pdclust_instance_obj(lid, &domain,
+				       LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				       !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 }
@@ -2686,15 +1408,16 @@ static void test_pdclust_instance_failure(void)
 	/* Simulate memory allocation error in m0_pdclust_instance_build(). */
 	lid = 13001;
 	m0_fi_enable_once("pdclust_instance_build", "mem_err1");
-	rc = test_pdclust_instance_obj(LIST_ENUM_ID, lid, LESS_THAN_INLINE,
+	rc = test_pdclust_instance_obj(lid, &domain,
+				       LIST_ENUM_ID, LESS_THAN_INLINE,
 				       FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 
 	/* Simulate memory allocation error in m0_pdclust_instance_build(). */
 	lid = 13002;
 	m0_fi_enable_once("pdclust_instance_build", "mem_err2");
-	rc = test_pdclust_instance_obj(LINEAR_ENUM_ID, lid,
-				       INLINE_NOT_APPLICABLE,
+	rc = test_pdclust_instance_obj(lid, &domain,
+				       LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				       FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 
@@ -2704,8 +1427,8 @@ static void test_pdclust_instance_failure(void)
 	 */
 	lid = 13003;
 	m0_fi_enable_once("pdclust_instance_build", "parity_math_err");
-	rc = test_pdclust_instance_obj(LINEAR_ENUM_ID, lid,
-				       INLINE_NOT_APPLICABLE,
+	rc = test_pdclust_instance_obj(lid, &domain,
+				       LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				       FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EPROTO);
 }
@@ -2739,110 +1462,19 @@ void pair_set(struct m0_db_pair *pair, uint64_t *lid,
 	pair->dp_rec.db_buf.b_nob  = num_bytes;
 }
 
-static int test_add_pdclust(uint32_t enum_id, uint64_t lid,
-			    uint32_t inline_test,
-			    bool layout_destroy, struct m0_layout **l_obj,
-			    bool duplicate_test,
-			    bool failure_test);
-
-/* Tests the API m0_layout_lookup(), for the PDCLUST layout type. */
-static int test_lookup_pdclust(uint32_t enum_id, uint64_t lid,
-			       bool existing_test,
-			       uint32_t inline_test,
-			       bool failure_test)
-{
-	m0_bcount_t        num_bytes;
-	void              *area;
-	struct m0_layout  *l1;
-	struct m0_layout  *l1_copy;
-	struct m0_layout  *l2;
-	struct m0_layout  *l3;
-	struct m0_db_pair  pair;
-	struct m0_db_tx    tx;
-	int                rc_tmp;
-
-	M0_ENTRY();
-	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
-	M0_UT_ASSERT(ergo(!existing_test, failure_test));
-
-	/*
-	 * If existing_test is true, then first add a layout object to the
-	 * DB.
-	 */
-	if (existing_test) {
-		rc = test_add_pdclust(enum_id, lid,
-				      inline_test,
-				      !LAYOUT_DESTROY, &l1,
-				      !DUPLICATE_TEST,
-				      !FAILURE_TEST);
-		M0_UT_ASSERT(rc == 0);
-		if (!failure_test)
-			pdclust_layout_copy(enum_id, l1, &l1_copy);
-
-		/*
-		 * Lookup for the layout object to verify that the same object
-		 * is returned from the memory, not requiring a lookup from the
-		 * DB.
-		 */
-		rc = m0_layout_lookup(&domain, lid, &m0_pdclust_layout_type,
-				      &tx, &pair, &l2);
-		M0_UT_ASSERT(rc == 0);
-		M0_UT_ASSERT(l2 == l1);
-
-		/* Release the reference acquired by m0_layout_lookup(). */
-		m0_layout_put(l1);
-
-		/* Destroy the layout object. */
-		m0_layout_put(l1);
-	}
-
-	M0_UT_ASSERT(list_lookup(lid) == NULL);
-
-	/* Lookup for the layout object from the DB. */
-	allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
-
-	rc = m0_db_tx_init(&tx, &dbenv, DBFLAGS);
-	M0_UT_ASSERT(rc == 0);
-
-	pair_set(&pair, &lid, area, num_bytes);
-
-	rc = m0_layout_lookup(&domain, lid, &m0_pdclust_layout_type,
-			      &tx, &pair, &l3);
-	if (failure_test)
-		M0_UT_ASSERT(rc == -ENOENT || rc == -ENOMEM || rc == -EPROTO ||
-			     rc == LO_DECODE_ERR);
-	else
-		M0_UT_ASSERT(rc == 0);
-
-	rc_tmp = m0_db_tx_commit(&tx);
-	M0_UT_ASSERT(rc_tmp == 0);
-
-	if (existing_test && !failure_test) {
-		M0_UT_ASSERT(list_lookup(lid) == l3);
-		pdclust_layout_compare(enum_id, l1_copy, l3, false);
-		pdclust_layout_copy_delete(enum_id, l1_copy);
-
-		/* Destroy the layout object. */
-		m0_layout_put(l3);
-		M0_UT_ASSERT(list_lookup(lid) == NULL);
-	}
-	m0_free(area);
-	M0_LEAVE();
-	return rc;
-}
-
+#if 0 //todo rm
 struct ghost_data {
 	uint64_t                 lid;
 	struct m0_layout        *l;
 	struct m0_bufvec_cursor *cur;
 };
+#endif
 
-static bool ghost_create(void *d)
+bool ghost_create(void *d)
 {
 	struct ghost_data     *data = d;
 	struct m0_layout_type *lt;
 
-	M0_ENTRY();
 	M0_UT_ASSERT(list_lookup(data->lid) == NULL);
 
 	lt = &m0_pdclust_layout_type;
@@ -2855,114 +1487,8 @@ static bool ghost_create(void *d)
 
 	/* Unlock the layout, locked by lto_allocate() */
 	m0_mutex_unlock(&data->l->l_lock);
-
-	M0_LEAVE();
-	return rc;
-}
-
-static int test_lookup_with_ghost_creation(uint32_t enum_id, uint64_t lid,
-					   uint32_t inline_test)
-{
-	struct m0_layout        *l1;
-	struct m0_layout        *l1_copy;
-	struct ghost_data        g_data = { 0 };
-	void                    *area_for_encode;
-	m0_bcount_t              num_bytes_for_encode;
-	struct m0_bufvec         bv_for_encode;
-	struct m0_bufvec_cursor  cur_for_encode;
-	struct m0_layout        *l_from_DB;
-	m0_bcount_t              num_bytes_for_lookup;
-	void                    *area_for_lookup;
-	struct m0_db_pair        pair;
-	struct m0_db_tx          tx;
-	int                      rc_tmp;
-
-	M0_ENTRY();
-	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
-
-	/* Create one layout object and add it to the LDB. */
-	rc = test_add_pdclust(enum_id, lid,
-			      inline_test,
-			      !LAYOUT_DESTROY, &l1,
-			      !DUPLICATE_TEST,
-			      !FAILURE_TEST);
-	M0_UT_ASSERT(rc == 0);
-	pdclust_layout_copy(enum_id, l1, &l1_copy);
-
-        /*
-	 * Encode the layout object and store its encoded representation into
-	 * the ghost_data (g_data.cur) so that the ghost can be created at a
-	 * later point.
-	 */
-	if (enum_id == LIST_ENUM_ID)
-		allocate_area(&area_for_encode, ADDITIONAL_BYTES_DEFAULT,
-			      &num_bytes_for_encode);
-	else
-		allocate_area(&area_for_encode, ADDITIONAL_BYTES_NONE,
-			      &num_bytes_for_encode);
-	bv_for_encode = (struct m0_bufvec) M0_BUFVEC_INIT_BUF(&area_for_encode,
-						&num_bytes_for_encode);
-	m0_bufvec_cursor_init(&cur_for_encode, &bv_for_encode);
-	m0_mutex_lock(&l1->l_lock);
-	rc = m0_layout_encode(l1, M0_LXO_BUFFER_OP, NULL, &cur_for_encode);
-	m0_mutex_unlock(&l1->l_lock);
-	M0_UT_ASSERT(rc == 0);
-	/* Rewind the cursor. */
-	m0_bufvec_cursor_init(&cur_for_encode, &bv_for_encode);
-	g_data.cur = &cur_for_encode;
-	g_data.lid = lid;
-
-	/*
-	 * Destroy the layout object, so that the next m0_layout_lookup() does
-	 * not return right away with the layout object read from memory and
-	 * instead goes to the LDB to read it.
-	 */
-	m0_layout_put(l1);
-	M0_UT_ASSERT(list_lookup(lid) == NULL);
-
-	/*
-	 * Lookup for the layout object from the LDB, using m0_layout_lookup().
-	 * But while this m0_layout_lookup() is in progress, ghost_create()
-	 * will create another in-memory layout object using m0_layout_decode()
-	 * performed on the serialised representation of the same layout
-	 * created above and stored in g_data.cur.
-	 */
-	if (enum_id == LIST_ENUM_ID)
-		allocate_area(&area_for_lookup, ADDITIONAL_BYTES_DEFAULT,
-			      &num_bytes_for_lookup);
-	else
-		allocate_area(&area_for_lookup, ADDITIONAL_BYTES_NONE,
-			      &num_bytes_for_lookup);
-
-	rc = m0_db_tx_init(&tx, &dbenv, DBFLAGS);
-	M0_UT_ASSERT(rc == 0);
-
-	pair_set(&pair, &lid, area_for_lookup, num_bytes_for_lookup);
-	m0_fi_enable_func("m0_layout_lookup", "ghost_creation",
-			  ghost_create, &g_data);
-	rc = m0_layout_lookup(&domain, lid, &m0_pdclust_layout_type,
-			      &tx, &pair, &l_from_DB);
-	M0_UT_ASSERT(rc == 0);
-	m0_layout_put(l_from_DB);
-	m0_fi_disable("m0_layout_lookup", "ghost_creation");
-	rc_tmp = m0_db_tx_commit(&tx);
-	M0_UT_ASSERT(rc_tmp == 0);
-
-	M0_UT_ASSERT(l_from_DB == g_data.l);
-	M0_UT_ASSERT(list_lookup(lid) == l_from_DB);
-	pdclust_layout_compare(enum_id, l1_copy, l_from_DB, false);
-	pdclust_layout_copy_delete(enum_id, l1_copy);
-
-	/* Destroy the layout object. */
-	m0_layout_put(l_from_DB);
-	M0_UT_ASSERT(list_lookup(lid) == NULL);
-
-	m0_free(area_for_encode);
-	m0_free(area_for_lookup);
-	M0_LEAVE();
 	return rc;
 }
-
 /* Tests the API m0_layout_lookup(). */
 static void test_lookup(void)
 {
@@ -2973,9 +1499,9 @@ static void test_lookup(void)
 	 * exist in the DB.
 	 */
 	lid = 14001;
-	rc = test_lookup_pdclust(LIST_ENUM_ID, lid,
+	rc = test_lookup_pdclust(lid, &domain,
+				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 !EXISTING_TEST,
-				 MORE_THAN_INLINE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOENT);
 
@@ -2984,9 +1510,9 @@ static void test_lookup(void)
 	 * with a few inline entries only. Then perform lookup for it.
 	 */
 	lid = 14002;
-	rc = test_lookup_pdclust(LIST_ENUM_ID, lid,
+	rc = test_lookup_pdclust(lid, &domain,
+				 LIST_ENUM_ID, LESS_THAN_INLINE,
 				 EXISTING_TEST,
-				 LESS_THAN_INLINE,
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -2996,9 +1522,9 @@ static void test_lookup(void)
 	 * LDB_MAX_INLINE_COB_ENTRIES. Then perform lookup for it.
 	 */
 	lid = 14003;
-	rc = test_lookup_pdclust(LIST_ENUM_ID, lid,
+	rc = test_lookup_pdclust(lid, &domain,
+				 LIST_ENUM_ID, EXACT_INLINE,
 				 EXISTING_TEST,
-				 EXACT_INLINE,
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -3008,9 +1534,9 @@ static void test_lookup(void)
 	 * Then perform lookup for it.
 	 */
 	lid = 14004;
-	rc = test_lookup_pdclust(LIST_ENUM_ID, lid,
+	rc = test_lookup_pdclust(lid, &domain,
+				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 EXISTING_TEST,
-				 MORE_THAN_INLINE,
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -3019,9 +1545,9 @@ static void test_lookup(void)
 	 * for a layout object that does not exist in the DB.
 	 */
 	lid = 14005;
-	rc = test_lookup_pdclust(LIST_ENUM_ID, lid,
+	rc = test_lookup_pdclust(lid, &domain,
+				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 !EXISTING_TEST,
-				 MORE_THAN_INLINE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOENT);
 
@@ -3030,9 +1556,9 @@ static void test_lookup(void)
 	 * Then perform lookup for it.
 	 */
 	lid = 14006;
-	rc = test_lookup_pdclust(LINEAR_ENUM_ID, lid,
+	rc = test_lookup_pdclust(lid, &domain,
+				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				 EXISTING_TEST,
-				 INLINE_NOT_APPLICABLE,
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -3042,8 +1568,9 @@ static void test_lookup(void)
 	 * m0_layout_lookup() with having the domain lock released.
 	 */
 	lid = 14007;
-	rc = test_lookup_with_ghost_creation(LINEAR_ENUM_ID, lid,
-					     INLINE_NOT_APPLICABLE);
+	rc = test_lookup_pdclust_with_ghost_creation(lid, &domain,
+						     LINEAR_ENUM_ID,
+						     INLINE_NOT_APPLICABLE);
 	M0_UT_ASSERT(rc == 0);
 
 	/*
@@ -3108,16 +1635,14 @@ static void test_lookup_failure(void)
 	struct m0_db_pair  pair;
 	struct m0_layout  *l;
 
-	M0_ENTRY();
-
 	/*
 	 * Lookup for a layout object with LIST enum type, that does not
 	 * exist in the DB.
 	 */
 	lid = 15001;
-	rc = test_lookup_pdclust(LIST_ENUM_ID, lid,
+	rc = test_lookup_pdclust(lid, &domain,
+				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 !EXISTING_TEST,
-				 MORE_THAN_INLINE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOENT);
 
@@ -3126,18 +1651,18 @@ static void test_lookup_failure(void)
 	 * exist in the DB.
 	 */
 	lid = 15002;
-	rc = test_lookup_pdclust(LINEAR_ENUM_ID, lid,
+	rc = test_lookup_pdclust(lid, &domain,
+				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				 !EXISTING_TEST,
-				 INLINE_NOT_APPLICABLE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOENT);
 
 	/* Simulate pdclust_allocate() failure in m0_layout_lookup(). */
 	lid = 15003;
 	m0_fi_enable_off_n_on_m("pdclust_allocate", "mem_err", 1, 1);
-	rc = test_lookup_pdclust(LINEAR_ENUM_ID, lid,
+	rc = test_lookup_pdclust(lid, &domain,
+				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				 EXISTING_TEST,
-				 INLINE_NOT_APPLICABLE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 	m0_fi_disable("pdclust_allocate", "mem_err");
@@ -3145,9 +1670,9 @@ static void test_lookup_failure(void)
 	/* Simulate m0_layout_decode() failure in m0_layout_lookup(). */
 	lid = 15004;
 	m0_fi_enable_once("m0_layout_decode", "lo_decode_err");
-	rc = test_lookup_pdclust(LINEAR_ENUM_ID, lid,
+	rc = test_lookup_pdclust(lid, &domain,
+				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				 EXISTING_TEST,
-				 INLINE_NOT_APPLICABLE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == LO_DECODE_ERR);
 
@@ -3168,9 +1693,9 @@ static void test_lookup_failure(void)
 	 */
 	lid = 15006;
 	m0_fi_enable_once("noninline_read", "cursor_init_err");
-	rc = test_lookup_pdclust(LIST_ENUM_ID, lid,
+	rc = test_lookup_pdclust(lid, &domain,
+				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 EXISTING_TEST,
-				 MORE_THAN_INLINE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOENT);
 
@@ -3180,9 +1705,9 @@ static void test_lookup_failure(void)
 	 */
 	lid = 15007;
 	m0_fi_enable_once("noninline_read", "cursor_get_err");
-	rc = test_lookup_pdclust(LIST_ENUM_ID, lid,
+	rc = test_lookup_pdclust(lid, &domain,
+				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 EXISTING_TEST,
-				 MORE_THAN_INLINE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 
@@ -3192,101 +1717,11 @@ static void test_lookup_failure(void)
 	 */
 	lid = 15008;
 	m0_fi_enable_once("noninline_read", "invalid_fid_err");
-	rc = test_lookup_pdclust(LIST_ENUM_ID, lid,
+	rc = test_lookup_pdclust(lid, &domain,
+				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 EXISTING_TEST,
-				 MORE_THAN_INLINE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EPROTO);
-
-	M0_LEAVE();
-}
-
-/* Tests the API m0_layout_add(), for the PDCLUST layout type. */
-static int test_add_pdclust(uint32_t enum_id, uint64_t lid,
-			    uint32_t inline_test,
-			    bool layout_destroy, struct m0_layout **l_obj,
-			    bool duplicate_test,
-			    bool failure_test)
-{
-	m0_bcount_t                   num_bytes;
-	uint32_t                      N;
-	uint32_t                      K;
-	uint32_t                      P;
-	void                         *area;
-	struct m0_pdclust_layout     *pl;
-	struct m0_db_pair             pair;
-	struct m0_db_tx               tx;
-	struct m0_uint128             seed;
-	struct m0_layout_list_enum   *list_enum;
-	struct m0_layout_linear_enum *lin_enum;
-	int                           rc_tmp;
-
-	M0_ENTRY("lid %llu", (unsigned long long)lid);
-	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
-	M0_UT_ASSERT(ergo(layout_destroy, l_obj == NULL));
-	M0_UT_ASSERT(ergo(!layout_destroy, l_obj != NULL));
-	M0_UT_ASSERT(ergo(duplicate_test, !failure_test));
-
-	m0_uint128_init(&seed, "addpdclustlayout");
-
-	allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
-
-	/* Build a layout object. */
-	NKP_assign(enum_id,
-		   inline_test, 7, 1900, 1900,
-		   &N, &K, &P);
-
-	rc = pdclust_layout_build(enum_id, lid,
-				  N, K, P, &seed,
-				  100, 200,
-				  &pl, &list_enum, &lin_enum,
-				  !FAILURE_TEST);
-	M0_UT_ASSERT(rc == 0);
-
-	/* Add the layout object to the DB. */
-	rc = m0_db_tx_init(&tx, &dbenv, DBFLAGS);
-	M0_UT_ASSERT(rc == 0);
-
-	pair_set(&pair, &lid, area, num_bytes);
-
-	rc = m0_layout_add(&pl->pl_base.sl_base, &tx, &pair);
-	if (failure_test)
-		M0_UT_ASSERT(rc == -ENOENT || rc == LO_ENCODE_ERR);
-	else
-		M0_UT_ASSERT(rc == 0);
-
-	rc_tmp = m0_db_tx_commit(&tx);
-	M0_UT_ASSERT(rc_tmp == 0);
-
-	M0_UT_ASSERT(list_lookup(lid) == &pl->pl_base.sl_base);
-
-	/*
-	 * If duplicate_test is true, again try to add the same layout object
-	 * to the DB, to verify that it results into EEXIST error.
-	 */
-	if (duplicate_test) {
-		rc = m0_db_tx_init(&tx, &dbenv, DBFLAGS);
-		M0_UT_ASSERT(rc == 0);
-
-		pair_set(&pair, &lid, area, num_bytes);
-
-		rc = m0_layout_add(&pl->pl_base.sl_base, &tx, &pair);
-		M0_UT_ASSERT(rc == -EEXIST);
-
-		rc_tmp = m0_db_tx_commit(&tx);
-		M0_UT_ASSERT(rc_tmp == 0);
-	}
-
-	if (layout_destroy) {
-		m0_layout_put(&pl->pl_base.sl_base);
-		M0_UT_ASSERT(list_lookup(lid) == NULL);
-	}
-	else
-		*l_obj = &pl->pl_base.sl_base;
-
-	m0_free(area);
-	M0_LEAVE("lid %llu", (unsigned long long)lid);
-	return rc;
 }
 
 /* Tests the API m0_layout_add(). */
@@ -3299,8 +1734,8 @@ static void test_add(void)
 	 * with a few inline entries only.
 	 */
 	lid = 16001;
-	rc = test_add_pdclust(LIST_ENUM_ID, lid,
-			      LESS_THAN_INLINE,
+	rc = test_add_pdclust(lid, &domain,
+			      LIST_ENUM_ID, LESS_THAN_INLINE,
 			      LAYOUT_DESTROY, NULL,
 			      !DUPLICATE_TEST,
 			      !FAILURE_TEST);
@@ -3312,8 +1747,8 @@ static void test_add(void)
 	 * LDB_MAX_INLINE_COB_ENTRIES.
 	 */
 	lid = 16002;
-	rc = test_add_pdclust(LIST_ENUM_ID, lid,
-			      EXACT_INLINE,
+	rc = test_add_pdclust(lid, &domain,
+			      LIST_ENUM_ID, EXACT_INLINE,
 			      LAYOUT_DESTROY, NULL,
 			      !DUPLICATE_TEST,
 			      !FAILURE_TEST);
@@ -3324,8 +1759,8 @@ static void test_add(void)
 	 * including noninline entries.
 	 */
 	lid = 16003;
-	rc = test_add_pdclust(LIST_ENUM_ID, lid,
-			      MORE_THAN_INLINE,
+	rc = test_add_pdclust(lid, &domain,
+			      LIST_ENUM_ID, MORE_THAN_INLINE,
 			      LAYOUT_DESTROY, NULL,
 			      !DUPLICATE_TEST,
 			      !FAILURE_TEST);
@@ -3333,8 +1768,8 @@ static void test_add(void)
 
 	/* Add a layout object with PDCLUST layout type and LINEAR enum type. */
 	lid = 16004;
-	rc = test_add_pdclust(LINEAR_ENUM_ID, lid,
-			      INLINE_NOT_APPLICABLE,
+	rc = test_add_pdclust(lid, &domain,
+			      LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 			      LAYOUT_DESTROY, NULL,
 			      !DUPLICATE_TEST,
 			      !FAILURE_TEST);
@@ -3371,8 +1806,8 @@ static void test_add_failure(void)
 	/* Simulate m0_layout_encode() failure in m0_layout_add(). */
 	lid = 17001;
 	m0_fi_enable_once("m0_layout_encode", "lo_encode_err");
-	rc = test_add_pdclust(LIST_ENUM_ID, lid,
-			      MORE_THAN_INLINE,
+	rc = test_add_pdclust(lid, &domain,
+			      LIST_ENUM_ID, MORE_THAN_INLINE,
 			      LAYOUT_DESTROY, NULL,
 			      !DUPLICATE_TEST,
 			      FAILURE_TEST);
@@ -3387,8 +1822,8 @@ static void test_add_failure(void)
 	 * DUPLICATE_TEST.
 	 */
 	lid = 17002;
-	rc = test_add_pdclust(LINEAR_ENUM_ID, lid,
-			      INLINE_NOT_APPLICABLE,
+	rc = test_add_pdclust(lid, &domain,
+			      LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 			      LAYOUT_DESTROY, NULL,
 			      DUPLICATE_TEST,
 			      !FAILURE_TEST);
@@ -3400,8 +1835,8 @@ static void test_add_failure(void)
 	 */
 	lid = 17003;
 	m0_fi_enable_once("noninline_write", "cursor_init_err");
-	rc = test_add_pdclust(LIST_ENUM_ID, lid,
-			      MORE_THAN_INLINE,
+	rc = test_add_pdclust(lid, &domain,
+			      LIST_ENUM_ID, MORE_THAN_INLINE,
 			      LAYOUT_DESTROY, NULL,
 			      !DUPLICATE_TEST,
 			      FAILURE_TEST);
@@ -3413,8 +1848,8 @@ static void test_add_failure(void)
 	 */
 	lid = 17004;
 	m0_fi_enable_once("noninline_write", "cursor_add_err");
-	rc = test_add_pdclust(LIST_ENUM_ID, lid,
-			      MORE_THAN_INLINE,
+	rc = test_add_pdclust(lid, &domain,
+			      LIST_ENUM_ID, MORE_THAN_INLINE,
 			      LAYOUT_DESTROY, NULL,
 			      !DUPLICATE_TEST,
 			      FAILURE_TEST);
@@ -3459,136 +1894,6 @@ static void test_add_failure(void)
 
 }
 
-/* Tests the API m0_layout_update(), for the PDCLUST layout type. */
-static int test_update_pdclust(uint32_t enum_id, uint64_t lid,
-			       bool existing_test,
-			       uint32_t inline_test,
-			       bool failure_test)
-{
-	m0_bcount_t                   num_bytes;
-	void                         *area;
-	struct m0_db_pair             pair;
-	struct m0_db_tx               tx;
-	struct m0_layout             *l1;
-	struct m0_layout             *l1_copy;
-	struct m0_layout             *l2;
-	uint32_t                      i;
-	struct m0_uint128             seed;
-	uint32_t                      N;
-	uint32_t                      K;
-	uint32_t                      P;
-	struct m0_pdclust_layout     *pl;
-	struct m0_layout_list_enum   *list_enum;
-	struct m0_layout_linear_enum *lin_enum;
-	int                           rc_tmp;
-
-	M0_ENTRY();
-	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
-
-	allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
-
-	NKP_assign(enum_id,
-		   inline_test, 13, 123, 1230,
-		   &N, &K, &P);
-
-	if (existing_test) {
-		/* Add a layout object to the DB. */
-		rc = test_add_pdclust(enum_id, lid,
-				      inline_test,
-				      !LAYOUT_DESTROY, &l1,
-				      !DUPLICATE_TEST,
-				      !FAILURE_TEST);
-		M0_UT_ASSERT(rc == 0);
-	} else {
-		/* Build a layout object. */
-		m0_uint128_init(&seed, "updatepdclustlay");
-
-		rc = pdclust_layout_build(enum_id, lid,
-					  N, K, P, &seed,
-					  10, 20,
-					  &pl, &list_enum, &lin_enum,
-					  !FAILURE_TEST);
-		M0_UT_ASSERT(rc == 0);
-		l1 = &pl->pl_base.sl_base;
-	}
-
-	/* Verify the original user count is as expected. */
-	M0_UT_ASSERT(l1->l_user_count == 0);
-
-	/* Update the in-memory layout object - update its user count. */
-	for (i = 0; i < 100; ++i)
-		m0_layout_user_count_inc(l1);
-	M0_UT_ASSERT(l1->l_user_count == 100);
-
-	/* Update the layout object in the DB. */
-	rc = m0_db_tx_init(&tx, &dbenv, DBFLAGS);
-	M0_UT_ASSERT(rc == 0);
-
-	pair_set(&pair, &lid, area, num_bytes);
-
-	rc = m0_layout_update(l1, &tx, &pair);
-	if (failure_test)
-		M0_UT_ASSERT(rc == LO_ENCODE_ERR || rc == L_TABLE_UPDATE_ERR);
-	else
-		M0_UT_ASSERT(rc == 0);
-	/*
-	 * Even a non-existing record can be written to the database using
-	 * the database update operation.
-	 */
-	if (existing_test && !failure_test)
-		pdclust_layout_copy(enum_id, l1, &l1_copy);
-
-	rc_tmp = m0_db_tx_commit(&tx);
-	M0_UT_ASSERT(rc_tmp == 0);
-
-	/*
-	 * Update the in-memory layout object - update its user count. This is
-	 * to verify the functioning of m0_layout_user_count_dec().
-	 */
-	for (i = 0; i < 50; ++i)
-		m0_layout_user_count_dec(l1);
-	M0_UT_ASSERT(l1->l_user_count == 50);
-
-	/* Delete the in-memory layout. */
-	m0_layout_put(l1);
-	M0_UT_ASSERT(list_lookup(lid) == NULL);
-
-	if (existing_test && !failure_test) {
-		/*
-		 * Lookup for the layout object from the DB to verify that its
-		 * user count is indeed updated.
-		 */
-		rc = m0_db_tx_init(&tx, &dbenv, DBFLAGS);
-		M0_UT_ASSERT(rc == 0);
-
-		pair_set(&pair, &lid, area, num_bytes);
-
-		rc = m0_layout_lookup(&domain, lid, &m0_pdclust_layout_type,
-				      &tx, &pair, &l2);
-		M0_UT_ASSERT(rc == 0);
-		M0_UT_ASSERT(l2->l_user_count == 100);
-		M0_UT_ASSERT(m0_ref_read(&l2->l_ref) == 1);
-
-		rc = m0_db_tx_commit(&tx);
-		M0_UT_ASSERT(rc == 0);
-
-		/*
-		 * Compare the two layouts - one created earlier here and the
-		 * one that is looked up from the DB.
-		 */
-		pdclust_layout_compare(enum_id, l1_copy, l2, false);
-		pdclust_layout_copy_delete(enum_id, l1_copy);
-
-		/* Delete the in-memory layout. */
-		m0_layout_put(l2);
-		M0_UT_ASSERT(list_lookup(lid) == NULL);
-	}
-
-	m0_free(area);
-	M0_LEAVE();
-	return rc;
-}
-
 /* Tests the API m0_layout_update(). */
 static void test_update(void)
 {
@@ -3600,9 +1905,9 @@ static void test_update(void)
 	 * fails with the error ENOENT.
 	 */
 	lid = 18001;
-	rc = test_update_pdclust(LIST_ENUM_ID, lid,
+	rc = test_update_pdclust(lid, &domain,
+				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 !EXISTING_TEST,
-				 MORE_THAN_INLINE,
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -3611,9 +1916,9 @@ static void test_update(void)
 	 * with a few inline entries only.
 	 */
 	lid = 18002;
-	rc = test_update_pdclust(LIST_ENUM_ID, lid,
+	rc = test_update_pdclust(lid, &domain,
+				 LIST_ENUM_ID, LESS_THAN_INLINE,
 				 EXISTING_TEST,
-				 LESS_THAN_INLINE,
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -3623,9 +1928,9 @@ static void test_update(void)
 	 * LDB_MAX_INLINE_COB_ENTRIES.
 	 */
 	lid = 18003;
-	rc = test_update_pdclust(LIST_ENUM_ID, lid,
+	rc = test_update_pdclust(lid, &domain,
+				 LIST_ENUM_ID, EXACT_INLINE,
 				 EXISTING_TEST,
-				 EXACT_INLINE,
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -3634,9 +1939,9 @@ static void test_update(void)
 	 * type including noninline entries.
 	 */
 	lid = 18004;
-	rc = test_update_pdclust(LIST_ENUM_ID, lid,
+	rc = test_update_pdclust(lid, &domain,
+				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 EXISTING_TEST,
-				 MORE_THAN_INLINE,
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -3645,9 +1950,9 @@ static void test_update(void)
 	 * type.
 	 */
 	lid = 18005;
-	rc = test_update_pdclust(LINEAR_ENUM_ID, lid,
+	rc = test_update_pdclust(lid, &domain,
+				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				 EXISTING_TEST,
-				 INLINE_NOT_APPLICABLE,
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -3661,9 +1966,9 @@ static void test_update_failure(void)
 	/* Simulate m0_layout_encode() failure in m0_layout_update(). */
 	lid = 19001;
 	m0_fi_enable_off_n_on_m("m0_layout_encode", "lo_encode_err", 1, 1);
-	rc = test_update_pdclust(LIST_ENUM_ID, lid,
+	rc = test_update_pdclust(lid, &domain,
+				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 EXISTING_TEST,
-				 MORE_THAN_INLINE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == LO_ENCODE_ERR);
 	m0_fi_disable("m0_layout_encode", "lo_encode_err");
@@ -3671,109 +1976,13 @@ static void test_update_failure(void)
 	/* Simulate m0_table_update() failure in m0_layout_update(). */
 	lid = 19002;
 	m0_fi_enable_once("m0_layout_update", "table_update_err");
-	rc = test_update_pdclust(LINEAR_ENUM_ID, lid,
+	rc = test_update_pdclust(lid, &domain,
+				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				 EXISTING_TEST,
-				 INLINE_NOT_APPLICABLE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == L_TABLE_UPDATE_ERR);
 }
 
-/* Tests the API m0_layout_delete(), for the PDCLUST layout type. */
-static int test_delete_pdclust(uint32_t enum_id, uint64_t lid,
-			       bool existing_test,
-			       uint32_t inline_test,
-			       uint32_t failure_test)
-{
-	m0_bcount_t                   num_bytes;
-	void                         *area;
-	struct m0_db_pair             pair;
-	struct m0_db_tx               tx;
-	struct m0_layout             *l;
-	struct m0_uint128             seed;
-	uint32_t                      N;
-	uint32_t                      K;
-	uint32_t                      P;
-	struct m0_pdclust_layout     *pl;
-	struct m0_layout_list_enum   *list_enum;
-	struct m0_layout_linear_enum *lin_enum;
-	int                           rc_tmp;
-
-	M0_ENTRY();
-	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
-
-	allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
-
-	NKP_assign(enum_id,
-		   inline_test, 12, 122, 1220,
-		   &N, &K, &P);
-	if (existing_test) {
-		/* Add a layout object to the DB. */
-		rc = test_add_pdclust(enum_id, lid,
-				      inline_test,
-				      !LAYOUT_DESTROY, &l,
-				      !DUPLICATE_TEST,
-				      !FAILURE_TEST);
-		M0_UT_ASSERT(rc == 0);
-	} else {
-		/* Build a layout object. */
-		m0_uint128_init(&seed, "deletepdclustlay");
-
-		rc = pdclust_layout_build(enum_id, lid,
-					  N, K, P, &seed,
-					  10, 20,
-					  &pl, &list_enum, &lin_enum,
-					  !FAILURE_TEST);
-		M0_UT_ASSERT(rc == 0);
-		l = &pl->pl_base.sl_base;
-	}
-
-	if (M0_FI_ENABLED("nonzero_user_count_err"))
-		m0_layout_user_count_inc(l);
-
-	/* Delete the layout object from the DB. */
-	pair_set(&pair, &lid, area, num_bytes);
-
-	rc = m0_db_tx_init(&tx, &dbenv, DBFLAGS);
-	M0_UT_ASSERT(rc == 0);
-
-	rc = m0_layout_delete(l, &tx, &pair);
-	if (failure_test)
-		M0_UT_ASSERT(rc == -ENOENT || rc == -ENOMEM ||
-			     rc == -EPROTO || rc == LO_ENCODE_ERR);
-	else
-		M0_UT_ASSERT(rc == 0);
-
-	rc_tmp = m0_db_tx_commit(&tx);
-	M0_UT_ASSERT(rc_tmp == 0);
-
-	/* Destroy the layout object. */
-	m0_layout_put(l);
-	M0_UT_ASSERT(list_lookup(lid) == NULL);
-
-	if (!failure_test) {
-		/*
-		 * Lookup for the layout object from the DB, to verify that it
-		 * does not exist there and that the lookup results into
-		 * ENOENT error.
-		 */
-		rc = m0_db_tx_init(&tx, &dbenv, DBFLAGS);
-		M0_UT_ASSERT(rc == 0);
-
-		pair_set(&pair, &lid, area, num_bytes);
-
-		rc_tmp = m0_layout_lookup(&domain, lid, &m0_pdclust_layout_type,
-					  &tx, &pair, &l);
-		M0_UT_ASSERT(rc_tmp == -ENOENT);
-
-		rc_tmp = m0_db_tx_commit(&tx);
-		M0_UT_ASSERT(rc_tmp == 0);
-	}
-
-	m0_free(area);
-	M0_LEAVE();
-	return rc;
-}
-
 /* Tests the API m0_layout_delete(). */
 static void test_delete(void)
 {
@@ -3784,9 +1993,9 @@ static void test_delete(void)
 	 * with a few inline entries only.
 	 */
 	lid = 20001;
-	rc = test_delete_pdclust(LIST_ENUM_ID, lid,
+	rc = test_delete_pdclust(lid, &domain,
+				 LIST_ENUM_ID, LESS_THAN_INLINE,
 				 EXISTING_TEST,
-				 LESS_THAN_INLINE,
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -3796,9 +2005,9 @@ static void test_delete(void)
 	 * LDB_MAX_INLINE_COB_ENTRIES.
 	 */
 	lid = 20002;
-	rc = test_delete_pdclust(LIST_ENUM_ID, lid,
+	rc = test_delete_pdclust(lid, &domain,
+				 LIST_ENUM_ID, EXACT_INLINE,
 				 EXISTING_TEST,
-				 EXACT_INLINE,
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -3807,9 +2016,9 @@ static void test_delete(void)
 	 * type including noninline entries.
 	 */
 	lid = 20003;
-	rc = test_delete_pdclust(LIST_ENUM_ID, lid,
+	rc = test_delete_pdclust(lid, &domain,
+				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 EXISTING_TEST,
-				 MORE_THAN_INLINE,
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
@@ -3818,14 +2027,13 @@ static void test_delete(void)
 	 * type.
 	 */
 	lid = 20004;
-	rc = test_delete_pdclust(LINEAR_ENUM_ID, lid,
+	rc = test_delete_pdclust(lid, &domain,
+				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				 EXISTING_TEST,
-				 INLINE_NOT_APPLICABLE,
 				 !FAILURE_TEST);
 	M0_UT_ASSERT(rc == 0);
 
 	/* Delete a layout object with COMPOSITE layout type. */
-#if 1
 	lid = 20005;
 	rc = test_delete_composite(lid, &domain, 7, 5, /* todo 7, 107 */
 				   lid * 100, lid * 100 * 100,
@@ -3834,7 +2042,6 @@ static void test_delete(void)
 	M0_UT_ASSERT(rc == 0);
 
 	//todo Cover other cases
-#endif
 }
 
 static void test_delete_failure(void)
@@ -3844,9 +2051,9 @@ static void test_delete_failure(void)
 	/* Simulate m0_layout_encode() failure in m0_layout_delete(). */
 	lid = 21001;
 	m0_fi_enable_off_n_on_m("m0_layout_encode", "lo_encode_err", 1, 1);
-	rc = test_delete_pdclust(LINEAR_ENUM_ID, lid,
+	rc = test_delete_pdclust(lid, &domain,
+				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				 EXISTING_TEST,
-				 INLINE_NOT_APPLICABLE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == LO_ENCODE_ERR);
 	m0_fi_disable("m0_layout_encode", "lo_encode_err");
@@ -3857,9 +2064,9 @@ static void test_delete_failure(void)
 	 * into the error ENOENT.
 	 */
 	lid = 21002;
-	rc = test_delete_pdclust(LINEAR_ENUM_ID, lid,
+	rc = test_delete_pdclust(lid, &domain,
+				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				 !EXISTING_TEST,
-				 INLINE_NOT_APPLICABLE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOENT);
 
@@ -3869,9 +2076,9 @@ static void test_delete_failure(void)
 	 */
 	lid = 21003;
 	m0_fi_enable_once("noninline_write", "cursor_get_err");
-	rc = test_delete_pdclust(LIST_ENUM_ID, lid,
+	rc = test_delete_pdclust(lid, &domain,
+				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 EXISTING_TEST,
-				 MORE_THAN_INLINE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOENT);
 
@@ -3881,9 +2088,9 @@ static void test_delete_failure(void)
 	 */
 	lid = 21004;
 	m0_fi_enable_once("noninline_write", "cursor_del_err");
-	rc = test_delete_pdclust(LIST_ENUM_ID, lid,
+	rc = test_delete_pdclust(lid, &domain,
+				 LIST_ENUM_ID, MORE_THAN_INLINE,
 				 EXISTING_TEST,
-				 MORE_THAN_INLINE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -ENOMEM);
 
@@ -3894,9 +2101,9 @@ static void test_delete_failure(void)
 	 */
 	lid = 21005;
 	m0_fi_enable_once("test_delete_pdclust", "nonzero_user_count_err");
-	rc = test_delete_pdclust(LINEAR_ENUM_ID, lid,
+	rc = test_delete_pdclust(lid, &domain,
+				 LINEAR_ENUM_ID, INLINE_NOT_APPLICABLE,
 				 EXISTING_TEST,
-				 INLINE_NOT_APPLICABLE,
 				 FAILURE_TEST);
 	M0_UT_ASSERT(rc == -EPROTO);
 }
diff --git a/layout/ut/layout.h b/layout/ut/layout.h
index 3119a21..4eebec5 100644
--- a/layout/ut/layout.h
+++ b/layout/ut/layout.h
@@ -23,26 +23,6 @@
 #ifndef __MERO_LAYOUT_UT_LAYOUT_H__
 #define __MERO_LAYOUT_UT_LAYOUT_H__
 
-#include "lib/ut.h"
-#include "lib/ub.h"
-#include "lib/memory.h"
-#include "lib/misc.h"                    /* M0_SET0 */
-#include "lib/bitstring.h"
-#include "lib/vec.h"
-
-#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_LAYOUT
-#include "lib/trace.h"                   /* M0_LOG */
-
-#ifdef __KERNEL__
-# include "m0t1fs/linux_kernel/m0t1fs.h" /* m0t1fs_globals */
-#endif
-
-#include "lib/finject.h"
-
-struct m0_layout_list_enum;
-struct m0_layout_linear_enum;
-struct m0_pdclust_layout;
-
 enum {
 	DBFLAGS                  = 0,    /* Flag used for dbenv and tx init */
 	LIST_ENUM_ID             = 0x4C495354, /* "LIST" */
@@ -62,6 +42,7 @@ enum {
 	CONTIGUOUS_EXTENTS       = true  /* For extents of a sub-layout */
 };
 
+//todo Move the following to composite.h
 /*
  * Kind of the extent that 'is to be looked up from the extent list' or 'is to
  * be added to extent list' for a particular layer from a particular composite
@@ -80,16 +61,11 @@ extern struct m0_layout_type m0_composite_layout_type;
 extern struct m0_layout_enum_type m0_list_enum_type;
 extern struct m0_layout_enum_type m0_linear_enum_type;
 
-void allocate_area(void **area,
-		   m0_bcount_t additional_bytes,
+void allocate_area(void **area, m0_bcount_t additional_bytes,
 		   m0_bcount_t *num_bytes);
-
-void l_verify(struct m0_layout *l,
-	      uint64_t lid,
+void l_verify(struct m0_layout *l, uint64_t lid,
 	      bool if_user_count_incremented);
-
 void lbuf_verify(struct m0_bufvec_cursor *cur, uint32_t *lt_id);
-
 void lbuf_compare(struct m0_bufvec_cursor *cur1,
 		  struct m0_bufvec_cursor *cur2);
 void layout_compare(const struct m0_layout *l1,
@@ -100,30 +76,15 @@ void layout_copy(const struct m0_layout *l_src,
 
 void generic_buf_build(uint32_t lt_id, struct m0_bufvec_cursor *dcur);
 struct m0_layout *list_lookup(uint64_t lid);
-
-void NKP_assign(uint32_t enum_id,
-		uint32_t inline_test,
-		uint32_t list_nr_less,
-		uint32_t list_nr_more,
-		uint32_t linear_nr,
-		uint32_t *N, uint32_t *K, uint32_t *P);
-
-int pdclust_layout_build(uint32_t enum_id,
-			 uint64_t lid,
-			 uint32_t N, uint32_t K, uint32_t P,
-			 struct m0_uint128 *seed,
-			 uint32_t A, uint32_t B,
-			 struct m0_pdclust_layout **pl,
-			 struct m0_layout_list_enum **list_enum,
-			 struct m0_layout_linear_enum **lin_enum,
-			 bool failure_test);
-
-void pdclust_layout_verify(uint32_t enum_id,
-			   struct m0_layout *l, uint64_t lid,
-			   uint32_t N, uint32_t K, uint32_t P,
-			   struct m0_uint128 *seed,
-			   uint32_t A, uint32_t B,
-			   bool if_user_count_incremented);
+void enum_op_verify(struct m0_layout *l, uint64_t lid,
+		    uint32_t enum_id, uint32_t nr);
+bool ghost_create(void *d);
+
+struct ghost_data {
+	uint64_t                 lid;
+	struct m0_layout        *l;
+	struct m0_bufvec_cursor *cur;
+};
 
 int test_build_composite(uint64_t lid,
 			 struct m0_layout_domain *domain,
diff --git a/layout/ut/pdclust.c b/layout/ut/pdclust.c
new file mode 100644
index 0000000..f614e74
--- /dev/null
+++ b/layout/ut/pdclust.c
@@ -0,0 +1,1834 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Trupti Patil <trupti_patil@xyratex.com>
+ * Original creation date: 12/21/2011
+ */
+
+#include "lib/ut.h"                   /* M0_UT_ASSERT() */
+#include "lib/memory.h"
+#include "lib/misc.h"                 /* M0_SET0 */
+#include "lib/bitstring.h"
+#include "lib/vec.h"
+#include "lib/errno.h"
+
+#include "lib/finject.h"
+
+#include "fid/fid.h"                  /* m0_fid_set() */
+#include "layout/layout.h"
+#include "layout/layout_internal.h"   /* LDB_MAX_INLINE_COB_ENTRIES, *_ERR */
+#include "layout/layout_db.h"
+#include "layout/pdclust.h"
+#include "layout/list_enum.h"
+#include "layout/linear_enum.h"
+
+#include "layout/ut/ldemo_internal.c" /* layout_demo() */
+#include "layout/ut/layout.h"
+#include "layout/ut/pdclust.h"
+
+static int rc;
+
+/*
+ * Builds a layout object with PDCLUST layout type and using the provided
+ * enumeration object.
+ */
+static int pdclust_l_build(uint64_t lid, struct m0_layout_domain *domain,
+			   uint32_t N, uint32_t K, uint32_t P,
+			   struct m0_uint128 *seed,
+			   struct m0_layout_enum *le,
+			   struct m0_pdclust_layout **pl,
+			   bool failure_test)
+{
+	struct m0_layout_type  *lt;
+	struct m0_pdclust_attr  attr;
+
+	lt = &m0_pdclust_layout_type;
+
+	M0_UT_ASSERT(le != NULL);
+	M0_UT_ASSERT(pl != NULL);
+
+	attr.pa_N         = N;
+	attr.pa_K         = K;
+	attr.pa_P         = P;
+	attr.pa_unit_size = UNIT_SIZE;
+	attr.pa_seed      = *seed;
+
+	if (M0_FI_ENABLED("attr_err")) { attr.pa_P = 1; }
+	rc = m0_pdclust_build(domain, lid, &attr, le, pl);
+	if (failure_test)
+		M0_UT_ASSERT(rc == -ENOMEM || rc == -EPROTO);
+	else {
+		M0_UT_ASSERT(rc == 0);
+		M0_UT_ASSERT(list_lookup(lid) == &(*pl)->pl_base.sl_base);
+		M0_UT_ASSERT(m0_ref_read(&(*pl)->pl_base.sl_base.l_ref) == 1);
+		M0_UT_ASSERT((*pl)->pl_base.sl_base.l_user_count == 0);
+	}
+
+	return rc;
+}
+
+/*
+ * Builds a layout object with PDCLUST layout type, by first building an
+ * enumeration object with the specified enumeration type.
+ */
+int pdclust_layout_build(uint64_t lid, struct m0_layout_domain *domain,
+			 uint32_t enum_id,
+			 uint32_t N, uint32_t K, uint32_t P,
+			 struct m0_uint128 *seed,
+			 uint32_t A, uint32_t B,
+			 struct m0_pdclust_layout **pl,
+			 struct m0_layout_list_enum **list_enum,
+			 struct m0_layout_linear_enum **lin_enum,
+			 bool failure_test)
+{
+	struct m0_fid                *cob_list = NULL; /* to keep gcc happy. */
+	int                           i;
+	struct m0_layout_enum        *e;
+	struct m0_layout_linear_attr  lin_attr;
+	struct m0_layout             *l_from_pl;
+	struct m0_layout_enum        *e_from_layout;
+
+	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+	M0_UT_ASSERT(pl != NULL);
+
+	/* Build an enumeration object with the specified enum type. */
+	if (enum_id == LIST_ENUM_ID) {
+		M0_ALLOC_ARR(cob_list, P);
+		M0_UT_ASSERT(cob_list != NULL);
+
+		for (i = 0; i < P; ++i)
+			m0_fid_set(&cob_list[i], i * 100 + 1, i + 1);
+
+		if (M0_FI_ENABLED("list_attr_err")) { P = 0; }
+		rc = m0_list_enum_build(domain, cob_list, P, list_enum);
+		M0_UT_ASSERT(rc == 0 || rc == -ENOMEM || rc == -EPROTO);
+
+		e = &(*list_enum)->lle_base;
+
+	} else { /* LINEAR_ENUM_ID */
+		lin_attr.lla_nr = P;
+		lin_attr.lla_A  = A;
+		lin_attr.lla_B  = B;
+		if (M0_FI_ENABLED("lin_attr_err")) { lin_attr.lla_nr = 0; }
+		rc = m0_linear_enum_build(domain, &lin_attr, lin_enum);
+		M0_UT_ASSERT(rc == 0 || rc == -ENOMEM || rc == -EPROTO);
+
+		e = &(*lin_enum)->lle_base;
+	}
+	if (rc != 0) {
+		M0_UT_ASSERT(failure_test);
+		if (enum_id == LIST_ENUM_ID)
+			m0_free(cob_list);
+		return rc;
+	}
+
+	/*
+	 * Build a layout object with PDCLUST layout type and using the
+	 * enumeration object built earlier here.
+	 */
+	rc = pdclust_l_build(lid, domain, N, K, P, seed, e, pl, failure_test);
+	if (failure_test) {
+		M0_UT_ASSERT(rc == -ENOMEM || rc == -EPROTO);
+		m0_layout_enum_fini(e);
+		return rc;
+	}
+	else {
+		M0_UT_ASSERT(rc == 0);
+		M0_UT_ASSERT(list_lookup(lid) == &(*pl)->pl_base.sl_base);
+	}
+
+	/* Verify m0_pdl_to_layout(). */
+	l_from_pl = m0_pdl_to_layout(*pl);
+	M0_UT_ASSERT(l_from_pl == &(*pl)->pl_base.sl_base);
+
+	/* Verify m0_layout_to_enum(). */
+	e_from_layout = m0_layout_to_enum(l_from_pl);
+	M0_UT_ASSERT(e_from_layout == e);
+	return rc;
+}
+
+/*
+ * Verifies generic part of the layout object and the PDCLUST layout type
+ * specific part of it.
+ */
+static void pdclust_l_verify(struct m0_pdclust_layout *pl,
+			     uint64_t lid,
+			     uint32_t N, uint32_t K, uint32_t P,
+			     struct m0_uint128 *seed,
+			     bool if_user_count_incremented)
+{
+	/* Verify generic part of the layout object. */
+	l_verify(&pl->pl_base.sl_base, lid, if_user_count_incremented);
+
+	/* Verify PDCLUST layout type specific part of the layout object. */
+	M0_UT_ASSERT(pl->pl_base.sl_base.l_type == &m0_pdclust_layout_type);
+	M0_UT_ASSERT(pl->pl_attr.pa_N == N);
+	M0_UT_ASSERT(pl->pl_attr.pa_K == K);
+	M0_UT_ASSERT(pl->pl_attr.pa_P == P);
+	M0_UT_ASSERT(pl->pl_attr.pa_unit_size == UNIT_SIZE);
+	M0_UT_ASSERT(m0_uint128_eq(&pl->pl_attr.pa_seed, seed));
+}
+
+/* Verifies the layout object against the various input arguments. */
+void pdclust_layout_verify(struct m0_layout *l, uint64_t lid, uint32_t enum_id,
+			   uint32_t N, uint32_t K, uint32_t P,
+			   struct m0_uint128 *seed,
+			   uint32_t A, uint32_t B,
+			   bool if_user_count_incremented)
+{
+	struct m0_pdclust_layout     *pl;
+	struct m0_layout_list_enum   *list_enum;
+	struct m0_layout_linear_enum *lin_enum;
+	int                           i;
+	struct m0_fid                 cob_id;
+
+	M0_UT_ASSERT(l != NULL);
+	M0_UT_ASSERT(l->l_type == &m0_pdclust_layout_type);
+	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+
+	pl = container_of(l, struct m0_pdclust_layout, pl_base.sl_base);
+
+	/*
+	 * Verify generic and PDCLUST layout type specific parts of the
+	 * layout object.
+	 */
+	pdclust_l_verify(pl, lid, N, K, P, seed, if_user_count_incremented);
+
+	/* Verify enum type specific part of the layout object. */
+	M0_UT_ASSERT(pl->pl_base.sl_enum != NULL);
+
+	if (enum_id == LIST_ENUM_ID) {
+		list_enum = container_of(pl->pl_base.sl_enum,
+					 struct m0_layout_list_enum, lle_base);
+		for(i = 0; i < list_enum->lle_nr; ++i) {
+			m0_fid_set(&cob_id, i * 100 + 1, i + 1);
+			M0_UT_ASSERT(m0_fid_eq(&cob_id,
+					      &list_enum->lle_list_of_cobs[i]));
+		}
+		M0_UT_ASSERT(list_enum->lle_nr == P);
+	} else {
+		lin_enum = container_of(pl->pl_base.sl_enum,
+					struct m0_layout_linear_enum, lle_base);
+		M0_UT_ASSERT(lin_enum->lle_attr.lla_nr == P);
+		M0_UT_ASSERT(lin_enum->lle_attr.lla_A == A);
+		M0_UT_ASSERT(lin_enum->lle_attr.lla_B == B);
+	}
+}
+
+void NKP_assign(uint32_t enum_id,
+		uint32_t inline_test,
+		uint32_t list_nr_less, uint32_t list_nr_more,
+		uint32_t linear_nr,
+		uint32_t *N, uint32_t *K, uint32_t *P)
+{
+	M0_UT_ASSERT(ergo(enum_id == LIST_ENUM_ID,
+			  list_nr_less < LDB_MAX_INLINE_COB_ENTRIES &&
+			  list_nr_more > LDB_MAX_INLINE_COB_ENTRIES));
+
+	if (enum_id == LIST_ENUM_ID) {
+		switch (inline_test) {
+		case LESS_THAN_INLINE:
+			*P = list_nr_less;
+			break;
+		case EXACT_INLINE:
+			*P = LDB_MAX_INLINE_COB_ENTRIES;
+			break;
+		case MORE_THAN_INLINE:
+			*P = list_nr_more;
+			break;
+		default:
+			M0_ASSERT(0);
+		}
+	} else
+		*P = linear_nr;
+
+	if (*P <= 20)
+		*K = 1;
+	else if (*P <= 50)
+		*K = 2;
+	else if (*P <= 200)
+		*K = 6;
+	else if (*P <= 500)
+		*K = 12;
+	else if (*P <= 1000)
+		*K = 100;
+	else
+		*K = 200;
+
+	if (*P <= 20)
+		*N = *P - (2 * (*K));
+	else if (*P <= 100)
+		*N = *P - (2 * (*K)) - 10;
+	else if (*P <= 1000)
+		*N = *P - (2 * (*K)) - 12;
+	else
+		*N = *P - (2 * (*K)) - 100;
+}
+
+/*
+ * Tests the APIs supported for enumeration object build, layout object build
+ * and layout destruction that happens using m0_layout_put(). Verifies that the
+ * newly built layout object is added to the list of layout objects maintained
+ * in the domain object and that m0_layout_find() returns the same object.
+ */
+int test_build_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+		       uint32_t enum_id, uint32_t inline_test,
+		       bool failure_test)
+{
+	struct m0_uint128             seed;
+	uint32_t                      N;
+	uint32_t                      K;
+	uint32_t                      P;
+	struct m0_pdclust_layout     *pl;
+	struct m0_layout_list_enum   *list_enum;
+	struct m0_layout_linear_enum *lin_enum;
+	struct m0_layout             *l;
+
+	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+
+	m0_uint128_init(&seed, "buildpdclustlayo");
+
+	NKP_assign(enum_id,
+		   inline_test, 9, 109, 12000,
+		   &N, &K, &P);
+
+	rc = pdclust_layout_build(lid, domain, enum_id,
+				  N, K, P, &seed,
+				  10, 20,
+				  &pl, &list_enum, &lin_enum,
+				  failure_test);
+	if (failure_test)
+		M0_UT_ASSERT(rc == -ENOMEM || rc == -EPROTO);
+	else {
+		M0_UT_ASSERT(rc == 0);
+		/*
+		 * Verify that m0_layout_find() returns the same object by
+		 * reading it from the memory.
+		 */
+		l = m0_layout_find(domain, lid);
+		M0_UT_ASSERT(l == &pl->pl_base.sl_base);
+
+		/* Verify the layout object built earlier here. */
+		pdclust_layout_verify(&pl->pl_base.sl_base, lid, enum_id,
+				      N, K, P, &seed,
+				      10, 20, !USER_COUNT_INCREMENTED);
+		/* Release the reference that m0_layout_find() has acquired. */
+		m0_layout_put(&pl->pl_base.sl_base);
+
+		/* Delete the layout object by reducing its last reference. */
+		m0_layout_put(&pl->pl_base.sl_base);
+		M0_UT_ASSERT(list_lookup(lid) == NULL);
+	}
+
+	return rc;
+}
+
+/*
+ * Builds part of the buffer representing generic and PDCLUST layout type
+ * specific parts of the layout object.
+ */
+static void pdclust_buf_build(uint32_t let_id, uint64_t lid,
+			      uint32_t N, uint32_t K, uint32_t P,
+			      struct m0_uint128 *seed,
+			      struct m0_bufvec_cursor *dcur)
+{
+	struct m0_layout_pdclust_rec pl_rec;
+	m0_bcount_t                  nbytes_copied;
+
+	generic_buf_build(m0_pdclust_layout_type.lt_id, dcur);
+
+	pl_rec.pr_let_id            = let_id;
+	pl_rec.pr_attr.pa_N         = N;
+	pl_rec.pr_attr.pa_K         = K;
+	pl_rec.pr_attr.pa_P         = P;
+	pl_rec.pr_attr.pa_unit_size = UNIT_SIZE;
+	pl_rec.pr_attr.pa_seed      = *seed;
+
+	nbytes_copied = m0_bufvec_cursor_copyto(dcur, &pl_rec, sizeof pl_rec);
+	M0_UT_ASSERT(nbytes_copied == sizeof pl_rec);
+}
+
+/* Builds a buffer containing serialised representation of a layout object. */
+static int pdclust_layout_buf_build(uint64_t lid, uint32_t enum_id,
+				    uint32_t N, uint32_t K, uint32_t P,
+				    struct m0_uint128 *seed,
+				    uint32_t A, uint32_t B,
+				    struct m0_bufvec_cursor *dcur)
+{
+	uint32_t                     let_id;
+	m0_bcount_t                  nbytes_copied;
+	struct cob_entries_header    ce_header;
+	struct m0_fid                cob_id;
+	uint32_t                     i;
+	struct m0_layout_linear_attr lin_rec;
+
+	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+	M0_UT_ASSERT(dcur != NULL);
+
+	/*
+	 * Build part of the buffer representing generic and the PDCLUST layout
+	 * type specific parts of the layout object.
+	 */
+	let_id = enum_id == LIST_ENUM_ID ? m0_list_enum_type.let_id :
+					   m0_linear_enum_type.let_id;
+	pdclust_buf_build(let_id, lid, N, K, P, seed, dcur);
+
+	/*
+	 * Build part of the buffer representing enum type specific part of
+	 * the layout object.
+	 */
+	if (enum_id == LIST_ENUM_ID) {
+		ce_header.ces_nr = P;
+		nbytes_copied = m0_bufvec_cursor_copyto(dcur, &ce_header,
+							sizeof ce_header);
+		M0_UT_ASSERT(nbytes_copied == sizeof ce_header);
+
+		for (i = 0; i < ce_header.ces_nr; ++i) {
+			m0_fid_set(&cob_id, i * 100 + 1, i + 1);
+			nbytes_copied = m0_bufvec_cursor_copyto(dcur, &cob_id,
+								sizeof cob_id);
+			M0_UT_ASSERT(nbytes_copied == sizeof cob_id);
+		}
+	} else {
+		lin_rec.lla_nr = P;
+		lin_rec.lla_A  = A;
+		lin_rec.lla_B  = B;
+
+		nbytes_copied = m0_bufvec_cursor_copyto(dcur, &lin_rec,
+							sizeof lin_rec);
+		M0_UT_ASSERT(nbytes_copied == sizeof lin_rec);
+	}
+
+	return 0;
+}
+
+/* Tests the API m0_layout_decode() for PDCLUST layout type. */
+int test_decode_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+			uint32_t enum_id, uint32_t inline_test,
+			bool failure_test)
+{
+	void                    *area;
+	m0_bcount_t              num_bytes;
+	struct m0_bufvec         bv;
+	struct m0_bufvec_cursor  cur;
+	struct m0_layout        *l;
+	struct m0_uint128        seed;
+	uint32_t                 N;
+	uint32_t                 K;
+	uint32_t                 P;
+	struct m0_layout_type   *lt;
+
+	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+
+	m0_uint128_init(&seed, "decodepdclustlay");
+
+	/* Build a layout buffer. */
+	if (enum_id == LIST_ENUM_ID)
+		allocate_area(&area, ADDITIONAL_BYTES_DEFAULT, &num_bytes);
+	else
+		allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
+
+	bv = (struct m0_bufvec) M0_BUFVEC_INIT_BUF(&area, &num_bytes);
+	m0_bufvec_cursor_init(&cur, &bv);
+
+	NKP_assign(enum_id,
+		   inline_test, 5, 125, 1500,
+		   &N, &K, &P);
+
+	rc = pdclust_layout_buf_build(lid, enum_id,
+				      N, K, P, &seed,
+				      777, 888, &cur);
+	M0_UT_ASSERT(rc == 0);
+
+	/* Rewind the cursor. */
+	m0_bufvec_cursor_init(&cur, &bv);
+
+	lt = &m0_pdclust_layout_type;
+	rc = lt->lt_ops->lto_allocate(domain, lid, &l);
+	M0_UT_ASSERT(rc == 0);
+
+	/* Decode the layout buffer into a layout object. */
+	rc = m0_layout_decode(l, &cur, M0_LXO_BUFFER_OP, NULL);
+	if (failure_test)
+		M0_UT_ASSERT(rc == -ENOMEM || rc == -EPROTO);
+	else {
+		M0_UT_ASSERT(rc == 0);
+		M0_UT_ASSERT(list_lookup(lid) == l);
+
+		/* Verify the layout object built by m0_layout_decode(). */
+		pdclust_layout_verify(l, lid, enum_id,
+				      N, K, P, &seed,
+				      777, 888, !USER_COUNT_INCREMENTED);
+	}
+
+	/* Destroy the layout object. */
+	if (failure_test)
+		l->l_ops->lo_delete(l);
+	else {
+		/* Unlock the layout, locked by lto_allocate() */
+		m0_mutex_unlock(&l->l_lock);
+		m0_layout_put(l);
+	}
+	M0_UT_ASSERT(list_lookup(lid) == NULL);
+
+	m0_free(area);
+	return rc;
+}
+
+/*
+ * Verifies part of the layout buffer representing PDCLUST layout type specific
+ * part of the layout object.
+ */
+static void pdclust_lbuf_verify(uint32_t N, uint32_t K, uint32_t P,
+				struct m0_uint128 *seed,
+				struct m0_bufvec_cursor *cur,
+				uint32_t *let_id)
+{
+	struct m0_layout_pdclust_rec *pl_rec;
+
+	M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >= sizeof *pl_rec);
+
+	pl_rec = m0_bufvec_cursor_addr(cur);
+
+	M0_UT_ASSERT(pl_rec->pr_attr.pa_N == N);
+	M0_UT_ASSERT(pl_rec->pr_attr.pa_K == K);
+	M0_UT_ASSERT(pl_rec->pr_attr.pa_P == P);
+	M0_UT_ASSERT(m0_uint128_eq(&pl_rec->pr_attr.pa_seed, seed));
+	M0_UT_ASSERT(pl_rec->pr_attr.pa_unit_size == UNIT_SIZE);
+
+	*let_id = pl_rec->pr_let_id;
+	m0_bufvec_cursor_move(cur, sizeof *pl_rec);
+}
+
+/* Verifies layout buffer against the various input arguments. */
+static void pdclust_layout_buf_verify(uint64_t lid, uint32_t enum_id,
+				      uint32_t N, uint32_t K, uint32_t P,
+				      struct m0_uint128 *seed,
+				      uint32_t A, uint32_t B,
+				      struct m0_bufvec_cursor *cur)
+{
+	uint32_t                      lt_id;
+	uint32_t                      let_id;
+	uint32_t                      i;
+	struct cob_entries_header    *ce_header;
+	struct m0_fid                *cob_id_from_layout;
+	struct m0_fid                 cob_id_calculated;
+	struct m0_layout_linear_attr *lin_attr;
+
+	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+	M0_UT_ASSERT(cur != NULL);
+
+	/* Verify generic part of the layout buffer. */
+	lbuf_verify(cur, &lt_id);
+	M0_UT_ASSERT(lt_id == m0_pdclust_layout_type.lt_id);
+
+	/* Verify PDCLUST layout type specific part of the layout buffer. */
+	pdclust_lbuf_verify(N, K, P, seed, cur, &let_id);
+
+	/* Verify enum type specific part of the layout buffer. */
+	if (enum_id == LIST_ENUM_ID) {
+		M0_UT_ASSERT(let_id == m0_list_enum_type.let_id);
+
+		M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >= sizeof *ce_header);
+
+		ce_header = m0_bufvec_cursor_addr(cur);
+		M0_UT_ASSERT(ce_header != NULL);
+		m0_bufvec_cursor_move(cur, sizeof *ce_header);
+
+		M0_UT_ASSERT(ce_header->ces_nr == P);
+		M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >=
+			     ce_header->ces_nr * sizeof *cob_id_from_layout);
+
+		for (i = 0; i < ce_header->ces_nr; ++i) {
+			cob_id_from_layout = m0_bufvec_cursor_addr(cur);
+			M0_UT_ASSERT(cob_id_from_layout != NULL);
+
+			m0_fid_set(&cob_id_calculated, i * 100 + 1, i + 1);
+			M0_UT_ASSERT(m0_fid_eq(cob_id_from_layout,
+					       &cob_id_calculated));
+
+			m0_bufvec_cursor_move(cur, sizeof *cob_id_from_layout);
+		}
+	} else {
+		M0_UT_ASSERT(let_id == m0_linear_enum_type.let_id);
+
+		M0_UT_ASSERT(m0_bufvec_cursor_step(cur) >= sizeof *lin_attr);
+
+		lin_attr = m0_bufvec_cursor_addr(cur);
+		M0_UT_ASSERT(lin_attr->lla_nr == P);
+		M0_UT_ASSERT(lin_attr->lla_A == A);
+		M0_UT_ASSERT(lin_attr->lla_B == B);
+	}
+}
+
+/* Tests the API m0_layout_encode() for PDCLUST layout type. */
+int test_encode_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+			uint32_t enum_id, uint32_t inline_test,
+			bool failure_test)
+{
+	struct m0_pdclust_layout     *pl;
+	void                         *area;
+	m0_bcount_t                   num_bytes;
+	struct m0_bufvec              bv;
+	struct m0_bufvec_cursor       cur;
+	struct m0_uint128             seed;
+	uint32_t                      N;
+	uint32_t                      K;
+	uint32_t                      P;
+	struct m0_layout_list_enum   *list_enum;
+	struct m0_layout_linear_enum *lin_enum;
+
+	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+
+	m0_uint128_init(&seed, "encodepdclustlay");
+
+	/* Build a layout object. */
+	NKP_assign(enum_id,
+		   inline_test, 10, 120, 120,
+		   &N, &K, &P);
+	rc = pdclust_layout_build(lid, domain, enum_id,
+				  N, K, P, &seed,
+				  11, 21,
+				  &pl, &list_enum, &lin_enum,
+				  !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+
+	/* Encode the layout object into a layout buffer. */
+	if (enum_id == LIST_ENUM_ID)
+		allocate_area(&area, ADDITIONAL_BYTES_DEFAULT, &num_bytes);
+	else
+		allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
+	bv = (struct m0_bufvec) M0_BUFVEC_INIT_BUF(&area, &num_bytes);
+	m0_bufvec_cursor_init(&cur, &bv);
+
+	m0_mutex_lock(&pl->pl_base.sl_base.l_lock);
+	rc  = m0_layout_encode(&pl->pl_base.sl_base, M0_LXO_BUFFER_OP,
+			       NULL, &cur);
+	m0_mutex_unlock(&pl->pl_base.sl_base.l_lock);
+	if (failure_test)
+		M0_UT_ASSERT(rc == LO_ENCODE_ERR);
+	else
+		M0_UT_ASSERT(rc == 0);
+
+	/* Rewind the cursor. */
+	m0_bufvec_cursor_init(&cur, &bv);
+
+	/* Verify the layout buffer produced by m0_layout_encode(). */
+	if (!failure_test)
+		pdclust_layout_buf_verify(lid, enum_id,
+					  N, K, P, &seed,
+					  11, 21, &cur);
+
+	/* Delete the layout object. */
+	m0_layout_put(&pl->pl_base.sl_base);
+	M0_UT_ASSERT(list_lookup(lid) == NULL);
+	m0_free(area);
+	return rc;
+}
+
+/* Compares PDCLUST layout type specific part of the layout buffers. */
+static void pdclust_lbuf_compare(struct m0_bufvec_cursor *cur1,
+				 struct m0_bufvec_cursor *cur2)
+{
+	struct m0_layout_pdclust_rec *pl_rec1;
+	struct m0_layout_pdclust_rec *pl_rec2;
+
+	M0_UT_ASSERT(m0_bufvec_cursor_step(cur1) >= sizeof *pl_rec1);
+	M0_UT_ASSERT(m0_bufvec_cursor_step(cur2) >= sizeof *pl_rec2);
+
+	pl_rec1 = m0_bufvec_cursor_addr(cur1);
+	pl_rec2 = m0_bufvec_cursor_addr(cur2);
+
+	M0_UT_ASSERT(pl_rec1->pr_attr.pa_N == pl_rec2->pr_attr.pa_N);
+	M0_UT_ASSERT(pl_rec1->pr_attr.pa_K == pl_rec2->pr_attr.pa_K);
+	M0_UT_ASSERT(pl_rec1->pr_attr.pa_P == pl_rec2->pr_attr.pa_P);
+	M0_UT_ASSERT(m0_uint128_eq(&pl_rec1->pr_attr.pa_seed,
+				   &pl_rec2->pr_attr.pa_seed));
+	M0_UT_ASSERT(pl_rec1->pr_attr.pa_unit_size ==
+		     pl_rec2->pr_attr.pa_unit_size);
+
+	m0_bufvec_cursor_move(cur1, sizeof *pl_rec1);
+	m0_bufvec_cursor_move(cur2, sizeof *pl_rec2);
+}
+
+/* Compares two layout buffers provided as input arguments. */
+static void pdclust_layout_buf_compare(uint32_t enum_id,
+				       struct m0_bufvec_cursor *cur1,
+				       struct m0_bufvec_cursor *cur2)
+{
+	struct cob_entries_header    *ce_header1;
+	struct cob_entries_header    *ce_header2;
+	struct m0_fid                *cob_id1;
+	struct m0_fid                *cob_id2;
+	struct m0_layout_linear_attr *lin_attr1;
+	struct m0_layout_linear_attr *lin_attr2;
+	uint32_t                      i;
+
+	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+	M0_UT_ASSERT(cur1 != NULL);
+	M0_UT_ASSERT(cur2 != NULL);
+
+	/* Compare generic part of the layout buffers. */
+	lbuf_compare(cur1, cur2);
+
+	/* Compare PDCLUST layout type specific part of the layout buffers. */
+	pdclust_lbuf_compare(cur1, cur2);
+
+	/* Compare enumeration type specific part of the layout buffers. */
+	if (enum_id == LIST_ENUM_ID) {
+		M0_UT_ASSERT(m0_bufvec_cursor_step(cur1) >= sizeof *ce_header1);
+		M0_UT_ASSERT(m0_bufvec_cursor_step(cur2) >= sizeof *ce_header2);
+
+		ce_header1 = m0_bufvec_cursor_addr(cur1);
+		ce_header2 = m0_bufvec_cursor_addr(cur2);
+
+		m0_bufvec_cursor_move(cur1, sizeof *ce_header1);
+		m0_bufvec_cursor_move(cur2, sizeof *ce_header2);
+
+		M0_UT_ASSERT(ce_header1->ces_nr == ce_header2->ces_nr);
+
+		M0_UT_ASSERT(m0_bufvec_cursor_step(cur1) >=
+			     ce_header1->ces_nr * sizeof *cob_id1);
+		M0_UT_ASSERT(m0_bufvec_cursor_step(cur2) >=
+			     ce_header2->ces_nr * sizeof *cob_id2);
+
+		for (i = 0; i < ce_header1->ces_nr; ++i) {
+			cob_id1 = m0_bufvec_cursor_addr(cur1);
+			cob_id2 = m0_bufvec_cursor_addr(cur2);
+
+			M0_UT_ASSERT(m0_fid_eq(cob_id1, cob_id2));
+
+			m0_bufvec_cursor_move(cur1, sizeof *cob_id1);
+			m0_bufvec_cursor_move(cur2, sizeof *cob_id2);
+		}
+	} else {
+		M0_UT_ASSERT(m0_bufvec_cursor_step(cur1) >= sizeof *lin_attr1);
+		M0_UT_ASSERT(m0_bufvec_cursor_step(cur2) >= sizeof *lin_attr2);
+
+		lin_attr1 = m0_bufvec_cursor_addr(cur1);
+		lin_attr2 = m0_bufvec_cursor_addr(cur2);
+
+		M0_UT_ASSERT(lin_attr1->lla_nr == lin_attr2->lla_nr);
+		M0_UT_ASSERT(lin_attr1->lla_A == lin_attr2->lla_A);
+		M0_UT_ASSERT(lin_attr1->lla_B == lin_attr2->lla_B);
+	}
+}
+
+/*
+ * Tests the API sequence m0_layout_decode() followed by m0_layout_encode(),
+ * for the PDCLUST layout type.
+ */
+int test_decode_encode_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+			       uint32_t enum_id, uint32_t inline_test)
+{
+	void                    *area1;
+	struct m0_bufvec         bv1;
+	struct m0_bufvec_cursor  cur1;
+	void                    *area2;
+	struct m0_bufvec         bv2;
+	struct m0_bufvec_cursor  cur2;
+	m0_bcount_t              num_bytes;
+	uint32_t                 N;
+	uint32_t                 K;
+	uint32_t                 P;
+	struct m0_uint128        seed;
+	struct m0_layout        *l;
+	struct m0_layout_type   *lt;
+
+	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+
+	m0_uint128_init(&seed, "decodeencodepdcl");
+
+	/* Build a layout buffer. */
+	if (enum_id == LIST_ENUM_ID)
+		allocate_area(&area1, ADDITIONAL_BYTES_DEFAULT, &num_bytes);
+	else
+		allocate_area(&area1, ADDITIONAL_BYTES_NONE, &num_bytes);
+
+	bv1 = (struct m0_bufvec) M0_BUFVEC_INIT_BUF(&area1, &num_bytes);
+	m0_bufvec_cursor_init(&cur1, &bv1);
+
+	NKP_assign(enum_id,
+		   inline_test, 3, 103, 1510,
+		   &N, &K, &P);
+
+	rc = pdclust_layout_buf_build(lid, LINEAR_ENUM_ID,
+				      N, K, P, &seed,
+				      777, 888, &cur1);
+	M0_UT_ASSERT(rc == 0);
+
+	/* Rewind the cursor. */
+	m0_bufvec_cursor_init(&cur1, &bv1);
+
+	lt = &m0_pdclust_layout_type;
+	rc = lt->lt_ops->lto_allocate(domain, lid, &l);
+	M0_UT_ASSERT(rc == 0);
+
+	/* Decode the layout buffer into a layout object. */
+	rc = m0_layout_decode(l, &cur1, M0_LXO_BUFFER_OP, NULL);
+	M0_UT_ASSERT(rc == 0);
+
+	/* Unlock the layout, locked by lto_allocate() */
+	m0_mutex_unlock(&l->l_lock);
+
+	/* Rewind the cursor. */
+	m0_bufvec_cursor_init(&cur1, &bv1);
+
+	/*
+	 * Encode the layout object produced by m0_layout_decode() into
+	 * another layout buffer.
+	 */
+	if (enum_id == LIST_ENUM_ID)
+		allocate_area(&area2, ADDITIONAL_BYTES_DEFAULT, &num_bytes);
+	else
+		allocate_area(&area2, ADDITIONAL_BYTES_NONE, &num_bytes);
+
+	bv2 = (struct m0_bufvec) M0_BUFVEC_INIT_BUF(&area2, &num_bytes);
+	m0_bufvec_cursor_init(&cur2, &bv2);
+
+	m0_mutex_lock(&l->l_lock);
+	rc = m0_layout_encode(l, M0_LXO_BUFFER_OP, NULL, &cur2);
+	m0_mutex_unlock(&l->l_lock);
+	M0_UT_ASSERT(rc == 0);
+
+	/* Rewind the cursor. */
+	m0_bufvec_cursor_init(&cur2, &bv2);
+
+	/*
+	 * Compare the two layout buffers - one created earlier here and
+	 * the one that is produced by m0_layout_encode().
+	 */
+	pdclust_layout_buf_compare(enum_id, &cur1, &cur2);
+
+	/* Destroy the layout. */
+	m0_layout_put(l);
+	M0_UT_ASSERT(list_lookup(lid) == NULL);
+
+	m0_free(area1);
+	m0_free(area2);
+	return rc;
+}
+
+/*
+ * Compares two layout objects with PDCLUST layout type, provided as input
+ * arguments.
+ */
+static void pdclust_layout_compare(uint32_t enum_id,
+				   const struct m0_layout *l1,
+				   const struct m0_layout *l2,
+				   bool l2_ref_elevated)
+{
+	struct m0_pdclust_layout     *pl1;
+	struct m0_pdclust_layout     *pl2;
+	struct m0_layout_list_enum   *list_e1;
+	struct m0_layout_list_enum   *list_e2;
+	struct m0_layout_linear_enum *lin_e1;
+	struct m0_layout_linear_enum *lin_e2;
+	uint32_t                      i;
+
+	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+	M0_UT_ASSERT(l1 != NULL && l2 != NULL);
+
+	/* Compare generic part of the layout objects. */
+	layout_compare(l1, l2, l2_ref_elevated);
+
+	/* Compare PDCLUST layout type specific part of the layout objects. */
+	pl1 = container_of(l1, struct m0_pdclust_layout, pl_base.sl_base);
+	pl2 = container_of(l2, struct m0_pdclust_layout, pl_base.sl_base);
+
+	M0_UT_ASSERT(pl1->pl_attr.pa_N == pl2->pl_attr.pa_N);
+	M0_UT_ASSERT(pl1->pl_attr.pa_K == pl2->pl_attr.pa_K);
+	M0_UT_ASSERT(pl1->pl_attr.pa_P == pl2->pl_attr.pa_P);
+	M0_UT_ASSERT(m0_uint128_eq(&pl1->pl_attr.pa_seed,
+				   &pl2->pl_attr.pa_seed));
+
+	/* Compare enumeration specific part of the layout objects. */
+	M0_UT_ASSERT(pl1->pl_base.sl_enum->le_type ==
+		     pl2->pl_base.sl_enum->le_type);
+	M0_UT_ASSERT(pl1->pl_base.sl_enum->le_sl == &pl1->pl_base);
+	M0_UT_ASSERT(pl1->pl_base.sl_enum->le_sl->sl_base.l_id ==
+		     pl2->pl_base.sl_enum->le_sl->sl_base.l_id);
+	M0_UT_ASSERT(pl1->pl_base.sl_enum->le_ops ==
+		     pl2->pl_base.sl_enum->le_ops);
+
+	/* Compare enumeration type specific part of the layout objects. */
+	if (enum_id == LIST_ENUM_ID) {
+		list_e1 = container_of(pl1->pl_base.sl_enum,
+				       struct m0_layout_list_enum, lle_base);
+		list_e2 = container_of(pl2->pl_base.sl_enum,
+				       struct m0_layout_list_enum, lle_base);
+
+		M0_UT_ASSERT(list_e1->lle_nr == list_e2->lle_nr);
+
+		for (i = 0; i < list_e1->lle_nr; ++i)
+			M0_UT_ASSERT(m0_fid_eq(&list_e1->lle_list_of_cobs[i],
+					       &list_e2->lle_list_of_cobs[i]));
+	} else { /* LINEAR_ENUM_ID */
+		lin_e1 = container_of(pl1->pl_base.sl_enum,
+				      struct m0_layout_linear_enum, lle_base);
+		lin_e2 = container_of(pl2->pl_base.sl_enum,
+				      struct m0_layout_linear_enum, lle_base);
+
+		M0_UT_ASSERT(lin_e1->lle_attr.lla_nr ==
+			     lin_e2->lle_attr.lla_nr);
+		M0_UT_ASSERT(lin_e1->lle_attr.lla_A == lin_e2->lle_attr.lla_A);
+		M0_UT_ASSERT(lin_e1->lle_attr.lla_B == lin_e2->lle_attr.lla_B);
+	}
+}
+
+/* Copies contents of one layout object to the other. */
+static void pdclust_layout_copy(uint32_t enum_id,
+				const struct m0_layout *l_src,
+				struct m0_layout **l_dest)
+{
+	struct m0_pdclust_layout     *pl_src;
+	struct m0_pdclust_layout     *pl_dest;
+	struct m0_layout_list_enum   *list_src;
+	struct m0_layout_list_enum   *list_dest;
+	struct m0_layout_linear_enum *lin_src;
+	struct m0_layout_linear_enum *lin_dest;
+	uint32_t                      i;
+
+	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+	M0_UT_ASSERT(l_src != NULL && l_dest != NULL);
+
+	pl_src = container_of(l_src, struct m0_pdclust_layout,
+			      pl_base.sl_base);
+	M0_ALLOC_PTR(pl_dest);
+	M0_UT_ASSERT(pl_dest != NULL);
+	*l_dest = &pl_dest->pl_base.sl_base;
+
+	/* Copy generic part of the layout object. */
+	layout_copy(l_src, *l_dest);
+
+	/* Copy PDCLUST layout type specific part of the layout objects. */
+	pl_dest->pl_attr = pl_src->pl_attr;
+
+	/* Copy enumeration type specific part of the layout objects. */
+	if (enum_id == LIST_ENUM_ID) {
+		list_src = container_of(pl_src->pl_base.sl_enum,
+					struct m0_layout_list_enum, lle_base);
+		list_dest = m0_alloc(sizeof *list_src);
+		M0_UT_ASSERT(list_src != NULL);
+
+		list_dest->lle_nr = list_src->lle_nr;
+		M0_ALLOC_ARR(list_dest->lle_list_of_cobs, list_dest->lle_nr);
+
+		for (i = 0; i < list_src->lle_nr; ++i)
+			list_dest->lle_list_of_cobs[i] =
+					       list_src->lle_list_of_cobs[i];
+
+		pl_dest->pl_base.sl_enum = &list_dest->lle_base;
+	} else { /* LINEAR_ENUM_ID */
+		lin_src = container_of(pl_src->pl_base.sl_enum,
+				       struct m0_layout_linear_enum, lle_base);
+		lin_dest = m0_alloc(sizeof *lin_src);
+		M0_UT_ASSERT(lin_src != NULL);
+
+		lin_dest->lle_attr = lin_src->lle_attr;
+		pl_dest->pl_base.sl_enum = &lin_dest->lle_base;
+	}
+
+	/* Copy enumeration specific part of the layout objects. */
+	pl_dest->pl_base.sl_enum->le_type = pl_src->pl_base.sl_enum->le_type;
+	pl_dest->pl_base.sl_enum->le_ops = pl_src->pl_base.sl_enum->le_ops;
+	pl_dest->pl_base.sl_enum->le_sl = &pl_dest->pl_base;
+
+	pdclust_layout_compare(enum_id, &pl_src->pl_base.sl_base,
+			       &pl_dest->pl_base.sl_base, false);
+}
+
+static void pdclust_layout_copy_delete(uint32_t enum_id, struct m0_layout *l)
+{
+	struct m0_pdclust_layout     *pl;
+	struct m0_layout_list_enum   *list_enum;
+	struct m0_layout_linear_enum *lin_enum;
+
+	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+	M0_UT_ASSERT(l != NULL);
+
+	pl = container_of(l, struct m0_pdclust_layout, pl_base.sl_base);
+	if (enum_id == LIST_ENUM_ID) {
+		list_enum = container_of(pl->pl_base.sl_enum,
+					struct m0_layout_list_enum, lle_base);
+		m0_free(list_enum->lle_list_of_cobs);
+		m0_free(list_enum);
+	} else { /* LINEAR_ENUM_ID */
+		lin_enum = container_of(pl->pl_base.sl_enum,
+				        struct m0_layout_linear_enum, lle_base);
+		m0_free(lin_enum);
+	}
+
+	m0_free(pl);
+}
+
+/*
+ * Tests the API sequence m0_layout_encode() followed by m0_layout_decode(),
+ * for the PDCLUST layout type.
+ */
+int test_encode_decode_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+			       uint32_t enum_id, uint32_t inline_test)
+{
+	struct m0_pdclust_layout     *pl;
+	void                         *area;
+	m0_bcount_t                   num_bytes;
+	struct m0_bufvec              bv;
+	struct m0_bufvec_cursor       cur;
+	struct m0_uint128             seed;
+	uint32_t                      N;
+	uint32_t                      K;
+	uint32_t                      P;
+	struct m0_layout_list_enum   *list_enum;
+	struct m0_layout_linear_enum *lin_enum;
+	struct m0_layout             *l;
+	struct m0_layout             *l_copy;
+	struct m0_layout_type        *lt;
+
+	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+
+	m0_uint128_init(&seed, "encodedecodepdcl");
+
+	/* Build a layout object. */
+	NKP_assign(enum_id,
+		   inline_test, 13, 113, 1130,
+		   &N, &K, &P);
+	rc = pdclust_layout_build(lid, domain, enum_id,
+				  N, K, P, &seed,
+				  10, 20,
+				  &pl, &list_enum, &lin_enum,
+				  !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+
+	pdclust_layout_copy(enum_id, &pl->pl_base.sl_base, &l_copy);
+	M0_UT_ASSERT(l_copy != NULL);
+
+	/* Encode the layout object into a layout buffer. */
+	if (enum_id == LIST_ENUM_ID)
+		allocate_area(&area, ADDITIONAL_BYTES_DEFAULT, &num_bytes);
+	else
+		allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
+	bv = (struct m0_bufvec) M0_BUFVEC_INIT_BUF(&area, &num_bytes);
+	m0_bufvec_cursor_init(&cur, &bv);
+
+	m0_mutex_lock(&pl->pl_base.sl_base.l_lock);
+	rc = m0_layout_encode(&pl->pl_base.sl_base, M0_LXO_BUFFER_OP,
+			      NULL, &cur);
+	m0_mutex_unlock(&pl->pl_base.sl_base.l_lock);
+	M0_UT_ASSERT(rc == 0);
+
+	/* Destroy the layout. */
+	m0_layout_put(&pl->pl_base.sl_base);
+	M0_UT_ASSERT(list_lookup(lid) == NULL);
+
+	/* Rewind the cursor. */
+	m0_bufvec_cursor_init(&cur, &bv);
+
+	lt = &m0_pdclust_layout_type;
+	rc = lt->lt_ops->lto_allocate(domain, lid, &l);
+	M0_UT_ASSERT(rc == 0);
+
+	/*
+	 * Decode the layout buffer produced by m0_layout_encode() into another
+	 * layout object.
+	 */
+	rc = m0_layout_decode(l, &cur, M0_LXO_BUFFER_OP, NULL);
+	M0_UT_ASSERT(rc == 0);
+
+	/*
+	 * Comapre the two layout objects - one created earlier here and the
+	 * one that is produced by m0_layout_decode().
+	 */
+	pdclust_layout_compare(enum_id, l_copy, l, false);
+	pdclust_layout_copy_delete(enum_id, l_copy);
+
+	/* Unlock the layout, locked by lto_allocate() */
+	m0_mutex_unlock(&l->l_lock);
+
+	/* Destroy the layout. */
+	m0_layout_put(l);
+	M0_UT_ASSERT(list_lookup(lid) == NULL);
+
+	m0_free(area);
+	return rc;
+}
+
+/*
+ * Tests the API m0_layout_get() and m0_layout_put(), for the PDCLUST layout
+ * type.
+ */
+int test_ref_get_put_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+			     uint32_t enum_id)
+{
+	struct m0_pdclust_layout     *pl;
+	struct m0_uint128             seed;
+	uint32_t                      N;
+	uint32_t                      K;
+	uint32_t                      P;
+	struct m0_layout_list_enum   *list_enum;
+	struct m0_layout_linear_enum *lin_enum;
+	uint32_t                      i;
+
+	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+
+	m0_uint128_init(&seed, "refgetputpdclust");
+
+	/* Build a layout object. */
+	NKP_assign(enum_id,
+		   MORE_THAN_INLINE, 10, 1212, 1212,
+		   &N, &K, &P);
+
+	rc = pdclust_layout_build(lid, domain, LIST_ENUM_ID,
+				  N, K, P, &seed,
+				  10, 20,
+				  &pl, &list_enum, &lin_enum,
+				  !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+
+	/* Verify that the ref count is set to 1. */
+	M0_UT_ASSERT(m0_ref_read(&pl->pl_base.sl_base.l_ref) == 1);
+
+	/* Add multiple references on the layout object. */
+	for (i = 0; i < 123; ++i)
+		m0_layout_get(&pl->pl_base.sl_base);
+	M0_UT_ASSERT(m0_ref_read(&pl->pl_base.sl_base.l_ref) == 1 + 123);
+
+	/* Release multiple references on the layout object. */
+	for (i = 0; i < 123; ++i)
+		m0_layout_put(&pl->pl_base.sl_base);
+	M0_UT_ASSERT(m0_ref_read(&pl->pl_base.sl_base.l_ref) == 1);
+
+	/* Release the last reference so as to delete the layout. */
+	m0_layout_put(&pl->pl_base.sl_base);
+	M0_UT_ASSERT(list_lookup(lid) == NULL);
+
+	return rc;
+}
+
+/*
+ * Tests the enum operations pointed by leo_nr and leo_get, for the PDCLUST
+ * layout type.
+ */
+int test_enum_ops_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+			  uint32_t enum_id, uint32_t inline_test)
+{
+	struct m0_uint128             seed;
+	uint32_t                      N;
+	uint32_t                      K;
+	uint32_t                      P;
+	struct m0_pdclust_layout     *pl;
+	struct m0_layout_list_enum   *list_enum;
+	struct m0_layout_linear_enum *lin_enum;
+
+	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+
+	/* Build a layout object. */
+	m0_uint128_init(&seed, "enumopspdclustla");
+
+	NKP_assign(enum_id,
+		   inline_test, 14, 1014, 1014,
+		   &N, &K, &P);
+
+	rc = pdclust_layout_build(lid, domain, enum_id,
+				  N, K, P, &seed,
+				  777, 888,
+				  &pl, &list_enum, &lin_enum,
+				  !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+
+	/* Verify enum operations. */
+	enum_op_verify(&pl->pl_base.sl_base, lid, enum_id, P);
+
+	/* Destroy the layout object. */
+	m0_layout_put(&pl->pl_base.sl_base);
+	M0_UT_ASSERT(list_lookup(lid) == NULL);
+
+	return rc;
+}
+
+/*
+ * Calculates the recsize by considering the sizes of the internal data
+ * structures and their values, as applicable. Then verifies that the recsize
+ * provided as an argument matches the calcualted one.
+ */
+static void pdclust_recsize_verify(uint32_t enum_id,
+				   struct m0_layout *l,
+				   m0_bcount_t recsize_to_verify)
+{
+	struct m0_pdclust_layout    *pl;
+	struct m0_layout_list_enum  *list_enum;
+	m0_bcount_t                  recsize;
+
+	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+	M0_UT_ASSERT(l != NULL);
+	M0_UT_ASSERT(l->l_type == &m0_pdclust_layout_type);
+
+	pl = container_of(l, struct m0_pdclust_layout, pl_base.sl_base);
+
+	/* Account for the enum type specific recsize. */
+	if (enum_id == LIST_ENUM_ID) {
+		list_enum = container_of(pl->pl_base.sl_enum,
+					 struct m0_layout_list_enum, lle_base);
+		if (list_enum->lle_nr < LDB_MAX_INLINE_COB_ENTRIES)
+			recsize = sizeof(struct cob_entries_header) +
+				  list_enum->lle_nr * sizeof(struct m0_fid);
+		else
+			recsize = sizeof(struct cob_entries_header) +
+				  LDB_MAX_INLINE_COB_ENTRIES *
+				  sizeof(struct m0_fid);
+	} else
+		recsize = sizeof(struct m0_layout_linear_attr);
+
+	/*
+	 * Account for the recsize for the generic part of the layout object
+	 * and for the PDCLUST layout type specific part of it.
+	 */
+	recsize = sizeof(struct m0_layout_rec) +
+		  sizeof(struct m0_layout_pdclust_rec) + recsize;
+
+	/* Compare the two sizes. */
+	M0_UT_ASSERT(recsize == recsize_to_verify);
+}
+
+/* Tests the function lo_recsize(), for the PDCLUST layout type. */
+int test_recsize_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+			 uint32_t enum_id, uint32_t inline_test)
+{
+	struct m0_pdclust_layout     *pl;
+	struct m0_layout             *l;
+	struct m0_uint128             seed;
+	uint32_t                      N;
+	uint32_t                      K;
+	uint32_t                      P;
+	struct m0_layout_list_enum   *list_enum;
+	struct m0_layout_linear_enum *lin_enum;
+	m0_bcount_t                   recsize;
+
+	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+
+	m0_uint128_init(&seed, "recsizepdclustla");
+
+	/* Build a layout object. */
+	NKP_assign(enum_id,
+		   inline_test, 1, 1200, 1111,
+		   &N, &K, &P);
+
+	rc = pdclust_layout_build(lid, domain, enum_id,
+				  N, K, P, &seed,
+				  10, 20,
+				  &pl, &list_enum, &lin_enum,
+				  !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+
+	/* Obtain the recsize by using the internal function lo_recsize(). */
+	l = &pl->pl_base.sl_base;
+	recsize = l->l_ops->lo_recsize(l);
+
+	/* Verify the recsize returned by lo_recsize(). */
+	pdclust_recsize_verify(enum_id, &pl->pl_base.sl_base, recsize);
+
+	/* Destroy the layout object. */
+	m0_layout_put(l);
+	M0_UT_ASSERT(list_lookup(lid) == NULL);
+	return rc;
+}
+
+/* Tests the APIs supported for m0_pdclust_instance object. */
+int test_pdclust_instance_obj(uint64_t lid, struct m0_layout_domain *domain,
+			      uint32_t enum_id, uint32_t inline_test,
+			      bool failure_test)
+{
+	struct m0_uint128             seed;
+	uint32_t                      N;
+	uint32_t                      K;
+	uint32_t                      P;
+	struct m0_layout             *l;
+	struct m0_pdclust_layout     *pl;
+	struct m0_layout_list_enum   *list_enum;
+	struct m0_layout_linear_enum *lin_enum;
+	struct m0_pdclust_instance   *pi;
+	struct m0_fid                 gfid;
+	struct m0_layout_instance    *li;
+
+	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+
+	m0_uint128_init(&seed, "buildpdclustlayo");
+
+	NKP_assign(enum_id,
+		   inline_test, 14, 30, 30,
+		   &N, &K, &P);
+
+	rc = pdclust_layout_build(lid, domain, enum_id,
+				  N, K, P, &seed,
+				  10, 20,
+				  &pl, &list_enum, &lin_enum,
+				  !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+
+	/* Verify some pdclust APIs. */
+	M0_UT_ASSERT(m0_pdclust_N(pl) == N);
+	M0_UT_ASSERT(m0_pdclust_K(pl) == K);
+	M0_UT_ASSERT(m0_pdclust_P(pl) == P);
+	M0_UT_ASSERT(m0_pdclust_unit_size(pl) == UNIT_SIZE);
+
+	M0_UT_ASSERT(m0_pdclust_unit_classify(pl, N - 1) == M0_PUT_DATA);
+	M0_UT_ASSERT(m0_pdclust_unit_classify(pl, N) == M0_PUT_PARITY);
+	M0_UT_ASSERT(m0_pdclust_unit_classify(pl, N + 2 * K ) == M0_PUT_SPARE);
+
+	/* Build pdclust instance. */
+	m0_fid_set(&gfid, 0, 999);
+	l = m0_pdl_to_layout(pl);
+	M0_UT_ASSERT(m0_ref_read(&l->l_ref) == 1);
+	rc = m0_layout_instance_build(l, &gfid, &li);
+	if (failure_test)
+		M0_UT_ASSERT(rc == -ENOMEM || rc == -EPROTO);
+	else {
+		M0_UT_ASSERT(rc == 0);
+		M0_UT_ASSERT(m0_ref_read(&l->l_ref) == 2);
+		pi = m0_layout_instance_to_pdi(li);
+		layout_demo(pi, pl, 1, 1, false);
+
+		/* Verify m0_layout_instance_to_pdi(). */
+		li = &pi->pi_base;
+		M0_UT_ASSERT(m0_layout_instance_to_pdi(li) == pi);
+
+		/* Verify m0_layout_instance_to_enum */
+		if (enum_id == LIST_ENUM_ID)
+			M0_UT_ASSERT(m0_layout_instance_to_enum(li) ==
+				     &list_enum->lle_base);
+		else
+			M0_UT_ASSERT(m0_layout_instance_to_enum(li) ==
+				     &lin_enum->lle_base);
+
+		/* Delete the pdclust instance object. */
+		m0_layout_instance_fini(&pi->pi_base);
+		M0_UT_ASSERT(m0_ref_read(&l->l_ref) == 1);
+	}
+
+	/* Delete the layout object. */
+	m0_layout_put(m0_pdl_to_layout(pl)); //todo l
+	M0_UT_ASSERT(list_lookup(lid) == NULL);
+	return rc;
+}
+
+//todo Jan 14 Continue from following
+
+#ifndef __KERNEL__
+/* Tests the API m0_layout_lookup(), for the PDCLUST layout type. */
+int test_lookup_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+			uint32_t enum_id, uint32_t inline_test,
+			bool existing_test,
+			bool failure_test)
+{
+	m0_bcount_t        num_bytes;
+	void              *area;
+	struct m0_layout  *l1;
+	struct m0_layout  *l1_copy;
+	struct m0_layout  *l2;
+	struct m0_layout  *l3;
+	struct m0_db_pair  pair;
+	struct m0_db_tx    tx;
+	int                rc_tmp;
+
+	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+	M0_UT_ASSERT(ergo(!existing_test, failure_test));
+
+	/*
+	 * If existing_test is true, then first add a layout object to the
+	 * DB.
+	 */
+	if (existing_test) {
+		rc = test_add_pdclust(lid, domain,
+				      enum_id, inline_test,
+				      !LAYOUT_DESTROY, &l1,
+				      !DUPLICATE_TEST,
+				      !FAILURE_TEST);
+		M0_UT_ASSERT(rc == 0);
+		if (!failure_test)
+			pdclust_layout_copy(enum_id, l1, &l1_copy);
+
+		/*
+		 * Lookup for the layout object to verify that the same object
+		 * is returned from the memory, not requiring a lookup from the
+		 * DB.
+		 */
+		rc = m0_layout_lookup(domain, lid, &m0_pdclust_layout_type,
+				      &tx, &pair, &l2);
+		M0_UT_ASSERT(rc == 0);
+		M0_UT_ASSERT(l2 == l1);
+
+		/* Release the reference acquired by m0_layout_lookup(). */
+		m0_layout_put(l1);
+
+		/* Destroy the layout object. */
+		m0_layout_put(l1);
+	}
+
+	M0_UT_ASSERT(list_lookup(lid) == NULL);
+
+	/* Lookup for the layout object from the DB. */
+	allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
+
+	rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
+	M0_UT_ASSERT(rc == 0);
+
+	pair_set(&pair, &lid, area, num_bytes);
+
+	rc = m0_layout_lookup(domain, lid, &m0_pdclust_layout_type,
+			      &tx, &pair, &l3);
+	if (failure_test)
+		M0_UT_ASSERT(rc == -ENOENT || rc == -ENOMEM || rc == -EPROTO ||
+			     rc == LO_DECODE_ERR);
+	else
+		M0_UT_ASSERT(rc == 0);
+
+	rc_tmp = m0_db_tx_commit(&tx);
+	M0_UT_ASSERT(rc_tmp == 0);
+
+	if (existing_test && !failure_test) {
+		M0_UT_ASSERT(list_lookup(lid) == l3);
+		pdclust_layout_compare(enum_id, l1_copy, l3, false);
+		pdclust_layout_copy_delete(enum_id, l1_copy);
+
+		/* Destroy the layout object. */
+		m0_layout_put(l3);
+		M0_UT_ASSERT(list_lookup(lid) == NULL);
+	}
+	m0_free(area);
+	return rc;
+}
+
+/* todo Make the name pdclust specific */
+int test_lookup_pdclust_with_ghost_creation(uint64_t lid,
+					    struct m0_layout_domain *domain,
+					    uint32_t enum_id,
+					    uint32_t inline_test)
+{
+	struct m0_layout        *l1;
+	struct m0_layout        *l1_copy;
+	struct ghost_data        g_data = { 0 };
+	void                    *area_for_encode;
+	m0_bcount_t              num_bytes_for_encode;
+	struct m0_bufvec         bv_for_encode;
+	struct m0_bufvec_cursor  cur_for_encode;
+	struct m0_layout        *l_from_DB;
+	m0_bcount_t              num_bytes_for_lookup;
+	void                    *area_for_lookup;
+	struct m0_db_pair        pair;
+	struct m0_db_tx          tx;
+	int                      rc_tmp;
+
+	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+
+	/* Create one layout object and add it to the LDB. */
+	rc = test_add_pdclust(lid, domain,
+			      enum_id, inline_test,
+			      !LAYOUT_DESTROY, &l1,
+			      !DUPLICATE_TEST,
+			      !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+	pdclust_layout_copy(enum_id, l1, &l1_copy);
+
+        /*
+	 * Encode the layout object and store its encoded representation into
+	 * the ghost_data (g_data.cur) so that the ghost can be created at a
+	 * later point.
+	 */
+	if (enum_id == LIST_ENUM_ID)
+		allocate_area(&area_for_encode, ADDITIONAL_BYTES_DEFAULT,
+			      &num_bytes_for_encode);
+	else
+		allocate_area(&area_for_encode, ADDITIONAL_BYTES_NONE,
+			      &num_bytes_for_encode);
+	bv_for_encode = (struct m0_bufvec) M0_BUFVEC_INIT_BUF(&area_for_encode,
+						&num_bytes_for_encode);
+	m0_bufvec_cursor_init(&cur_for_encode, &bv_for_encode);
+	m0_mutex_lock(&l1->l_lock);
+	rc = m0_layout_encode(l1, M0_LXO_BUFFER_OP, NULL, &cur_for_encode);
+	m0_mutex_unlock(&l1->l_lock);
+	M0_UT_ASSERT(rc == 0);
+	/* Rewind the cursor. */
+	m0_bufvec_cursor_init(&cur_for_encode, &bv_for_encode);
+	g_data.cur = &cur_for_encode;
+	g_data.lid = lid;
+
+	/*
+	 * Destroy the layout object, so that the next m0_layout_lookup() does
+	 * not return right away with the layout object read from memory and
+	 * instead goes to the LDB to read it.
+	 */
+	m0_layout_put(l1);
+	M0_UT_ASSERT(list_lookup(lid) == NULL);
+
+	/*
+	 * Lookup for the layout object from the LDB, using m0_layout_lookup().
+	 * But while this m0_layout_lookup() is in progress, ghost_create()
+	 * will create another in-memory layout object using m0_layout_decode()
+	 * performed on the serialised representation of the same layout
+	 * created above and stored in g_data.cur.
+	 */
+	if (enum_id == LIST_ENUM_ID)
+		allocate_area(&area_for_lookup, ADDITIONAL_BYTES_DEFAULT,
+			      &num_bytes_for_lookup);
+	else
+		allocate_area(&area_for_lookup, ADDITIONAL_BYTES_NONE,
+			      &num_bytes_for_lookup);
+
+	rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
+	M0_UT_ASSERT(rc == 0);
+
+	pair_set(&pair, &lid, area_for_lookup, num_bytes_for_lookup);
+	m0_fi_enable_func("m0_layout_lookup", "ghost_creation",
+			  ghost_create, &g_data);
+	rc = m0_layout_lookup(domain, lid, &m0_pdclust_layout_type,
+			      &tx, &pair, &l_from_DB);
+	M0_UT_ASSERT(rc == 0);
+	m0_layout_put(l_from_DB);
+	m0_fi_disable("m0_layout_lookup", "ghost_creation");
+	rc_tmp = m0_db_tx_commit(&tx);
+	M0_UT_ASSERT(rc_tmp == 0);
+
+	M0_UT_ASSERT(l_from_DB == g_data.l);
+	M0_UT_ASSERT(list_lookup(lid) == l_from_DB);
+	pdclust_layout_compare(enum_id, l1_copy, l_from_DB, false);
+	pdclust_layout_copy_delete(enum_id, l1_copy);
+
+	/* Destroy the layout object. */
+	m0_layout_put(l_from_DB);
+	M0_UT_ASSERT(list_lookup(lid) == NULL);
+
+	m0_free(area_for_encode);
+	m0_free(area_for_lookup);
+	return rc;
+}
+
+/* Tests the API m0_layout_add(), for the PDCLUST layout type. */
+int test_add_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+		     uint32_t enum_id, uint32_t inline_test,
+		     bool layout_destroy, struct m0_layout **l_obj,
+		     bool duplicate_test,
+		     bool failure_test)
+{
+	m0_bcount_t                   num_bytes;
+	uint32_t                      N;
+	uint32_t                      K;
+	uint32_t                      P;
+	void                         *area;
+	struct m0_pdclust_layout     *pl;
+	struct m0_db_pair             pair;
+	struct m0_db_tx               tx;
+	struct m0_uint128             seed;
+	struct m0_layout_list_enum   *list_enum;
+	struct m0_layout_linear_enum *lin_enum;
+	int                           rc_tmp;
+
+	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+	M0_UT_ASSERT(ergo(layout_destroy, l_obj == NULL));
+	M0_UT_ASSERT(ergo(!layout_destroy, l_obj != NULL));
+	M0_UT_ASSERT(ergo(duplicate_test, !failure_test));
+
+	m0_uint128_init(&seed, "addpdclustlayout");
+
+	allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
+
+	/* Build a layout object. */
+	NKP_assign(enum_id,
+		   inline_test, 7, 1900, 1900,
+		   &N, &K, &P);
+
+	rc = pdclust_layout_build(lid, domain, enum_id,
+				  N, K, P, &seed,
+				  100, 200,
+				  &pl, &list_enum, &lin_enum,
+				  !FAILURE_TEST);
+	M0_UT_ASSERT(rc == 0);
+
+	/* Add the layout object to the DB. */
+	rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
+	M0_UT_ASSERT(rc == 0);
+
+	pair_set(&pair, &lid, area, num_bytes);
+
+	rc = m0_layout_add(&pl->pl_base.sl_base, &tx, &pair);
+	if (failure_test)
+		M0_UT_ASSERT(rc == -ENOENT || rc == LO_ENCODE_ERR);
+	else
+		M0_UT_ASSERT(rc == 0);
+
+	rc_tmp = m0_db_tx_commit(&tx);
+	M0_UT_ASSERT(rc_tmp == 0);
+
+	M0_UT_ASSERT(list_lookup(lid) == &pl->pl_base.sl_base);
+
+	/*
+	 * If duplicate_test is true, again try to add the same layout object
+	 * to the DB, to verify that it results into EEXIST error.
+	 */
+	if (duplicate_test) {
+		rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
+		M0_UT_ASSERT(rc == 0);
+
+		pair_set(&pair, &lid, area, num_bytes);
+
+		rc = m0_layout_add(&pl->pl_base.sl_base, &tx, &pair);
+		M0_UT_ASSERT(rc == -EEXIST);
+
+		rc_tmp = m0_db_tx_commit(&tx);
+		M0_UT_ASSERT(rc_tmp == 0);
+	}
+
+	if (layout_destroy) {
+		m0_layout_put(&pl->pl_base.sl_base);
+		M0_UT_ASSERT(list_lookup(lid) == NULL);
+	}
+	else
+		*l_obj = &pl->pl_base.sl_base;
+
+	m0_free(area);
+	return rc;
+}
+
+/* Tests the API m0_layout_update(), for the PDCLUST layout type. */
+int test_update_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+			uint32_t enum_id, uint32_t inline_test,
+			bool existing_test,
+			bool failure_test)
+{
+	m0_bcount_t                   num_bytes;
+	void                         *area;
+	struct m0_db_pair             pair;
+	struct m0_db_tx               tx;
+	struct m0_layout             *l1;
+	struct m0_layout             *l1_copy;
+	struct m0_layout             *l2;
+	uint32_t                      i;
+	struct m0_uint128             seed;
+	uint32_t                      N;
+	uint32_t                      K;
+	uint32_t                      P;
+	struct m0_pdclust_layout     *pl;
+	struct m0_layout_list_enum   *list_enum;
+	struct m0_layout_linear_enum *lin_enum;
+	int                           rc_tmp;
+
+	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+
+	allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
+
+	NKP_assign(enum_id,
+		   inline_test, 13, 123, 1230,
+		   &N, &K, &P);
+
+	if (existing_test) {
+		/* Add a layout object to the DB. */
+		rc = test_add_pdclust(lid, domain,
+				      enum_id, inline_test,
+				      !LAYOUT_DESTROY, &l1,
+				      !DUPLICATE_TEST,
+				      !FAILURE_TEST);
+		M0_UT_ASSERT(rc == 0);
+	} else {
+		/* Build a layout object. */
+		m0_uint128_init(&seed, "updatepdclustlay");
+
+		rc = pdclust_layout_build(lid, domain, enum_id,
+					  N, K, P, &seed,
+					  10, 20,
+					  &pl, &list_enum, &lin_enum,
+					  !FAILURE_TEST);
+		M0_UT_ASSERT(rc == 0);
+		l1 = &pl->pl_base.sl_base;
+	}
+
+	/* Verify the original user count is as expected. */
+	M0_UT_ASSERT(l1->l_user_count == 0);
+
+	/* Update the in-memory layout object - update its user count. */
+	for (i = 0; i < 100; ++i)
+		m0_layout_user_count_inc(l1);
+	M0_UT_ASSERT(l1->l_user_count == 100);
+
+	/* Update the layout object in the DB. */
+	rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
+	M0_UT_ASSERT(rc == 0);
+
+	pair_set(&pair, &lid, area, num_bytes);
+
+	rc = m0_layout_update(l1, &tx, &pair);
+	if (failure_test)
+		M0_UT_ASSERT(rc == LO_ENCODE_ERR || rc == L_TABLE_UPDATE_ERR);
+	else
+		M0_UT_ASSERT(rc == 0);
+	/*
+	 * Even a non-existing record can be written to the database using
+	 * the database update operation.
+	 */
+	if (existing_test && !failure_test)
+		pdclust_layout_copy(enum_id, l1, &l1_copy);
+
+	rc_tmp = m0_db_tx_commit(&tx);
+	M0_UT_ASSERT(rc_tmp == 0);
+
+	/*
+	 * Update the in-memory layout object - update its user count. This is
+	 * to verify the functioning of m0_layout_user_count_dec().
+	 */
+	for (i = 0; i < 50; ++i)
+		m0_layout_user_count_dec(l1);
+	M0_UT_ASSERT(l1->l_user_count == 50);
+
+	/* Delete the in-memory layout. */
+	m0_layout_put(l1);
+	M0_UT_ASSERT(list_lookup(lid) == NULL);
+
+	if (existing_test && !failure_test) {
+		/*
+		 * Lookup for the layout object from the DB to verify that its
+		 * user count is indeed updated.
+		 */
+		rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
+		M0_UT_ASSERT(rc == 0);
+
+		pair_set(&pair, &lid, area, num_bytes);
+
+		rc = m0_layout_lookup(domain, lid, &m0_pdclust_layout_type,
+				      &tx, &pair, &l2);
+		M0_UT_ASSERT(rc == 0);
+		M0_UT_ASSERT(l2->l_user_count == 100);
+		M0_UT_ASSERT(m0_ref_read(&l2->l_ref) == 1);
+
+		rc = m0_db_tx_commit(&tx);
+		M0_UT_ASSERT(rc == 0);
+
+		/*
+		 * Compare the two layouts - one created earlier here and the
+		 * one that is looked up from the DB.
+		 */
+		pdclust_layout_compare(enum_id, l1_copy, l2, false);
+		pdclust_layout_copy_delete(enum_id, l1_copy);
+
+		/* Delete the in-memory layout. */
+		m0_layout_put(l2);
+		M0_UT_ASSERT(list_lookup(lid) == NULL);
+	}
+
+	m0_free(area);
+	return rc;
+}
+
+/* Tests the API m0_layout_delete(), for the PDCLUST layout type. */
+int test_delete_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+			uint32_t enum_id, uint32_t inline_test,
+			bool existing_test,
+			uint32_t failure_test)
+{
+	m0_bcount_t                   num_bytes;
+	void                         *area;
+	struct m0_db_pair             pair;
+	struct m0_db_tx               tx;
+	struct m0_layout             *l;
+	struct m0_uint128             seed;
+	uint32_t                      N;
+	uint32_t                      K;
+	uint32_t                      P;
+	struct m0_pdclust_layout     *pl;
+	struct m0_layout_list_enum   *list_enum;
+	struct m0_layout_linear_enum *lin_enum;
+	int                           rc_tmp;
+
+	M0_UT_ASSERT(enum_id == LIST_ENUM_ID || enum_id == LINEAR_ENUM_ID);
+
+	allocate_area(&area, ADDITIONAL_BYTES_NONE, &num_bytes);
+
+	NKP_assign(enum_id,
+		   inline_test, 12, 122, 1220,
+		   &N, &K, &P);
+	if (existing_test) {
+		/* Add a layout object to the DB. */
+		rc = test_add_pdclust(lid, domain,
+				      enum_id, inline_test,
+				      !LAYOUT_DESTROY, &l,
+				      !DUPLICATE_TEST,
+				      !FAILURE_TEST);
+		M0_UT_ASSERT(rc == 0);
+	} else {
+		/* Build a layout object. */
+		m0_uint128_init(&seed, "deletepdclustlay");
+
+		rc = pdclust_layout_build(lid, domain, enum_id,
+					  N, K, P, &seed,
+					  10, 20,
+					  &pl, &list_enum, &lin_enum,
+					  !FAILURE_TEST);
+		M0_UT_ASSERT(rc == 0);
+		l = &pl->pl_base.sl_base;
+	}
+
+	if (M0_FI_ENABLED("nonzero_user_count_err"))
+		m0_layout_user_count_inc(l);
+
+	/* Delete the layout object from the DB. */
+	pair_set(&pair, &lid, area, num_bytes);
+
+	rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
+	M0_UT_ASSERT(rc == 0);
+
+	rc = m0_layout_delete(l, &tx, &pair);
+	if (failure_test)
+		M0_UT_ASSERT(rc == -ENOENT || rc == -ENOMEM ||
+			     rc == -EPROTO || rc == LO_ENCODE_ERR);
+	else
+		M0_UT_ASSERT(rc == 0);
+
+	rc_tmp = m0_db_tx_commit(&tx);
+	M0_UT_ASSERT(rc_tmp == 0);
+
+	/* Destroy the layout object. */
+	m0_layout_put(l);
+	M0_UT_ASSERT(list_lookup(lid) == NULL);
+
+	if (!failure_test) {
+		/*
+		 * Lookup for the layout object from the DB, to verify that it
+		 * does not exist there and that the lookup results into
+		 * ENOENT error.
+		 */
+		rc = m0_db_tx_init(&tx, domain->ld_dbenv, DBFLAGS);
+		M0_UT_ASSERT(rc == 0);
+
+		pair_set(&pair, &lid, area, num_bytes);
+
+		rc_tmp = m0_layout_lookup(domain, lid, &m0_pdclust_layout_type,
+					  &tx, &pair, &l);
+		M0_UT_ASSERT(rc_tmp == -ENOENT);
+
+		rc_tmp = m0_db_tx_commit(&tx);
+		M0_UT_ASSERT(rc_tmp == 0);
+	}
+
+	m0_free(area);
+	return rc;
+}
+#endif /* __KERNEL__ */
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
diff --git a/layout/ut/pdclust.h b/layout/ut/pdclust.h
new file mode 100644
index 0000000..4caa576
--- /dev/null
+++ b/layout/ut/pdclust.h
@@ -0,0 +1,103 @@
+/* -*- C -*- */
+/*
+ * COPYRIGHT 2013 XYRATEX TECHNOLOGY LIMITED
+ *
+ * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
+ * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
+ * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
+ * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
+ * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
+ * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
+ * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
+ *
+ * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
+ * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
+ * http://www.xyratex.com/contact
+ *
+ * Original author: Trupti Patil <trupti_patil@xyratex.com>
+ * Original creation date: 01/15/2013
+ */
+
+#pragma once
+
+#ifndef __MERO_LAYOUT_UT_PDCLUST_H__
+#define __MERO_LAYOUT_UT_PDCLUST_H__
+
+struct m0_layout_list_enum;
+struct m0_layout_linear_enum;
+
+void NKP_assign(uint32_t enum_id, uint32_t inline_test,
+		uint32_t list_nr_less, uint32_t list_nr_more,
+		uint32_t linear_nr,
+		uint32_t *N, uint32_t *K, uint32_t *P);
+int pdclust_layout_build(uint64_t lid, struct m0_layout_domain *domain,
+			 uint32_t enum_id,
+			 uint32_t N, uint32_t K, uint32_t P,
+			 struct m0_uint128 *seed,
+			 uint32_t A, uint32_t B,
+			 struct m0_pdclust_layout **pl,
+			 struct m0_layout_list_enum **list_enum,
+			 struct m0_layout_linear_enum **lin_enum,
+			 bool failure_test);
+void pdclust_layout_verify(struct m0_layout *l, uint64_t lid, uint32_t enum_id,
+			   uint32_t N, uint32_t K, uint32_t P,
+			   struct m0_uint128 *seed,
+			   uint32_t A, uint32_t B,
+			   bool if_user_count_incremented);
+			   
+
+int test_build_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+		       uint32_t enum_id, uint32_t inline_test,
+		       bool failure_test);
+int test_decode_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+			uint32_t enum_id, uint32_t inline_test,
+			bool failure_test);
+int test_encode_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+			uint32_t enum_id, uint32_t inline_test,
+			bool failure_test);
+int test_decode_encode_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+			       uint32_t enum_id, uint32_t inline_test);
+int test_encode_decode_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+			       uint32_t enum_id, uint32_t inline_test);
+int test_ref_get_put_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+			     uint32_t enum_id);
+int test_enum_ops_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+			  uint32_t enum_id, uint32_t inline_test);
+int test_recsize_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+			  uint32_t enum_id, uint32_t inline_test);
+int test_pdclust_instance_obj(uint64_t lid, struct m0_layout_domain *domain,
+			      uint32_t enum_id, uint32_t inline_test,
+			      bool failure_test);
+int test_lookup_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+			uint32_t enum_id, uint32_t inline_test,
+			bool existing_test, bool failure_test);
+int test_lookup_pdclust_with_ghost_creation(uint64_t lid,
+					    struct m0_layout_domain *domain,
+					    uint32_t enum_id,
+					    uint32_t inline_test);
+int test_add_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+		     uint32_t enum_id, uint32_t inline_test,
+		     bool layout_destroy, struct m0_layout **l_obj,
+		     bool duplicate_test,
+		     bool failure_test);
+int test_update_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+			uint32_t enum_id, uint32_t inline_test,
+			bool existing_test,
+			bool failure_test);
+int test_delete_pdclust(uint64_t lid, struct m0_layout_domain *domain,
+			uint32_t enum_id, uint32_t inline_test,
+			bool existing_test,
+			uint32_t failure_test);
+
+/* __MERO_LAYOUT_PDCLUST_H__ */
+#endif
+
+/*
+ *  Local variables:
+ *  c-indentation-style: "K&R"
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ *  fill-column: 80
+ *  scroll-step: 1
+ *  End:
+ */
-- 
1.8.3.2

