From fb72fd30ceab4cd70e8da9740fbbb149bcc4e10b Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Wed, 17 Oct 2012 21:28:51 +0530
Subject: [PATCH 004/157] Basic encode-decode support for composite layout

---
 layout/composite.c | 153 ++++++++++++++++++++---------
 layout/composite.h |  46 +++++++--
 layout/layout_db.c |   4 +-
 layout/list_enum.h |   1 +
 layout/ut/layout.c | 281 ++++++++++++++++++++++++++++++++++++++++++++++-------
 5 files changed, 388 insertions(+), 97 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index 07c1fe7..e944b73 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -63,7 +63,7 @@ struct composite_schema_data {
 	struct c2_emap csd_comp_layout_ext_map;
 };
 
-/** Prefix for comp_layout_ext_map table. */
+/** Prefix for the comp_layout_ext_map table. */
 struct layout_prefix {
 	/**
 	 * Layout id for the composite layout.
@@ -78,12 +78,10 @@ struct layout_prefix {
 	uint64_t lp_filler;
 };
 
-#if 1
-C2_TL_DESCR_DEFINE(c2_sub_layout, "sub-layout-list", ,
+C2_TL_DESCR_DEFINE(c2_sub_layout, "sub-layout-list", /* global */,
 		   struct c2_composite_sub_layout, csl_list_linkage, csl_magic,
 		   C2_LAYOUT_COMP_SUBL_MAGIC, C2_LAYOUT_COMP_SUBL_HEAD_MAGIC);
 C2_TL_DEFINE(c2_sub_layout, /* global */, struct c2_composite_sub_layout);
-#endif
 
 static bool composite_allocated_invariant(const struct c2_composite_layout *cl)
 {
@@ -91,7 +89,8 @@ static bool composite_allocated_invariant(const struct c2_composite_layout *cl)
 		cl != NULL &&
 		c2_layout__allocated_invariant(&cl->cl_base) &&
 		c2_mutex_is_locked(&cl->cl_base.l_lock) &&
-		cl->cl_sub_layouts == NULL;
+		cl->cl_sub_layouts == NULL &&
+		cl->cl_nr == 0;
 }
 
 static bool composite_invariant(const struct c2_composite_layout *cl)
@@ -100,6 +99,7 @@ static bool composite_invariant(const struct c2_composite_layout *cl)
 		c2_composite_layout_bob_check(cl) &&
 		c2_layout__invariant(&cl->cl_base) &&
 		cl->cl_sub_layouts != NULL &&
+		cl->cl_nr != 0 &&
 		!c2_sub_layout_tlist_is_empty(cl->cl_sub_layouts) &&
 		c2_tl_forall(c2_sub_layout, sl, cl->cl_sub_layouts,
 			     c2_layout__invariant(sl->csl_l));
@@ -157,13 +157,12 @@ static void composite_delete(struct c2_layout *l)
 	C2_LEAVE();
 }
 
-//todo Check if the return type should be int or make it void
 static int composite_populate(struct c2_composite_layout *cl,
 			      struct c2_tl *sub_layouts,
 			      uint32_t user_count)
 {
-	/* todo Oct12 Continue form here. */
 	struct c2_composite_sub_layout *sl;
+	uint32_t                        nr = 0;
 
 	C2_PRE(composite_allocated_invariant(cl));
 	C2_PRE(sub_layouts != NULL);
@@ -171,12 +170,17 @@ static int composite_populate(struct c2_composite_layout *cl,
 	C2_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 
 	c2_layout__populate(&cl->cl_base, user_count);
+
+	/* todo Validate the sub layout list received as input and ... */
 	/* Add a reference to each of the sub-layouts. */
 	c2_tl_for(c2_sub_layout, sub_layouts, sl) {
 		C2_ASSERT(c2_layout__invariant(sl->csl_l));
-		c2_layout_get(sl->csl_l);
+		c2_layout_get(sl->csl_l); //todo check
+		//todo c2_layout_user_count_inc(sl->csl_l);
+		++nr;
 	} c2_tl_endfor;
 	cl->cl_sub_layouts = sub_layouts;
+	cl->cl_nr = nr;
 
 	C2_POST(composite_invariant(cl));
 	C2_POST(c2_mutex_is_locked(&cl->cl_base.l_lock));
@@ -240,6 +244,7 @@ static void composite_fini(struct c2_layout *l)
 	c2_composite_layout_bob_fini(cl);
 
 	c2_tl_for(c2_sub_layout, cl->cl_sub_layouts, sl) {
+		//todo c2_layout_user_count_inc(sl->csl_l);
 		/* Release the reference acquired by composite_populate(). */
 		c2_layout_put(sl->csl_l);
 		c2_sub_layout_tlist_del(sl);
@@ -324,34 +329,70 @@ static c2_bcount_t composite_max_recsize(struct c2_layout_domain *dom)
 
 static const struct c2_layout_ops composite_ops;
 
-/**
- * Implementation of lo_decode() for composite layout type.
- *
- * Continues to build the in-memory layout object from its representation
- * either 'stored in the Layout DB' or 'received through the buffer'.
- *
- * @param op This enum parameter indicates what if a DB operation is to be
- * performed on the layout record and it could be LOOKUP if at all.
- * If it is BUFFER_OP, then the layout is decoded from its representation
- * received through the buffer.
- */
+/** Implementation of lo_decode() for composite layout type. */
 static int composite_decode(struct c2_layout *l,
 			    struct c2_bufvec_cursor *cur,
 			    enum c2_layout_xcode_op op,
 			    struct c2_db_tx *tx,
 			    uint32_t ref_count)
 {
-	/*
-	@code
-	struct c2_composite_layout *cl;
-
-	C2_PRE(C2_IN(op, (C2_LXO_DB_LOOKUP, C2_LXO_BUFFER_OP));
+	struct c2_composite_layout     *cl;
+	struct c2_composite_sub_layout *sl;
+	struct c2_tl                   *sub_layouts;
+	struct sub_layouts_header      *sl_header;
+	struct sub_layout_entry        *sl_entry;
+	uint32_t                        i;
+	int                             rc;
+
+	C2_PRE(c2_layout__allocated_invariant(l));
+	C2_PRE(cur != NULL);
+	C2_PRE(c2_bufvec_cursor_step(cur) >= sizeof *sl_header);
+	C2_PRE(C2_IN(op, (C2_LXO_DB_LOOKUP, C2_LXO_BUFFER_OP)));
+	C2_PRE(ergo(op == C2_LXO_DB_LOOKUP, tx != NULL));
 
-	C2_ALLOC_PTR(cl);
+	C2_ENTRY("lid %llu", (unsigned long long)l->l_id);
+	cl = bob_of(l, struct c2_composite_layout, cl_base, &composite_bob);
+	C2_PRE(composite_allocated_invariant(cl));
 
-	c2_layout__init(dom, &cl->cl_base, lid,
-			&c2_composite_layout_type, &composite_ops);
+	sl_header = c2_bufvec_cursor_addr(cur);
+	c2_bufvec_cursor_move(cur, sizeof *sl_header);
+	C2_ASSERT(c2_bufvec_cursor_step(cur) >= sl_header->slh_nr *
+						sizeof *sl_entry);
+
+	C2_ALLOC_PTR(sub_layouts);
+	/* todo Handle error */
+	c2_sub_layout_tlist_init(sub_layouts);
+	for (i = 0; i < sl_header->slh_nr; ++i) {
+		sl_entry = c2_bufvec_cursor_addr(cur);
+		c2_bufvec_cursor_move(cur, sizeof *sl_entry);
+
+		C2_ALLOC_PTR(sl);
+		if (sl == NULL) {
+			c2_layout__log("composite_decode",
+				       "C2_ALLOC_PTR() failed",
+				       &c2_addb_oom, &layout_global_ctx,
+				       l->l_id, -ENOMEM);
+			return -ENOMEM;
+		}
+
+		/* todo c2_layout_find ?? */
+		sl->csl_l = c2_layout_find(cl->cl_base.l_dom,
+					   sl_entry->sle_lid);
+		C2_ASSERT(sl->csl_l != NULL);
+		C2_CNT_DEC(sl->csl_l->l_ref);
+		//todo Check the above and handle error.
+
+		sl->csl_ext.e_start = sl_entry->sle_ext.e_start;
+		sl->csl_ext.e_end = sl_entry->sle_ext.e_end;
+		c2_sub_layout_tlink_init_at(sl, sub_layouts);
+	}
+	C2_ASSERT(i == sl_header->slh_nr);
 
+	rc = composite_populate(cl, sub_layouts, ref_count);
+	if (rc != 0) {
+		/* todo Handle error. */
+	}
+#if 0
 	if (op == C2_LXO_DB_LOOKUP) {
 		Read all the segments from the comp_layout_ext_map table,
 		belonging to composite layout with layout id 'lid' and store
@@ -361,36 +402,53 @@ static int composite_decode(struct c2_layout *l,
 		Parse the sub-layout information from the buffer pointed by
 		cur and store it in cl->cl_sub_layouts.
 	}
-
-	*out = &cl->cl_base;
-	@endcode
-	*/
-
-	return 0;
+#endif
+	rc = 0;
+	return rc; //todo C2_POST etc
 }
 
-/**
- * Implementation of lo_encode() for composite layout type.
- *
- * Continues to use the in-memory layout object and either 'stores it in the
- * Layout DB' or 'converts it to a buffer'.
- *
- * @param op This enum parameter indicates what is the DB operation to be
- * performed on the layout record if at all and it could be one of
- * ADD/UPDATE/DELETE. If it is BUFFER_OP, then the layout is stored in the
- * buffer.
- */
+/** Implementation of lo_encode() for composite layout type. */
 static int composite_encode(struct c2_layout *l,
 			    enum c2_layout_xcode_op op,
 			    struct c2_db_tx *tx,
 			    struct c2_bufvec_cursor *out)
 {
-	/*
-	@code
+	struct c2_composite_layout     *cl;
+	struct c2_composite_sub_layout *sl;
+	struct sub_layouts_header       sl_header;
+	struct sub_layout_entry         sl_entry;
+	uint32_t                        num_sublayouts = 0;
+	c2_bcount_t                     nbytes;
 
+	C2_PRE(l != NULL);
 	C2_PRE(C2_IN(op, (C2_LXO_DB_ADD, C2_LXO_DB_UPDATE,
 			  C2_LXO_DB_DELETE, C2_LXO_BUFFER_OP)));
+	C2_PRE(ergo(op != C2_LXO_BUFFER_OP, tx != NULL));
+	C2_PRE(out != NULL);
+
+	C2_ENTRY("%llu", (unsigned long long)l->l_id);
+	cl = c2_layout_to_cl(l);
+	C2_ASSERT(c2_bufvec_cursor_step(out) >= sizeof sl_header);
+	sl_header.slh_nr = cl->cl_nr;
+	nbytes = c2_bufvec_cursor_copyto(out, &sl_header, sizeof sl_header);
+	C2_ASSERT(nbytes == sizeof sl_header);
+
+	C2_ASSERT(c2_bufvec_cursor_step(out) >= cl->cl_nr * sizeof sl_entry);
+	if (op == C2_LXO_BUFFER_OP) {
+		c2_tl_for(c2_sub_layout, cl->cl_sub_layouts, sl) {
+			sl_entry.sle_lid         = sl->csl_l->l_id;
+			sl_entry.sle_ext.e_start = sl->csl_ext.e_start;
+			sl_entry.sle_ext.e_end   = sl->csl_ext.e_end;
+			nbytes = c2_bufvec_cursor_copyto(out, &sl_entry,
+							 sizeof sl_entry);
+			C2_ASSERT(nbytes == sizeof sl_entry);
+			++num_sublayouts;
+		} c2_tl_endfor;
+		C2_ASSERT(num_sublayouts == cl->cl_nr);
+	}
 
+	/*
+	@code
 	if ((op == C2_LXO_DB_ADD) || (op == C2_LXO_DB_UPDATE) ||
             (op == C2_LXO_DB_DELETE)) {
 		Form records for the cob_lists table by using data from the
@@ -401,10 +459,9 @@ static int composite_encode(struct c2_layout *l,
 		about the sub-layouts, into the buffer by referring it from
 		c2_layout object l.
 	}
-
 	@endcode
 	*/
-
+	C2_LEAVE("lid %llu", (unsigned long long)l->l_id);
 	return 0;
 }
 
diff --git a/layout/composite.h b/layout/composite.h
index c1ea51b..88eaecb 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -51,7 +51,10 @@ struct c2_composite_layout {
 	/* Number of sub-layouts in this composite layout. */
 	uint32_t          cl_nr;
 
-	/** List of of sub-layouts owned by this composite layout. */
+	/**
+	 * List of of sub-layouts (struct c2_composite_sub_layout) owned by
+	 * this composite layout.
+	 */
 	struct c2_tl     *cl_sub_layouts;
 
 	uint64_t          cl_magic;
@@ -75,17 +78,8 @@ struct c2_composite_sub_layout {
 	 * particular composite layout.
 	 */
 	struct c2_tlink   csl_list_linkage;
-
-	/* todo Oct 11: Continue from here. */
 };
 
-#if 0
-C2_TL_DESCR_DEFINE(c2_sub_layout, "sub-layout-list", static,
-		   struct c2_composite_sub_layout, csl_list_linkage, csl_magic,
-		   C2_LAYOUT_COMP_SUBL_MAGIC, C2_LAYOUT_COMP_SUBL_HEAD_MAGIC);
-C2_TL_DEFINE(c2_sub_layout, , struct c2_composite_sub_layout);
-#endif
-
 C2_TL_DECLARE(c2_sub_layout, extern, struct c2_composite_sub_layout);
 
 int c2_composite_build(struct c2_layout_domain *dom,
@@ -98,6 +92,38 @@ struct c2_layout *c2_cl_to_layout(struct c2_composite_layout *cl);
 
 extern struct c2_layout_type c2_composite_layout_type;
 
+/**
+ * Following structure is part of the internal implementation. It is required
+ * to be accessed by the UT as well. Hence, is placed here in the header file.
+ *
+ * Structure used to store number of sub-layouts.
+ * @todo Do we want this number to be bound ?
+ *
+ * @note This structure needs to be maintained as 8 bytes aligned.
+ * todo BASSERT
+ */
+struct sub_layouts_header {
+	/** Total number of sub-layouts in a specific composite layout. */
+	uint32_t slh_nr;
+
+	/** Padding to make the structure 8 bytes aligned. */
+	uint32_t slh_pad;
+};
+
+/**
+ * Following structure is part of the internal implementation. It is required
+ * to be accessed by the UT as well. Hence, is placed here in the header file.
+ *
+ * todo
+ */
+struct sub_layout_entry {
+	/** Layout id for the sub-layout. */
+	uint64_t       sle_lid;
+
+	/** Extent describing the segment the sub-layout is for. */
+	struct c2_ext  sle_ext;
+};
+
 /** @} end group composite */
 
 /* __COLIBRI_LAYOUT_COMPOSITE_H__ */
diff --git a/layout/layout_db.c b/layout/layout_db.c
index 572861a..4339c81 100644
--- a/layout/layout_db.c
+++ b/layout/layout_db.c
@@ -214,8 +214,8 @@
  *
  * @endverbatim
  *
- * composite_layout_id is the layout_id for the COMPOSITE type of layout,
- * stored as key in the layouts table.
+ * composite_layout_id is the layout_id for the COMPOSITE type of a layout,
+ * stored as a key in the layouts table.
  *
  * layout_id is a foreign key referring record, in the layouts table.
  *
diff --git a/layout/list_enum.h b/layout/list_enum.h
index 58fbf56..a52f29a 100644
--- a/layout/list_enum.h
+++ b/layout/list_enum.h
@@ -104,6 +104,7 @@ struct cob_entries_header {
 	 */
 	char      ces_cobs[0];
 };
+/* todo change ces to ceh, Add BASSERT. */
 
 /* __COLIBRI_LAYOUT_LIST_ENUM_H__ */
 #endif
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index fcebbcc..3177280 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -727,6 +727,7 @@ static void NKP_assign(uint32_t enum_id,
 		*N = *P - (2 * (*K)) - 100;
 }
 
+/* todo Remove the pool init and fini part from this test suite. */
 static void NKP_assign_and_pool_init(uint32_t enum_id,
 				     uint32_t inline_test,
 				     uint32_t list_nr_less,
@@ -745,7 +746,7 @@ static void NKP_assign_and_pool_init(uint32_t enum_id,
 
 /*
  * Tests the APIs supported for enumeration object build, layout object build
- * and layout dstruction that happens using c2_layout_put(). Verifies that the
+ * and layout destruction that happens using c2_layout_put(). Verifies that the
  * newly build layout object is added to the list of layout objects maintained
  * in the domain object and that c2_layout_find() returns the same object.
  */
@@ -790,15 +791,10 @@ static int test_build_pdclust(uint32_t enum_id, uint64_t lid,
 		pdclust_layout_verify(enum_id, &pl->pl_base.sl_base, lid,
 				      N, K, P, &seed,
 				      10, 20);
-		/*
-		 * Delete the layout object by reducing the reference that
-		 * c2_layout_find() has acquired on it.
-		 */
+		/* Reduce the reference that c2_layout_find() has acquired. */
 		c2_layout_put(&pl->pl_base.sl_base);
 
-		/*
-		 * Delete the layout object by reducing the last reference.
-		 */
+		/* Delete the layout object by reducing its last reference. */
 		c2_layout_put(&pl->pl_base.sl_base);
 		C2_UT_ASSERT(list_lookup(lid) == NULL);
 	}
@@ -830,6 +826,7 @@ static void sub_layouts_build(uint64_t composite_lid,
 
 	c2_uint128_init(&seed, "sub_layouts_buil");
 	for (i = 0; i < num_sublayouts; ++i) {
+		/* Build a sub-layout. */
 		sublayout_lid = composite_lid * 100 + i;
 		enum_id = i % 2 ? LIST_ENUM_ID : LINEAR_ENUM_ID;
 		inline_test = i % 5 ? LESS_THAN_INLINE : MORE_THAN_INLINE;
@@ -838,15 +835,16 @@ static void sub_layouts_build(uint64_t composite_lid,
 					  N, K, P, &seed,
 					  10, 20,
 					  &pl, &list_enum, &lin_enum,
-					  false /* failure_test todo */ );
+					  false);
 		C2_UT_ASSERT(rc == 0);
 
+		/* Add the sub-layout to the sub-layout-list. */
 		C2_ALLOC_PTR(sub_layout);
 		C2_UT_ASSERT(sub_layout != NULL);
-		sub_layout->csl_l = c2_pdl_to_layout(pl);
+		sub_layout->csl_l           = c2_pdl_to_layout(pl);
 		sub_layout->csl_ext.e_start = i * delta;
-		sub_layout->csl_ext.e_end = sub_layout->csl_ext.e_start +
-					    delta - 1;
+		sub_layout->csl_ext.e_end   = sub_layout->csl_ext.e_start +
+					      delta - 1;
 		c2_sub_layout_tlink_init_at(sub_layout, sub_layout_list);
 	}
 }
@@ -876,18 +874,20 @@ static void composite_layout_verify(struct c2_layout *l,
 
 	c2_uint128_init(&seed, "sub_layouts_buil");
         c2_tl_for(c2_sub_layout, cl->cl_sub_layouts, sl) {
-		/* Verify sl->csl_l. */
+		/* Verify the sub-layout. */
 		sub_layout_lid = composite_lid * 100 + i;
-		enum_id = i % 2 ? LIST_ENUM_ID : LINEAR_ENUM_ID;
-		inline_test = i % 5 ? LESS_THAN_INLINE : MORE_THAN_INLINE;
+		enum_id        = i % 2 ? LIST_ENUM_ID : LINEAR_ENUM_ID;
+		inline_test    = i % 5 ? LESS_THAN_INLINE : MORE_THAN_INLINE;
 		NKP_assign(enum_id, inline_test, 9, 109, 1200, &N, &K, &P);
 		pdclust_layout_verify(enum_id, sl->csl_l, sub_layout_lid,
 				      N, K, P, &seed, 10, 20);
+		//todo C2_UT_ASSERT(sl->csl_l->l_user_count == 1);
 
 		/* Verify sl->csl_ext. */
 		C2_UT_ASSERT(sl->csl_ext.e_start == i * delta);
 		C2_UT_ASSERT(sl->csl_ext.e_end ==
 			     sl->csl_ext.e_start + delta - 1);
+
 		--i;
         } c2_tl_endfor;
 	C2_UT_ASSERT(i == -1);
@@ -907,8 +907,6 @@ static int composite_layout_build(uint64_t lid,
 	struct c2_layout *l;
 	struct c2_layout *l_from_cl;
 	struct c2_tl     *sub_layout_list;
-	uint32_t          sub_layout_lid;
-	uint32_t          i;
 
 	C2_UT_ASSERT(cl != NULL);
 
@@ -945,28 +943,12 @@ static int composite_layout_build(uint64_t lid,
 		/* Verify the composite layout object contents. */
 		composite_layout_verify(l_from_cl, lid,
 					num_sublayouts, end_offset);
-
-		/*
-		 * Delete the composite layout object by reducing its last
-		 * reference.
-		 */
-		c2_layout_put(&(*cl)->cl_base);
-		C2_UT_ASSERT(list_lookup(lid) == NULL);
-		C2_UT_ASSERT(c2_layout_find(&domain, lid) == NULL);
-	}
-
-	/* Delete all the sub-layouts. */
-	for (i = 0; i < num_sublayouts; ++i) {
-		sub_layout_lid = lid * 100 + i;
-		l = c2_layout_find(&domain, sub_layout_lid);
-		c2_layout_put(l);
-		c2_layout_put(l);
 	}
 
 	return rc;
 }
 
-/* todo Comment
+/*
  * Tests the APIs supported for layout object build and layout destruction
  * that happens using c2_layout_put(). Verifies that the newly built layout
  * object is added to the list of layout objects maintained in the domain
@@ -976,19 +958,39 @@ static int test_build_composite(uint64_t lid,
 				bool failure_test)
 {
 	struct c2_composite_layout *cl;
+	struct c2_layout           *l;
+	uint32_t                    sub_layout_lid;
+	uint32_t                    i;
 
 	rc = composite_layout_build(lid, &cl, 5, 500, failure_test);
 	if (failure_test)
 		C2_UT_ASSERT(rc == -ENOMEM);
-	else
+	else {
 		C2_UT_ASSERT(rc == 0);
 
+		/*
+		 * Delete the composite layout object by reducing its last
+		 * reference.
+		 */
+		c2_layout_put(&cl->cl_base);
+		C2_UT_ASSERT(list_lookup(lid) == NULL);
+		C2_UT_ASSERT(c2_layout_find(&domain, lid) == NULL);
+
+		/* Delete all the sub-layouts. */
+		for (i = 0; i < 5; ++i) {
+			sub_layout_lid = lid * 100 + i;
+			l = c2_layout_find(&domain, sub_layout_lid);
+			c2_layout_put(l);
+			c2_layout_put(l);
+		}
+	}
+
 	return rc;
 }
 
 /*
  * Tests the APIs supported for enumeration object build, layout object build
- * and layout dstruction that happens using c2_layout_put().
+ * and layout destruction that happens using c2_layout_put().
  */
 static void test_build(void)
 {
@@ -1031,7 +1033,7 @@ static void test_build(void)
 				!FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
 
-	/* todo Comment */
+	/* Build a layout object with COMPOSITE layout type and destroy it. */
 	lid = 1005;
 	rc = test_build_composite(lid, !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
@@ -1303,6 +1305,126 @@ static int test_decode_pdclust(uint32_t enum_id, uint64_t lid,
 	return rc;
 }
 
+/* Builds a buffer containing serialised representation of a layout object. */
+static int composite_layout_buf_build(uint64_t lid,
+				      uint32_t num_sublayouts,
+				      c2_bindex_t end_offset,
+				      struct c2_bufvec_cursor *dcur)
+{
+	c2_bcount_t                     nbytes;
+	struct c2_tl                   *sub_layout_list;
+	struct c2_composite_sub_layout *sl;
+	struct sub_layouts_header       sl_header;
+	struct sub_layout_entry         sl_entry;
+
+	C2_UT_ASSERT(dcur != NULL);
+
+	/* Build part of the buffer representing generic part of the layout. */
+	buf_build(c2_composite_layout_type.lt_id, dcur);
+
+	/* Build sub-layouts. */
+	/* todo move these 3 lines into sub_layouts_build(). */
+	C2_ALLOC_PTR(sub_layout_list);
+	C2_UT_ASSERT(sub_layout_list != NULL);
+	c2_sub_layout_tlist_init(sub_layout_list);
+	sub_layouts_build(lid, sub_layout_list, num_sublayouts, end_offset);
+	C2_UT_ASSERT(!c2_sub_layout_tlist_is_empty(sub_layout_list));
+
+	/*
+	 * Build part of the buffer representing composite type specific part
+	 * of the layout.
+	 */
+	sl_header.slh_nr = num_sublayouts;
+	C2_ASSERT(c2_bufvec_cursor_step(dcur) >= sizeof sl_header);
+	nbytes = c2_bufvec_cursor_copyto(dcur, &sl_header, sizeof sl_header);
+	C2_ASSERT(nbytes == sizeof sl_header);
+
+	C2_ASSERT(c2_bufvec_cursor_step(dcur) >= sl_header.slh_nr *
+						 sizeof sl_entry);
+	c2_tl_for(c2_sub_layout, sub_layout_list, sl) {
+		sl_entry.sle_lid         = sl->csl_l->l_id;
+		sl_entry.sle_ext.e_start = sl->csl_ext.e_start;
+		sl_entry.sle_ext.e_end   = sl->csl_ext.e_end;
+		nbytes = c2_bufvec_cursor_copyto(dcur, &sl_entry,
+						 sizeof sl_entry);
+		C2_ASSERT(nbytes == sizeof sl_entry);
+		c2_sub_layout_tlist_del(sl);
+		c2_sub_layout_tlink_fini(sl);
+		c2_free(sl);
+	} c2_tl_endfor;
+
+        c2_sub_layout_tlist_fini(sub_layout_list);
+        c2_free(sub_layout_list);
+	return 0;
+}
+
+/* Tests the API c2_layout_decode() for COMPOSITE layout type. */
+static int test_decode_composite(uint64_t lid, bool failure_test)
+{
+	void                    *area;
+	c2_bcount_t              num_bytes;
+	struct c2_bufvec         bv;
+	struct c2_bufvec_cursor  cur;
+	struct c2_layout        *l;
+	struct c2_layout_type   *lt;
+	uint64_t                 sub_layout_lid;
+	uint32_t                 i;
+
+	C2_ENTRY();
+
+	/* Build a layout buffer. */
+	allocate_area(&area, ADDITIONAL_BYTES_DEFAULT * 4, &num_bytes); //todo
+	bv = (struct c2_bufvec) C2_BUFVEC_INIT_BUF(&area, &num_bytes);
+	c2_bufvec_cursor_init(&cur, &bv);
+
+	rc = composite_layout_buf_build(lid, 6, 600, &cur);
+	C2_UT_ASSERT(rc == 0);
+
+	/* Rewind the cursor. */
+	c2_bufvec_cursor_init(&cur, &bv);
+
+	lt = &c2_composite_layout_type;
+	rc = lt->lt_ops->lto_allocate(&domain, lid, &l);
+	C2_UT_ASSERT(rc == 0);
+
+	/* Decode the layout buffer into a layout object. */
+	rc = c2_layout_decode(l, &cur, C2_LXO_BUFFER_OP, NULL);
+	if (failure_test)
+		C2_UT_ASSERT(rc == -ENOMEM);
+	else {
+		C2_UT_ASSERT(rc == 0);
+		C2_UT_ASSERT(list_lookup(lid) == l);
+#if 0
+		/* Verify the layout object built by c2_layout_decode(). */
+		composite_layout_verify(l, lid, 6, 600);
+#endif
+	}
+
+	/* Destroy the layout object. */
+	if (failure_test)
+		l->l_ops->lo_delete(l);
+	else {
+		/* Unlock the layout, locked by lto_allocate() */
+		c2_mutex_unlock(&l->l_lock);
+		/* Delete the composite layout. */
+		c2_layout_put(l);
+	}
+	C2_UT_ASSERT(list_lookup(lid) == NULL);
+
+	/* Delete all the sub-layouts. */
+	for (i = 0; i < 6; ++i) {
+		sub_layout_lid = lid * 100 + i;
+		l = c2_layout_find(&domain, sub_layout_lid);
+		c2_layout_put(l);
+		c2_layout_put(l);
+	}
+
+	c2_free(area);
+	c2_pool_fini(&pool);
+	C2_LEAVE();
+	return rc;
+}
+
 /* Tests the API c2_layout_decode(). */
 static void test_decode(void)
 {
@@ -1344,6 +1466,11 @@ static void test_decode(void)
 	rc = test_decode_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE,
 				 !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
+
+	/* Decode a layout object with COMPOSITE layout type. */
+	lid = 2005; //todo
+	rc = test_decode_composite(lid, !FAILURE_TEST);
+	C2_UT_ASSERT(rc == 0);
 }
 
 static void test_decode_failure(void)
@@ -1589,6 +1716,81 @@ static int test_encode_pdclust(uint32_t enum_id, uint64_t lid,
 	return rc;
 }
 
+/* Tests the API c2_layout_encode() for COMPOSITE layout type. */
+static int test_encode_composite(uint64_t lid, bool failure_test)
+{
+	struct c2_composite_layout   *cl;
+	void                         *area;
+	c2_bcount_t                   num_bytes;
+	struct c2_bufvec              bv;
+	struct c2_bufvec_cursor       cur;
+	uint64_t                      sub_layout_lid;
+	struct c2_layout             *l;
+	uint32_t                      i;
+#if 0
+	struct c2_uint128             seed;
+	uint32_t                      N;
+	uint32_t                      K;
+	uint32_t                      P;
+#endif
+
+	C2_ENTRY("lid %llu", (unsigned long long)lid);
+
+	/* Build a layout object. */
+	allocate_area(&area, ADDITIONAL_BYTES_DEFAULT * 4, &num_bytes); //todo
+	rc = composite_layout_build(lid, &cl, 5, 500, failure_test);
+	if (failure_test)
+		C2_UT_ASSERT(rc == -ENOMEM);
+	else
+		C2_UT_ASSERT(rc == 0);
+
+	bv = (struct c2_bufvec) C2_BUFVEC_INIT_BUF(&area, &num_bytes);
+	c2_bufvec_cursor_init(&cur, &bv);
+
+	/* Encode the layout object into a layout buffer. */
+	rc  = c2_layout_encode(&cl->cl_base, C2_LXO_BUFFER_OP, NULL, &cur);
+	if (failure_test)
+		C2_UT_ASSERT(rc == LO_ENCODE_ERR);
+	else
+		C2_UT_ASSERT(rc == 0);
+
+	/* Rewind the cursor. */
+	c2_bufvec_cursor_init(&cur, &bv);
+
+#if 0
+	/* todo Verify the layout buffer produced by c2_layout_encode(). */
+	if (!failure_test)
+		composite_layout_buf_verify(enum_id, lid,
+					  N, K, P, &seed,
+					  11, 21, &cur);
+#endif
+
+	/*
+	 * todo Add a routine to combine deletion of comp layout and all its
+	 * sub-layouts.
+	 */
+
+	/*
+	 * Delete the composite layout object by reducing its last
+	 * reference.
+	 */
+	c2_layout_put(&cl->cl_base);
+	C2_UT_ASSERT(c2_layout_find(&domain, lid) == NULL);
+
+	/* Delete all the sub-layouts. */
+	for (i = 0; i < 5; ++i) {
+		sub_layout_lid = lid * 100 + i;
+		l = c2_layout_find(&domain, sub_layout_lid);
+		c2_layout_put(l);
+		c2_layout_put(l);
+	}
+
+	c2_free(area);
+	c2_pool_fini(&pool);
+	C2_LEAVE();
+	return rc;
+}
+
 /* Tests the API c2_layout_encode(). */
 static void test_encode(void)
 {
@@ -1628,6 +1830,11 @@ static void test_encode(void)
 	rc = test_encode_pdclust(LINEAR_ENUM_ID, lid, INLINE_NOT_APPLICABLE,
 				 !FAILURE_TEST);
 	C2_UT_ASSERT(rc == 0);
+
+	/* Encode for COMPOSITE layout type. */
+	lid = 3005; //todo
+	rc = test_encode_composite(lid, !FAILURE_TEST);
+	C2_UT_ASSERT(rc == 0);
 }
 
 static void test_encode_failure(void)
-- 
1.8.3.2

