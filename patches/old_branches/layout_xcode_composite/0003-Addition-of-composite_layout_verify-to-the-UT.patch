From c676fc13de4208ddf0d3e08b3fb6a90a6da900da Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Mon, 15 Oct 2012 16:13:05 +0530
Subject: [PATCH 003/157] Addition of composite_layout_verify() to the UT

---
 layout/composite.c |  6 +-----
 layout/pdclust.c   |  6 ++----
 layout/ut/layout.c | 62 ++++++++++++++++++++++++++++++++++++++++++++++++------
 3 files changed, 59 insertions(+), 15 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index ba0a2ee..07c1fe7 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -136,7 +136,6 @@ err1_injected:
 
 	*out = &cl->cl_base;
 	C2_POST(composite_allocated_invariant(cl));
-	C2_POST(c2_mutex_is_locked(&(*out)->l_lock));
 	C2_LEAVE("lid %llu, cl pointer %p", (unsigned long long)lid, cl);
 	return 0;
 }
@@ -149,7 +148,6 @@ static void composite_delete(struct c2_layout *l)
 	cl = bob_of(l, struct c2_composite_layout,
 		    cl_base, &composite_bob);
 	C2_PRE(composite_allocated_invariant(cl));
-	C2_PRE(c2_mutex_is_locked(&l->l_lock));
 
 	C2_ENTRY("lid %llu", (unsigned long long)l->l_id);
 	c2_mutex_unlock(&l->l_lock);
@@ -168,13 +166,12 @@ static int composite_populate(struct c2_composite_layout *cl,
 	struct c2_composite_sub_layout *sl;
 
 	C2_PRE(composite_allocated_invariant(cl));
-	C2_PRE(c2_mutex_is_locked(&cl->cl_base.l_lock));
 	C2_PRE(sub_layouts != NULL);
 
 	C2_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 
 	c2_layout__populate(&cl->cl_base, user_count);
-	/* Add reference to each of the sub-layouts. */
+	/* Add a reference to each of the sub-layouts. */
 	c2_tl_for(c2_sub_layout, sub_layouts, sl) {
 		C2_ASSERT(c2_layout__invariant(sl->csl_l));
 		c2_layout_get(sl->csl_l);
@@ -187,7 +184,6 @@ static int composite_populate(struct c2_composite_layout *cl,
 	return 0;
 }
 
-
 /*
  * @post A composite type of layout object is created. User is expected to
  * add a reference on the layout object as required and is expected to release
diff --git a/layout/pdclust.c b/layout/pdclust.c
index 6dd5c98..3f81fd0 100644
--- a/layout/pdclust.c
+++ b/layout/pdclust.c
@@ -125,7 +125,8 @@ static bool pdclust_allocated_invariant(const struct c2_pdclust_layout *pl)
 {
 	return
 		pl != NULL &&
-		c2_layout__striped_allocated_invariant(&pl->pl_base);
+		c2_layout__striped_allocated_invariant(&pl->pl_base) &&
+		c2_mutex_is_locked(&pl->pl_base.sl_base.l_lock);
 }
 
 static bool pdclust_invariant(const struct c2_pdclust_layout *pl)
@@ -226,7 +227,6 @@ err1_injected:
 
 	*out = &pl->pl_base.sl_base;
 	C2_POST(pdclust_allocated_invariant(pl));
-	C2_POST(c2_mutex_is_locked(&(*out)->l_lock));
 	C2_LEAVE("lid %llu, pl pointer %p", (unsigned long long)lid, pl);
 	return 0;
 }
@@ -239,7 +239,6 @@ static void pdclust_delete(struct c2_layout *l)
 	pl = bob_of(l, struct c2_pdclust_layout,
 		    pl_base.sl_base, &pdclust_bob);
 	C2_PRE(pdclust_allocated_invariant(pl));
-	C2_PRE(c2_mutex_is_locked(&l->l_lock));
 
 	C2_ENTRY("lid %llu", (unsigned long long)l->l_id);
 	c2_mutex_unlock(&l->l_lock);
@@ -265,7 +264,6 @@ static int pdclust_populate(struct c2_pdclust_layout *pl,
 	K = attr->pa_K;
 	P = attr->pa_P;
 	C2_PRE(pdclust_allocated_invariant(pl));
-	C2_PRE(c2_mutex_is_locked(&pl->pl_base.sl_base.l_lock));
 	C2_PRE(le != NULL);
 
 	if (N + 2 * K > P) {
diff --git a/layout/ut/layout.c b/layout/ut/layout.c
index 6d51c52..fcebbcc 100644
--- a/layout/ut/layout.c
+++ b/layout/ut/layout.c
@@ -52,6 +52,8 @@ static struct c2_pool          pool;
 enum c2_addb_ev_level          orig_addb_level;
 static int                     rc;
 
+C2_TL_DESCR_DECLARE(c2_sub_layout, extern);
+
 enum {
 	DBFLAGS                  = 0,    /* Flag used for dbenv and tx init */
 	LIST_ENUM_ID             = 0x4C495354, /* "LIST" */
@@ -603,7 +605,7 @@ static int pdclust_layout_build(uint32_t enum_id,
 static void l_verify(struct c2_layout *l, uint64_t lid)
 {
 	C2_UT_ASSERT(l->l_id == lid);
-	C2_UT_ASSERT(l->l_ref >= 0);
+	C2_UT_ASSERT(l->l_ref >= 1);
 	C2_UT_ASSERT(l->l_ops != NULL);
 }
 
@@ -620,6 +622,7 @@ static void pdclust_l_verify(struct c2_pdclust_layout *pl,
 	l_verify(&pl->pl_base.sl_base, lid);
 
 	/* Verify PDCLUST layout type specific part of the layout object. */
+	C2_UT_ASSERT(pl->pl_base.sl_base.l_type == &c2_pdclust_layout_type);
 	C2_UT_ASSERT(pl->pl_attr.pa_N == N);
 	C2_UT_ASSERT(pl->pl_attr.pa_K == K);
 	C2_UT_ASSERT(pl->pl_attr.pa_P == P);
@@ -809,7 +812,7 @@ static void sub_layouts_build(uint64_t composite_lid,
 			      uint32_t num_sublayouts,
 			      c2_bindex_t end_offset)
 {
-	uint32_t                        lid;
+	uint32_t                        sublayout_lid;
 	uint32_t                        enum_id;
 	bool                            inline_test;
 	struct c2_uint128               seed;
@@ -827,11 +830,11 @@ static void sub_layouts_build(uint64_t composite_lid,
 
 	c2_uint128_init(&seed, "sub_layouts_buil");
 	for (i = 0; i < num_sublayouts; ++i) {
-		lid = composite_lid * 100 + i;
+		sublayout_lid = composite_lid * 100 + i;
 		enum_id = i % 2 ? LIST_ENUM_ID : LINEAR_ENUM_ID;
 		inline_test = i % 5 ? LESS_THAN_INLINE : MORE_THAN_INLINE;
 		NKP_assign(enum_id, inline_test, 9, 109, 1200, &N, &K, &P);
-		rc = pdclust_layout_build(enum_id, lid,
+		rc = pdclust_layout_build(enum_id, sublayout_lid,
 					  N, K, P, &seed,
 					  10, 20,
 					  &pl, &list_enum, &lin_enum,
@@ -848,6 +851,48 @@ static void sub_layouts_build(uint64_t composite_lid,
 	}
 }
 
+static void composite_layout_verify(struct c2_layout *l,
+				    uint64_t composite_lid,
+				    uint32_t num_sublayouts,
+				    c2_bindex_t end_offset)
+{
+	struct c2_composite_layout     *cl;
+	struct c2_composite_sub_layout *sl;
+	uint64_t                        sub_layout_lid;
+	uint32_t                        enum_id;
+	bool                            inline_test;
+	struct c2_uint128               seed;
+	uint32_t                        N;
+	uint32_t                        K;
+	uint32_t                        P;
+	int                             i = num_sublayouts - 1;
+	c2_bindex_t                     delta = end_offset / num_sublayouts;
+
+	C2_UT_ASSERT(l != NULL);
+	C2_UT_ASSERT(l->l_type == &c2_composite_layout_type);
+
+	cl = c2_layout_to_cl(l);
+	l_verify(l, composite_lid);
+
+	c2_uint128_init(&seed, "sub_layouts_buil");
+        c2_tl_for(c2_sub_layout, cl->cl_sub_layouts, sl) {
+		/* Verify sl->csl_l. */
+		sub_layout_lid = composite_lid * 100 + i;
+		enum_id = i % 2 ? LIST_ENUM_ID : LINEAR_ENUM_ID;
+		inline_test = i % 5 ? LESS_THAN_INLINE : MORE_THAN_INLINE;
+		NKP_assign(enum_id, inline_test, 9, 109, 1200, &N, &K, &P);
+		pdclust_layout_verify(enum_id, sl->csl_l, sub_layout_lid,
+				      N, K, P, &seed, 10, 20);
+
+		/* Verify sl->csl_ext. */
+		C2_UT_ASSERT(sl->csl_ext.e_start == i * delta);
+		C2_UT_ASSERT(sl->csl_ext.e_end ==
+			     sl->csl_ext.e_start + delta - 1);
+		--i;
+        } c2_tl_endfor;
+	C2_UT_ASSERT(i == -1);
+}
+
 /*
  * Builds a layout object with COMPOSITE layout type, by first building some
  * sub-layouts.
@@ -858,6 +903,7 @@ static int composite_layout_build(uint64_t lid,
 				  c2_bindex_t end_offset,
 				  bool failure_test)
 {
+
 	struct c2_layout *l;
 	struct c2_layout *l_from_cl;
 	struct c2_tl     *sub_layout_list;
@@ -897,9 +943,13 @@ static int composite_layout_build(uint64_t lid,
 		C2_UT_ASSERT(l_from_cl == &(*cl)->cl_base);
 
 		/* Verify the composite layout object contents. */
-		//todo composite_layout_verify(&cl->cl_base, lid);
+		composite_layout_verify(l_from_cl, lid,
+					num_sublayouts, end_offset);
 
-		/* Delete the layout object by reducing its last reference. */
+		/*
+		 * Delete the composite layout object by reducing its last
+		 * reference.
+		 */
 		c2_layout_put(&(*cl)->cl_base);
 		C2_UT_ASSERT(list_lookup(lid) == NULL);
 		C2_UT_ASSERT(c2_layout_find(&domain, lid) == NULL);
-- 
1.8.3.2

