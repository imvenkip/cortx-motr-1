From 5d3c02cda287e6f81ba401669ac0dbf7a7e9b8c3 Mon Sep 17 00:00:00 2001
From: "trupti.patil" <trupti_patil@xyratex.com>
Date: Wed, 6 Mar 2013 14:24:15 +0530
Subject: [PATCH 073/157] Added m0_tlist_splice, now
 m0_composite_layer::clr_extents is not a pointer

---
 layout/composite.c    | 119 ++++++++++++++------------------------------------
 layout/composite.h    |  13 +++---
 layout/ut/composite.c |  75 +++++++++++--------------------
 lib/list.c            |  22 ++++++++++
 lib/list.h            |  10 ++++-
 lib/tlist.c           |  10 +++++
 lib/tlist.h           |  11 +++++
 7 files changed, 113 insertions(+), 147 deletions(-)

diff --git a/layout/composite.c b/layout/composite.c
index bef6ce4..ca944ec 100644
--- a/layout/composite.c
+++ b/layout/composite.c
@@ -206,10 +206,10 @@ static bool composite_invariant(const struct m0_composite_layout *cl)
 			     layer->clr_cl == &cl->cl_base &&
 			     m0_layout__invariant(layer->clr_sl) &&
 			     layer->clr_idx == i++ &&
-			     layer->clr_extents != NULL &&
+			     layer->clr_extents_nr > 0 &&
 			     layer->clr_extents_nr ==
 			     m0_composite_layer_ext_tlist_length(
-							layer->clr_extents));
+							&layer->clr_extents));
 }
 
 /**
@@ -222,16 +222,15 @@ static bool layer_invariant(const struct m0_composite_layer *layer)
 	m0_bindex_t                       addr = 0;
 	uint32_t                          i = 0;
 
-	if (layer->clr_extents == NULL ||
-	    layer->clr_extents_nr !=
-	    m0_composite_layer_ext_tlist_length(layer->clr_extents))
+	if (layer->clr_extents_nr !=
+	    m0_composite_layer_ext_tlist_length(&layer->clr_extents))
 		return false;
 
 	/*
 	 * Since assignment can not be performed in between a m0_tl_forall()
 	 * loop, it has not been used in this invariant.
 	 */
-	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+	m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
 		M0_ASSERT(lr_ext->cle_ext.e_start == addr);
 		addr = lr_ext->cle_ext.e_end;
 		if (i == 0 && lr_ext->cle_ext.e_start != 0)
@@ -423,7 +422,8 @@ static int layer_inmem_add(struct m0_composite_layout *cl,
 	layer->clr_sl         = sublayout;
 	layer->clr_idx        = cl->cl_layers_nr;
 	layer->clr_extents_nr = ext_nr;
-	layer->clr_extents    = extlist;
+	m0_composite_layer_ext_tlist_init(&layer->clr_extents);
+	m0_composite_layer_ext_tlist_splice(&layer->clr_extents, extlist);
 	m0_layout_get(layer->clr_sl);
 	m0_layout_user_count_inc(layer->clr_sl);
 	comp_layer_tlink_init_at_tail(layer, &cl->cl_layers);
@@ -446,7 +446,6 @@ static void extlist_free(struct m0_tl *extlist)
 		m0_free(lr_ext);
 	} m0_tl_endfor;
 	m0_composite_layer_ext_tlist_fini(extlist);
-	m0_free(extlist);
 }
 
 /**
@@ -471,7 +470,7 @@ static void layer_inmem_delete(struct m0_composite_layout *cl,
 	comp_layer_tlink_del_fini(layer);
 	m0_layout_user_count_dec(layer->clr_sl);
 	m0_layout_put(layer->clr_sl);
-	extlist_free(layer->clr_extents);
+	extlist_free(&layer->clr_extents);
 	M0_POST(layer->clr_idx == cl->cl_layers_nr);
 	m0_free(layer);
 	M0_POST(composite_invariant(cl));
@@ -551,7 +550,7 @@ static void composite_fini(struct m0_ref *ref)
 	m0_composite_layout_bob_fini(cl);
 
 	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
-		extlist_free(layer->clr_extents);
+		extlist_free(&layer->clr_extents);
 		comp_layer_tlink_del_fini(layer);
 		/* Release the reference acquired by layer_inmem_add(). */
 		m0_layout_put(layer->clr_sl);
@@ -699,9 +698,8 @@ static struct m0_layout *layout_find(struct m0_layout_domain *dom,
 static int extlist_inbuf_read(struct m0_composite_layout *cl,
 			      struct m0_bufvec_cursor *cur,
 			      uint32_t extents_nr,
-			      struct m0_tl **extents)
+			      struct m0_tl *extlist)
 {
-	struct m0_tl  *extlist;
 	struct m0_ext *ext;
 	uint64_t      *ext_state;
 	uint32_t       i;
@@ -710,17 +708,7 @@ static int extlist_inbuf_read(struct m0_composite_layout *cl,
 	M0_ENTRY("lid %llu", (unsigned long long)cl->cl_base.l_id);
 	M0_PRE(m0_bufvec_cursor_step(cur) >= extents_nr * sizeof *ext);
 
-	M0_ALLOC_PTR(extlist);
-	if (extlist == NULL) {
-		m0_layout__log("extlist_inbuf_read",
-			       "failed to allocate composite extent list",
-			       M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_1,
-			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id,
-			       -ENOMEM);
-		return -ENOMEM;
-	}
 	m0_composite_layer_ext_tlist_init(extlist);
-
 	rc = 0;
 	for (i = 0; i < extents_nr; ++i) {
 		ext = m0_bufvec_cursor_addr(cur);
@@ -737,7 +725,6 @@ static int extlist_inbuf_read(struct m0_composite_layout *cl,
 				       M0_LAYOUT_ADDB_LOC_COMP_ELIST_READ_2,
 				       &cl->cl_base.l_addb_ctx,
 				       cl->cl_base.l_id, -ENOMEM);
-			extlist_free(extlist);
 			return -EINVAL;
 		}
 		rc = ext_inmem_add_internal(NULL, &cl->cl_base, extlist,
@@ -747,11 +734,9 @@ static int extlist_inbuf_read(struct m0_composite_layout *cl,
 			M0_LOG(M0_ERROR, "lid %llu, Extent could not be "
 			       "added to the list",
 			       (unsigned long long)cl->cl_base.l_id);
-			extlist_free(extlist);
 			return rc;
 		}
 	}
-	*extents = extlist;
 	M0_RETURN(rc);
 }
 
@@ -766,7 +751,7 @@ static int comp_layout_inbuf_read(struct m0_composite_layout *cl,
 	struct composite_header       *cl_header;
 	struct composite_layer_header *lr_header;
 	struct m0_layout              *sublayout;
-	struct m0_tl                  *extlist;
+	struct m0_tl                   extlist;
 	uint32_t                       i;
 	int                            rc = 0; /* To keep the compiler happy. */
 
@@ -817,11 +802,11 @@ static int comp_layout_inbuf_read(struct m0_composite_layout *cl,
 		}
 
 		if (lr_header->clh_idx == 0) /* Zeroth layer */
-			rc = composite_populate(cl, sublayout, extlist,
+			rc = composite_populate(cl, sublayout, &extlist,
 						lr_header->clh_extents_nr,
 						user_count);
 		else
-			rc = layer_add_internal(cl, sublayout, extlist,
+			rc = layer_add_internal(cl, sublayout, &extlist,
 						lr_header->clh_extents_nr,
 						NULL);
 		/*
@@ -907,7 +892,7 @@ static void comp_layout_inbuf_write(const struct m0_composite_layout *cl,
 		lr_header.clh_pad        = 0;
 		nbytes = m0_bufvec_cursor_copyto(out, &lr_header,
 						 sizeof lr_header);
-		m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+		m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
 			nbytes = m0_bufvec_cursor_copyto(out,
 							&lr_ext->cle_ext,
 							sizeof lr_ext->cle_ext);
@@ -1034,7 +1019,7 @@ static int ext_inmem_find(struct m0_composite_layer *layer,
 		 (unsigned long long)expected_ext_state);
 
 	ext_encountered = false;
-	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+	m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
 		if (lr_ext->cle_ext.e_end <= ext->e_start)
 			continue;
 		else if (lr_ext->cle_ext.e_start == ext->e_start &&
@@ -1088,7 +1073,7 @@ static int ext_inmem_add_internal(struct m0_composite_layer *layer,
 	if (l == NULL)
 		l = layer->clr_cl;
 	if (extlist == NULL)
-		extlist = layer->clr_extents;
+		extlist = &layer->clr_extents;
 	M0_ENTRY("lid %llu, layer %lu , e_start %llu, e_end %llu, "
 		 "e_state %llu, add_position %lu, "
 		 "adjacent_ext_start %llu, adjacent_ext_end %llu",
@@ -1149,7 +1134,7 @@ static int ext_inmem_add(struct m0_composite_layer *layer,
 		 (unsigned long long)ext->e_end, (unsigned long long)ext_state);
 	lr_ext_to_insert_before = NULL;
 	lr_ext_to_insert_after = NULL;
-	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+	m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
 		if (ext->e_start < lr_ext->cle_ext.e_start)
 			lr_ext_to_insert_before = lr_ext;
 		if (ext->e_start >= lr_ext->cle_ext.e_end)
@@ -1206,7 +1191,7 @@ static int ext_inmem_lookup(struct m0_composite_layout *cl,
 
 	while (layer != NULL) {
 		M0_ASSERT(layer->clr_idx == i);
-		m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+		m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
 			if (offset >= lr_ext->cle_ext.e_end)
 				continue;
 			else {
@@ -1361,7 +1346,7 @@ static int ext_inmem_validate(struct m0_composite_layout *cl,
 	rc = 0;
 	*lr_ext_nearest = NULL;
 	first_noninvalid_state = M0_CLRES_INVALID;
-	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+	m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
 		/* Nearest extent from the list. */
 		if (ext->e_start >= lr_ext->cle_ext.e_start)
 			*lr_ext_nearest = lr_ext;
@@ -1547,32 +1532,6 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 		/* New ext state. */
 		bstart[1] = new_ext_state;
 
-#if 0
-#ifndef __KERNEL__
-	printf("ext_inmem_write(2): lid %llu, layer %lu \n"
-		"\te_start %llu, e_end %llu \n"
-		"\tlr_ext_to_insert_into_start %llu, \n"
-		"\tlr_ext_to_insert_into_end %llu\n"
-		"\tchunk_start %llu, chunk_end %llu\n "
-		"\tclip_start %llu, clip_end %llu \n"
-		"\tlength[0] %llu, bstart[0] %llu \n"
-		"\tlength[1] %llu, bstart[1] %llu \n"
-		"\tlength[2] %llu, bstart[2] %llu \n",
-		(unsigned long long)layer->clr_cl->l_id,
-		(unsigned long)layer->clr_idx,
-		(unsigned long long)ext0.e_start,
-		(unsigned long long)ext0.e_end,
-		(unsigned long long)lr_ext_to_insert_into->cle_ext.e_start,
-		(unsigned long long)lr_ext_to_insert_into->cle_ext.e_end,
-		(unsigned long long)chunk->e_start,
-		(unsigned long long)chunk->e_end,
-		(unsigned long long)clip.e_start,
-		(unsigned long long)clip.e_end,
-		(unsigned long long)length[0], (unsigned long long)bstart[0],
-		(unsigned long long)length[1], (unsigned long long)bstart[1],
-		(unsigned long long)length[2], (unsigned long long)bstart[2]);
-#endif
-#endif
 		split_required  = true;
 		delete_required = false;
 		lr_ext_to_del   = NULL;
@@ -1594,7 +1553,7 @@ static int ext_inmem_write(struct m0_composite_layout *cl,
 		lr_ext_next = NULL;
 		if (!m0_ext_is_empty(&ext0)) {
 			lr_ext_next = m0_composite_layer_ext_tlist_next(
-                                                        layer->clr_extents,
+                                                        &layer->clr_extents,
                                                         lr_ext_to_insert_into);
 
 			/*
@@ -1867,7 +1826,7 @@ static int ext_inmem_delete(struct m0_composite_layer *layer,
 		 (unsigned long long)old_ext_state);
 
 	lr_ext_to_delete_found = false;
-	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+	m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
 		if (ext->e_start > lr_ext->cle_ext.e_end)
 			continue;
 		if (ext->e_start == lr_ext->cle_ext.e_start) {
@@ -2409,7 +2368,7 @@ static int extmap_indb_add(struct m0_composite_layout *cl,
 	M0_ASSERT(seg->ee_ext.e_end == M0_BINDEX_MAX + 1);
 	M0_ASSERT(seg->ee_val == M0_CLRES_INVALID);
 
-	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+	m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
 		M0_ASSERT(M0_IN(lr_ext->cle_state, (M0_CLRES_INVALID,
 						    M0_CLRES_VALID,
 						    M0_CLRES_FLATTENING)));
@@ -2463,7 +2422,7 @@ static int layer_indb_add(struct m0_composite_layout *cl,
 static int extentmap_indb_read(struct m0_composite_layout *cl,
 			       uint32_t layer_idx,
 			       struct m0_db_tx *tx,
-			       struct m0_tl **extlist,
+			       struct m0_tl *extlist,
 			       uint32_t *extents_nr)
 {
 	struct m0_emap        *emap;
@@ -2486,18 +2445,7 @@ static int extentmap_indb_read(struct m0_composite_layout *cl,
 		return rc;
 	}
 
-	M0_ALLOC_PTR(*extlist);
-	if (*extlist == NULL) {
-		m0_layout__log("extentmap_indb_read",
-			       "failed to allocate composite extent list",
-			       M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_2,
-			       &cl->cl_base.l_addb_ctx, cl->cl_base.l_id,
-			       -ENOMEM);
-		m0_emap_close(&it);
-		return -ENOMEM;
-	}
-	m0_composite_layer_ext_tlist_init(*extlist);
-
+	m0_composite_layer_ext_tlist_init(extlist);
 	*extents_nr = 0;
 	seg = m0_emap_seg_get(&it);
 	while (1) {
@@ -2510,20 +2458,17 @@ static int extentmap_indb_read(struct m0_composite_layout *cl,
 				       M0_LAYOUT_ADDB_LOC_COMP_EMAP_READ_3,
 				       &cl->cl_base.l_addb_ctx,
 				       cl->cl_base.l_id, -ENOMEM);
-			extlist_free(*extlist);
 			m0_emap_close(&it);
 			return -EINVAL;
 		}
 
-		rc = ext_inmem_add_internal(NULL, &cl->cl_base, *extlist,
+		rc = ext_inmem_add_internal(NULL, &cl->cl_base, extlist,
 					    &seg->ee_ext, seg->ee_val,
 					    ADD_AT_TAIL, NULL);
 		if (rc != 0) {
-			extlist_free(*extlist);
 			m0_emap_close(&it);
 			return rc;
 		}
-		*extents_nr = m0_composite_layer_ext_tlist_length(*extlist);
 
 		if (m0_emap_ext_is_last(&seg->ee_ext))
 			break;
@@ -2531,7 +2476,7 @@ static int extentmap_indb_read(struct m0_composite_layout *cl,
 		seg = m0_emap_seg_get(&it);
 	}
 	m0_emap_close(&it);
-
+	*extents_nr = m0_composite_layer_ext_tlist_length(extlist);
 	M0_POST(*extents_nr > 0);
 	M0_RETURN(rc);
 }
@@ -2546,7 +2491,7 @@ static int comp_layout_indb_read(struct m0_composite_layout *cl,
 {
 	uint64_t                   sublayout_id;
 	struct m0_layout          *sublayout;
-	struct m0_tl              *extents;
+	struct m0_tl               extents;
 	uint32_t                   extents_nr;
 	struct m0_composite_layer *layer;
 	uint32_t                   i; /* layer idx */
@@ -2600,11 +2545,11 @@ static int comp_layout_indb_read(struct m0_composite_layout *cl,
 		}
 
 		if (i == 0)
-			rc = composite_populate(cl, sublayout, extents,
+			rc = composite_populate(cl, sublayout, &extents,
 						extents_nr, user_count);
 		else
 			/* Now, write the layer to the in-memory layout. */
-			rc = layer_inmem_add(cl, sublayout, extents,
+			rc = layer_inmem_add(cl, sublayout, &extents,
 					     extents_nr, &layer);
 		if (rc != 0) {
 			M0_LOG(M0_ERROR, "lid %llu, layer %lu could not be "
@@ -2697,7 +2642,7 @@ static int delete_verify(struct m0_composite_layout *cl,
 
 	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
 		/* In-memory layer verification. */
-		m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+		m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
 			if (lr_ext->cle_state != M0_CLRES_INVALID) {
 				M0_LOG(M0_ERROR, "lid %llu, layout can not be "
 				       "deleted since in-memory layer %lu "
@@ -2808,8 +2753,8 @@ static int extents_indb_delete(struct m0_composite_layout *cl,
 	M0_ASSERT(seg->ee_ext.e_end == M0_BINDEX_MAX + 1);
 
 	/*
-	 * Combine all the invalid extents into one, by adding an
-	 * invalid extent with the complete offset space.
+	 * Combine all the invalid extents into one, by adding an invalid
+	 * extent with the complete offset space.
 	 */
 	rc = single_ext_indb_write(&it, layer);
 	m0_emap_close(&it);
diff --git a/layout/composite.h b/layout/composite.h
index f542a9a..f9c0b96 100644
--- a/layout/composite.h
+++ b/layout/composite.h
@@ -122,13 +122,7 @@ struct m0_composite_layer {
 	 * that is [0, M0_BINDEX_MAX]. The extents are stored in the form of a
 	 * list of the m0_composite_layer_extent structures.
 	 */
-	/*
-	 * todo This shall not be a pointer.
-	 * You can move the entire list from one m0_tl to another by updating
-	 * a couple of pointers. We don't have an appropriate operation in
-	 * tlist.h, but it can easily be added. See linux/list.h:list_splice().
-	 */
-	struct m0_tl     *clr_extents;
+	struct m0_tl      clr_extents;
 
 	/** Magic number set while adding an entry to the list of layers. */
 	uint64_t          clr_magic;
@@ -251,7 +245,10 @@ M0_INTERNAL int m0_composite_build(struct m0_layout_domain *dom,
  *
  * @param extlist Extent mask to be associated with the layer being added.
  * This is to be generated by the user using the m0_composite_layer_ext_tlist
- * and the related interfaces.
+ * and the related interfaces. This list is spliced together with
+ * m0_composite_layer::clr_extents. In case of successfully adding a layer to
+ * the composite layout, user shall not free the nodes added to the extlist.
+ * They are internally freed when the layer is freed.
  *
  * @note In case the layer is added successfully, the user shall not free the
  * extlist supplied as an argument. It will be implicitly freed when the
diff --git a/layout/ut/composite.c b/layout/ut/composite.c
index 7d8f38a..e4fa226 100644
--- a/layout/ut/composite.c
+++ b/layout/ut/composite.c
@@ -129,13 +129,12 @@ static void sublayouts_delete(struct m0_layout_domain *domain,
  * 1) Add tests for having the first layer spanning the whole namespace
  * 2) Add test to cover the functioning of the ext lookup
  */
-static void extentlist_build(struct m0_tl **extlist,
+static void extentlist_build(struct m0_tl *extents,
 			     uint32_t extents_nr,
 			     m0_bindex_t min_start_offset,
 			     m0_bindex_t approximate_end_offset,
 			     bool if_contiguous_extents)
 {
-	struct m0_tl                     *extents;
 	struct m0_composite_layer_extent *lr_ext;
 	m0_bindex_t                       delta;
 	uint32_t                          i;
@@ -144,8 +143,6 @@ static void extentlist_build(struct m0_tl **extlist,
 	approximate_end_offset = M0_BINDEX_MAX + 1;
 
 	/* Initialise a m0_tl for storing the extents. */
-	M0_ALLOC_PTR(extents);
-	M0_UT_ASSERT(extents != NULL);
 	m0_composite_layer_ext_tlist_init(extents);
 	M0_UT_ASSERT(m0_composite_layer_ext_tlist_is_empty(extents));
 
@@ -167,8 +164,7 @@ static void extentlist_build(struct m0_tl **extlist,
 
 		m0_composite_layer_ext_tlink_init_at_tail(lr_ext, extents);
 	}
-	*extlist = extents;
-	M0_UT_ASSERT(!m0_composite_layer_ext_tlist_is_empty(*extlist));
+	M0_UT_ASSERT(!m0_composite_layer_ext_tlist_is_empty(extents));
 }
 
 static void composite_layout_verify(struct m0_layout *l,
@@ -230,7 +226,7 @@ static void composite_layout_verify(struct m0_layout *l,
 		j = 0;
 		delta = (approximate_end_offset - min_start_offset) /
 			extents_nr;
-		m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+		m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
 			M0_UT_ASSERT(lr_ext->cle_ext.e_start ==
 				     min_start_offset + j * delta);
 			M0_UT_ASSERT(lr_ext->cle_ext.e_end ==
@@ -313,7 +309,7 @@ static void extlist_dump(const struct m0_composite_layout *cl,
 			  (unsigned long long)cl->cl_base.l_id,
 			  (unsigned long)layer_idx);
 	i = 0;
-	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+	m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
 		my_console_printf("\t ext[%lu]: start %llu, end %llu, "
 				  "state %llu \n",
 				  (unsigned long)i,
@@ -350,7 +346,7 @@ static int composite_build(uint64_t lid,
 {
 	struct m0_layout *sublayout;
 	uint64_t          sublayout_id;
-	struct m0_tl     *extents;
+	struct m0_tl      extents;
 	struct m0_layout *l_from_cl;
 	int               rc;
 
@@ -365,7 +361,7 @@ static int composite_build(uint64_t lid,
 
 	/* Build a composite layout. */
 	rc = m0_composite_build(domain, lid, sublayout,
-				extents, min_extents_nr, cl);
+				&extents, min_extents_nr, cl);
 	if (failure_test) {
 		M0_UT_ASSERT(rc == -ENOMEM);
 		//todo shall get rid of the extentlist built
@@ -403,7 +399,7 @@ static int composite_layers_add(struct m0_composite_layout *cl,
 {
 	uint64_t          sublayout_id;
 	struct m0_layout *sublayout;
-	struct m0_tl     *extents;
+	struct m0_tl      extents;
 	uint32_t          extents_nr;
 	uint32_t          i;
 	int               rc;
@@ -424,8 +420,8 @@ static int composite_layers_add(struct m0_composite_layout *cl,
 				 min_start_offset, approximate_end_offset,
 				 if_contiguous_extents);
 
-		rc = m0_composite_layer_add(cl, sublayout, extents, extents_nr,
-					    tx);
+		rc = m0_composite_layer_add(cl, sublayout, &extents,
+					    extents_nr, tx);
 		if (layer_add_failure_test) {
 			M0_UT_ASSERT(rc == L_TABLE_INSERT_ERR);
 			/* todo get rid of extentlist built. */
@@ -571,23 +567,15 @@ static void extent_to_be_operated(const struct m0_composite_layout *cl,
 	ext_idxth.e_end = 0;
 	ext_idx_plus_oneth.e_start = 0;
 	ext_idx_plus_oneth.e_end = 0;
-	m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
-		if (i == extent_idx) {
+	m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
+		if (i == extent_idx)
 			ext_idxth = lr_ext->cle_ext;
-#if 0
-			if (kind_of_extent_to_operate == EXACT_EXISTING)
-				break;
-#endif
-		} else if (i == extent_idx + 1) {
+		else if (i == extent_idx + 1) {
 			ext_idx_plus_oneth = lr_ext->cle_ext;
 			break;
 		}
 		++i;
 	} m0_tl_endfor;
-#if 0
-	M0_UT_ASSERT(ergo(!if_contiguous_extents,
-			  ext_idxth.e_end != ext_idx_plus_oneth.e_start));
-#endif
 	M0_UT_ASSERT(ext_idxth.e_end == ext_idx_plus_oneth.e_start);
 
 	if (kind_of_extent_to_operate == EXACT_EXISTING) {
@@ -1120,16 +1108,17 @@ static void composite_layout_compare(const struct m0_layout *l1,
 	layer2 = comp_layer_tlist_head(&cl2->cl_layers);
 	m0_tl_for(comp_layer, &cl1->cl_layers, layer1) {
 		/*
-		 * Can not compare with layer2->clr_cl->l_id since
-		 * layer2->clr_cl might be deleted and recreated e.g. in case
-		 * of ext_operate()
+		 * Can not check layer1->clr_l->l_id or layer2->clr_l->l_id
+		 * since layer1->clr_cl or layer1->clr_cl that is the composite
+		 * layout might be deleted and recreated e.g. say by reading it
+		 * from DB.
+		 * M0_UT_ASSERT(layer1->clr_cl->l_id == cl2->cl_base.l_id);
 		 */
-		M0_UT_ASSERT(layer1->clr_cl->l_id == cl2->cl_base.l_id);
 		M0_UT_ASSERT(layer1->clr_sl == layer2->clr_sl);
 		M0_UT_ASSERT(layer1->clr_extents_nr == layer2->clr_extents_nr);
 		lr_ext2 = m0_composite_layer_ext_tlist_head(
-							layer2->clr_extents);
-		m0_tl_for(m0_composite_layer_ext, layer1->clr_extents,
+							&layer2->clr_extents);
+		m0_tl_for(m0_composite_layer_ext, &layer1->clr_extents,
 			  lr_ext1) {
 			M0_UT_ASSERT(lr_ext1->cle_ext.e_start ==
 				     lr_ext2->cle_ext.e_start);
@@ -1137,7 +1126,7 @@ static void composite_layout_compare(const struct m0_layout *l1,
 				     lr_ext2->cle_ext.e_end);
 			M0_UT_ASSERT(lr_ext1->cle_state == lr_ext2->cle_state);
 			lr_ext2 = m0_composite_layer_ext_tlist_next(
-							layer2->clr_extents,
+							&layer2->clr_extents,
 							lr_ext2);
 		} m0_tl_endfor;
 		layer2 = comp_layer_tlist_next(&cl2->cl_layers, layer2);
@@ -1176,11 +1165,8 @@ static void composite_layout_copy(const struct m0_layout *l_src,
 		layer_dest->clr_idx = layer_src->clr_idx;
 		layer_dest->clr_extents_nr = layer_src->clr_extents_nr;
 
-		M0_ALLOC_PTR(layer_dest->clr_extents);
-		M0_UT_ASSERT(layer_dest->clr_extents != NULL);
-		m0_composite_layer_ext_tlist_init(layer_dest->clr_extents);
-
-		m0_tl_for(m0_composite_layer_ext, layer_src->clr_extents,
+		m0_composite_layer_ext_tlist_init(&layer_dest->clr_extents);
+		m0_tl_for(m0_composite_layer_ext, &layer_src->clr_extents,
 			  lr_ext_src) {
 			M0_ALLOC_PTR(lr_ext_dest);
 			M0_UT_ASSERT(lr_ext_dest != NULL);
@@ -1188,7 +1174,7 @@ static void composite_layout_copy(const struct m0_layout *l_src,
 			lr_ext_dest->cle_state = lr_ext_src->cle_state;
 			m0_composite_layer_ext_tlink_init_at_tail(
 						lr_ext_dest,
-						layer_dest->clr_extents);
+						&layer_dest->clr_extents);
 		} m0_tl_endfor;
 		comp_layer_tlink_init_at_tail(layer_dest, &cl_dest->cl_layers);
 	} m0_tl_endfor;
@@ -1206,12 +1192,11 @@ static void composite_layout_copy_delete(struct m0_layout *l)
 
 	cl = container_of(l, struct m0_composite_layout, cl_base);
 	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
-		m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+		m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
 			m0_composite_layer_ext_tlist_del(lr_ext);
 			m0_composite_layer_ext_tlink_fini(lr_ext);
 			m0_free(lr_ext);
 		} m0_tl_endfor;
-		m0_free(layer->clr_extents);
 		comp_layer_tlist_del(layer);
 		comp_layer_tlink_fini(layer);
 		m0_free(layer);
@@ -1480,13 +1465,6 @@ static int ext_operate(enum extent_operation eop,
 
 	M0_UT_ASSERT(M0_IN(eop, (EXTENT_LOOKUP, EXTENT_ADD, EXTENT_UPDATE,
 				 EXTENT_DELETE)));
-#if 0
-	M0_UT_ASSERT(ergo(M0_IN(eop, (EXTENT_LOOKUP, EXTENT_DELETE),
-			  ext_state == M0_CLRES_INVALID)));
-	M0_UT_ASSERT(ergo(M0_IN(eop, (EXTENT_ADD, EXTENT_UPDATE)),
-		          M0_IN(ext_state, (M0_CLRES_VALID,
-					    M0_CLRES_FLATTENING))));
-#endif
 
 	if (!domain->ld_is_db_available) {
 		/* Build a composite layout and add some layers to it. */
@@ -1927,11 +1905,8 @@ int test_update_composite(uint64_t lid,
 	struct m0_layout                 *l1;
 	struct m0_layout                 *l1_copy;
 	struct m0_layout                 *l2;
-	//struct m0_layout                 *l_lookup;
 	struct m0_db_pair                 pair;
 	struct m0_db_tx                   tx;
-	//struct m0_composite_layer        *layer;
-	//struct m0_composite_layer_extent *lr_ext;
 	struct m0_ext                     ext_to_operate;
 	uint32_t                          layer_id_lookup;
 	struct m0_ext                     ext_lookup;
@@ -2179,7 +2154,7 @@ int test_delete_composite(uint64_t lid,
 	M0_UT_ASSERT(rc == 0);
 
 	m0_tl_for(comp_layer, &cl->cl_layers, layer) {
-		m0_tl_for(m0_composite_layer_ext, layer->clr_extents, lr_ext) {
+		m0_tl_for(m0_composite_layer_ext, &layer->clr_extents, lr_ext) {
 			/*
 			 * Shall not pass &lr_ext->cle_ext directly since
 			 * lr_ext is going to get deleted. Hence, make a copy.
diff --git a/lib/list.c b/lib/list.c
index 77f6334..960265a 100644
--- a/lib/list.c
+++ b/lib/list.c
@@ -73,6 +73,28 @@ M0_INTERNAL size_t m0_list_length(const struct m0_list *list)
 	return length;
 }
 
+M0_INTERNAL void m0_list_splice(struct m0_list *head,
+				const struct m0_list *list)
+{
+	struct m0_list_link *prev = head->l_head;
+	struct m0_list_link *next = head->l_head->ll_next;
+	struct m0_list_link *first = list->l_head;
+	struct m0_list_link *last  = list->l_tail;
+
+	M0_ASSERT(m0_list_invariant(head));
+	M0_ASSERT(m0_list_invariant(list));
+
+	if (m0_list_length(list) == 0)
+		return;
+	first->ll_prev = prev;
+	prev->ll_next = first;
+
+	last->ll_next = next;
+	next->ll_prev = last;
+
+	M0_ASSERT(m0_list_invariant(head));
+}
+
 M0_INTERNAL bool m0_list_contains(const struct m0_list *list,
 				  const struct m0_list_link *link)
 {
diff --git a/lib/list.h b/lib/list.h
index 720d8a9..ebff813 100644
--- a/lib/list.h
+++ b/lib/list.h
@@ -115,16 +115,22 @@ M0_INTERNAL bool m0_list_contains(const struct m0_list *list,
 				  const struct m0_list_link *link);
 
 /**
- This function iterate over the argument list checking that double-linked
+ This function iterates over the argument list checking that double-linked
  list invariant holds (x->ll_prev->ll_next == x && x->ll_next->ll_prev == x).
 
  @return true iff @list isn't corrupted
-*/
+ */
 M0_INTERNAL bool m0_list_invariant(const struct m0_list *list);
 
 M0_INTERNAL size_t m0_list_length(const struct m0_list *list);
 
 /**
+  This function joins the two lists.
+ */
+M0_INTERNAL void m0_list_splice(struct m0_list *head,
+				const struct m0_list *list);
+
+/**
  add list to top on the list
 
  This function can be called on an uninitialised @next link. All @next fields are
diff --git a/lib/tlist.c b/lib/tlist.c
index 6cf14ea..dd589bb 100644
--- a/lib/tlist.c
+++ b/lib/tlist.c
@@ -119,6 +119,16 @@ M0_INTERNAL size_t m0_tlist_length(const struct m0_tl_descr *d,
 }
 M0_EXPORTED(m0_tlist_length);
 
+M0_INTERNAL void  m0_tlist_splice(const struct m0_tl_descr *d,
+				  struct m0_tl *list,
+				  const struct m0_tl *list_to_add)
+{
+	M0_INVARIANT_EX(m0_tlist_invariant(d, list));
+	M0_INVARIANT_EX(m0_tlist_invariant(d, list_to_add));
+	return m0_list_splice(&list->t_head, &list_to_add->t_head);
+}
+M0_EXPORTED(m0_tlist_splice);
+
 M0_INTERNAL void m0_tlist_add(const struct m0_tl_descr *d, struct m0_tl *list,
 			      void *obj)
 {
diff --git a/lib/tlist.h b/lib/tlist.h
index b21d508..f8542de 100644
--- a/lib/tlist.h
+++ b/lib/tlist.h
@@ -288,6 +288,9 @@ M0_INTERNAL bool m0_tlist_contains(const struct m0_tl_descr *d,
 				   const struct m0_tl *list, const void *obj);
 M0_INTERNAL size_t m0_tlist_length(const struct m0_tl_descr *d,
 				   const struct m0_tl *list);
+M0_INTERNAL void m0_tlist_splice(const struct m0_tl_descr *d,
+				 struct m0_tl *list,
+				 const struct m0_tl *list_to_add);
 
 /**
    Adds an element to the beginning of a list.
@@ -506,6 +509,8 @@ scope bool   name ## _tlink_is_in   (const amb_type *amb);		\
 scope bool   name ## _tlist_contains(const struct m0_tl *list,		\
 				     const amb_type *amb);		\
 scope size_t name ## _tlist_length(const struct m0_tl *list);		\
+scope void name ## _tlist_splice(struct m0_tl *list,			\
+				 const struct m0_tl *list_to_add);	\
 scope void   name ## _tlist_add(struct m0_tl *list, amb_type *amb);	\
 scope void   name ## _tlist_add_tail(struct m0_tl *list, amb_type *amb); \
 scope void   name ## _tlist_add_after(amb_type *amb, amb_type *next);	\
@@ -611,6 +616,12 @@ scope __AUN size_t name ## _tlist_length(const struct m0_tl *list)	\
 	return m0_tlist_length(&name ## _tl, list);			\
 }									\
 									\
+scope __AUN void name ## _tlist_splice(struct m0_tl *list,		\
+				       const struct m0_tl *list_to_add) \
+{									\
+	return m0_tlist_splice(&name ## _tl, list, list_to_add);	\
+}									\
+									\
 scope __AUN void   name ## _tlist_add(struct m0_tl *list, amb_type *amb) \
 {									\
 	m0_tlist_add(&name ## _tl, list, amb);				\
-- 
1.8.3.2

