From 9e0d861a91f9d2d5ee6381c06e09f35d01089b5a Mon Sep 17 00:00:00 2001
From: Andriy Tkachuk <andriy_tkachuk@xyratex.com>
Date: Tue, 11 Feb 2014 18:09:14 +0200
Subject: [PATCH 42/60] rpc slots references cleanup

---
 addb/addb_monitor.h                |   1 -
 cm/cm.c                            |   3 +-
 cm/cm.h                            |   1 -
 conf/confc.c                       |   8 +-
 console/console.c                  |   1 -
 console/ut/console.c               |   2 -
 ioservice/io_service.c             |   3 +-
 ioservice/ut/bulkio_common.c       |   1 -
 ioservice/ut/bulkio_common.h       |   1 -
 ioservice/ut/cob_foms.c            |   2 -
 m0t1fs/linux_kernel/m0t1fs.h       |   1 -
 m0t1fs/linux_kernel/super.c        |   3 +-
 mero/conf.c                        |   2 -
 mero/ut/cs_ut_main.c               |   2 -
 mgmt/ctl/utils.c                   |   1 -
 mgmt/svc/ut/mgmt_svc_setup.c       |   2 -
 net/lnet/linux_kernel/klnet_core.c |   2 +-
 pool/pool_trigger.c                |   5 +-
 reqh/ut/reqh_fom_ut.c              |   2 -
 rm/ut/rmut.c                       |   2 +-
 rpc/conn.c                         |   2 +-
 rpc/conn_internal.h                |   4 +-
 rpc/formation2.c                   |   2 -
 rpc/formation2_internal.h          |   2 -
 rpc/it/rpc_ping.c                  |   6 --
 rpc/rev_conn.c                     |   3 +-
 rpc/rpclib.c                       |   8 +-
 rpc/rpclib.h                       |   7 +-
 rpc/session.c                      |  34 ++-----
 rpc/session.h                      | 183 ++-----------------------------------
 rpc/session_foms.c                 |   2 +-
 rpc/session_internal.h             |   6 +-
 rpc/ub/README                      |   5 +-
 rpc/ub/plot.sh                     |  61 ++++---------
 rpc/ub/ub.c                        |   2 -
 rpc/ut/clnt_srv_ctx.c              |   2 -
 rpc/ut/rcv_session.c               |  19 +---
 rpc/ut/session.c                   |   9 +-
 sns/cm/repair/ut/net.c             |   5 +-
 sns/cm/st/repair_cli.c             |   4 +-
 sns/cm/st/repair_cli.h             |   1 -
 stats/util/stats_util.c            |   2 -
 42 files changed, 66 insertions(+), 348 deletions(-)

diff --git a/addb/addb_monitor.h b/addb/addb_monitor.h
index be699d9..05e1ab9 100644
--- a/addb/addb_monitor.h
+++ b/addb/addb_monitor.h
@@ -214,7 +214,6 @@ struct addb_post_fom;
 
 enum {
 	ADDB_STATS_MAX_RPCS_IN_FLIGHT = 1,
-	ADDB_STATS_MAX_RPC_SLOTS_NR   = 1
 };
 
 M0_TL_DESCR_DECLARE(addb_mon, M0_EXTERN);
diff --git a/cm/cm.c b/cm/cm.c
index 47150b3..b0a2c33 100644
--- a/cm/cm.c
+++ b/cm/cm.c
@@ -704,8 +704,7 @@ static int cm_replicas_connect(struct m0_cm *cm, struct m0_rpc_machine *rmach,
 			rc = m0_rpc_client_connect(&pxy->px_conn,
 						   &pxy->px_session,
 						   rmach, ex->ex_endpoint,
-						   CM_MAX_NR_RPC_IN_FLIGHT,
-						   CM_NR_SLOTS_PER_SESSION);
+						   CM_MAX_NR_RPC_IN_FLIGHT);
 			if (rc == 0) {
 				m0_cm_proxy_add(cm, pxy);
 				M0_LOG(M0_DEBUG, "Connected to %s", ex->ex_endpoint);
diff --git a/cm/cm.h b/cm/cm.h
index 07673f8..8bfd240 100644
--- a/cm/cm.h
+++ b/cm/cm.h
@@ -149,7 +149,6 @@ enum m0_cm_failure {
 
 enum {
 	CM_RPC_TIMEOUT              = 30, /* seconds */
-	CM_NR_SLOTS_PER_SESSION     = 10,
 	CM_MAX_NR_RPC_IN_FLIGHT     = 100,
 };
 
diff --git a/conf/confc.c b/conf/confc.c
index 56c3b50..f9a5b4f 100644
--- a/conf/confc.c
+++ b/conf/confc.c
@@ -1324,10 +1324,7 @@ static int connect_to_confd(struct m0_confc *confc, const char *confd_addr,
 			    struct m0_rpc_machine *rpc_mach)
 {
 	enum {
-		NR_SLOTS = 5, /* That many m0_confc_ctx's will be able
-			       * to talk to confd simultaneously. */
-		MAX_RPCS_IN_FLIGHT = 2 * NR_SLOTS /* XXX Or should it
-						   * be == NR_SLOTS? */
+		MAX_RPCS_IN_FLIGHT = 2
 	};
 	int rc;
 
@@ -1335,8 +1332,7 @@ static int connect_to_confd(struct m0_confc *confc, const char *confd_addr,
 	M0_PRE(not_empty(confd_addr) && rpc_mach != NULL);
 
 	rc = m0_rpc_client_connect(&confc->cc_rpc_conn, &confc->cc_rpc_session,
-				   rpc_mach, confd_addr, MAX_RPCS_IN_FLIGHT,
-				   NR_SLOTS);
+				   rpc_mach, confd_addr, MAX_RPCS_IN_FLIGHT);
 	M0_POST((rc == 0) == confc_is_online(confc));
 	M0_RETURN(rc);
 }
diff --git a/console/console.c b/console/console.c
index 23d17e7..66bccb6 100644
--- a/console/console.c
+++ b/console/console.c
@@ -195,7 +195,6 @@ int main(int argc, char **argv)
 		.rcx_net_dom               = &client_net_dom,
 		.rcx_local_addr            = "0@lo:12345:34:*",
 		.rcx_remote_addr           = "0@lo:12345:34:1",
-		.rcx_nr_slots              = 1,
 		.rcx_max_rpcs_in_flight    = 1,
 	};
 
diff --git a/console/ut/console.c b/console/ut/console.c
index 5d63239..3216d19 100644
--- a/console/ut/console.c
+++ b/console/ut/console.c
@@ -76,7 +76,6 @@ static struct m0_ut_redirect err_redir;
 
 enum {
 	CLIENT_COB_DOM_ID  = 14,
-	SESSION_SLOTS      = 1,
 	MAX_RPCS_IN_FLIGHT = 1,
 	MAX_RETRIES        = 5,
 };
@@ -88,7 +87,6 @@ static struct m0_rpc_client_ctx cctx = {
 	.rcx_net_dom            = &client_net_dom,
 	.rcx_local_addr         = CLIENT_ENDPOINT_ADDR,
 	.rcx_remote_addr        = SERVER_ENDPOINT_ADDR,
-	.rcx_nr_slots           = SESSION_SLOTS,
 	.rcx_max_rpcs_in_flight = MAX_RPCS_IN_FLIGHT,
 };
 
diff --git a/ioservice/io_service.c b/ioservice/io_service.c
index 68e3e1b..634336e 100644
--- a/ioservice/io_service.c
+++ b/ioservice/io_service.c
@@ -616,7 +616,6 @@ static void ios_stats_post_addb(struct m0_reqh_service *service)
 
 enum {
 	RPC_TIMEOUT          = 8, /* seconds */
-	NR_SLOTS_PER_SESSION = 10,
 	MAX_NR_RPC_IN_FLIGHT = 100,
 };
 
@@ -647,7 +646,7 @@ static int m0_ios_mds_conn_init(struct m0_reqh *reqh,
 	M0_LOG(M0_DEBUG, "Ios connecting to mds %s", srv_ep_addr);
 	rc = m0_rpc_client_connect(&conn->imc_conn, &conn->imc_session,
 				   rpc_machine, srv_ep_addr,
-				   MAX_NR_RPC_IN_FLIGHT, NR_SLOTS_PER_SESSION);
+				   MAX_NR_RPC_IN_FLIGHT);
 	if (rc == 0) {
 		conn->imc_connected = true;
 		M0_LOG(M0_DEBUG, "Ios connected to mds %s", srv_ep_addr);
diff --git a/ioservice/ut/bulkio_common.c b/ioservice/ut/bulkio_common.c
index 4cefd33..adb35e4 100644
--- a/ioservice/ut/bulkio_common.c
+++ b/ioservice/ut/bulkio_common.c
@@ -451,7 +451,6 @@ int bulkio_client_start(struct bulkio_params *bp, const char *caddr,
 	M0_ASSERT(cctx != NULL);
 
 	cctx->rcx_remote_addr           = saddr;
-	cctx->rcx_nr_slots              = IO_RPC_SESSION_SLOTS;
 	cctx->rcx_max_rpcs_in_flight    = IO_RPC_MAX_IN_FLIGHT;
 	cctx->rcx_recv_queue_min_length = M0_NET_TM_RECV_QUEUE_DEF_LEN;
 	cctx->rcx_max_rpc_msg_size	= M0_RPC_DEF_MAX_RPC_MSG_SIZE;
diff --git a/ioservice/ut/bulkio_common.h b/ioservice/ut/bulkio_common.h
index a16f578..296155d 100644
--- a/ioservice/ut/bulkio_common.h
+++ b/ioservice/ut/bulkio_common.h
@@ -52,7 +52,6 @@ enum IO_UT_VALUES {
 	IO_SEG_START_OFFSET  = IO_SEG_SIZE,
 	IO_CLIENT_COBDOM_ID  = 21,
 	IO_SERVER_COBDOM_ID  = 29,
-	IO_RPC_SESSION_SLOTS = 8,
 	IO_RPC_MAX_IN_FLIGHT = 32,
 	IO_SERVER_ARGC	     = 32,
 	IO_SERVER_SERVICE_NR = 1,
diff --git a/ioservice/ut/cob_foms.c b/ioservice/ut/cob_foms.c
index c0fede3..7a7c59b 100644
--- a/ioservice/ut/cob_foms.c
+++ b/ioservice/ut/cob_foms.c
@@ -56,7 +56,6 @@ enum cob_fom_type {
 
 enum {
 	CLIENT_COB_DOM_ID         = 12,
-	CLIENT_RPC_SESSION_SLOTS  = 1,
 	CLIENT_RPC_CONN_TIMEOUT   = 200,
 	CLIENT_MAX_RPCS_IN_FLIGHT = 8,
 	COB_NAME_STRLEN           = 34,
@@ -142,7 +141,6 @@ static void cobfoms_utinit(void)
 	cctx->rcx_net_dom            = &cut->cu_nd;
 	cctx->rcx_local_addr         = CLIENT_EP_ADDR;
 	cctx->rcx_remote_addr        = SERVER_EP_ADDR;
-	cctx->rcx_nr_slots           = CLIENT_RPC_SESSION_SLOTS;
 	cctx->rcx_max_rpcs_in_flight = CLIENT_MAX_RPCS_IN_FLIGHT;
 
 	rc = m0_rpc_client_start(cctx);
diff --git a/m0t1fs/linux_kernel/m0t1fs.h b/m0t1fs/linux_kernel/m0t1fs.h
index 5c6552e..34a9c0d 100644
--- a/m0t1fs/linux_kernel/m0t1fs.h
+++ b/m0t1fs/linux_kernel/m0t1fs.h
@@ -399,7 +399,6 @@ const char *m0t1fs_param_node_uuid_get(void);
 enum {
 	M0T1FS_RPC_TIMEOUT              = 30, /* seconds */
 	M0T1FS_RPC_MAX_RETRIES          = 5,
-	M0T1FS_NR_SLOTS_PER_SESSION     = 10,
 	M0T1FS_MAX_NR_RPC_IN_FLIGHT     = 100,
 	M0T1FS_DEFAULT_NR_DATA_UNITS    = 1,
 	M0T1FS_DEFAULT_NR_PARITY_UNITS  = 1,
diff --git a/m0t1fs/linux_kernel/super.c b/m0t1fs/linux_kernel/super.c
index d6ad4e1..920d8c2 100644
--- a/m0t1fs/linux_kernel/super.c
+++ b/m0t1fs/linux_kernel/super.c
@@ -504,8 +504,7 @@ static int connect_to_service(const char *addr, enum m0_conf_service_type type,
 	m0t1fs_service_context_init(ctx, csb, type);
 	rc = m0_rpc_client_connect(&ctx->sc_conn, &ctx->sc_session,
 				   &m0t1fs_globals.g_rpc_machine, addr,
-				   M0T1FS_MAX_NR_RPC_IN_FLIGHT,
-				   M0T1FS_NR_SLOTS_PER_SESSION);
+				   M0T1FS_MAX_NR_RPC_IN_FLIGHT);
 	if (rc == 0) {
 		svc_ctx_tlist_add_tail(&csb->csb_service_contexts, ctx);
 		M0_CNT_INC(csb->csb_nr_active_contexts);
diff --git a/mero/conf.c b/mero/conf.c
index cf0d1dd..3175c2f 100644
--- a/mero/conf.c
+++ b/mero/conf.c
@@ -175,7 +175,6 @@ M0_INTERNAL int cs_conf_to_args(struct cs_args *args, const char *confd_addr,
 {
 	enum {
 		MAX_RPCS_IN_FLIGHT = 32,
-		NR_SLOTS           = 1
 	};
 	static struct m0_net_domain     client_net_dom;
 	static struct m0_rpc_client_ctx cctx;
@@ -192,7 +191,6 @@ M0_INTERNAL int cs_conf_to_args(struct cs_args *args, const char *confd_addr,
 	cctx.rcx_net_dom               = &client_net_dom;
 	cctx.rcx_local_addr            = client_ep;
 	cctx.rcx_remote_addr           = server_ep;
-	cctx.rcx_nr_slots              = NR_SLOTS;
 	cctx.rcx_max_rpcs_in_flight    = MAX_RPCS_IN_FLIGHT;
 	cctx.rcx_recv_queue_min_length = M0_NET_TM_RECV_QUEUE_DEF_LEN;
 	cctx.rcx_max_rpc_msg_size      = M0_RPC_DEF_MAX_RPC_MSG_SIZE;
diff --git a/mero/ut/cs_ut_main.c b/mero/ut/cs_ut_main.c
index b14ed5a..c7694ad 100644
--- a/mero/ut/cs_ut_main.c
+++ b/mero/ut/cs_ut_main.c
@@ -214,7 +214,6 @@ static struct m0_net_xprt *cs_xprts[] = {
 
 enum {
 	MAX_RPCS_IN_FLIGHT = 10,
-	MAX_RPC_SLOTS_NR   = 2,
 };
 
 #define SERVER_LOG_FILE_NAME	"cs_ut.errlog"
@@ -237,7 +236,6 @@ static int cs_ut_client_init(struct cl_ctx *cctx, const char *cl_ep_addr,
 	cl_ctx->rcx_net_dom            = &cctx->cl_ndom;
 	cl_ctx->rcx_local_addr         = cl_ep_addr;
 	cl_ctx->rcx_remote_addr        = srv_ep_addr;
-	cl_ctx->rcx_nr_slots           = MAX_RPC_SLOTS_NR;
 	cl_ctx->rcx_max_rpcs_in_flight = MAX_RPCS_IN_FLIGHT;
 
 	rc = m0_rpc_client_start(cl_ctx);
diff --git a/mgmt/ctl/utils.c b/mgmt/ctl/utils.c
index 91d313c..58ecf14 100644
--- a/mgmt/ctl/utils.c
+++ b/mgmt/ctl/utils.c
@@ -94,7 +94,6 @@ static int client_init(struct m0_mgmt_ctl_ctx *ctx)
 	c->rcx_net_dom               = &ctx->mcc_net_dom;
 	c->rcx_local_addr            = ctx->mcc_client.mcc_mgmt_ep;
 	c->rcx_remote_addr           = ctx->mcc_node.mnc_m0d_ep;
-	c->rcx_nr_slots              = 1;
 	c->rcx_max_rpcs_in_flight    = 1;
 	if (ctx->mcc_client.mcc_recvq_min_len != 0)
 		c->rcx_recv_queue_min_length =
diff --git a/mgmt/svc/ut/mgmt_svc_setup.c b/mgmt/svc/ut/mgmt_svc_setup.c
index 107b3c5..b278fe9 100644
--- a/mgmt/svc/ut/mgmt_svc_setup.c
+++ b/mgmt/svc/ut/mgmt_svc_setup.c
@@ -26,7 +26,6 @@
 
 #define MGMT_SVC_UT_CLIENT_ENDPOINT_ADDR "0@lo:12345:35:*"
 enum {
-	MGMT_SVC_UT_SESSION_SLOTS      = 5,
 	MGMT_SVC_UT_MAX_RPCS_IN_FLIGHT = 32,
 };
 
@@ -37,7 +36,6 @@ static struct m0_rpc_client_ctx mgmt_svc_ut_cctx = {
 	.rcx_net_dom               = &mgmt_svc_ut_client_net_dom,
 	.rcx_local_addr            = MGMT_SVC_UT_CLIENT_ENDPOINT_ADDR,
 	.rcx_remote_addr           = MGMT_SVC_UT_SERVER_ENDPOINT_ADDR,
-	.rcx_nr_slots              = MGMT_SVC_UT_SESSION_SLOTS,
 	.rcx_max_rpcs_in_flight    = MGMT_SVC_UT_MAX_RPCS_IN_FLIGHT,
 	.rcx_recv_queue_min_length = M0_NET_TM_RECV_QUEUE_DEF_LEN,
 };
diff --git a/net/lnet/linux_kernel/klnet_core.c b/net/lnet/linux_kernel/klnet_core.c
index 46b91fe..bd05308 100644
--- a/net/lnet/linux_kernel/klnet_core.c
+++ b/net/lnet/linux_kernel/klnet_core.c
@@ -340,7 +340,7 @@ HLD of Mero LNet Transport</a>
 
    @subsection KLNetCoreDLD-lspec-buf-res LNet Buffer Resources
 
-   A network buffer is associated with a Match Descriptor (MD).  This is
+   A network buffer is associated with a Memory Descriptor (MD).  This is
    represented by the nlx_kcore_buffer::kb_mdh handle.  There may be a Match
    Entry (ME) associated with this MD for some operations, but when created, it
    is set up to unlink automatically when the MD is unlinked so it is not
diff --git a/pool/pool_trigger.c b/pool/pool_trigger.c
index 6f6c2f7..09bab82 100644
--- a/pool/pool_trigger.c
+++ b/pool/pool_trigger.c
@@ -45,7 +45,6 @@ struct m0_rpc_client_ctx cl_ctx;
 
 enum {
 	MAX_RPCS_IN_FLIGHT = 10,
-	MAX_RPC_SLOTS_NR   = 10,
 	MAX_DEV_NR         = 100,
 	MAX_SERVERS        = 1024
 };
@@ -85,7 +84,6 @@ static int poolmach_client_init(void)
 	cl_ctx.rcx_net_dom            = &cl_ndom;
 	cl_ctx.rcx_local_addr         = cl_ep_addr;
 	cl_ctx.rcx_remote_addr        = srv_ep_addr[0];
-	cl_ctx.rcx_nr_slots           = MAX_RPC_SLOTS_NR;
 	cl_ctx.rcx_max_rpcs_in_flight = MAX_RPCS_IN_FLIGHT;
 
 	rc = m0_rpc_client_start(&cl_ctx);
@@ -112,8 +110,7 @@ static int poolmach_rpc_ctx_init(struct rpc_ctx *ctx, const char *sep)
 				     &ctx->ctx_session,
 				     &cl_ctx.rcx_rpc_machine,
 				     sep,
-				     MAX_RPCS_IN_FLIGHT,
-				     MAX_RPC_SLOTS_NR);
+				     MAX_RPCS_IN_FLIGHT);
 }
 
 static void poolmach_rpc_ctx_fini(struct rpc_ctx *ctx)
diff --git a/reqh/ut/reqh_fom_ut.c b/reqh/ut/reqh_fom_ut.c
index 4e8bf6f..e994968 100644
--- a/reqh/ut/reqh_fom_ut.c
+++ b/reqh/ut/reqh_fom_ut.c
@@ -61,7 +61,6 @@
 
 enum {
 	CLIENT_COB_DOM_ID  = 101,
-	SESSION_SLOTS      = 5,
 	MAX_RPCS_IN_FLIGHT = 32,
 	MAX_RETRIES        = 5,
 };
@@ -423,7 +422,6 @@ void test_reqh(void)
 		.rcx_net_dom            = &net_dom,
 		.rcx_local_addr         = CLIENT_ENDPOINT_ADDR,
 		.rcx_remote_addr        = SERVER_ENDPOINT_ADDR,
-		.rcx_nr_slots           = SESSION_SLOTS,
 		.rcx_max_rpcs_in_flight = MAX_RPCS_IN_FLIGHT,
 	};
 
diff --git a/rm/ut/rmut.c b/rm/ut/rmut.c
index ec93432..651ba23 100644
--- a/rm/ut/rmut.c
+++ b/rm/ut/rmut.c
@@ -214,7 +214,7 @@ void rm_ctx_connect(struct rm_context *src, const struct rm_context *dest)
 	M0_UT_ASSERT(rc == 0);
 
 	rc = m0_rpc_session_create(&src->rc_sess[dest->rc_id],
-				   &src->rc_conn[dest->rc_id], 1,
+				   &src->rc_conn[dest->rc_id],
 				   M0_TIME_NEVER);
 	M0_UT_ASSERT(rc == 0);
 }
diff --git a/rpc/conn.c b/rpc/conn.c
index 0713802..838440e 100644
--- a/rpc/conn.c
+++ b/rpc/conn.c
@@ -322,7 +322,7 @@ static int session_zero_attach(struct m0_rpc_conn *conn)
 	if (session == NULL)
 		M0_RETURN(-ENOMEM);
 
-	rc = m0_rpc_session_init_locked(session, conn, 10 /* NR_SLOTS */);
+	rc = m0_rpc_session_init_locked(session, conn);
 	if (rc != 0) {
 		m0_free(session);
 		M0_RETURN(rc);
diff --git a/rpc/conn_internal.h b/rpc/conn_internal.h
index 8467eb9..0e0de4a 100644
--- a/rpc/conn_internal.h
+++ b/rpc/conn_internal.h
@@ -109,8 +109,8 @@ M0_INTERNAL void m0_rpc_conn_establish_reply_received(struct m0_rpc_item *req);
    Cleans up in memory state of rpc connection.
 
    The conn_terminate FOM cannot free in-memory state of rpc connection.
-   Because it needs to send conn_terminate_reply fop, by using session-0 and
-   slot-0 of the rpc connection being terminated. Hence we cleanup in memory
+   Because it needs to send conn_terminate_reply fop, by using session-0
+   of the rpc connection being terminated. Hence we cleanup in memory
    state of the conn when conn_terminate_reply has been sent.
 
    @pre conn_state(conn) == M0_RPC_CONN_TERMINATING
diff --git a/rpc/formation2.c b/rpc/formation2.c
index 463d5e6..1643e64 100644
--- a/rpc/formation2.c
+++ b/rpc/formation2.c
@@ -501,8 +501,6 @@ static void frm_balance(struct m0_rpc_frm *frm)
  * This case can arise if:
  * - Accumulated bytes are >= max_nr_bytes_accumulated,
  *   hence frm is READY AND
- * - All the items in frm are unbound items AND
- * - No slot is available to bind with any of these items.
  */
 
 /**
diff --git a/rpc/formation2_internal.h b/rpc/formation2_internal.h
index 28f5b9f..4a73bec 100644
--- a/rpc/formation2_internal.h
+++ b/rpc/formation2_internal.h
@@ -164,11 +164,9 @@ enum m0_rpc_frm_itemq_type {
    - RPC item is posted for sending
    - RPC packet has been sent or packet sending is failed
    - deadline timer of WAITING item is expired
-   - Ready slot is available
 
    Events that formation machine triggers for rest of RPC are:
    - Packet is ready for sending
-   - Request to bind an item to a slot
 
 @verbatim
                 FRM_UNINITIALISED
diff --git a/rpc/it/rpc_ping.c b/rpc/it/rpc_ping.c
index eea5d00..f5b2f36 100644
--- a/rpc/it/rpc_ping.c
+++ b/rpc/it/rpc_ping.c
@@ -85,7 +85,6 @@ static char *client_nid        = "0@lo";
 static int   server_tmid       = 1;
 static int   client_tmid       = 2;
 static int   nr_client_threads = 1;
-static int   nr_slots          = 1;
 static int   nr_ping_bytes     = 8;
 static int   nr_ping_item      = 1;
 static int   tm_recv_queue_len = M0_NET_TM_RECV_QUEUE_DEF_LEN;
@@ -116,9 +115,6 @@ MODULE_PARM_DESC(client_tmid, "local transfer machine identifier");
 module_param(nr_client_threads, int, S_IRUGO);
 MODULE_PARM_DESC(nr_client_threads, "number of client threads");
 
-module_param(nr_slots, int, S_IRUGO);
-MODULE_PARM_DESC(nr_slots, "number of slots");
-
 module_param(nr_ping_bytes, int, S_IRUGO);
 MODULE_PARM_DESC(nr_ping_bytes, "number of ping fop bytes");
 
@@ -321,7 +317,6 @@ static int run_client(void)
 	cctx.rcx_net_dom               = &client_net_dom;
 	cctx.rcx_local_addr            = client_endpoint;
 	cctx.rcx_remote_addr           = server_endpoint;
-	cctx.rcx_nr_slots              = nr_slots;
 	cctx.rcx_max_rpcs_in_flight    = MAX_RPCS_IN_FLIGHT;
 	cctx.rcx_recv_queue_min_length = tm_recv_queue_len;
 	cctx.rcx_max_rpc_msg_size      = max_rpc_msg_size,
@@ -530,7 +525,6 @@ int main(int argc, char *argv[])
 		M0_FORMATARG('b', "size in bytes", "%i", &nr_ping_bytes),
 		M0_FORMATARG('t', "number of client threads", "%i",
 						&nr_client_threads),
-		M0_FORMATARG('l', "number of slots", "%i", &nr_slots),
 		M0_FORMATARG('n', "number of ping items", "%i", &nr_ping_item),
 		M0_FORMATARG('q', "minimum TM receive queue length \n"
 				   "Note: It's default value is 2. \n"
diff --git a/rpc/rev_conn.c b/rpc/rev_conn.c
index 3ec7f1e..1a6d7f6 100644
--- a/rpc/rev_conn.c
+++ b/rpc/rev_conn.c
@@ -46,7 +46,6 @@
 
 enum {
 	RPCS_IN_FLIGHT = 1,
-	NR_SLOTS       = 1,
 };
 
 struct rev_conn_state_transition {
@@ -184,7 +183,7 @@ static int session_establish(struct m0_fom *fom)
 
 	revc = container_of(fom, struct m0_reverse_connection, rcf_fom);
 
-	rc = m0_rpc_session_init(revc->rcf_sess, revc->rcf_conn, NR_SLOTS);
+	rc = m0_rpc_session_init(revc->rcf_sess, revc->rcf_conn);
 	if (rc == 0) {
 		rc = m0_rpc_session_establish(revc->rcf_sess,
 				      m0_time_from_now(M0_REV_CONN_TIMEOUT, 0));
diff --git a/rpc/rpclib.c b/rpc/rpclib.c
index 1faaa9f..e996df6 100644
--- a/rpc/rpclib.c
+++ b/rpc/rpclib.c
@@ -102,8 +102,7 @@ M0_INTERNAL int m0_rpc_client_connect(struct m0_rpc_conn    *conn,
 				      struct m0_rpc_session *session,
 				      struct m0_rpc_machine *rpc_mach,
 				      const char            *remote_addr,
-				      uint64_t               max_rpcs_in_flight,
-				      uint32_t               nr_slots)
+				      uint64_t               max_rpcs_in_flight)
 {
 	struct m0_net_end_point *ep;
 	int                      rc;
@@ -120,7 +119,7 @@ M0_INTERNAL int m0_rpc_client_connect(struct m0_rpc_conn    *conn,
 	if (rc != 0)
 		M0_RETURN(rc);
 
-	rc = m0_rpc_session_create(session, conn, nr_slots, M0_TIME_NEVER);
+	rc = m0_rpc_session_create(session, conn, M0_TIME_NEVER);
 	if (rc != 0)
 		(void)m0_rpc_conn_destroy(conn, M0_TIME_NEVER);
 
@@ -167,8 +166,7 @@ int m0_rpc_client_start(struct m0_rpc_client_ctx *cctx)
 	rc = m0_rpc_client_connect(&cctx->rcx_connection, &cctx->rcx_session,
 				   &cctx->rcx_rpc_machine,
 				   cctx->rcx_remote_addr,
-				   cctx->rcx_max_rpcs_in_flight,
-				   cctx->rcx_nr_slots);
+				   cctx->rcx_max_rpcs_in_flight);
 	if (rc == 0)
 		M0_RETURN(rc);
 
diff --git a/rpc/rpclib.h b/rpc/rpclib.h
index 870ed8c..a061463 100644
--- a/rpc/rpclib.h
+++ b/rpc/rpclib.h
@@ -122,9 +122,6 @@ struct m0_rpc_client_ctx {
 	/** Transport specific remote address (server's address) */
 	const char                *rcx_remote_addr;
 
-	/** Number of session slots */
-	uint32_t		   rcx_nr_slots;
-
 	uint64_t		   rcx_max_rpcs_in_flight;
 
 	/* -------------------------------------------------------------
@@ -157,14 +154,12 @@ struct m0_rpc_client_ctx {
  * @param[in]  rpc_mach
  * @param[in]  remote_addr
  * @param[in]  max_rpcs_in_flight
- * @param[in]  nr_slots
  */
 M0_INTERNAL int m0_rpc_client_connect(struct m0_rpc_conn    *conn,
 				      struct m0_rpc_session *session,
 				      struct m0_rpc_machine *rpc_mach,
 				      const char            *remote_addr,
-				      uint64_t               max_rpcs_in_flight,
-				      uint32_t               nr_slots);
+				      uint64_t               max_rpcs_in_flight);
 
 /**
  * Starts client's rpc machine.
diff --git a/rpc/session.c b/rpc/session.c
index 2568d90..ddfee56 100644
--- a/rpc/session.c
+++ b/rpc/session.c
@@ -196,24 +196,22 @@ M0_INTERNAL bool m0_rpc_session_invariant(const struct m0_rpc_session *session)
 
 M0_INTERNAL bool m0_rpc_session_is_idle(const struct m0_rpc_session *session)
 {
-	return session->s_nr_active_items == 0 &&
-	       session->s_hold_cnt == 0;
+	return session->s_hold_cnt == 0;
 }
 
 M0_INTERNAL int m0_rpc_session_init(struct m0_rpc_session *session,
-				    struct m0_rpc_conn *conn, uint32_t nr_slots)
+				    struct m0_rpc_conn *conn)
 {
 	struct m0_rpc_machine *machine;
 	int                    rc;
 
-	M0_ENTRY("session: %p, conn: %p, nr_slots: %u", session,
-		 conn, nr_slots);
-	M0_PRE(session != NULL && conn != NULL && nr_slots >= 1);
+	M0_ENTRY("session: %p, conn: %p", session, conn);
+	M0_PRE(session != NULL && conn != NULL);
 
 	machine = conn->c_rpc_machine;
 	M0_PRE(machine != NULL);
 	m0_rpc_machine_lock(machine);
-	rc = m0_rpc_session_init_locked(session, conn, nr_slots);
+	rc = m0_rpc_session_init_locked(session, conn);
 	m0_rpc_machine_unlock(machine);
 
 	M0_RETURN(rc);
@@ -221,8 +219,7 @@ M0_INTERNAL int m0_rpc_session_init(struct m0_rpc_session *session,
 M0_EXPORTED(m0_rpc_session_init);
 
 M0_INTERNAL int m0_rpc_session_init_locked(struct m0_rpc_session *session,
-					   struct m0_rpc_conn *conn,
-					   uint32_t UNUSED_nr_slots)
+					   struct m0_rpc_conn *conn)
 {
 	M0_ENTRY("session: %p, conn: %p", session, conn);
 	M0_PRE(session != NULL && conn != NULL);
@@ -317,14 +314,13 @@ M0_EXPORTED(m0_rpc_session_timedwait);
 
 M0_INTERNAL int m0_rpc_session_create(struct m0_rpc_session *session,
 				      struct m0_rpc_conn *conn,
-				      uint32_t nr_slots, m0_time_t abs_timeout)
+				      m0_time_t abs_timeout)
 {
 	int rc;
 
-	M0_ENTRY("session: %p, conn: %p, nr_slots: %u", session,
-		 conn, nr_slots);
+	M0_ENTRY("session: %p, conn: %p", session, conn);
 
-	rc = m0_rpc_session_init(session, conn, nr_slots);
+	rc = m0_rpc_session_init(session, conn);
 	if (rc == 0) {
 		rc = m0_rpc_session_establish_sync(session, abs_timeout);
 		if (rc != 0)
@@ -731,18 +727,6 @@ M0_INTERNAL void m0_rpc_session_release(struct m0_rpc_session *session)
 	session_idle_x_busy(session);
 }
 
-M0_INTERNAL void m0_rpc_session_mod_nr_active_items(struct m0_rpc_session
-						    *session, int delta)
-{
-	M0_PRE(session != NULL);
-
-	if (delta != 0) {
-		/* XXX TODO overflow check */
-		session->s_nr_active_items += delta;
-		session_idle_x_busy(session);
-	}
-}
-
 /** Perform (IDLE -> BUSY) or (BUSY -> IDLE) transition if required */
 static void session_idle_x_busy(struct m0_rpc_session *session)
 {
diff --git a/rpc/session.h b/rpc/session.h
index d7ec777..586be28 100644
--- a/rpc/session.h
+++ b/rpc/session.h
@@ -51,12 +51,8 @@ http://tools.ietf.org/html/rfc5661#section-2.10.6
 Session module defines following types of objects:
 - rpc connection @see m0_rpc_conn
 - rpc session @see m0_rpc_session
-- slot @see m0_rpc_slot
-- slot ref @see m0_rpc_slot_ref.
 
 Out of these, m0_rpc_conn and m0_rpc_session are visible to user.
-m0_rpc_slot and m0_rpc_slot_ref are internal to rpc layer and not visible to
-users outside rpc layer.
 
 Session module uses following types of objects:
 - rpc machine @see m0_rpc_machine
@@ -73,146 +69,10 @@ Rpc connection has a list of rpc sessions, which are created on this
 connection. A rpc connection cannot be terminated until all the sessions
 created on the connection are terminated.
 
-A session contains one or more slots. Number of slots in the session can
-vary over the lifetime of session (In current implementation state, the number
-of slots do not vary. The slot count is fixed for entire lifetime of session.
-Slot count is specified at the time of session initialisation).
-
-Each object of type [m0_rpc_conn|m0_rpc_session|m0_rpc_slot] on sender
+Each object of type [m0_rpc_conn|m0_rpc_session] on sender
 has counterpart object of same type on receiver. (Note: same structure
 definitions are used on both sender and receiver side)
 
-<B> Bound and Unbound rpc items: </B>
-
-Rpc layer can send an rpc item on network only if it is associated with some
-slot within the session. User can specify the slot on which the item needs to
-be sent. Or the user can just specify session and leave the task of choosing
-any available slot to rpc layer.
-
-With respect to session and slots, an rpc item is said to be "bound" if
-the item is associated with slot. An item is called as "unbound"/"freestanding"
-if it is not associated with any particular slot yet. An unbound item will be
-eventually associated with slot, and hence become bound item.
-
-<b> Reply cache: </b>
-
-Reply cache caches replies of update operations. Reply of read-only
-operation is not cached. When a duplicate update item is received which is
-already executed on receiver, then instead of again processing the item,
-its reply is retrieved from reply cache and returned to the sender.
-By preventing multiple executions of same item (or FOP), reply cache provides
-"exactly once" semantics. If reply cache is persistent, then EOS can be
-guaranteed even in the face of receiver restart. Mero implements Reply
-Cache via FOL (File Operation Log). See section "Slot as a cob" for more
-details on this.
-
-<B> Slot as a "cob": </B>
-Session module implements a slot as a "special file". This allows to reuse
-persistent data structure and code of cob infrastructure.
-
-For each slot, session module will create a cob named $SLOT_ID:$GEN inside
-directory /sessions/$SENDER_ID/$SESSION_ID/.
-Where $SENDER_ID, $SESSION_ID, $SLOT_ID and $GEN are place-holders for actual
-identifier values.
-
-Version number of slot is same as version number of cob that represents
-the slot. Each item also contains a version number. If an item is received,
-whose version number matches with version number of slot, then the item is
-accepted as valid item in the sequence and sent for execution. If item is an
-"update operation" (i.e. it modifies file-system state) then the version
-number of slot is advanced.
-
-FOL (File Operation Log) contains record for each update operation executed.
-The FOL record contains all the information required to undo or redo that
-specific operation. If along with the operation details, reply of operation
-is also stored in the FOL record, the FOL itself acts as a "Reply Cache".
-Given fid of cob that represents the slot and version number of item, it is
-possible to determine whether the item is duplicate or not. If it is duplicate
-item then version number within the item will be less than version number of
-slot. And there will be a record already present in the FOL representing the
-same operation. Then the reply can be extracted from the FOL record and resent
-back to sender.
-
-<B>Ensuring FIFO when slot.max_in_flight > 1 </B>
-
- XXX Current implementation does not have way to define dependencies.
-     Hence no more than 1 items are allowed to be in-flight for a particular
-     slot.
-
- First, let's clarify that xid is used to uniquely identify items sent through
- a particular slot, whereas verno is used to identify the state of target
- objects (including slots) when the operation is applicable.
-
- We want to achieve the following goals:
-
-   - sequence of operations sent through a slot can be exactly reproduced
-     after the receiver or the network failed. "Reproduced" here means that
-     after the operations are re-applied the same observable system state
-     results.
-
-   - Network level concurrency (multiple items in flight).
-
-   - Server level concurrency (multiple operations executed on the receiver
-     concurrently, where possible).
-
-   - Operations might have dependencies.
-
- Let's put the following data into each item:
- @code
- struct m0_rpc_item {
-       struct m0_verno     verno;
-       uint64_t            xid;
-       struct m0_rpc_item *dep;
- };
- @endcode
-
- ->verno and ->xid are used as usual. ->dep identifies an item, sent to
-  the same receiver, which this item "depends on". item can be executed only
-  after item->dep has been executed. If an item does not depend on any other
-  item, then item->dep == NULL.
-
- When an item is submitted to the rpc layer, its ->dep is
-
-   - either set by the caller (the rpc checks that the receiver is the same
-     in a pre-condition);
-
-   - set to NULL to indicate that there are no dependencies;
-
-   - set to a special LAST constant value, to indicate that the item depends
-     on the last item sent through the same slot. In this case, the rpc code
-     assigns ->dep to the appropriate item:
-
-     @code
-       if (item->flags & MUTABO)
-               item->dep = latest item on the slot list;
-       else
-               item->dep = latest MUTABO item on the slot list;
-     @endcode
-
-     For a freestanding item, this assignment is done lately, when the
-     freestanding item is assigned a slot and xid.
-
- item->dep->xid is sent to the receiver along with other item attributes. On
- the receiver, the item is submitted to the request handler only when
-
-   - item->dep item has been received and executed and
-
-   - item->verno matches the slot verno (as usual).
-
- Typical scenarios are as following:
-
-   - update operations are submitted, all with LAST dep, they are sent
-     over the network concurrently (up to slot->max_in_flight) and executed
-     serially by the receiver;
-
-   - an update item I0 is submitted, then a set of read-only items is submitted,
-     all with ->dep set to LAST. Read-only operations are sent concurrently and
-     executed concurrently after I0 has been executed.
-
- Note that LAST can be nicely generalized (we don't need this now): instead of
- distinguishing MUTABO and !MUTABO items, we split items into "commutative"
- groups such that items in a group can be executed in any order.
-
  <B> Using two identifiers for session and conn </B>
  @todo
  currently, receiver assigns identifiers to connections and sessions and
@@ -228,12 +88,8 @@ back to sender.
     @todo
 	- Generate ADDB data points for important session events
 	- store replies in FOL
-	- Support more than one items in flight for a slot
 	- Optimization: Cache misordered items at receiver, rather than
 	  discarding them.
-	- How to get unique stob_id for session and slot cobs?
-	- slot table resize needs to be implemented.
-	- Design protocol to dynamically adjust number of slots.
  */
 
 #include "lib/list.h"
@@ -263,21 +119,14 @@ enum m0_rpc_session_state {
 	 */
 	M0_RPC_SESSION_ESTABLISHING,
 	/**
-	   A session is IDLE if both of following is true
-		- for each slot S in session
-			for each item I in S->item_list
-				// I has got reply
-				I->state is in {PAST_COMMITTED, PAST_VOLATILE}
-		- formation queue has no item associated with this session
 	   A session can be terminated only if it is IDLE.
 	 */
 	M0_RPC_SESSION_IDLE,
 	/**
 	   A session is busy if any of following is true
-		- Any of slots has item to be sent (FUTURE items)
-		- Any of slots has item for which reply is not received
-			(IN_PROGRESS items)
-		- Formation queue has item associated with this session
+		- There is item for which the reply is not received yet
+			(on receive side).
+		- Formation queue has item associated with this session.
 	 */
 	M0_RPC_SESSION_BUSY,
 	/**
@@ -305,7 +154,7 @@ enum m0_rpc_session_state {
    Rpc connection can be shared by multiple entities (e.g. users) by
    creating their own "session" on the connection.
    A session can be used to maintain authentication information or QoS
-   parameters. But currently it is just a container for slots.
+   parameters.
 
    <B> Liveness: </B>
 
@@ -378,8 +227,7 @@ enum m0_rpc_session_state {
 
    // INITIALISE SESSION
 
-   nr_slots = 4;
-   rc = m0_rpc_session_init(session, conn, nr_slots);
+   rc = m0_rpc_session_init(session, conn);
    M0_ASSERT(ergo(rc == 0, session_state(session) ==
                            M0_RPC_SESSION_INITIALISED));
 
@@ -462,14 +310,6 @@ struct m0_rpc_session {
 	 */
 	struct m0_tlink		  s_link;
 
-	/** Number of items that needs to be sent or their reply is
-	    not yet received. i.e. count of items in {FUTURE, IN_PROGRESS}
-	    state in all slots belonging to this session.
-
-	    XXX FIXME The value can't be negative. Change the type to uint32_t.
-	 */
-	int32_t                   s_nr_active_items;
-
 	/** if > 0, then session is in BUSY state */
 	uint32_t                  s_hold_cnt;
 
@@ -483,21 +323,18 @@ struct m0_rpc_session {
 };
 
 /**
-   Initialises all fields of session. Allocates and initialises
-   nr_slots number of slots.
+   Initialises all fields of session.
    No network communication is involved.
 
    @param session session being initialised
    @param conn rpc connection with which this session is associated
-   @param nr_slots number of slots in the session
 
    @post ergo(rc == 0, session_state(session) == M0_RPC_SESSION_INITIALISED &&
 		       session->s_conn == conn &&
 		       session->s_session_id == SESSION_ID_INVALID)
  */
 M0_INTERNAL int m0_rpc_session_init(struct m0_rpc_session *session,
-				    struct m0_rpc_conn *conn,
-				    uint32_t nr_slots);
+				    struct m0_rpc_conn *conn);
 
 /**
     Sends a SESSION_ESTABLISH fop across pre-defined session-0 in
@@ -531,12 +368,10 @@ M0_INTERNAL int m0_rpc_session_establish_sync(struct m0_rpc_session *session,
  * A combination of m0_rpc_session_init() and m0_rpc_session_establish_sync() in
  * a single routine - initialize session object, establish a session and wait
  * until it become idle.
- *
- * @see m0_rpc_session::s_nr_slots
  */
 M0_INTERNAL int m0_rpc_session_create(struct m0_rpc_session *session,
 				      struct m0_rpc_conn *conn,
-				      uint32_t nr_slots, m0_time_t abs_timeout);
+				      m0_time_t abs_timeout);
 
 /**
    Sends terminate session fop to receiver.
diff --git a/rpc/session_foms.c b/rpc/session_foms.c
index d57e407..c4dc83c 100644
--- a/rpc/session_foms.c
+++ b/rpc/session_foms.c
@@ -321,7 +321,7 @@ M0_INTERNAL int m0_rpc_fom_session_establish_tick(struct m0_fom *fom)
 		goto out;
 	}
 	m0_rpc_machine_lock(machine);
-	rc = m0_rpc_session_init_locked(session, conn, 1 /* unused */);
+	rc = m0_rpc_session_init_locked(session, conn);
 	if (rc == 0) {
 		do {
 			session->s_session_id = m0_rpc_id_generate();
diff --git a/rpc/session_internal.h b/rpc/session_internal.h
index 07be753..951e998 100644
--- a/rpc/session_internal.h
+++ b/rpc/session_internal.h
@@ -75,8 +75,7 @@ M0_INTERNAL void session_state_set(struct m0_rpc_session *session, int state);
 M0_INTERNAL int session_state(const struct m0_rpc_session *session);
 
 M0_INTERNAL int m0_rpc_session_init_locked(struct m0_rpc_session *session,
-					   struct m0_rpc_conn *conn,
-					   uint32_t nr_slots);
+					   struct m0_rpc_conn *conn);
 M0_INTERNAL void m0_rpc_session_fini_locked(struct m0_rpc_session *session);
 
 /**
@@ -109,9 +108,6 @@ M0_INTERNAL bool m0_rpc_session_is_idle(const struct m0_rpc_session *session);
 
 M0_INTERNAL void m0_rpc_session_item_failed(struct m0_rpc_item *item);
 
-M0_INTERNAL void m0_rpc_session_mod_nr_active_items(struct m0_rpc_session
-						    *session, int delta);
-
 M0_INTERNAL struct m0_rpc_machine *session_machine(const struct m0_rpc_session
 						   *s);
 
diff --git a/rpc/ub/README b/rpc/ub/README
index f90c0b6..f184e7e 100644
--- a/rpc/ub/README
+++ b/rpc/ub/README
@@ -3,7 +3,6 @@ See benchmark results and analysis: http://goo.gl/mMaSQ
 A set of RPC benchmarks measures data needed for the following plots:
 
   - rate (in messages per second) vs. number of connections;
-  - rate vs. number of slots (concurrency);
   - rate vs. message length (in bytes);
   - processor utilisation vs. number of connections.
 
@@ -17,8 +16,8 @@ of millions.
      num. of connections  |              |
     --------------------->|              |  rate (MPS)
                           |              +--------------->
-     num. of slots        |              |
-    --------------------->|    rpc-ub    |
+                          |              |
+                          |    rpc-ub    |
                           |              |  CPU load (%)
      message length       |              +--------------->
     --------------------->|              |
diff --git a/rpc/ub/plot.sh b/rpc/ub/plot.sh
index ca0213f..e27f84d 100755
--- a/rpc/ub/plot.sh
+++ b/rpc/ub/plot.sh
@@ -12,94 +12,72 @@ rpc-ub() {
 
     {
 	cat <<EOF
->>>>> 'nr_slots=16,msg_len=1024,nr_msgs=100' nr_conns '8 16 32 64 96'
-----------[ nr_conns=8,nr_slots=16,msg_len=1024,nr_msgs=100 ]----------
+>>>>> 'msg_len=1024,nr_msgs=100' nr_conns '8 16 32 64 96'
+----------[ nr_conns=8,msg_len=1024,nr_msgs=100 ]----------
 -- round  1 rpc-ub[.]
 	       bench: [   iter]    min    max    avg   std   sec/op   op/sec
 set: rpc-ub
 	         run: [      1]   1.74   1.74   1.74  0.00% 1.743e+00/5.738e-01
-----------[ nr_conns=16,nr_slots=16,msg_len=1024,nr_msgs=100 ]----------
+----------[ nr_conns=16,msg_len=1024,nr_msgs=100 ]----------
 -- round  1 rpc-ub[.]
 	       bench: [   iter]    min    max    avg   std   sec/op   op/sec
 set: rpc-ub
 	         run: [      1]   1.75   1.75   1.75  0.00% 1.749e+00/5.718e-01
-----------[ nr_conns=32,nr_slots=16,msg_len=1024,nr_msgs=100 ]----------
+----------[ nr_conns=32,msg_len=1024,nr_msgs=100 ]----------
 -- round  1 rpc-ub[.]
 	       bench: [   iter]    min    max    avg   std   sec/op   op/sec
 set: rpc-ub
 	         run: [      1]   2.48   2.48   2.48  0.00% 2.482e+00/4.029e-01
-----------[ nr_conns=64,nr_slots=16,msg_len=1024,nr_msgs=100 ]----------
+----------[ nr_conns=64,msg_len=1024,nr_msgs=100 ]----------
 -- round  1 rpc-ub[.]
 	       bench: [   iter]    min    max    avg   std   sec/op   op/sec
 set: rpc-ub
 	         run: [      1]  13.81  13.81  13.81  0.00% 1.381e+01/7.242e-02
-----------[ nr_conns=96,nr_slots=16,msg_len=1024,nr_msgs=100 ]----------
+----------[ nr_conns=96,msg_len=1024,nr_msgs=100 ]----------
 -- round  1 rpc-ub[.]
 	       bench: [   iter]    min    max    avg   std   sec/op   op/sec
 set: rpc-ub
 	         run: [      1] 260.08 260.08 260.08  0.00% 2.601e+02/3.845e-03
 
->>>>> 'nr_conns=32,msg_len=1024,nr_msgs=400' nr_slots '8 16 32 64'
-----------[ nr_slots=8,nr_conns=32,msg_len=1024,nr_msgs=400 ]----------
--- round  1 rpc-ub[.]
-	       bench: [   iter]    min    max    avg   std   sec/op   op/sec
-set: rpc-ub
-	         run: [      1]  10.86  10.86  10.86  0.00% 1.086e+01/9.210e-02
-----------[ nr_slots=16,nr_conns=32,msg_len=1024,nr_msgs=400 ]----------
--- round  1 rpc-ub[.]
-	       bench: [   iter]    min    max    avg   std   sec/op   op/sec
-set: rpc-ub
-	         run: [      1]   7.97   7.97   7.97  0.00% 7.970e+00/1.255e-01
-----------[ nr_slots=32,nr_conns=32,msg_len=1024,nr_msgs=400 ]----------
--- round  1 rpc-ub[.]
-	       bench: [   iter]    min    max    avg   std   sec/op   op/sec
-set: rpc-ub
-	         run: [      1]   8.14   8.14   8.14  0.00% 8.143e+00/1.228e-01
-----------[ nr_slots=64,nr_conns=32,msg_len=1024,nr_msgs=400 ]----------
--- round  1 rpc-ub[.]
-	       bench: [   iter]    min    max    avg   std   sec/op   op/sec
-set: rpc-ub
-	         run: [      1]  29.58  29.58  29.58  0.00% 2.958e+01/3.381e-02
-
->>>>> 'nr_conns=96,nr_slots=16,nr_msgs=100' msg_len '64 128 256 512'
-----------[ msg_len=64,nr_conns=96,nr_slots=16,nr_msgs=100 ]----------
+>>>>> 'nr_conns=96,nr_msgs=100' msg_len '64 128 256 512'
+----------[ msg_len=64,nr_conns=96,nr_msgs=100 ]----------
 -- round  1 rpc-ub[.]
 	       bench: [   iter]    min    max    avg   std   sec/op   op/sec
 set: rpc-ub
 	         run: [      1]  67.36  67.36  67.36  0.00% 6.736e+01/1.484e-02
-----------[ msg_len=128,nr_conns=96,nr_slots=16,nr_msgs=100 ]----------
+----------[ msg_len=128,nr_conns=96,nr_msgs=100 ]----------
 -- round  1 rpc-ub[.]
 	       bench: [   iter]    min    max    avg   std   sec/op   op/sec
 set: rpc-ub
 	         run: [      1]  47.41  47.41  47.41  0.00% 4.741e+01/2.109e-02
-----------[ msg_len=256,nr_conns=96,nr_slots=16,nr_msgs=100 ]----------
+----------[ msg_len=256,nr_conns=96,nr_msgs=100 ]----------
 -- round  1 rpc-ub[.]
 	       bench: [   iter]    min    max    avg   std   sec/op   op/sec
 set: rpc-ub
 	         run: [      1]  44.83  44.83  44.83  0.00% 4.483e+01/2.230e-02
-----------[ msg_len=512,nr_conns=96,nr_slots=16,nr_msgs=100 ]----------
+----------[ msg_len=512,nr_conns=96,nr_msgs=100 ]----------
 -- round  1 rpc-ub[.]
 	       bench: [   iter]    min    max    avg   std   sec/op   op/sec
 set: rpc-ub
 	         run: [      1]  69.11  69.11  69.11  0.00% 6.911e+01/1.447e-02
 
->>>>> 'nr_conns=32,nr_slots=16,nr_msgs=400' msg_len '256 512 1024 2048'
-----------[ msg_len=256,nr_conns=32,nr_slots=16,nr_msgs=400 ]----------
+>>>>> 'nr_conns=32,nr_msgs=400' msg_len '256 512 1024 2048'
+----------[ msg_len=256,nr_conns=32,nr_msgs=400 ]----------
 -- round  1 rpc-ub[.]
 	       bench: [   iter]    min    max    avg   std   sec/op   op/sec
 set: rpc-ub
 	         run: [      1]   4.77   4.77   4.77  0.00% 4.769e+00/2.097e-01
-----------[ msg_len=512,nr_conns=32,nr_slots=16,nr_msgs=400 ]----------
+----------[ msg_len=512,nr_conns=32,nr_msgs=400 ]----------
 -- round  1 rpc-ub[.]
 	       bench: [   iter]    min    max    avg   std   sec/op   op/sec
 set: rpc-ub
 	         run: [      1]   6.03   6.03   6.03  0.00% 6.031e+00/1.658e-01
-----------[ msg_len=1024,nr_conns=32,nr_slots=16,nr_msgs=400 ]----------
+----------[ msg_len=1024,nr_conns=32,nr_msgs=400 ]----------
 -- round  1 rpc-ub[.]
 	       bench: [   iter]    min    max    avg   std   sec/op   op/sec
 set: rpc-ub
 	         run: [      1]   7.97   7.97   7.97  0.00% 7.970e+00/1.255e-01
-----------[ msg_len=2048,nr_conns=32,nr_slots=16,nr_msgs=400 ]----------
+----------[ msg_len=2048,nr_conns=32,nr_msgs=400 ]----------
 -- round  1 rpc-ub[.]
 	       bench: [   iter]    min    max    avg   std   sec/op   op/sec
 set: rpc-ub
@@ -198,10 +176,9 @@ trap "rm $TMP" 0
 i=0
 {
     cat <<EOF
-nr_slots=16,msg_len=1024,nr_msgs=100 nr_conns 8 16 32 64 96
-nr_conns=32,msg_len=1024,nr_msgs=400 nr_slots 8 16 32 64
-nr_conns=32,nr_slots=16,nr_msgs=400  msg_len  256 512 1024 2048
-nr_conns=96,nr_slots=16,nr_msgs=100  msg_len  64 128 256 512
+msg_len=1024,nr_msgs=100 nr_conns 8 16 32 64 96
+nr_conns=32,nr_msgs=400  msg_len  256 512 1024 2048
+nr_conns=96,nr_msgs=100  msg_len  64 128 256 512
 EOF
 } | while read -a ARGS; do
     CSV=$((++i)).csv
diff --git a/rpc/ub/ub.c b/rpc/ub/ub.c
index 3ea96e0..27091e8 100644
--- a/rpc/ub/ub.c
+++ b/rpc/ub/ub.c
@@ -41,7 +41,6 @@
 /* X(name, defval, max) */
 #define ARGS                     \
 	X(nr_conns,    2, 10000) \
-	X(nr_slots,   15,   100) \
 	X(nr_msgs,  1000,  5000) \
 	X(msg_len,    32,  8192)
 
@@ -202,7 +201,6 @@ static void _client_start(struct ub_rpc_client *client, uint32_t cob_dom_id,
 
 	client->rc_ctx = (struct m0_rpc_client_ctx){
 		.rcx_net_dom               = &client->rc_net_dom,
-		.rcx_nr_slots              = g_args.a_nr_slots,
 		.rcx_local_addr            = m0_strdup(ep),
 		.rcx_remote_addr           = SERVER_ENDPOINT_ADDR,
 		.rcx_max_rpcs_in_flight    = MAX_RPCS_IN_FLIGHT,
diff --git a/rpc/ut/clnt_srv_ctx.c b/rpc/ut/clnt_srv_ctx.c
index 50b8fcc..0f0eb0b 100644
--- a/rpc/ut/clnt_srv_ctx.c
+++ b/rpc/ut/clnt_srv_ctx.c
@@ -35,7 +35,6 @@
 #define SERVER_ENDPOINT       "lnet:" SERVER_ENDPOINT_ADDR
 
 enum {
-	SESSION_SLOTS      = 15,
 	MAX_RPCS_IN_FLIGHT = 1,
 	CONNECT_TIMEOUT    = 5,
 	MAX_RETRIES        = 5,
@@ -49,7 +48,6 @@ static struct m0_rpc_client_ctx cctx = {
 	.rcx_net_dom               = &client_net_dom,
 	.rcx_local_addr            = CLIENT_ENDPOINT_ADDR,
 	.rcx_remote_addr           = SERVER_ENDPOINT_ADDR,
-	.rcx_nr_slots              = SESSION_SLOTS,
 	.rcx_max_rpcs_in_flight    = MAX_RPCS_IN_FLIGHT,
 	.rcx_recv_queue_min_length = M0_NET_TM_RECV_QUEUE_DEF_LEN,
 };
diff --git a/rpc/ut/rcv_session.c b/rpc/ut/rcv_session.c
index dc2fb12..d6ae645 100644
--- a/rpc/ut/rcv_session.c
+++ b/rpc/ut/rcv_session.c
@@ -34,7 +34,6 @@ static struct m0_rpc_machine *machine;
 static const char            *remote_addr;
 enum {
 	TIMEOUT  = 4 /* second */,
-	NR_SLOTS = 5,
 };
 
 static int ts_rcv_session_init(void)   /* ts_ for "test suite" */
@@ -124,7 +123,6 @@ static void test_session_establish(void)
 	struct m0_net_end_point *ep;
 	struct m0_rpc_session    session;
 	struct m0_rpc_conn       conn;
-	int                      count;
 	int                      rc;
 	int                      i;
 	struct fp fps[] = {
@@ -140,7 +138,7 @@ static void test_session_establish(void)
 	rc = m0_rpc_conn_create(&conn, ep, machine, MAX_RPCS_IN_FLIGHT,
 				m0_time_from_now(TIMEOUT, 0));
 	M0_UT_ASSERT(rc == 0);
-	rc = m0_rpc_session_create(&session, &conn, NR_SLOTS,
+	rc = m0_rpc_session_create(&session, &conn,
 				   m0_time_from_now(TIMEOUT, 0));
 	M0_UT_ASSERT(rc == 0);
 	rc = m0_rpc_session_destroy(&session, m0_time_from_now(TIMEOUT, 0));
@@ -148,23 +146,12 @@ static void test_session_establish(void)
 
 	for (i = 0; i < ARRAY_SIZE(fps); ++i) {
 		m0_fi_enable(fps[i].fn, fps[i].pt);
-		rc = m0_rpc_session_create(&session, &conn, NR_SLOTS,
+		rc = m0_rpc_session_create(&session, &conn,
 					   m0_time_from_now(TIMEOUT, 0));
 		M0_UT_ASSERT(rc == fps[i].erc);
 		m0_fi_disable(fps[i].fn, fps[i].pt);
 	}
 
-	count = 0;
-	m0_fi_enable_func("slot_table_alloc_and_init", "failed",
-			  enable_for_all_but_first_call, &count);
-	rc = m0_rpc_session_create(&session, &conn, NR_SLOTS,
-				   m0_time_from_now(TIMEOUT, 0));
-	M0_UT_ASSERT(rc == -ENOMEM);
-	m0_fi_disable("slot_table_alloc_and_init", "failed");
-
-	rc = m0_rpc_conn_destroy(&conn, m0_time_from_now(TIMEOUT, 0));
-	M0_UT_ASSERT(rc == 0);
-
 	m0_net_end_point_put(ep);
 }
 
@@ -186,7 +173,7 @@ static void test_session_terminate(void)
 	rc = m0_rpc_conn_create(&conn, ep, machine, MAX_RPCS_IN_FLIGHT,
 				m0_time_from_now(TIMEOUT, 0));
 	for (i = 0; i < ARRAY_SIZE(fps); ++i) {
-		rc = m0_rpc_session_create(&session, &conn, NR_SLOTS,
+		rc = m0_rpc_session_create(&session, &conn,
 					   m0_time_from_now(TIMEOUT, 0));
 		M0_UT_ASSERT(rc == 0);
 
diff --git a/rpc/ut/session.c b/rpc/ut/session.c
index 4ba9da4..5d972ac 100644
--- a/rpc/ut/session.c
+++ b/rpc/ut/session.c
@@ -27,7 +27,6 @@
 enum {
 	SENDER_ID  = 1001,
 	SESSION_ID = 101,
-	SLOTS_NR   = 1,
 };
 
 static struct m0_rpc_machine machine;
@@ -67,7 +66,7 @@ static int session_ut_init(void)
 	rmach_watch_tlist_init(&machine.rm_watch);
 
 	m0_sm_group_init(&machine.rm_sm_grp);
-	rc = m0_rpc_session_init(&session0, &conn, SLOTS_NR);
+	rc = m0_rpc_session_init(&session0, &conn);
 	M0_ASSERT(rc == 0);
 	session0.s_session_id = SESSION_ID_0;
 
@@ -100,7 +99,7 @@ static void session_init(void)
 {
 	int rc;
 
-	rc = m0_rpc_session_init(&session, &conn, SLOTS_NR);
+	rc = m0_rpc_session_init(&session, &conn);
 	M0_UT_ASSERT(rc == 0);
 	M0_UT_ASSERT(session_state(&session) == M0_RPC_SESSION_INITIALISED);
 }
@@ -223,11 +222,11 @@ static void session_init_fail_test(void)
 	int rc;
 	/* Checks for m0_rpc_session_init() failure due to allocation failure */
 	m0_fi_enable_once("m0_alloc", "fail_allocation");
-	rc = m0_rpc_session_init(&session, &conn, SLOTS_NR);
+	rc = m0_rpc_session_init(&session, &conn);
 	M0_UT_ASSERT(rc == -ENOMEM);
 
 	m0_fi_enable_off_n_on_m("m0_alloc", "fail_allocation", 1, 1);
-	rc = m0_rpc_session_init(&session, &conn, SLOTS_NR);
+	rc = m0_rpc_session_init(&session, &conn);
 	M0_UT_ASSERT(rc == -ENOMEM);
 	m0_fi_disable("m0_alloc", "fail_allocation");
 }
diff --git a/sns/cm/repair/ut/net.c b/sns/cm/repair/ut/net.c
index 2c243cc..c840f92 100644
--- a/sns/cm/repair/ut/net.c
+++ b/sns/cm/repair/ut/net.c
@@ -66,7 +66,6 @@ static struct m0_net_buffer_pool  r_nbp;
 /* Sender side. */
 enum {
         CLIENT_COB_DOM_ID  = 44,
-        SESSION_SLOTS      = 2,
         MAX_RPCS_IN_FLIGHT = 5,
         STOB_UPDATE_DELAY  = 1,
         MAX_RETRIES        = 5,
@@ -94,7 +93,6 @@ static struct m0_rpc_client_ctx cctx = {
         .rcx_net_dom            = &client_net_dom,
         .rcx_local_addr         = client_addr,
         .rcx_remote_addr        = server_addr,
-        .rcx_nr_slots           = SESSION_SLOTS,
         .rcx_max_rpcs_in_flight = MAX_RPCS_IN_FLIGHT,
 };
 
@@ -710,8 +708,7 @@ static void sender_init()
 				   &sender_cm_proxy.px_session,
                                    &cctx.rcx_rpc_machine,
                                    cctx.rcx_remote_addr,
-                                   cctx.rcx_max_rpcs_in_flight,
-                                   cctx.rcx_nr_slots);
+                                   cctx.rcx_max_rpcs_in_flight);
 	M0_UT_ASSERT(rc == 0);
 	cp_cm_proxy_init(&sender_cm_proxy,
 		sender_cm_proxy.px_conn.c_rpcchan->rc_destep->nep_addr);
diff --git a/sns/cm/st/repair_cli.c b/sns/cm/st/repair_cli.c
index ff7d526..1db1f2a 100644
--- a/sns/cm/st/repair_cli.c
+++ b/sns/cm/st/repair_cli.c
@@ -52,7 +52,6 @@ M0_INTERNAL void repair_client_init(void)
 	cl_ctx.rcx_net_dom            = &cl_ndom;
 	cl_ctx.rcx_local_addr         = cl_ep_addr;
 	cl_ctx.rcx_remote_addr        = srv_ep_addr[0];
-	cl_ctx.rcx_nr_slots           = MAX_RPC_SLOTS_NR;
 	cl_ctx.rcx_max_rpcs_in_flight = MAX_RPCS_IN_FLIGHT;
 
 	rc = m0_rpc_client_start(&cl_ctx);
@@ -74,8 +73,7 @@ M0_INTERNAL int repair_rpc_ctx_init(struct rpc_ctx *ctx, const char *sep)
 	return m0_rpc_client_connect(&ctx->ctx_conn,
 				     &ctx->ctx_session,
 				     &cl_ctx.rcx_rpc_machine, sep,
-				     MAX_RPCS_IN_FLIGHT,
-				     MAX_RPC_SLOTS_NR);
+				     MAX_RPCS_IN_FLIGHT);
 }
 
 M0_INTERNAL void repair_rpc_ctx_fini(struct rpc_ctx *ctx)
diff --git a/sns/cm/st/repair_cli.h b/sns/cm/st/repair_cli.h
index 05de06b..4086cb5 100644
--- a/sns/cm/st/repair_cli.h
+++ b/sns/cm/st/repair_cli.h
@@ -27,7 +27,6 @@
 
 enum {
 	MAX_RPCS_IN_FLIGHT = 10,
-	MAX_RPC_SLOTS_NR   = 10,
 	MAX_FILES_NR       = 10,
 	MAX_SERVERS        = 1024
 };
diff --git a/stats/util/stats_util.c b/stats/util/stats_util.c
index 1d3d6a3..6181706 100644
--- a/stats/util/stats_util.c
+++ b/stats/util/stats_util.c
@@ -42,7 +42,6 @@
 #include "lib/user_space/getopts.h"
 
 enum {
-	STATS_SESSION_SLOTS = 2,
 	STATS_MAX_COUNT     = 3,
 	STATS_MAX_NAME_SIZE = 32,
 	STATS_DEFAULT_COUNT = 1,
@@ -57,7 +56,6 @@ static bool signaled = false;
 static struct m0_rpc_client_ctx cctx = {
 	.rcx_net_dom               = &client_net_dom,
 	.rcx_max_rpcs_in_flight    = 1,
-	.rcx_nr_slots              = STATS_SESSION_SLOTS,
 	.rcx_max_rpc_msg_size      = M0_RPC_DEF_MAX_RPC_MSG_SIZE,
 	.rcx_recv_queue_min_length = M0_NET_TM_RECV_QUEUE_DEF_LEN,
 };
-- 
1.8.3.2

