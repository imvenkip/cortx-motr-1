From b7df00b9797e7f62920856529178dae1adeadd83 Mon Sep 17 00:00:00 2001
From: Amit Jambure <Amit_Jambure@xyratex.com>
Date: Fri, 24 May 2013 14:33:17 +0530
Subject: [PATCH 10/60] rpc: Deleting m0_rpc_slot. Not complete yet.

---
 rpc/conn.c                |  23 +-
 rpc/conn_internal.h       |   5 -
 rpc/formation2_internal.h |  10 -
 rpc/frmops.c              |  40 +-
 rpc/item.h                |  54 +--
 rpc/item_internal.h       |  33 +-
 rpc/packet.c              |  16 +-
 rpc/rpc.c                 |  34 +-
 rpc/rpc.h                 |  14 -
 rpc/rpc_addb.h            |   1 -
 rpc/rpc_helpers.h         |  15 +-
 rpc/rpc_internal.h        |   7 -
 rpc/rpc_onwire.h          |  62 +--
 rpc/session.h             |  32 --
 rpc/session_fops.c        |  26 +-
 rpc/session_fops.h        |   5 -
 rpc/session_internal.h    |  35 --
 rpc/session_utils.c       |   9 +-
 rpc/slot.c                | 987 ----------------------------------------------
 19 files changed, 38 insertions(+), 1370 deletions(-)

diff --git a/rpc/conn.c b/rpc/conn.c
index f949469..3318207 100644
--- a/rpc/conn.c
+++ b/rpc/conn.c
@@ -309,7 +309,6 @@ static int __conn_init(struct m0_rpc_conn      *conn,
 
 static int session_zero_attach(struct m0_rpc_conn *conn)
 {
-	struct m0_rpc_slot    *slot;
 	struct m0_rpc_session *session;
 	int                    rc;
 	int                    i;
@@ -330,20 +329,11 @@ static int session_zero_attach(struct m0_rpc_conn *conn)
 	}
 
 	session->s_session_id = SESSION_ID_0;
-
 	/* It is done as there is no need to establish session0 explicitly
 	 * and direct transition from INITIALISED => IDLE is not allowed.
 	 */
-	session_state_set(session, M0_RPC_SESSION_ESTABLISHING);
 	session_state_set(session, M0_RPC_SESSION_IDLE);
 
-	for (i = 0; i < session->s_nr_slots; ++i) {
-		slot = session->s_slot_table[i];
-		M0_ASSERT(slot != NULL &&
-			  slot->sl_ops != NULL &&
-			  slot->sl_ops->so_slot_idle != NULL);
-		slot->sl_ops->so_slot_idle(slot);
-	}
 	M0_ASSERT(m0_rpc_session_invariant(session));
 	M0_RETURN(0);
 }
@@ -452,8 +442,6 @@ static void session_zero_detach(struct m0_rpc_conn *conn)
 	session = m0_rpc_conn_session0(conn);
 	M0_ASSERT(session_state(session) == M0_RPC_SESSION_IDLE);
 
-	session_state_set(session, M0_RPC_SESSION_TERMINATING);
-	m0_rpc_session_del_slots_from_ready_list(session);
 	session_state_set(session, M0_RPC_SESSION_TERMINATED);
 	m0_rpc_session_fini_locked(session);
 	m0_free(session);
@@ -642,13 +630,9 @@ M0_EXPORTED(m0_rpc_conn_establish);
  */
 static void conn_failed(struct m0_rpc_conn *conn, int32_t error)
 {
-	struct m0_rpc_session *session0;
-
 	M0_ENTRY("conn: %p, error: %d", conn, error);
-	m0_sm_fail(&conn->c_sm, M0_RPC_CONN_FAILED, error);
 
-	session0 = m0_rpc_conn_session0(conn);
-	m0_rpc_session_del_slots_from_ready_list(session0);
+	m0_sm_fail(&conn->c_sm, M0_RPC_CONN_FAILED, error);
 
 	M0_ASSERT(m0_rpc_conn_invariant(conn));
 	M0_LEAVE();
@@ -927,11 +911,6 @@ M0_INTERNAL bool m0_rpc_item_is_conn_establish(const struct m0_rpc_item *item)
 	return item->ri_type->rit_opcode == M0_RPC_CONN_ESTABLISH_OPCODE;
 }
 
-M0_INTERNAL bool m0_rpc_item_is_conn_terminate(const struct m0_rpc_item *item)
-{
-	return item->ri_type->rit_opcode == M0_RPC_CONN_TERMINATE_OPCODE;
-}
-
 /**
    Just for debugging purpose. Useful in gdb.
 
diff --git a/rpc/conn_internal.h b/rpc/conn_internal.h
index f032b17..8467eb9 100644
--- a/rpc/conn_internal.h
+++ b/rpc/conn_internal.h
@@ -130,11 +130,6 @@ M0_INTERNAL void m0_rpc_conn_terminate_reply_received(struct m0_rpc_item *req);
 M0_INTERNAL bool m0_rpc_item_is_conn_establish(const struct m0_rpc_item *item);
 
 /**
-   Returns true iff given rpc item is conn_terminate.
- */
-M0_INTERNAL bool m0_rpc_item_is_conn_terminate(const struct m0_rpc_item *item);
-
-/**
    @see m0_rpc_fop_conn_establish_ctx for more information.
  */
 M0_INTERNAL void m0_rpc_fop_conn_establish_ctx_init(struct m0_rpc_item *item,
diff --git a/rpc/formation2_internal.h b/rpc/formation2_internal.h
index 45b9c36..6af0db0 100644
--- a/rpc/formation2_internal.h
+++ b/rpc/formation2_internal.h
@@ -262,16 +262,6 @@ struct m0_rpc_frm_ops {
 		   m0_rpc_packet instance pointed by p is freed.
 	 */
 	bool (*fo_packet_ready)(struct m0_rpc_packet *p);
-
-	/**
-	   Bind a slot to the item.
-
-	   @pre m0_rpc_item_is_unbound(item) && item->ri_session != NULL
-	   @pre m0_rpc_machine_is_locked(item_machine(item))
-	   @post equi(result, m0_rpc_item_is_bound(item))
-	   @post m0_rpc_machine_is_locked(item_machine(item))
-	 */
-	bool (*fo_item_bind)(struct m0_rpc_item *item);
 };
 
 /**
diff --git a/rpc/frmops.c b/rpc/frmops.c
index 9763e75..38c6833 100644
--- a/rpc/frmops.c
+++ b/rpc/frmops.c
@@ -37,7 +37,6 @@
  */
 
 static bool packet_ready(struct m0_rpc_packet *p);
-static bool item_bind(struct m0_rpc_item *item);
 
 static int net_buffer_allocate(struct m0_net_buffer *netbuf,
 			       struct m0_net_domain *ndom,
@@ -59,7 +58,6 @@ static void item_sent(struct m0_rpc_item *item);
  */
 const struct m0_rpc_frm_ops m0_rpc_frm_default_ops = {
 	.fo_packet_ready = packet_ready,
-	.fo_item_bind    = item_bind,
 };
 
 /**
@@ -410,15 +408,6 @@ static void item_done(struct m0_rpc_item *item, unsigned long rc)
 	M0_ENTRY("item: %p rc: %lu", item, rc);
 	M0_PRE(item != NULL);
 
-	if (m0_rpc_item_is_request(item) &&
-	    M0_IN(item->ri_stage, (RPC_ITEM_STAGE_PAST_VOLATILE,
-				   RPC_ITEM_STAGE_PAST_COMMITTED))) {
-		/* cannot fail already completed request, just because
-		   resending it failed.
-		 */
-		M0_ASSERT(item->ri_reply != NULL && item->ri_nr_sent > 0);
-		rc = 0;
-	}
 	if (item->ri_pending_reply != NULL) {
 		/* item that is never sent, i.e. item->ri_nr_sent == 0,
 		   can never have a (pending/any) reply.
@@ -465,22 +454,12 @@ static void item_sent(struct m0_rpc_item *item)
 		 */
 		stats->rs_nr_resent_items++;
 
-	/*
-	 * Request and Reply items take hold on session until
-	 * they are SENT/FAILED.
-	 * See: m0_rpc__post_locked(), m0_rpc_reply_post()
-	 *      m0_rpc_item_send()
-	 */
-	if (m0_rpc_item_is_request(item) || m0_rpc_item_is_reply(item))
-		m0_rpc_session_release(item->ri_session);
-
 	if (m0_rpc_item_is_request(item)) {
 		m0_rpc_item_change_state(item, M0_RPC_ITEM_WAITING_FOR_REPLY);
 		if (item->ri_pending_reply != NULL) {
 			/* Reply has already been received when we
 			   were waiting for buffer callback */
-			m0_rpc_slot_process_reply(item,
-						  item->ri_pending_reply);
+			m0_rpc_process_reply(item, item->ri_pending_reply);
 			item->ri_pending_reply = NULL;
 			M0_ASSERT(item->ri_sm.sm_state == M0_RPC_ITEM_REPLIED);
 		}
@@ -488,23 +467,6 @@ static void item_sent(struct m0_rpc_item *item)
 	M0_LEAVE();
 }
 
-/**
-   @see m0_rpc_frm_ops::fo_item_bind()
- */
-static bool item_bind(struct m0_rpc_item *item)
-{
-	bool result;
-
-	M0_ENTRY("item: %p", item);
-	M0_PRE(item != NULL && m0_rpc_item_is_unbound(item));
-	M0_PRE(item->ri_session != NULL);
-
-	result = m0_rpc_session_bind_item(item);
-
-	M0_LEAVE("result: %s", m0_bool_to_str(result));
-	return result;
-}
-
 #undef M0_TRACE_SUBSYSTEM
 
 /** @} */
diff --git a/rpc/item.h b/rpc/item.h
index d9bf354..db6a0f7 100644
--- a/rpc/item.h
+++ b/rpc/item.h
@@ -39,7 +39,6 @@
  */
 
 /* Imports */
-struct m0_rpc_slot;
 struct m0_rpc_session;
 struct m0_bufvec_cursor;
 struct m0_rpc_frm;
@@ -60,13 +59,6 @@ enum m0_rpc_item_state {
 	M0_RPC_ITEM_UNINITIALISED,
 	M0_RPC_ITEM_INITIALISED,
 	/**
-	 * On sender side when a bound item is posted to RPC, the item
-	 * is kept in slot's item stream. The item remains in this state
-	 * until slot forwards this item to formation.
-	 * @see __slot_balance()
-	 */
-	M0_RPC_ITEM_WAITING_IN_STREAM,
-	/**
 	 * Item is in one of the WAITING_ queues maintained by formation.
 	 * The item is waiting to be selected by formation machine for sending
 	 * on the network.
@@ -111,46 +103,6 @@ enum m0_rpc_item_state {
 	M0_RPC_ITEM_NR_STATES,
 };
 
-/** Stages of item in slot */
-enum m0_rpc_item_stage {
-	/** the reply for the item was received and the receiver confirmed
-	    that the item is persistent */
-	RPC_ITEM_STAGE_PAST_COMMITTED = 1,
-	/** the reply was received, but persistence confirmation wasn't */
-	RPC_ITEM_STAGE_PAST_VOLATILE,
-	/** the item is sent but no reply is received */
-	RPC_ITEM_STAGE_IN_PROGRESS,
-	/** Operation is timedout. Uncertain whether receiver has processed
-	    the request or not. */
-	RPC_ITEM_STAGE_TIMEDOUT,
-	/** Failed to send the item */
-	RPC_ITEM_STAGE_FAILED,
-	/** the item is not sent */
-	RPC_ITEM_STAGE_FUTURE,
-};
-
-enum {
-	/** Maximum number of slots to which an rpc item can be associated */
-	MAX_SLOT_REF    = 1,
-};
-
-/**
-   slot_ref object establishes association between m0_rpc_item and
-   m0_rpc_slot. Upto MAX_SLOT_REF number of m0_rpc_slot_ref objects are
-   embeded with m0_rpc_item.
- */
-struct m0_rpc_slot_ref {
-	/** sr_slot and sr_item identify two ends of association */
-	struct m0_rpc_slot           *sr_slot;
-	struct m0_rpc_item           *sr_item;
-	/** Part of onwire RPC item header */
-	struct m0_rpc_onwire_slot_ref sr_ow;
-	/** Anchor to put item on m0_rpc_slot::sl_item_list
-	    List descriptor: slot_item
-	 */
-	struct m0_tlink               sr_link;
-};
-
 /**
    RPC item direction.
  */
@@ -213,11 +165,7 @@ struct m0_rpc_item {
 	    "pending" until the request item moves to SENT state.
 	 */
 	struct m0_rpc_item              *ri_pending_reply;
-	struct m0_rpc_slot_ref		 ri_slot_refs[MAX_SLOT_REF];
-	/** @deprecated Anchor to put item on
-	    m0_rpc_session::s_unbound_items list
-	 */
-	struct m0_list_link		 ri_unbound_link;
+	struct m0_rpc_item_header        ri_header;
 	/** Item size in bytes. header + payload.
 	    Set during first call to m0_rpc_item_size() on this item.
 	 */
diff --git a/rpc/item_internal.h b/rpc/item_internal.h
index afb1e6d..34ef019 100644
--- a/rpc/item_internal.h
+++ b/rpc/item_internal.h
@@ -40,11 +40,9 @@ M0_INTERNAL int m0_rpc_item_module_init(void);
 */
 M0_INTERNAL void m0_rpc_item_module_fini(void);
 
-M0_INTERNAL bool m0_rpc_item_is_bound(const struct m0_rpc_item *item);
-
-M0_INTERNAL bool m0_rpc_item_is_unbound(const struct m0_rpc_item *item);
-
 M0_INTERNAL bool m0_rpc_item_is_oneway(const struct m0_rpc_item *item);
+M0_INTERNAL bool m0_rpc_item_is_request(const struct m0_rpc_item *item);
+M0_INTERNAL bool m0_rpc_item_is_reply(const struct m0_rpc_item *item);
 
 M0_INTERNAL void m0_rpc_item_sm_init(struct m0_rpc_item *item,
 				     enum m0_rpc_item_dir dir);
@@ -52,7 +50,6 @@ M0_INTERNAL void m0_rpc_item_sm_fini(struct m0_rpc_item *item);
 
 M0_INTERNAL void m0_rpc_item_change_state(struct m0_rpc_item *item,
 					  enum m0_rpc_item_state state);
-
 M0_INTERNAL void m0_rpc_item_failed(struct m0_rpc_item *item, int32_t rc);
 
 M0_INTERNAL int m0_rpc_item_start_timer(struct m0_rpc_item *item);
@@ -60,34 +57,8 @@ M0_INTERNAL void m0_rpc_item_stop_timer(struct m0_rpc_item *item);
 
 M0_INTERNAL void m0_rpc_item_send(struct m0_rpc_item *item);
 
-M0_INTERNAL void m0_rpc_item_set_stage(struct m0_rpc_item *item,
-				       enum m0_rpc_item_stage s);
-
-/**
-   Returns true if item modifies file system state, false otherwise
- */
-M0_INTERNAL bool m0_rpc_item_is_update(const struct m0_rpc_item *item);
-
-/**
-   Returns true if item is request item. False if it is a reply item
- */
-M0_INTERNAL bool m0_rpc_item_is_request(const struct m0_rpc_item *item);
-
-M0_INTERNAL bool m0_rpc_item_is_reply(const struct m0_rpc_item *item);
-
-M0_INTERNAL bool item_is_active(const struct m0_rpc_item *item);
-M0_INTERNAL struct m0_verno *item_verno(struct m0_rpc_item *item, int idx);
-M0_INTERNAL uint64_t item_xid(struct m0_rpc_item *item, int idx);
 M0_INTERNAL const char *item_kind(const struct m0_rpc_item *item);
 M0_INTERNAL const char *item_state_name(const struct m0_rpc_item *item);
 
-M0_TL_DESCR_DECLARE(slot_item, M0_EXTERN);
-M0_TL_DECLARE(slot_item, M0_INTERNAL, struct m0_rpc_item);
-
-/** Helper macro to iterate over every item in a slot */
-#define for_each_item_in_slot(item, slot) \
-	        m0_tl_for(slot_item, &slot->sl_item_list, item)
-#define end_for_each_item_in_slot m0_tl_endfor
-
 /** @} */
 #endif /* __MERO_RPC_ITEM_INT_H__ */
diff --git a/rpc/packet.c b/rpc/packet.c
index 5a73ba8..9b97221 100644
--- a/rpc/packet.c
+++ b/rpc/packet.c
@@ -279,8 +279,8 @@ static int packet_header_decode(struct m0_bufvec_cursor            *cursor,
 static int item_encode(struct m0_rpc_item       *item,
 		       struct m0_bufvec_cursor  *cursor)
 {
-	struct m0_rpc_item_onwire_header ioh;
-	int                              rc;
+	struct m0_rpc_item_header1 ioh;
+	int                        rc;
 
 	M0_ENTRY("item: %p cursor: %p", item, cursor);
 	M0_PRE(item != NULL && cursor != NULL);
@@ -288,12 +288,12 @@ static int item_encode(struct m0_rpc_item       *item,
 	       item->ri_type->rit_ops != NULL &&
 	       item->ri_type->rit_ops->rito_encode != NULL);
 
-	ioh = (struct m0_rpc_item_onwire_header){
+	ioh = (struct m0_rpc_item_header1){
 		.ioh_opcode = item->ri_type->rit_opcode,
 		.ioh_magic  = M0_RPC_ITEM_MAGIC,
 	};
 
-	rc = m0_rpc_item_header_encode(&ioh, cursor);
+	rc = m0_rpc_item_header1_encode(&ioh, cursor);
 	if (rc == 0)
 		rc = item->ri_type->rit_ops->rito_encode(item->ri_type,
 							 item, cursor);
@@ -359,14 +359,14 @@ M0_INTERNAL int m0_rpc_packet_decode_using_cursor(struct m0_rpc_packet *p,
 static int item_decode(struct m0_bufvec_cursor  *cursor,
 		       struct m0_rpc_item      **item_out)
 {
-	struct m0_rpc_item_type         *item_type;
-	struct m0_rpc_item_onwire_header ioh;
-	int                              rc;
+	struct m0_rpc_item_type    *item_type;
+	struct m0_rpc_item_header1  ioh;
+	int                         rc;
 
 	M0_ENTRY();
 	M0_PRE(cursor != NULL && item_out != NULL);
 
-	rc = m0_rpc_item_header_decode(cursor, &ioh);
+	rc = m0_rpc_item_header1_decode(cursor, &ioh);
 	if (rc != 0)
 		M0_RETURN(rc);
 
diff --git a/rpc/rpc.c b/rpc/rpc.c
index 0eeb649..0720ce4 100644
--- a/rpc/rpc.c
+++ b/rpc/rpc.c
@@ -38,8 +38,7 @@
  * @{
  */
 
-M0_INTERNAL int m0_rpc__post_locked(struct m0_rpc_item *item,
-				    struct m0_rpc_slot *slot);
+M0_INTERNAL int m0_rpc__post_locked(struct m0_rpc_item *item);
 
 struct m0_addb_ctx m0_rpc_addb_ctx;
 
@@ -158,12 +157,6 @@ M0_INTERNAL void m0_rpc_fini(void)
 
 M0_INTERNAL int m0_rpc_post(struct m0_rpc_item *item)
 {
-	return m0_rpc_post_slot(item, NULL);
-}
-
-M0_INTERNAL int m0_rpc_post_slot(struct m0_rpc_item *item,
-				 struct m0_rpc_slot *slot)
-{
 	int                    rc;
 	uint64_t               size;
 	struct m0_rpc_machine *machine;
@@ -178,15 +171,14 @@ M0_INTERNAL int m0_rpc_post_slot(struct m0_rpc_item *item,
 	M0_ASSERT(size <= machine->rm_min_recv_size);
 
 	m0_rpc_machine_lock(machine);
-	rc = m0_rpc__post_locked(item, slot);
+	rc = m0_rpc__post_locked(item);
 	m0_rpc_machine_unlock(machine);
 
 	M0_RETURN(rc);
 }
 M0_EXPORTED(m0_rpc_post);
 
-M0_INTERNAL int m0_rpc__post_locked(struct m0_rpc_item *item,
-				    struct m0_rpc_slot *slot)
+M0_INTERNAL int m0_rpc__post_locked(struct m0_rpc_item *item)
 {
 	struct m0_rpc_session  *session;
 
@@ -206,20 +198,15 @@ M0_INTERNAL int m0_rpc__post_locked(struct m0_rpc_item *item,
 	item->ri_rpc_time = m0_time_now();
 	m0_rpc_item_sm_init(item, M0_RPC_ITEM_OUTGOING);
 
-	if (slot == NULL) {
-		item->ri_stage = RPC_ITEM_STAGE_FUTURE;
-		m0_rpc_item_send(item);
-	} else {
-		m0_rpc_slot_item_add(slot, item);
-	}
+	item->ri_stage = RPC_ITEM_STAGE_FUTURE;
+	m0_rpc_item_send(item);
+
 	M0_RETURN(item->ri_error);
 }
 
 int m0_rpc_reply_post(struct m0_rpc_item *request, struct m0_rpc_item *reply)
 {
-	struct m0_rpc_slot_ref *sref;
 	struct m0_rpc_machine  *machine;
-	struct m0_rpc_slot     *slot;
 
 	M0_ENTRY("req_item: %p, rep_item: %p", request, reply);
 	M0_PRE(request != NULL && reply != NULL);
@@ -239,22 +226,13 @@ int m0_rpc_reply_post(struct m0_rpc_item *request, struct m0_rpc_item *reply)
 	reply->ri_rpc_time = m0_time_now();
 	reply->ri_session  = request->ri_session;
 	machine = reply->ri_rmachine = request->ri_rmachine;
-	/* BEWARE: structure instance copy ahead */
-	reply->ri_slot_refs[0] = request->ri_slot_refs[0];
-	sref = &reply->ri_slot_refs[0];
-	/* don't need values of sr_link and sr_ready_link of request item */
-	slot_item_tlink_init(reply);
-
-	sref->sr_item = reply;
 
 	reply->ri_prio     = request->ri_prio;
 	reply->ri_deadline = 0;
 	reply->ri_error    = 0;
 
-	slot = sref->sr_slot;
 	m0_rpc_machine_lock(machine);
 	m0_rpc_item_sm_init(reply, M0_RPC_ITEM_OUTGOING);
-	__slot_reply_received(slot, request, reply);
 	m0_rpc_machine_unlock(machine);
 	M0_RETURN(0);
 }
diff --git a/rpc/rpc.h b/rpc/rpc.h
index 45013de..0e3aa2a 100644
--- a/rpc/rpc.h
+++ b/rpc/rpc.h
@@ -49,18 +49,12 @@ V6NzJfMTljbTZ3anhjbg&hl=en
 #include "rpc/item.h"        /* m0_rpc_item_onwire_header_size */
 #include "rpc/item_source.h"
 
-/* imports */
-struct m0_db_tx;
-
 M0_INTERNAL int m0_rpc_init(void);
 M0_INTERNAL void m0_rpc_fini(void);
 
 /**
   Posts an item to the rpc layer.
 
-  If slot is not NULL then item will be bound to the slot, otherwise RPC
-  will choose any available slot in item->ri_session.
-
   The rpc layer will try to send the item out not later than
   item->ri_deadline and with priority of item->ri_priority.
 
@@ -100,14 +94,6 @@ M0_INTERNAL void m0_rpc_fini(void);
   @pre m0_rpc_item_size(item) <=
           m0_rpc_session_get_max_item_size(item->ri_session)
 */
-M0_INTERNAL int m0_rpc_post_slot(struct m0_rpc_item *item,
-				 struct m0_rpc_slot *slot);
-
-/**
-   @see m0_rpc_post_slot()
-
-   Calls m0_rpc_post_slot() with NULL slot.
- */
 M0_INTERNAL int m0_rpc_post(struct m0_rpc_item *item);
 
 /**
diff --git a/rpc/rpc_addb.h b/rpc/rpc_addb.h
index f3fe800..b8b3391 100644
--- a/rpc/rpc_addb.h
+++ b/rpc/rpc_addb.h
@@ -62,7 +62,6 @@ enum {
 	M0_RPC_ADDB_LOC_BULK_BUF_ADD     = 3030,
 	M0_RPC_ADDB_LOC_BULK_BUF_OP      = 3040,
 	/* rpc_session */
-	M0_RPC_ADDB_LOC_SESSION_SLOT_TABLE_ALLOC_AND_INIT = 4010,
 	M0_RPC_ADDB_LOC_SESSION_ESTABLISH                 = 4020,
 	/* rpc_sesison_fop */
 	M0_RPC_ADDB_LOC_SESSION_FOP_CONN_ESTABLISH_ITEM_DECODE = 5010,
diff --git a/rpc/rpc_helpers.h b/rpc/rpc_helpers.h
index d5f0dfb..a2dc10a 100644
--- a/rpc/rpc_helpers.h
+++ b/rpc/rpc_helpers.h
@@ -25,23 +25,16 @@
 
 #include "lib/vec.h"  /* m0_bufvec_what */
 
-struct m0_rpc_slot_ref;
+struct m0_rpc_item_header;
 
 /**
  * @addtogroup rpc
  * @{
  */
 
-/**
- * Encodes or decodes onwire parts of m0_rpc_slot_refs.
- *
- * For every x in `slot_refs' array, encodes or decodes, depending on
- * `what' argument, x->sr_ow.
- */
-M0_INTERNAL int m0_rpc_slot_refs_encdec(struct m0_bufvec_cursor *cur,
-					struct m0_rpc_slot_ref *slot_refs,
-					int nr_slot_refs,
-					enum m0_bufvec_what what);
+M0_INTERNAL int m0_rpc_item_header_encdec(struct m0_bufvec_cursor   *cur,
+					  struct m0_rpc_item_header *ih,
+					  enum m0_bufvec_what what);
 
 /** @} */
 
diff --git a/rpc/rpc_internal.h b/rpc/rpc_internal.h
index e44b935..a547421 100644
--- a/rpc/rpc_internal.h
+++ b/rpc/rpc_internal.h
@@ -26,7 +26,6 @@
 #include "addb/addb.h"
 #include "rpc/conn_internal.h"
 #include "rpc/session_internal.h"
-#include "rpc/slot_internal.h"
 #include "rpc/item_internal.h"
 #include "rpc/rpc_machine_internal.h"
 #include "rpc/formation2_internal.h"
@@ -79,10 +78,6 @@ M0_INTERNAL void m0_rpc_session_module_fini(void);
 
 /**
    Called for each received item.
-   If item is request then
-	APPLY the item to proper slot
-   else
-	report REPLY_RECEIVED to appropriate slot
  */
 M0_INTERNAL int m0_rpc_item_received(struct m0_rpc_item *item,
 				     struct m0_rpc_machine *machine);
@@ -104,8 +99,6 @@ M0_INTERNAL int m0_rpc__fop_post(struct m0_fop *fop,
  */
 M0_INTERNAL int m0_rpc_item_dispatch(struct m0_rpc_item *item);
 
-M0_INTERNAL bool m0_rpc_item_is_control_msg(const struct m0_rpc_item *item);
-
 M0_INTERNAL void m0_rpc_oneway_item_post_locked(const struct m0_rpc_conn *conn,
 						struct m0_rpc_item *item);
 
diff --git a/rpc/rpc_onwire.h b/rpc/rpc_onwire.h
index 45a5c18..81b8100 100644
--- a/rpc/rpc_onwire.h
+++ b/rpc/rpc_onwire.h
@@ -25,8 +25,6 @@
 
 #include "lib/types.h"        /* uint64_t */
 #include "lib/types_xc.h"     /* m0_uint128_xc */
-#include "dtm/verno.h"        /* m0_verno */
-#include "dtm/verno_xc.h"     /* m0_verno_xc */
 #include "xcode/xcode_attr.h" /* M0_XCA_RECORD */
 
 /**
@@ -38,42 +36,6 @@ enum {
 	M0_RPC_VERSION_1 = 1,
 };
 
-struct m0_rpc_onwire_slot_ref {
-	struct m0_uint128 osr_uuid;
-	uint64_t          osr_sender_id;
-	uint64_t          osr_session_id;
-
-	/** Numeric id of slot. Used when encoding and decoding rpc item to
-	    and from wire-format
-	 */
-	uint32_t          osr_slot_id;
-
-	/** If slot has verno matching sr_verno, then only the item can be
-	    APPLIED to the slot
-	 */
-	struct m0_verno   osr_verno;
-	/**
-	 * @todo These are temporary fields; there is no need to duplicate
-	 * this information with each and every reply. In the future, special
-	 * 1-way item will be used to transfer this information.
-	 */
-	/** In each reply item, receiver reports to sender, verno of item
-	    whose effects have reached persistent storage, using this field
-	 */
-	struct m0_verno   osr_last_persistent_verno;
-
-	/** Inform the sender about current slot version */
-	struct m0_verno   osr_last_seen_verno;
-
-	/** An identifier that uniquely identifies item within
-	    slot->item_list.
-        */
-	uint64_t          osr_xid;
-
-	/** Generation number of slot */
-	uint64_t          osr_slot_gen;
-} M0_XCA_RECORD;
-
 struct m0_rpc_packet_onwire_header {
 	/* Version */
 	uint32_t poh_version;
@@ -84,26 +46,24 @@ struct m0_rpc_packet_onwire_header {
 	uint64_t poh_magic;
 } M0_XCA_RECORD;
 
-struct m0_rpc_item_onwire_header {
+struct m0_rpc_item_header1 {
 	/* Item opcode */
 	uint32_t ioh_opcode;
 
 	uint64_t ioh_magic;
 } M0_XCA_RECORD;
 
-M0_INTERNAL int m0_rpc_item_header_encode(struct m0_rpc_item_onwire_header *ioh,
-					  struct m0_bufvec_cursor *cur);
+struct m0_rpc_item_header2 {
+	struct m0_uint128 osr_uuid;
+	uint64_t          osr_sender_id;
+	uint64_t          osr_session_id;
+	uint64_t          osr_xid;
+} M0_XCA_RECORD;
 
-/**
-    Decodes the rpc item header into a bufvec
-    @param ioh RPC item header to be decoded
-    @param cur Current bufvec cursor position
-    @retval 0 (success)
-    @retval -errno  (failure)
-*/
-M0_INTERNAL int m0_rpc_item_header_decode(struct m0_bufvec_cursor *cur,
-					  struct m0_rpc_item_onwire_header
-					  *ioh);
+M0_INTERNAL int m0_rpc_item_header1_encode(struct m0_rpc_item_header1 *ioh,
+					  struct m0_bufvec_cursor *cur);
+M0_INTERNAL int m0_rpc_item_header1_decode(struct m0_bufvec_cursor *cur,
+					  struct m0_rpc_item_header1 *ioh);
 
 /** @}  End of rpc group */
 
diff --git a/rpc/session.h b/rpc/session.h
index 97a4868..5b5925a 100644
--- a/rpc/session.h
+++ b/rpc/session.h
@@ -244,8 +244,6 @@ back to sender.
 
 /* Imports */
 struct m0_rpc_conn;
-struct m0_cob;
-struct m0_rpc_slot;
 
 /* Exports */
 struct m0_rpc_session;
@@ -472,36 +470,6 @@ struct m0_rpc_session {
 	 */
 	int32_t                   s_nr_active_items;
 
-	/** list of items that can be sent through any available slot.
-	    items are placed using m0_rpc_item::ri_unbound_link
-	    @deprecated XXX
-	 */
-	struct m0_list            s_unbound_items;
-
-	/** Capacity of slot table */
-	uint32_t                  s_slot_table_capacity;
-
-	/**
-	 * Only [0, s_nr_slots) slots from the s_slot_table can be used to bind
-	 * items.  s_nr_slots <= s_slot_table_capacity
-	 *
-	 * Each slot is serial: the next fop is sent only once the reply to the
-	 * previous one has been received.  Hence, ->s_nr_slots should be equal
-	 * to the expected concurrency level.
-	 */
-	uint32_t                  s_nr_slots;
-
-	/** Array of pointers to slots */
-	struct m0_rpc_slot      **s_slot_table;
-
-	/** if > 0, then session is in BUSY state */
-	uint32_t                  s_hold_cnt;
-
-	/** List of slots, which can be associated with an unbound item.
-	    Link: m0_rpc_slot::sl_link
-	 */
-	struct m0_tl              s_ready_slots;
-
 	/** RPC session state machine
 	    @see m0_rpc_session_state, session_conf
 	 */
diff --git a/rpc/session_fops.c b/rpc/session_fops.c
index f3af308..e14b5cb 100644
--- a/rpc/session_fops.c
+++ b/rpc/session_fops.c
@@ -92,9 +92,6 @@ static int conn_establish_item_decode(const struct m0_rpc_item_type *item_type,
 	M0_RETURN(rc);
 }
 
-const struct m0_fop_type_ops m0_rpc_fop_noop_ops = {
-};
-
 static struct m0_rpc_item_type_ops conn_establish_item_type_ops = {
 	M0_FOP_DEFAULT_ITEM_TYPE_OPS,
 	.rito_decode       = conn_establish_item_decode,
@@ -108,7 +105,6 @@ struct m0_fop_type m0_rpc_fop_session_establish_fopt;
 struct m0_fop_type m0_rpc_fop_session_establish_rep_fopt;
 struct m0_fop_type m0_rpc_fop_session_terminate_fopt;
 struct m0_fop_type m0_rpc_fop_session_terminate_rep_fopt;
-struct m0_fop_type m0_rpc_fop_noop_fopt;
 
 static struct m0_fop_type *fop_types[] = {
 	&m0_rpc_fop_conn_establish_fopt,
@@ -119,12 +115,10 @@ static struct m0_fop_type *fop_types[] = {
 	&m0_rpc_fop_conn_terminate_rep_fopt,
 	&m0_rpc_fop_session_establish_rep_fopt,
 	&m0_rpc_fop_session_terminate_rep_fopt,
-	&m0_rpc_fop_noop_fopt,
 };
 
 M0_INTERNAL void m0_rpc_session_fop_fini(void)
 {
-	m0_fop_type_fini(&m0_rpc_fop_noop_fopt);
 	m0_fop_type_fini(&m0_rpc_fop_session_terminate_rep_fopt);
 	m0_fop_type_fini(&m0_rpc_fop_session_establish_rep_fopt);
 	m0_fop_type_fini(&m0_rpc_fop_conn_terminate_rep_fopt);
@@ -143,6 +137,7 @@ extern struct m0_fom_type_ops m0_rpc_fom_session_establish_type_ops;
 extern struct m0_fom_type_ops m0_rpc_fom_conn_terminate_type_ops;
 extern struct m0_fom_type_ops m0_rpc_fom_session_terminate_type_ops;
 extern struct m0_reqh_service_type m0_rpc_service_type;
+
 M0_INTERNAL int m0_rpc_session_fop_init(void)
 {
 	m0_xc_session_fops_init();
@@ -206,13 +201,6 @@ M0_INTERNAL int m0_rpc_session_fop_init(void)
 			 .opcode    = M0_RPC_SESSION_TERMINATE_REP_OPCODE,
 			 .xt        = m0_rpc_fop_session_terminate_rep_xc,
 			 .rpc_flags = M0_RPC_ITEM_TYPE_REPLY,
-			 .svc_type  = &m0_rpc_service_type) ?:
-		M0_FOP_TYPE_INIT(&m0_rpc_fop_noop_fopt,
-			 .name      = "No-op",
-			 .opcode    = M0_RPC_NOOP_OPCODE,
-			 .xt        = m0_rpc_fop_noop_xc,
-			 .rpc_flags = M0_RPC_ITEM_TYPE_REQUEST,
-			 .fop_ops   = &m0_rpc_fop_noop_ops,
 			 .svc_type  = &m0_rpc_service_type);
 }
 
@@ -234,18 +222,6 @@ M0_INTERNAL void m0_rpc_fop_conn_establish_ctx_init(struct m0_rpc_item *item,
 	M0_LEAVE();
 }
 
-M0_INTERNAL bool m0_rpc_item_is_control_msg(const struct m0_rpc_item *item)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(fop_types); i++) {
-		if (item->ri_type->rit_opcode ==
-		    fop_types[i]->ft_rpc_item_type.rit_opcode)
-			return true;
-	}
-	return false;
-}
-
 /** @} End of rpc_session group */
 /*
  *  Local variables:
diff --git a/rpc/session_fops.h b/rpc/session_fops.h
index bf4c47d..3df82bc 100644
--- a/rpc/session_fops.h
+++ b/rpc/session_fops.h
@@ -51,7 +51,6 @@ extern struct m0_fop_type m0_rpc_fop_session_establish_fopt;
 extern struct m0_fop_type m0_rpc_fop_session_establish_rep_fopt;
 extern struct m0_fop_type m0_rpc_fop_session_terminate_fopt;
 extern struct m0_fop_type m0_rpc_fop_session_terminate_rep_fopt;
-extern struct m0_fop_type m0_rpc_fop_noop_fopt;
 
 M0_INTERNAL int m0_rpc_session_fop_init(void);
 
@@ -192,10 +191,6 @@ struct m0_rpc_fop_session_terminate_rep {
 	uint32_t rstr_rc;
 } M0_XCA_RECORD;
 
-struct m0_rpc_fop_noop {
-	uint64_t n_unused;
-} M0_XCA_RECORD;
-
 /* __MERO_RPC_SESSION_FOPS_H__ */
 
 /** @}  End of rpc_session group */
diff --git a/rpc/session_internal.h b/rpc/session_internal.h
index e1b0261..7d8d4b9 100644
--- a/rpc/session_internal.h
+++ b/rpc/session_internal.h
@@ -41,8 +41,6 @@ enum {
 	/** Range of valid session ids */
 	SESSION_ID_MIN           = SESSION_ID_0 + 1,
 	SESSION_ID_MAX           = SESSION_ID_INVALID - 1,
-	SLOT_ID_INVALID          = UINT32_MAX,
-	SESSION_COB_MAX_NAME_LEN = 40,
 };
 
 /**
@@ -50,29 +48,6 @@ enum {
  */
 M0_INTERNAL bool m0_rpc_session_invariant(const struct m0_rpc_session *session);
 
-/**
-   Holds a session in BUSY state.
-   Every call to m0_rpc_session_hold_busy() must accompany
-   call to m0_rpc_session_release()
-
-   @pre M0_IN(session_state(session), (M0_RPC_SESSION_IDLE,
-				       M0_RPC_SESSION_BUSY))
-   @pre m0_rpc_machine_is_locked(session_machine(session))
-   @post session_state(session) == M0_RPC_SESSION_BUSY
- */
-M0_INTERNAL void m0_rpc_session_hold_busy(struct m0_rpc_session *session);
-
-/**
-   Decrements hold count. Moves session to IDLE state if it becomes idle.
-
-   @pre session_state(session) == M0_RPC_SESSION_BUSY
-   @pre session->s_hold_cnt > 0
-   @pre m0_rpc_machine_is_locked(session_machine(session))
-   @post ergo(m0_rpc_session_is_idle(session),
-	      session_state(session) == M0_RPC_SESSION_IDLE)
- */
-M0_INTERNAL void m0_rpc_session_release(struct m0_rpc_session *session);
-
 M0_INTERNAL void session_state_set(struct m0_rpc_session *session, int state);
 M0_INTERNAL int session_state(const struct m0_rpc_session *session);
 
@@ -107,18 +82,8 @@ M0_INTERNAL void m0_rpc_session_establish_reply_received(struct m0_rpc_item
 M0_INTERNAL void m0_rpc_session_terminate_reply_received(struct m0_rpc_item
 							 *req);
 
-/**
-   For all slots belonging to @session,
-     if slot is in m0_rpc_machine::rm_ready_slots list,
-     then remove it from the list.
- */
-M0_INTERNAL void m0_rpc_session_del_slots_from_ready_list(struct m0_rpc_session
-							  *session);
-
 M0_INTERNAL bool m0_rpc_session_is_idle(const struct m0_rpc_session *session);
 
-M0_INTERNAL bool m0_rpc_session_bind_item(struct m0_rpc_item *item);
-
 M0_INTERNAL void m0_rpc_session_item_failed(struct m0_rpc_item *item);
 
 M0_INTERNAL void m0_rpc_session_mod_nr_active_items(struct m0_rpc_session
diff --git a/rpc/session_utils.c b/rpc/session_utils.c
index 5170a03..161abcf 100644
--- a/rpc/session_utils.c
+++ b/rpc/session_utils.c
@@ -53,8 +53,8 @@ M0_INTERNAL void m0_rpc_session_module_fini(void)
         m0_rpc_session_fop_fini();
 }
 
-M0_INTERNAL int m0_rpc__post_locked(struct m0_rpc_item *item,
-				    struct m0_rpc_slot *slot);
+M0_INTERNAL int m0_rpc__post_locked(struct m0_rpc_item *item);
+
 /**
    Initialises rpc item and posts it to rpc-layer
  */
@@ -89,7 +89,7 @@ M0_INTERNAL int m0_rpc__fop_post(struct m0_fop *fop,
 		if (item->ri_nr_sent_max == 0)
 			item->ri_nr_sent_max = 1;
 	}
-	rc = m0_rpc__post_locked(item, NULL);
+	rc = m0_rpc__post_locked(item);
 	M0_RETURN(rc);
 }
 
@@ -108,9 +108,6 @@ M0_INTERNAL uint64_t m0_rpc_id_generate(void)
 	return id;
 }
 
-/**
-  XXX temporary routine that submits the fop inside item for execution.
- */
 M0_INTERNAL int m0_rpc_item_dispatch(struct m0_rpc_item *item)
 {
 	int rc;
diff --git a/rpc/slot.c b/rpc/slot.c
index c7a2bbf..8b13789 100644
--- a/rpc/slot.c
+++ b/rpc/slot.c
@@ -1,988 +1 @@
-/* -*- C -*- */
-/*
- * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
- *
- * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
- * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
- * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
- * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
- * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
- * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
- * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
- *
- * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
- * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
- * http://www.xyratex.com/contact
- *
- * Original author: Rohan Puri <Rohan_Puri@xyratex.com>
- *                  Amit Jambure <Amit_Jambure@xyratex.com>
- * Original creation date: 08/24/2011
- */
 
-#define M0_TRACE_SUBSYSTEM M0_TRACE_SUBSYS_RPC
-#include "lib/trace.h"
-
-#include "lib/errno.h"
-#include "lib/memory.h"
-#include "lib/misc.h"
-#include "lib/bitstring.h"
-#include "lib/finject.h"
-#include "fop/fop.h"
-#include "lib/arith.h"
-#include "db/db.h"
-#include "dtm/verno.h"
-#include "mero/magic.h"
-#include "rpc/rpc_internal.h"
-
-/**
-   @addtogroup rpc_session
-
-   @{
-
-   This file contains implementation of rpc slots.
-
- */
-
-M0_INTERNAL void frm_item_reply_received(struct m0_rpc_item *reply_item,
-					 struct m0_rpc_item *req_item);
-M0_INTERNAL void m0_rpc_item_set_stage(struct m0_rpc_item *item,
-				       enum m0_rpc_item_stage stage);
-M0_INTERNAL int m0_rpc_slot_item_received(struct m0_rpc_item *item);
-
-static void duplicate_item_received(struct m0_rpc_slot *slot,
-				    struct m0_rpc_item *item);
-static void misordered_item_received(struct m0_rpc_slot *slot,
-				     struct m0_rpc_item *item);
-
-M0_TL_DESCR_DEFINE(slot_item, "slot-ref-item-list", M0_INTERNAL,
-		   struct m0_rpc_item, ri_slot_refs[0].sr_link, ri_magic,
-		   M0_RPC_ITEM_MAGIC, M0_RPC_SLOT_REF_HEAD_MAGIC);
-M0_TL_DEFINE(slot_item, M0_INTERNAL, struct m0_rpc_item);
-
-static struct m0_rpc_machine *
-slot_get_rpc_machine(const struct m0_rpc_slot *slot)
-{
-	return slot->sl_session->s_conn->c_rpc_machine;
-}
-
-M0_INTERNAL bool m0_rpc_slot_invariant(const struct m0_rpc_slot *slot)
-{
-	struct m0_rpc_item *item1 = NULL;  /* init to NULL, required */
-	struct m0_rpc_item *item2;
-	struct m0_verno    *v1;
-	struct m0_verno    *v2;
-	bool                ok;
-
-	ok = _0C(slot != NULL) &&
-	     _0C(slot->sl_in_flight <= slot->sl_max_in_flight) &&
-	     M0_CHECK_EX(m0_tlist_invariant(&slot_item_tl,
-					    &slot->sl_item_list));
-	if (!ok)
-		return false;
-
-	/*
-	 * Traverse slot->sl_item_list using item2 ptr
-	 * item1 will be previous item of item2 i.e.
-	 * next(item1) == item2
-	 */
-	for_each_item_in_slot(item2, slot) {
-
-		if (item1 == NULL) {
-			/*
-			 * First element is dummy item. So no need to check.
-			 */
-			item1 = item2;
-			continue;
-		}
-		ok = _0C(ergo(M0_IN(item2->ri_stage,
-				(RPC_ITEM_STAGE_PAST_VOLATILE,
-				 RPC_ITEM_STAGE_PAST_COMMITTED)),
-			  item2->ri_reply != NULL));
-		if (!ok)
-			return false;
-
-		ok = _0C(item1->ri_stage <= item2->ri_stage);
-		if (!ok)
-			return false;
-
-		v1 = item_verno(item1, 0);
-		v2 = item_verno(item2, 0);
-
-		/*
-		 * AFTER an "update" item is applied on a slot
-		 * the version number of slot is advanced
-		 */
-		ok = m0_rpc_item_is_update(item1) ?
-			_0C(v1->vn_vc + 1 == v2->vn_vc) :
-			_0C(v1->vn_vc == v2->vn_vc);
-		if (!ok)
-			return false;
-
-		ok = _0C(item_xid(item1, 0) + 1 == item_xid(item2, 0));
-		if (!ok)
-			return false;
-
-		item1 = item2;
-	} end_for_each_item_in_slot;
-	return true;
-}
-
-M0_INTERNAL int m0_rpc_slot_init(struct m0_rpc_slot *slot,
-				 const struct m0_rpc_slot_ops *ops)
-{
-	struct m0_fop          *fop;
-	struct m0_rpc_item     *dummy_item;
-	struct m0_rpc_slot_ref *sref;
-
-	M0_ENTRY("slot: %p", slot);
-
-	/*
-	 * Allocate dummy item.
-	 * The dummy item is used to avoid special cases
-	 * i.e. last_sent == NULL, last_persistent == NULL
-	 */
-	fop = m0_fop_alloc(&m0_rpc_fop_noop_fopt, NULL);
-	if (fop == NULL)
-		M0_RETURN(-ENOMEM);
-
-	/*
-	 * Add a dummy item with very low verno in item_list
-	 */
-	dummy_item = &fop->f_item;
-	dummy_item->ri_stage     = RPC_ITEM_STAGE_PAST_COMMITTED;
-	/* set ri_reply to some value. Doesn't matter what */
-	dummy_item->ri_reply     = dummy_item;
-
-	/*
-	 * XXX temporary value for lsn. This will be set to some proper value
-	 * when sessions will be integrated with FOL
-	 */
-	*slot = (struct m0_rpc_slot){
-		.sl_verno = {
-			.vn_lsn = M0_LSN_RESERVED_NR + 2,
-			.vn_vc  = 0,
-		},
-		.sl_slot_gen        = 0,
-		.sl_xid             = 1, /* xid 0 will be taken by dummy item */
-		.sl_in_flight       = 0,
-		.sl_max_in_flight   = SLOT_DEFAULT_MAX_IN_FLIGHT,
-		.sl_ops             = ops,
-		.sl_last_sent       = dummy_item,
-		.sl_last_persistent = dummy_item,
-	};
-
-	ready_slot_tlink_init(slot);
-	slot_item_tlist_init(&slot->sl_item_list);
-
-	sref = &dummy_item->ri_slot_refs[0];
-	*sref = (struct m0_rpc_slot_ref){
-		.sr_slot = slot,
-		.sr_item = dummy_item,
-		.sr_ow   = {
-			.osr_xid      = 0,
-			/*
-			 * XXX lsn will be assigned to some proper value once
-			 * sessions code will be integrated with FOL
-			 */
-			.osr_verno    = {
-				.vn_lsn = M0_LSN_DUMMY_ITEM,
-				.vn_vc  = 0,
-			},
-			.osr_slot_gen = slot->sl_slot_gen,
-		},
-	};
-
-	slot_item_tlink_init_at(dummy_item, &slot->sl_item_list);
-	M0_RETURN(0);
-}
-
-/**
-  Frees all the items from slot->sl_item_list except dummy_item.
-
-  XXX This is temporary. This routine will be scraped entirely.
-  When slots will be integrated with FOL, there will be some pruning mechanism
-  that will evict items from slot's item_list. But for now, we need to be able
-  to fini() slot for testing purpose. That's why freeing the items explicitly.
- */
-static void slot_item_list_prune(struct m0_rpc_slot *slot)
-{
-	struct m0_rpc_item  *item;
-	struct m0_rpc_item  *reply;
-	struct m0_rpc_item  *dummy_item;
-	int                  count = 0;
-	bool                 first_item = true;
-
-	M0_ENTRY("slot: %p", slot);
-	/*
-	 * XXX See comments above function prototype
-	 */
-	M0_ASSERT(slot != NULL);
-
-	for_each_item_in_slot(item, slot) {
-
-		if (first_item) {
-			/*
-			 * Don't delete dummy item
-			 */
-			first_item = false;
-			continue;
-		}
-		reply = item->ri_reply;
-		if (reply != NULL)
-			m0_rpc_item_put(reply);
-		item->ri_reply = NULL;
-		slot_item_tlist_del(item);
-		m0_rpc_item_put(item);
-		count++;
-	} end_for_each_item_in_slot;
-        M0_ASSERT(slot_item_tlist_length(&slot->sl_item_list) == 1);
-
-        dummy_item = slot_item_tlist_head(&slot->sl_item_list);
-        M0_ASSERT(slot_item_tlink_is_in(dummy_item));
-
-	slot->sl_last_sent = dummy_item;
-	slot->sl_last_persistent = dummy_item;
-	M0_LEAVE();
-}
-
-M0_INTERNAL void m0_rpc_slot_fini(struct m0_rpc_slot *slot)
-{
-	struct m0_rpc_item  *dummy_item;
-	struct m0_fop       *fop;
-
-	M0_ENTRY("slot: %p", slot);
-
-	slot_item_list_prune(slot);
-	ready_slot_tlink_fini(slot);
-
-	/*
-	 * Remove the dummy item from the list
-	 */
-        M0_ASSERT(slot_item_tlist_length(&slot->sl_item_list) == 1);
-
-        dummy_item = slot_item_tlist_head(&slot->sl_item_list);
-        M0_ASSERT(slot_item_tlink_is_in(dummy_item));
-
-	slot_item_tlist_del(dummy_item);
-	M0_ASSERT(item_xid(dummy_item, 0) == 0);
-
-	fop = m0_rpc_item_to_fop(dummy_item);
-	m0_fop_put(fop);
-
-	slot_item_tlist_fini(&slot->sl_item_list);
-	M0_SET0(slot);
-	M0_LEAVE();
-}
-
-/**
-   Searches slot->sl_item_list to find item with matching @xid.
-   @return item if found, NULL otherwise.
- */
-static struct m0_rpc_item* item_find(const struct m0_rpc_slot *slot,
-				     uint64_t                  xid)
-{
-	struct m0_rpc_item *item;
-
-	M0_PRE(slot != NULL);
-	for_each_item_in_slot(item, slot) {
-
-		if (item_xid(item, 0) == xid)
-			return item;
-	} end_for_each_item_in_slot;
-	return NULL;
-}
-
-M0_INTERNAL uint32_t m0_rpc_slot_items_possible_inflight(struct m0_rpc_slot
-							 *slot)
-{
-	M0_PRE(slot != NULL);
-
-	return slot->sl_max_in_flight - slot->sl_in_flight;
-}
-
-/**
-   If slot->sl_item_list has item(s) in state FUTURE then
-	call slot->sl_ops->so_item_consume() for upto slot->sl_max_in_flight
-	  number of (FUTURE)items. (On sender, each "consumed" item will be
-	  given to formation for transmission. On receiver, "consumed" item is
-	  "dispatched" to request handler for execution)
-   else
-	Notify that the slot is idle (i.e. call slot->sl_ops->so_slot_idle()
-
-   if allow_events is false then items are not consumed.
-   This is required when formation wants to add item to slot->sl_item_list
-   but do not want item to be consumed.
- */
-static void __slot_balance(struct m0_rpc_slot *slot,
-			   bool                allow_events)
-{
-	struct m0_rpc_item *item;
-	int                 rc;
-
-	M0_ENTRY("slot: %p", slot);
-	M0_PRE(m0_rpc_slot_invariant(slot));
-	M0_PRE(m0_rpc_machine_is_locked(slot_get_rpc_machine(slot)));
-
-	while (slot->sl_in_flight < slot->sl_max_in_flight) {
-		item = slot_item_tlist_next(&slot->sl_item_list,
-					    slot->sl_last_sent);
-		if (item == NULL) {
-			if (allow_events)
-				slot->sl_ops->so_slot_idle(slot);
-			break;
-		} else {
-			if (allow_events)
-				slot->sl_ops->so_slot_busy(slot);
-		}
-
-		if (item->ri_stage == RPC_ITEM_STAGE_FUTURE)
-			m0_rpc_item_set_stage(item, RPC_ITEM_STAGE_IN_PROGRESS);
-
-		if (item->ri_reply != NULL && !m0_rpc_item_is_update(item)) {
-			/*
-			 * Don't send read only queries for which answer is
-			 * already known
-			 */
-			continue;
-		}
-		slot->sl_last_sent = item;
-		slot->sl_in_flight++;
-		/*
-		 * Tell formation module that an item is ready to be put in rpc
-		 */
-		if (allow_events) {
-			rc = slot->sl_ops->so_item_consume(item);
-			if (rc != 0)
-				m0_rpc_item_failed(item, rc);
-		}
-	}
-	M0_POST(m0_rpc_slot_invariant(slot));
-	M0_LEAVE();
-}
-
-/**
-   For more information see __slot_balance()
-   @see __slot_balance()
- */
-static void slot_balance(struct m0_rpc_slot *slot)
-{
-	__slot_balance(slot, true);
-}
-
-/**
-   @see m0_rpc_slot_item_add_internal()
- */
-static void __slot_item_add(struct m0_rpc_slot *slot,
-			    struct m0_rpc_item *item)
-{
-	struct m0_rpc_session  *session;
-	struct m0_rpc_machine  *machine;
-
-	M0_ENTRY("slot: %p, item: %p", slot, item);
-	M0_PRE(item != NULL);
-	M0_PRE(m0_rpc_slot_invariant(slot));
-	M0_PRE(m0_rpc_item_is_request(item));
-	M0_PRE(slot->sl_session == item->ri_session);
-	M0_PRE(slot->sl_session != NULL);
-
-	session = slot->sl_session;
-	machine = session_machine(session);
-	M0_PRE(m0_rpc_machine_is_locked(machine));
-
-	item->ri_slot_refs[0] = (struct m0_rpc_slot_ref){
-		.sr_ow = {
-			.osr_session_id = session->s_session_id,
-			.osr_sender_id  = session->s_conn->c_sender_id,
-			.osr_uuid       = session->s_conn->c_uuid,
-			/*
-			 * m0_rpc_slot_item_apply() will provide an item
-			 * which already has verno initialised. Yet, following
-			 * assignment should not be any problem because
-			 * slot_item_apply() will call this routine only if
-			 * verno of slot and item matches
-			 */
-			.osr_slot_id    = slot->sl_slot_id,
-			.osr_verno      = slot->sl_verno,
-			.osr_xid        = slot->sl_xid,
-			.osr_slot_gen   = slot->sl_slot_gen,
-		},
-		.sr_slot = slot,
-		.sr_item = item,
-	};
-
-	slot->sl_xid++;
-	if (m0_rpc_item_is_update(item)) {
-		/*
-		 * When integrated with lsn,
-		 * use m0_fol_lsn_allocate() to allocate new lsn and
-		 * use m0_verno_inc() to advance vn_vc.
-		 */
-		slot->sl_verno.vn_lsn++;
-		slot->sl_verno.vn_vc++;
-	}
-
-	m0_rpc_item_get(item);
-	slot_item_tlink_init_at_tail(item, &slot->sl_item_list);
-	item->ri_stage = RPC_ITEM_STAGE_FUTURE;
-	m0_rpc_session_mod_nr_active_items(session, 1);
-	M0_LEAVE();
-}
-
-M0_INTERNAL void m0_rpc_slot_item_add_internal(struct m0_rpc_slot *slot,
-					       struct m0_rpc_item *item)
-{
-	M0_ENTRY("slot: %p, item: %p", slot, item);
-	__slot_item_add(slot, item);
-	__slot_balance(slot, false); /* not allowed to trigger events */
-	M0_LEAVE();
-}
-
-M0_INTERNAL void m0_rpc_slot_item_add(struct m0_rpc_slot *slot,
-				      struct m0_rpc_item *item)
-{
-	M0_ENTRY("slot: %p, item: %p", slot, item);
-	__slot_item_add(slot, item);
-	if (m0_rpc_conn_is_snd(slot->sl_session->s_conn))
-		m0_rpc_item_change_state(item, M0_RPC_ITEM_WAITING_IN_STREAM);
-	slot_balance(slot);
-	M0_LEAVE();
-}
-
-static void misordered_item_received(struct m0_rpc_slot *slot,
-				     struct m0_rpc_item *item)
-{
-	struct m0_rpc_item *reply;
-	struct m0_fop      *fop;
-
-	M0_ENTRY("slot: %p, item: %p", slot, item);
-	/*
-	 * Send a dummy NOOP fop as reply to report misordered item
-	 * XXX We should've a special fop type to report session error
-	 */
-	fop = m0_fop_alloc(&m0_rpc_fop_noop_fopt, NULL);
-	if (fop != NULL) {
-		reply = &fop->f_item;
-		reply->ri_session = item->ri_session;
-		reply->ri_error   = -EBADR;
-		reply->ri_slot_refs[0] = item->ri_slot_refs[0];
-		slot_item_tlink_init(reply);
-
-		slot->sl_ops->so_reply_consume(item, reply);
-	}
-	m0_fop_put(fop);
-}
-
-M0_INTERNAL int m0_rpc_slot_item_apply(struct m0_rpc_slot *slot,
-				       struct m0_rpc_item *item)
-{
-	int rc = -EPROTO;
-
-	M0_ENTRY("slot: %p, item: %p", slot, item);
-	M0_ASSERT(item != NULL);
-	M0_ASSERT(m0_rpc_slot_invariant(slot));
-	M0_PRE(m0_rpc_machine_is_locked(slot_get_rpc_machine(slot)));
-
-	if (item_xid(item, 0) == slot->sl_xid) {
-		/* valid in sequence */
-		__slot_item_add(slot, item);
-		slot_balance(slot);
-		rc = 0;
-	} else if (item_xid(item, 0) < slot->sl_xid) {
-		duplicate_item_received(slot, item);
-	} else {
-		/* neither duplicate nor in seq */
-		misordered_item_received(slot, item);
-	}
-	M0_POST(m0_rpc_slot_invariant(slot));
-	M0_RETURN(rc);
-}
-
-static void duplicate_item_received(struct m0_rpc_slot *slot,
-				    struct m0_rpc_item *item)
-{
-	struct m0_rpc_item *req;
-
-	M0_ENTRY("slot: %p item: %p", slot, item);
-	/* item is a duplicate request. Find originial. */
-	req = item_find(slot, item_xid(item, 0));
-	if (req == NULL) {
-		misordered_item_received(slot, item);
-		M0_LEAVE();
-		return;
-	}
-	/*
-	 * XXX At this point req->ri_slot_refs[0].sr_verno and
-	 * item->ri_slot_refs[0].sr_verno MUST be same. If they are
-	 * not same then generate ADDB record.
-	 * For now, assert this condition for testing purpose.
-	 */
-	M0_ASSERT(m0_verno_cmp(item_verno(req, 0),
-			       item_verno(item, 0)) == 0);
-
-	switch (req->ri_stage) {
-	case RPC_ITEM_STAGE_PAST_VOLATILE:
-	case RPC_ITEM_STAGE_PAST_COMMITTED:
-		/*
-		 * @item is duplicate and corresponding original is
-		 * already consumed (i.e. executed if item is FOP).
-		 * Consume cached reply. (on receiver, this means
-		 * resend cached reply)
-		 */
-		M0_ASSERT(req->ri_reply != NULL);
-		slot->sl_ops->so_reply_consume(req, req->ri_reply);
-		break;
-	case RPC_ITEM_STAGE_IN_PROGRESS:
-	case RPC_ITEM_STAGE_FUTURE:
-		/* item is already present but is not
-		   processed yet. Ignore it*/
-		/* do nothing */;
-		break;
-	case RPC_ITEM_STAGE_FAILED:
-		/* The request is failed, but receiver could not send reply.
-		   e.g. consider fom allocation failed during
-			m0_reqh_fop_handle()
-		   Ignore the request. Sender side request should TIMEOUT.
-		 */
-		M0_LOG(M0_INFO, "Duplicate request of FAILED item rcvd");
-		break;
-	case RPC_ITEM_STAGE_TIMEDOUT:
-		M0_IMPOSSIBLE("Original req in TIMEDOUT/FAILED stage");
-		break;
-	default:
-		M0_IMPOSSIBLE("Invalid value of m0_rpc_item::ri_stage");
-	}
-	/*
-	 * Irrespective of any of above cases, we're going to
-	 * ignore this _duplicate_ item.
-	 */
-	M0_LEAVE();
-}
-
-M0_INTERNAL int m0_rpc_slot_reply_received(struct m0_rpc_slot *slot,
-					   struct m0_rpc_item *reply,
-					   struct m0_rpc_item **req_out)
-{
-	struct m0_rpc_item     *req;
-	struct m0_rpc_slot_ref *sref;
-	struct m0_rpc_machine  *machine;
-	int                     rc;
-
-	M0_ENTRY("slot: %p, item_reply: %p", slot, reply);
-	M0_PRE(slot != NULL && reply != NULL && req_out != NULL);
-
-	machine = slot_get_rpc_machine(slot);
-	M0_PRE(m0_rpc_machine_is_locked(machine));
-	M0_ASSERT(m0_rpc_slot_invariant(slot));
-
-	*req_out = NULL;
-
-	sref = &reply->ri_slot_refs[0];
-	M0_ASSERT(slot == sref->sr_slot);
-
-	req = item_find(slot, item_xid(reply, 0));
-	if (req == NULL) {
-		/*
-		 * Either it is a duplicate reply and its corresponding request
-		 * item is pruned from the item list, or it is a corrupted
-		 * reply
-		 * XXX This sutuation is not expected to arise during testing.
-		 *     When control reaches this point during testing it might
-		 *     be because of a possible bug. So assert.
-		 */
-		M0_ASSERT(false);
-		M0_RETURN(-EPROTO);
-	}
-	rc = __slot_reply_received(slot, req, reply);
-	if (rc == 0)
-		*req_out = req;
-
-	return rc;
-}
-
-M0_INTERNAL int __slot_reply_received(struct m0_rpc_slot *slot,
-				      struct m0_rpc_item *req,
-				      struct m0_rpc_item *reply)
-{
-	int rc;
-
-	M0_PRE(slot != NULL && req != NULL && reply != NULL);
-
-	/*
-	 * At this point req->ri_slot_refs[0].sr_verno and
-	 * reply->ri_slot_refs[0].sr_verno MUST be same. If they are not,
-	 * then generate ADDB record.
-	 * For now, assert this condition for testing purpose.
-	 */
-	M0_ASSERT(m0_verno_cmp(item_verno(req, 0), item_verno(reply, 0)) == 0);
-
-	rc = -EPROTO;
-	if (m0_verno_cmp(item_verno(req, 0),
-			 item_verno(slot->sl_last_sent, 0)) > 0) {
-		/*
-		 * Received a reply to an item that wasn't sent. This is
-		 * possible if the receiver failed and forget about some
-		 * items. The sender moved last_seen to the past, but then a
-		 * late reply to one of items unreplied before the failure
-		 * arrived.
-		 *
-		 * Such reply must be ignored
-		 */
-		/* Do nothing. */;
-	} else if (M0_IN(req->ri_stage, (RPC_ITEM_STAGE_TIMEDOUT,
-					 RPC_ITEM_STAGE_FAILED))) {
-		/*
-		 * TIMEDOUT:
-		 * The reply is valid but too late. The req has already
-		 * timedout. Return without setting *req_out.
-		 * FAILED:
-		 * FAILED items are not supposed to receive replies, but
-		 * this might be a result of corruption
-		 */
-		/* Do nothing */
-		M0_LOG(M0_DEBUG, "rply rcvd, timedout/failed req %p [%s/%u]",
-			req, item_kind(req), req->ri_type->rit_opcode);
-	} else {
-		/*
-		 * This is valid reply case.
-		 */
-		M0_PRE(M0_IN(req->ri_stage, (RPC_ITEM_STAGE_PAST_COMMITTED,
-					     RPC_ITEM_STAGE_PAST_VOLATILE,
-					     RPC_ITEM_STAGE_IN_PROGRESS)));
-		M0_ASSERT(ergo(req->ri_stage == RPC_ITEM_STAGE_IN_PROGRESS,
-			       slot->sl_in_flight > 0));
-
-		m0_rpc_item_get(reply);
-
-		switch (req->ri_sm.sm_state) {
-		case M0_RPC_ITEM_ENQUEUED:
-		case M0_RPC_ITEM_URGENT:
-			m0_rpc_frm_remove_item(
-				&req->ri_session->s_conn->c_rpcchan->rc_frm,
-				req);
-			m0_rpc_slot_process_reply(req, reply);
-			m0_rpc_session_release(req->ri_session);
-			break;
-
-		case M0_RPC_ITEM_SENDING:
-			/*
-			 * Buffer sent callback is still pending;
-			 * postpone reply processing.
-			 * item_sent() will process the reply.
-			 */
-			M0_LOG(M0_DEBUG, "req: %p rply: %p rply postponed",
-			       req, reply);
-			req->ri_pending_reply = reply;
-			break;
-
-		case M0_RPC_ITEM_ACCEPTED:
-		case M0_RPC_ITEM_WAITING_FOR_REPLY:
-			m0_rpc_slot_process_reply(req, reply);
-			break;
-
-		case M0_RPC_ITEM_REPLIED:
-			/* Duplicate reply. Drop it. */
-			req->ri_rmachine->rm_stats.rs_nr_dropped_items++;
-			m0_rpc_item_put(reply);
-			break;
-
-		default:
-			M0_ASSERT(false);
-		}
-		rc = 0;
-	}
-	return rc;
-}
-
-M0_INTERNAL void m0_rpc_slot_process_reply(struct m0_rpc_item *req,
-					   struct m0_rpc_item *reply)
-{
-	struct m0_rpc_slot *slot;
-
-	M0_ENTRY("req: %p", req);
-
-	M0_PRE(req != NULL && reply != NULL);
-	M0_PRE(m0_rpc_item_is_request(req));
-	M0_PRE(M0_IN(req->ri_sm.sm_state, (M0_RPC_ITEM_WAITING_FOR_REPLY,
-					   M0_RPC_ITEM_ACCEPTED,
-					   M0_RPC_ITEM_ENQUEUED,
-					   M0_RPC_ITEM_URGENT)));
-	M0_PRE(M0_IN(req->ri_stage, (RPC_ITEM_STAGE_PAST_COMMITTED,
-				     RPC_ITEM_STAGE_PAST_VOLATILE,
-				     RPC_ITEM_STAGE_IN_PROGRESS)));
-
-	m0_rpc_item_stop_timer(req);
-	if (req->ri_stage == RPC_ITEM_STAGE_IN_PROGRESS) {
-		req->ri_reply = reply;
-		if (req->ri_ops != NULL && req->ri_ops->rio_replied != NULL)
-			req->ri_ops->rio_replied(req);
-		m0_rpc_item_set_stage(req, RPC_ITEM_STAGE_PAST_VOLATILE);
-	} else {
-		/*
-		 * Got a reply to an item for which the reply was already
-		 * received in the past. Compare with the original reply.
-		 * XXX find out how to compare two rpc items to be same
-		 */
-		M0_ASSERT(req->ri_reply != NULL);
-		req->ri_rmachine->rm_stats.rs_nr_dropped_items++;
-		m0_rpc_item_put(reply);
-	}
-	m0_rpc_item_change_state(req, M0_RPC_ITEM_REPLIED);
-
-	slot = req->ri_slot_refs[0].sr_slot;
-	if (slot->sl_last_sent == req && slot->sl_in_flight == 1) {
-		M0_ASSERT(slot->sl_max_in_flight == 1);
-		slot->sl_in_flight--;
-		slot_balance(slot);
-	}
-	/*
-	 * On receiver, ->so_reply_consume(req, reply) will hand over
-	 * @reply to formation, to send it back to sender.
-	 * see: rcv_reply_consume(), snd_reply_consume()
-	 */
-	slot->sl_ops->so_reply_consume(req, req->ri_reply);
-	M0_LEAVE();
-}
-
-M0_INTERNAL void m0_rpc_slot_persistence(struct m0_rpc_slot *slot,
-					 struct m0_verno last_persistent)
-{
-	struct m0_rpc_item     *item;
-
-	M0_ENTRY("slot: %p, lsn_of_last_persistent: %llu", slot,
-		 (unsigned long long)last_persistent.vn_lsn);
-	M0_PRE(m0_rpc_slot_invariant(slot));
-	M0_PRE(m0_rpc_machine_is_locked(slot_get_rpc_machine(slot)));
-
-	/*
-	 * From last persistent item to end of slot->item_list,
-	 *    if item->verno <= @last_persistent
-	 *       Mark item as PAST_COMMITTED
-	 *    else
-	 *       break
-	 */
-	for (item = slot->sl_last_persistent; item != NULL;
-	     item = slot_item_tlist_next(&slot->sl_item_list, item)) {
-
-		if (m0_verno_cmp(item_verno(item, 0), &last_persistent) <= 0) {
-
-			M0_ASSERT(M0_IN(item->ri_stage,
-					(RPC_ITEM_STAGE_PAST_COMMITTED,
-					 RPC_ITEM_STAGE_PAST_VOLATILE)));
-
-			m0_rpc_item_set_stage(item,
-					      RPC_ITEM_STAGE_PAST_COMMITTED);
-			slot->sl_last_persistent = item;
-		} else {
-			break;
-		}
-	}
-
-	M0_POST(m0_verno_cmp(item_verno(slot->sl_last_persistent, 0),
-			     &last_persistent) >= 0);
-	M0_LEAVE();
-}
-
-M0_INTERNAL void m0_rpc_slot_reset(struct m0_rpc_slot *slot,
-				   struct m0_verno last_seen)
-{
-	struct m0_rpc_item     *item;
-	struct m0_rpc_slot_ref *sref;
-
-	M0_ENTRY("slot: %p, lsn_last_seen: %llu", slot,
-		 (unsigned long long)last_seen.vn_lsn);
-	M0_PRE(m0_rpc_slot_invariant(slot));
-	M0_PRE(m0_rpc_machine_is_locked(slot_get_rpc_machine(slot)));
-	M0_PRE(m0_verno_cmp(&slot->sl_verno, &last_seen) >= 0);
-
-	for_each_item_in_slot(item, slot) {
-
-		sref = &item->ri_slot_refs[0];
-		if (m0_verno_cmp(&sref->sr_ow.osr_verno, &last_seen) == 0) {
-			M0_ASSERT(item->ri_stage != RPC_ITEM_STAGE_FUTURE);
-			slot->sl_last_sent = item;
-			break;
-		}
-
-	} end_for_each_item_in_slot;
-	M0_ASSERT(m0_verno_cmp(item_verno(slot->sl_last_sent, 0),
-			       &last_seen) == 0);
-	slot_balance(slot);
-	M0_LEAVE();
-}
-
-M0_INTERNAL struct m0_rpc_conn *
-m0_rpc_machine_find_conn(const struct m0_rpc_machine *machine,
-			 const struct m0_rpc_item    *item)
-{
-	const struct m0_rpc_onwire_slot_ref *sref;
-	const struct m0_tl                  *conn_list;
-	struct m0_rpc_conn                  *conn;
-	bool                                 use_uuid;
-
-	M0_ENTRY("machine: %p, item: %p", machine, item);
-
-	sref = &item->ri_slot_refs[0].sr_ow;
-	use_uuid = (sref->osr_sender_id == SENDER_ID_INVALID);
-	conn_list = m0_rpc_item_is_request(item) ?
-			&machine->rm_incoming_conns :
-			&machine->rm_outgoing_conns;
-
-	m0_tl_for(rpc_conn, conn_list, conn) {
-		if (use_uuid) {
-			if (m0_uint128_cmp(&conn->c_uuid,
-					   &sref->osr_uuid) == 0)
-				break;
-		} else if (conn->c_sender_id == sref->osr_sender_id) {
-			break;
-		}
-	} m0_tl_endfor;
-
-	M0_LEAVE("conn: %p", conn);
-	return conn;
-}
-
-static int associate_session_and_slot(struct m0_rpc_item    *item,
-				      struct m0_rpc_machine *machine)
-{
-	struct m0_rpc_conn     *conn;
-	struct m0_rpc_session  *session;
-	struct m0_rpc_slot     *slot;
-	struct m0_rpc_slot_ref *sref;
-
-	M0_ENTRY("item: %p, machine: %p", item, machine);
-	M0_PRE(m0_rpc_machine_is_locked(machine));
-
-	sref = &item->ri_slot_refs[0];
-	if (sref->sr_ow.osr_session_id > SESSION_ID_MAX)
-		M0_RETERR(-EINVAL, "rpc_session_id");
-
-	conn = m0_rpc_machine_find_conn(machine, item);
-	if (conn == NULL)
-		M0_RETURN(-ENOENT);
-
-	session = m0_rpc_session_search(conn, sref->sr_ow.osr_session_id);
-	if (session == NULL || sref->sr_ow.osr_slot_id >= session->s_nr_slots)
-		M0_RETURN(-ENOENT);
-
-	slot = session->s_slot_table[sref->sr_ow.osr_slot_id];
-	/* XXX Check generation of slot */
-	M0_ASSERT(slot != NULL);
-	sref->sr_slot    = slot;
-	item->ri_session = session;
-
-	M0_POST(item->ri_session != NULL &&
-		item->ri_slot_refs[0].sr_slot != NULL);
-	M0_RETURN(0);
-}
-
-M0_INTERNAL int m0_rpc_item_received(struct m0_rpc_item *item,
-				     struct m0_rpc_machine *machine)
-{
-	int rc;
-
-	M0_ENTRY("item: %p, machine: %p", item, machine);
-	M0_PRE(item != NULL);
-	M0_PRE(m0_rpc_machine_is_locked(machine));
-
-	m0_addb_counter_update(&machine->rm_cntr_rcvd_item_sizes,
-			       (uint64_t)m0_rpc_item_size(item));
-	++machine->rm_stats.rs_nr_rcvd_items;
-
-	if (m0_rpc_item_is_oneway(item)) {
-		m0_rpc_item_dispatch(item);
-		M0_RETURN(0);
-	}
-
-	M0_ASSERT(m0_rpc_item_is_request(item) || m0_rpc_item_is_reply(item));
-	rc = associate_session_and_slot(item, machine);
-	if (rc == 0)
-		M0_RETURN(m0_rpc_slot_item_received(item));
-
-	if (m0_rpc_item_is_conn_establish(item)) {
-		m0_rpc_item_dispatch(item);
-		M0_RETURN(0);
-	}
-
-	/*
-	 * We cannot associate the item with its slot. The only thing
-	 * that we can do with this item is to discard it.
-	 *
-	 * XXX TODO: Generate ADDB record.
-	 *
-	 * At this point the item has only 1 reference on it. This
-	 * reference will be dropped in packet_received(), resulting
-	 * in the item getting deallocated.
-	 */
-	M0_RETURN(rc);
-}
-
-M0_INTERNAL int m0_rpc_slot_item_received(struct m0_rpc_item *item)
-{
-	struct m0_rpc_item *req;
-	struct m0_rpc_slot *slot;
-	int                 rc = 0;
-
-	slot = item->ri_slot_refs[0].sr_slot;
-	M0_ASSERT(slot != NULL);
-
-	if (m0_rpc_item_is_request(item))
-		rc = m0_rpc_slot_item_apply(slot, item);
-	else if (m0_rpc_item_is_reply(item))
-		rc = m0_rpc_slot_reply_received(slot, item, &req);
-
-	return rc;
-}
-
-/**
-   Just for debugging purpose.
- */
-#ifndef __KERNEL__
-int m0_rpc_slot_item_list_print(struct m0_rpc_slot *slot,
-				bool                only_active,
-				int                 count)
-{
-	struct m0_rpc_item *item;
-	bool                first = true;
-	char                str_stage[][20] = {
-				"INVALID",
-				"PAST_COMMITTED",
-				"PAST_VOLATILE",
-				"IN_PROGRESS",
-				"FUTURE"
-			     };
-
-	for_each_item_in_slot(item, slot) {
-		/* Skip dummy item */
-		if (first) {
-			first = false;
-			continue;
-		}
-		if (ergo(only_active,
-			 M0_IN(item->ri_stage,
-			       (RPC_ITEM_STAGE_IN_PROGRESS,
-				RPC_ITEM_STAGE_FUTURE)))) {
-
-			printf("%d: item %p <%u, %lu>  state %s\n",
-			       ++count,
-			       item,
-			       slot->sl_slot_id,
-			       item_xid(item, 0),
-			       str_stage[item->ri_stage]);
-		}
-	} end_for_each_item_in_slot;
-	return count;
-}
-#endif
-
-/** @} */
-#undef M0_TRACE_SUBSYSTEM
-
-/*
- *  Local variables:
- *  c-indentation-style: "K&R"
- *  c-basic-offset: 8
- *  tab-width: 8
- *  fill-column: 80
- *  scroll-step: 1
- *  End:
- */
-- 
1.8.3.2

