From a5b3cbc741684e36688e1e5d707376ca8e785101 Mon Sep 17 00:00:00 2001
From: Amit Jambure <Amit_Jambure@xyratex.com>
Date: Fri, 24 May 2013 15:35:23 +0530
Subject: [PATCH 12/60] rpc: Slot deletion continued.

---
 rpc/session.c      | 379 ++---------------------------------------------------
 rpc/session_fops.h |   4 -
 2 files changed, 13 insertions(+), 370 deletions(-)

diff --git a/rpc/session.c b/rpc/session.c
index 7905bc9..f1a41ae 100644
--- a/rpc/session.c
+++ b/rpc/session.c
@@ -43,43 +43,10 @@
    This file defines functions related to m0_rpc_session.
  */
 
-static void snd_slot_idle(struct m0_rpc_slot *slot);
-static void snd_slot_busy(struct m0_rpc_slot *slot);
-
-static int  snd_item_consume(struct m0_rpc_item *item);
-
-static void snd_reply_consume(struct m0_rpc_item *req,
-				 struct m0_rpc_item *reply);
-
-static void rcv_slot_idle(struct m0_rpc_slot *slot);
-static void rcv_slot_busy(struct m0_rpc_slot *slot);
-
-static int  rcv_item_consume(struct m0_rpc_item *item);
-
-static void rcv_reply_consume(struct m0_rpc_item *req,
-			      struct m0_rpc_item *reply);
-
-static int nr_active_items_count(const struct m0_rpc_session *session);
-
-static int slot_table_alloc_and_init(struct m0_rpc_session *session);
 static void __session_fini(struct m0_rpc_session *session);
 static void session_failed(struct m0_rpc_session *session, int32_t error);
 static void session_idle_x_busy(struct m0_rpc_session *session);
 
-static const struct m0_rpc_slot_ops snd_slot_ops = {
-	.so_slot_idle     = snd_slot_idle,
-	.so_slot_busy     = snd_slot_busy,
-	.so_item_consume  = snd_item_consume,
-	.so_reply_consume = snd_reply_consume
-};
-
-static const struct m0_rpc_slot_ops rcv_slot_ops = {
-	.so_slot_idle     = rcv_slot_idle,
-	.so_slot_busy     = rcv_slot_busy,
-	.so_item_consume  = rcv_item_consume,
-	.so_reply_consume = rcv_reply_consume
-};
-
 /**
    Container of session_establish fop.
 
@@ -104,11 +71,6 @@ static const struct m0_rpc_item_ops session_terminate_item_ops = {
 	.rio_replied = m0_rpc_session_terminate_reply_received,
 };
 
-M0_TL_DESCR_DEFINE(ready_slot, "ready-slots", M0_INTERNAL, struct m0_rpc_slot,
-		   sl_link, sl_magic, M0_RPC_SLOT_MAGIC,
-		   M0_RPC_SLOT_HEAD_MAGIC);
-M0_TL_DEFINE(ready_slot, M0_INTERNAL, struct m0_rpc_slot);
-
 M0_TL_DESCR_DEFINE(rpc_session, "rpc-sessions", M0_INTERNAL,
 		   struct m0_rpc_session, s_link, s_magic, M0_RPC_SESSION_MAGIC,
 		   M0_RPC_SESSION_HEAD_MAGIC);
@@ -197,9 +159,6 @@ M0_INTERNAL bool m0_rpc_session_invariant(const struct m0_rpc_session *session)
 
 	ok = _0C(session != NULL) &&
 	     _0C(session->s_conn != NULL) &&
-	     _0C(session->s_nr_slots > 0) &&
-	     _0C(nr_active_items_count(session) ==
-			session->s_nr_active_items) &&
 	     _0C(rpc_session_tlist_contains(&session->s_conn->c_sessions,
 			             session)) &&
 	     _0C(ergo(session->s_session_id != SESSION_ID_0,
@@ -208,22 +167,6 @@ M0_INTERNAL bool m0_rpc_session_invariant(const struct m0_rpc_session *session)
 	if (!ok)
 		return false;
 
-	for (i = 0; i < session->s_nr_slots; i++) {
-		slot = session->s_slot_table[i];
-		ok = m0_rpc_slot_invariant(slot) &&
-		     _0C(ergo(M0_IN(session_state(session),
-				(M0_RPC_SESSION_INITIALISED,
-				 M0_RPC_SESSION_ESTABLISHING,
-				 M0_RPC_SESSION_TERMINATING,
-				 M0_RPC_SESSION_TERMINATED,
-				 M0_RPC_SESSION_FAILED)),
-		          !ready_slot_tlink_is_in(slot)));
-		    /* A slot cannot be on ready slots list if session is
-		       in one of above states */
-		if (!ok)
-			return false;
-	}
-
 	switch (session_state(session)) {
 	case M0_RPC_SESSION_INITIALISED:
 	case M0_RPC_SESSION_ESTABLISHING:
@@ -255,28 +198,9 @@ M0_INTERNAL bool m0_rpc_session_invariant(const struct m0_rpc_session *session)
 
 M0_INTERNAL bool m0_rpc_session_is_idle(const struct m0_rpc_session *session)
 {
-	return session->s_nr_active_items == 0 &&
-	       session->s_hold_cnt == 0;
-}
-
-static int nr_active_items_count(const struct m0_rpc_session *session)
-{
-	struct m0_rpc_slot *slot;
-	struct m0_rpc_item *item;
-	int                 i;
-	int                 count = 0;
-
-	for (i = 0; i < session->s_nr_slots; i++) {
-		slot = session->s_slot_table[i];
-		for_each_item_in_slot(item, slot) {
-			if (item_is_active(item))
-				count++;
-		} end_for_each_item_in_slot;
-	}
-	return count;
+	return session->s_nr_active_items == 0;
 }
 
-
 M0_INTERNAL int m0_rpc_session_init(struct m0_rpc_session *session,
 				    struct m0_rpc_conn *conn, uint32_t nr_slots)
 {
@@ -289,11 +213,8 @@ M0_INTERNAL int m0_rpc_session_init(struct m0_rpc_session *session,
 
 	machine = conn->c_rpc_machine;
 	M0_PRE(machine != NULL);
-
 	m0_rpc_machine_lock(machine);
-
 	rc = m0_rpc_session_init_locked(session, conn, nr_slots);
-
 	m0_rpc_machine_unlock(machine);
 
 	M0_RETURN(rc);
@@ -302,79 +223,25 @@ M0_EXPORTED(m0_rpc_session_init);
 
 M0_INTERNAL int m0_rpc_session_init_locked(struct m0_rpc_session *session,
 					   struct m0_rpc_conn *conn,
-					   uint32_t nr_slots)
+					   uint32_t UNUSED_nr_slots)
 {
-	int rc;
-
-	M0_ENTRY("session: %p, conn: %p, nr_slots: %u", session,
-		 conn, nr_slots);
-	M0_PRE(session != NULL && conn != NULL && nr_slots >= 1);
+	M0_ENTRY("session: %p, conn: %p", session, conn);
+	M0_PRE(session != NULL && conn != NULL);
 	M0_PRE(m0_rpc_machine_is_locked(conn->c_rpc_machine));
 
 	M0_SET0(session);
 
-	session->s_session_id          = SESSION_ID_INVALID;
-	session->s_conn                = conn;
-	session->s_nr_slots            = nr_slots;
-	session->s_slot_table_capacity = nr_slots;
+	session->s_session_id = SESSION_ID_INVALID;
+	session->s_conn       = conn;
 
 	rpc_session_tlink_init(session);
-	m0_list_init(&session->s_unbound_items);
-	ready_slot_tlist_init(&session->s_ready_slots);
-
-	rc = slot_table_alloc_and_init(session);
-	if (rc == 0) {
-		m0_sm_init(&session->s_sm, &session_conf,
-			   M0_RPC_SESSION_INITIALISED,
-			   &conn->c_rpc_machine->rm_sm_grp);
-		M0_LOG(M0_INFO, "Session %p INITIALISED \n", session);
-		m0_rpc_conn_add_session(conn, session);
-		M0_ASSERT(m0_rpc_session_invariant(session));
-	} else {
-		__session_fini(session);
-	}
-
-	M0_RETURN(rc);
-}
-
-static int slot_table_alloc_and_init(struct m0_rpc_session *session)
-{
-	const struct m0_rpc_slot_ops *slot_ops;
-	struct m0_rpc_slot           *slot;
-	int                           i;
-	int                           rc;
-
-	M0_ENTRY("session: %p", session);
-
-	RPC_ALLOC_ARR(session->s_slot_table, session->s_nr_slots,
-		      SESSION_SLOT_TABLE_ALLOC_AND_INIT, &m0_rpc_addb_ctx);
-	if (session->s_slot_table == NULL)
-		M0_RETURN(-ENOMEM);
-
-	slot_ops = m0_rpc_conn_is_snd(session->s_conn) ? &snd_slot_ops
-					               : &rcv_slot_ops;
-	for (i = 0; i < session->s_nr_slots; i++) {
-
-		RPC_ALLOC_PTR(slot, SESSION_SLOT_TABLE_ALLOC_AND_INIT,
-			      &m0_rpc_addb_ctx);
-		if (slot == NULL) {
-			M0_RETURN(-ENOMEM);
-			/* __session_fini() will do the cleanup */
-		}
-
-		rc = m0_rpc_slot_init(slot, slot_ops);
-		if (rc != 0) {
-			m0_free(slot);
-			M0_RETURN(rc);
-		}
-
-		slot->sl_session = session;
-		slot->sl_slot_id = i;
+	m0_sm_init(&session->s_sm, &session_conf,
+		   M0_RPC_SESSION_INITIALISED,
+		   &conn->c_rpc_machine->rm_sm_grp);
+	m0_rpc_conn_add_session(conn, session);
+	M0_ASSERT(m0_rpc_session_invariant(session));
+	M0_LOG(M0_INFO, "Session %p INITIALISED \n", session);
 
-		session->s_slot_table[i] = slot;
-	}
-	if (M0_FI_ENABLED("failed"))
-		M0_RETURN(-ENOMEM);
 	M0_RETURN(0);
 }
 
@@ -386,28 +253,11 @@ static int slot_table_alloc_and_init(struct m0_rpc_session *session)
  */
 static void __session_fini(struct m0_rpc_session *session)
 {
-	struct m0_rpc_slot *slot;
-	int                 i;
-
 	M0_ENTRY("session: %p", session);
 
-	if (session->s_slot_table != NULL) {
-		for (i = 0; i < session->s_nr_slots; i++) {
-			slot = session->s_slot_table[i];
-			if (slot != NULL) {
-				m0_rpc_slot_fini(slot);
-				m0_free(slot);
-			}
-			session->s_slot_table[i] = NULL;
-		}
-		session->s_nr_slots = 0;
-		session->s_slot_table_capacity = 0;
-		m0_free(session->s_slot_table);
-		session->s_slot_table = NULL;
-	}
 	rpc_session_tlink_fini(session);
-	ready_slot_tlist_fini(&session->s_ready_slots);
 	m0_list_fini(&session->s_unbound_items);
+
 	M0_LEAVE();
 }
 
@@ -558,7 +408,6 @@ M0_INTERNAL int m0_rpc_session_establish(struct m0_rpc_session *session,
 	M0_ASSERT(args != NULL);
 
 	args->rse_sender_id = conn->c_sender_id;
-	args->rse_slot_cnt  = session->s_nr_slots;
 
 	session_0 = m0_rpc_conn_session0(conn);
 	rc = m0_rpc__fop_post(fop, session_0, &session_establish_item_ops,
@@ -652,10 +501,6 @@ M0_INTERNAL void m0_rpc_session_establish_reply_received(struct m0_rpc_item
 		    sender_id != SENDER_ID_INVALID) {
 			session->s_session_id = session_id;
 			session_state_set(session, M0_RPC_SESSION_IDLE);
-			for (i = 0; i < session->s_nr_slots; i++) {
-				slot = session->s_slot_table[i];
-				slot->sl_ops->so_slot_idle(slot);
-			}
 		} else {
 			rc = -EPROTO;
 		}
@@ -751,8 +596,6 @@ M0_INTERNAL int m0_rpc_session_terminate(struct m0_rpc_session *session,
 		M0_RETURN(0);
 	}
 
-	m0_rpc_session_del_slots_from_ready_list(session);
-
 	fop = m0_fop_alloc(&m0_rpc_fop_session_terminate_fopt, NULL);
 	if (fop == NULL) {
 		rc = -ENOMEM;
@@ -873,25 +716,6 @@ m0_rpc_session_get_max_item_payload_size(const struct m0_rpc_session *session)
 	       m0_rpc_item_onwire_header_size;
 }
 
-M0_INTERNAL void m0_rpc_session_hold_busy(struct m0_rpc_session *session)
-{
-	M0_LOG(M0_DEBUG, "session %p %d -> %d", session, session->s_hold_cnt,
-		session->s_hold_cnt + 1);
-	++session->s_hold_cnt;
-	session_idle_x_busy(session);
-}
-
-M0_INTERNAL void m0_rpc_session_release(struct m0_rpc_session *session)
-{
-	M0_PRE(session_state(session) == M0_RPC_SESSION_BUSY);
-	M0_PRE(session->s_hold_cnt > 0);
-
-	M0_LOG(M0_DEBUG, "session %p %d -> %d", session, session->s_hold_cnt,
-		session->s_hold_cnt - 1);
-	--session->s_hold_cnt;
-	session_idle_x_busy(session);
-}
-
 M0_INTERNAL void m0_rpc_session_mod_nr_active_items(struct m0_rpc_session
 						    *session, int delta)
 {
@@ -923,109 +747,6 @@ static void session_idle_x_busy(struct m0_rpc_session *session)
 					       M0_RPC_SESSION_BUSY)));
 }
 
-static void snd_slot_idle(struct m0_rpc_slot *slot)
-{
-	struct m0_rpc_frm *frm;
-
-	M0_PRE(slot != NULL);
-	M0_PRE(slot->sl_session != NULL);
-	M0_PRE(slot->sl_in_flight == 0);
-	M0_PRE(!ready_slot_tlink_is_in(slot));
-
-	ready_slot_tlist_add_tail(&slot->sl_session->s_ready_slots, slot);
-	frm = session_frm(slot->sl_session);
-	m0_rpc_frm_run_formation(frm);
-}
-
-static void snd_slot_busy(struct m0_rpc_slot *slot)
-{
-	M0_PRE(slot != NULL);
-
-	if (ready_slot_tlink_is_in(slot))
-		ready_slot_tlist_del(slot);
-}
-
-M0_INTERNAL bool m0_rpc_session_bind_item(struct m0_rpc_item *item)
-{
-	struct m0_rpc_session *session;
-	struct m0_rpc_slot    *slot;
-
-	M0_ENTRY("item: %p", item);
-	M0_PRE(item != NULL && item->ri_session != NULL);
-
-	session = item->ri_session;
-
-	if (ready_slot_tlist_is_empty(&session->s_ready_slots)) {
-		M0_LEAVE("rc: FALSE");
-		return false;
-	}
-	slot = ready_slot_tlist_head(&session->s_ready_slots);
-	ready_slot_tlist_del(slot);
-	m0_rpc_slot_item_add_internal(slot, item);
-
-	M0_POST(m0_rpc_item_is_bound(item));
-	M0_LEAVE("rc: TRUE");
-	return true;
-}
-
-static int snd_item_consume(struct m0_rpc_item *item)
-{
-	m0_rpc_item_send(item);
-	return 0;
-}
-
-static void snd_reply_consume(struct m0_rpc_item *req,
-			      struct m0_rpc_item *reply)
-{
-	/* Don't do anything on sender to consume reply */
-}
-
-static void rcv_slot_idle(struct m0_rpc_slot *slot)
-{
-	M0_ASSERT(slot->sl_in_flight == 0);
-	/*
-	 * On receiver side, no slot is placed on ready_slots list.
-	 * All consumed reply items, will be treated as bound items by
-	 * formation, and will find these items in its own lists.
-	 */
-}
-
-static void rcv_slot_busy(struct m0_rpc_slot *slot)
-{
-	/* Do nothing on receiver */
-}
-
-static int rcv_item_consume(struct m0_rpc_item *item)
-{
-	return m0_rpc_item_dispatch(item);
-}
-
-static void rcv_reply_consume(struct m0_rpc_item *req,
-			      struct m0_rpc_item *reply)
-{
-	switch (reply->ri_sm.sm_state) {
-	case M0_RPC_ITEM_INITIALISED:
-	case M0_RPC_ITEM_SENT:
-	case M0_RPC_ITEM_FAILED:
-		m0_rpc_item_send(reply);
-		break;
-	case M0_RPC_ITEM_ENQUEUED:
-	case M0_RPC_ITEM_URGENT:
-	case M0_RPC_ITEM_SENDING:
-		/*
-		  This situation can arise when reply item is posted but
-		  not yet sent (i.e. reply is in formation queue or is
-		  currently being sent) and duplicate req item is received.
-		  In this case there is no need to again queue the reply
-		  for sending.
-		 */
-		/* Do nothing */
-		break;
-	default:
-		M0_IMPOSSIBLE("State of reply item is invalid");
-	}
-}
-
 M0_INTERNAL int m0_rpc_rcv_session_terminate(struct m0_rpc_session *session)
 {
 	M0_ENTRY("session: %p", session);
@@ -1035,8 +756,6 @@ M0_INTERNAL int m0_rpc_rcv_session_terminate(struct m0_rpc_session *session)
 	M0_ASSERT(m0_rpc_session_invariant(session));
 	M0_PRE(session_state(session) == M0_RPC_SESSION_IDLE);
 
-	/* For receiver side session, no slots are on ready_slots list
-	   since all reply items are bound items. */
 	session_state_set(session, M0_RPC_SESSION_TERMINATED);
 
 	M0_ASSERT(m0_rpc_session_invariant(session));
@@ -1048,79 +767,7 @@ M0_INTERNAL void m0_rpc_session_item_failed(struct m0_rpc_item *item)
 	M0_PRE(item != NULL && item->ri_error != 0);
 	M0_PRE(item->ri_sm.sm_state == M0_RPC_ITEM_FAILED);
 
-	if (m0_rpc_item_is_request(item) &&
-	    M0_IN(item->ri_stage, (RPC_ITEM_STAGE_FUTURE,
-				   RPC_ITEM_STAGE_IN_PROGRESS))) {
-
-		M0_ASSERT(item->ri_error != 0);
-		if (item->ri_ops != NULL && item->ri_ops->rio_replied != NULL)
-			item->ri_ops->rio_replied(item);
-
-		if (item->ri_error == -ETIMEDOUT)
-			m0_rpc_item_set_stage(item, RPC_ITEM_STAGE_TIMEDOUT);
-		else
-			m0_rpc_item_set_stage(item, RPC_ITEM_STAGE_FAILED);
-	}
-	/*
-	 * Note that the slot is not marked as idle. Because we cannot
-	 * use this slot to send more items.
-	 * When session->s_nr_slots number of items fail then there will be
-	 * no slot left to send further items.
-	 *
-	 * @todo Replay mechanism should bring items from UNKNOWN stage to
-	 *       some known stage e.g. {PAST_VOLATILE, PAST_COMMITTED}
-	 * @todo If item is failed _before_ placing on network, then we
-	 *       can keep the slot in usable state, by performing inverse
-	 *       operation of m0_rpc_slot_item_apply(). But this will
-	 *       require reference counting implemented for RPC items.
-	 *       Otherwise how the item (which was removed from slot) will
-	 *       be freed?
-	 */
-}
-
-/**
-   For all slots belonging to @session,
-     if slot is in m0_rpc_session::s_ready_slots list,
-     then remove it from the list.
- */
-M0_INTERNAL void m0_rpc_session_del_slots_from_ready_list(struct m0_rpc_session
-							  *session)
-{
-	struct m0_rpc_slot    *slot;
-	struct m0_rpc_machine *machine = session_machine(session);
-	int                    i;
-
-	M0_ENTRY("session: %p", session);
-
-	M0_ASSERT(m0_rpc_machine_is_locked(machine));
-
-	for (i = 0; i < session->s_nr_slots; i++) {
-		slot = session->s_slot_table[i];
-
-		M0_ASSERT(slot != NULL);
-
-		if (ready_slot_tlink_is_in(slot))
-			ready_slot_tlist_del(slot);
-	}
-	M0_LEAVE();
-}
-#ifndef __KERNEL__
-/* for debugging  */
-M0_INTERNAL int m0_rpc_session_items_print(struct m0_rpc_session *session,
-					   bool only_active)
-{
-	struct m0_rpc_slot *slot;
-	int                 count;
-	int                 i;
-
-	count = 0;
-	for (i = 0; i < session->s_nr_slots; i++) {
-		slot  = session->s_slot_table[i];
-		count = m0_rpc_slot_item_list_print(slot, only_active, count);
-	}
-	return count;
 }
-#endif
 
 #undef M0_TRACE_SUBSYSTEM
 
diff --git a/rpc/session_fops.h b/rpc/session_fops.h
index 3df82bc..4282255 100644
--- a/rpc/session_fops.h
+++ b/rpc/session_fops.h
@@ -129,10 +129,6 @@ struct m0_rpc_fop_session_establish {
 	   sender_id of rpc-connection in which a new session is to be created.
 	 */
 	uint64_t rse_sender_id;
-	/**
-	   Number of slots the new session should have.
-	 */
-	uint32_t rse_slot_cnt;
 } M0_XCA_RECORD;
 
 /**
-- 
1.8.3.2

