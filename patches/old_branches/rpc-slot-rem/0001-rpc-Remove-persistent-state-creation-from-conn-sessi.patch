From e58221d6a3b68c4ce2aa1ef8d45964175b605cf1 Mon Sep 17 00:00:00 2001
From: Amit Jambure <Amit_Jambure@xyratex.com>
Date: Thu, 23 May 2013 12:49:58 +0530
Subject: [PATCH 01/60] rpc: Remove persistent state creation from
 [conn|session]_[establish|destroy]      code paths.

---
 rpc/conn.c    | 29 +++++++++++++++++++----------
 rpc/session.c | 23 ++++++++++++++++-------
 2 files changed, 35 insertions(+), 17 deletions(-)

diff --git a/rpc/conn.c b/rpc/conn.c
index e8d739a..93f37a5 100644
--- a/rpc/conn.c
+++ b/rpc/conn.c
@@ -63,8 +63,10 @@ static void session_zero_detach(struct m0_rpc_conn *conn);
  */
 static int conn_persistent_state_attach(struct m0_rpc_conn *conn,
 					uint64_t            sender_id,
-					struct m0_db_tx    *tx);
-static void __conn_persistent_state_put(struct m0_rpc_conn *conn);
+					struct m0_db_tx    *tx)
+__attribute__((unused));
+static void __conn_persistent_state_put(struct m0_rpc_conn *conn)
+__attribute__((unused));
 
 static int __conn_init(struct m0_rpc_conn      *conn,
 		       struct m0_net_end_point *ep,
@@ -209,8 +211,7 @@ M0_INTERNAL bool m0_rpc_conn_invariant(const struct m0_rpc_conn *conn)
 
 	case M0_RPC_CONN_ACTIVE:
 		return  conn->c_sender_id != SENDER_ID_INVALID &&
-			conn->c_nr_sessions >= 1 &&
-			ergo(recv_end, conn->c_cob != NULL);
+			conn->c_nr_sessions >= 1;
 
 	case M0_RPC_CONN_TERMINATING:
 		return  conn->c_nr_sessions == 1 &&
@@ -219,7 +220,6 @@ M0_INTERNAL bool m0_rpc_conn_invariant(const struct m0_rpc_conn *conn)
 	case M0_RPC_CONN_TERMINATED:
 		return	conn->c_nr_sessions == 1 &&
 			conn->c_sender_id != SENDER_ID_INVALID &&
-			conn->c_cob == NULL &&
 			conn->c_sm.sm_rc == 0;
 
 	case M0_RPC_CONN_FAILED:
@@ -947,6 +947,8 @@ static int conn_persistent_state_attach(struct m0_rpc_conn *conn,
 	int                    rc;
 	int                    i;
 
+	return 0;
+
 	M0_ENTRY("conn: %p, sender_id: %llu", conn,
 		 (unsigned long long)sender_id);
 	M0_PRE(m0_rpc_conn_invariant(conn) &&
@@ -975,7 +977,7 @@ cleanup:
 M0_INTERNAL int m0_rpc_rcv_conn_establish(struct m0_rpc_conn *conn)
 {
 	struct m0_rpc_machine *machine;
-	struct m0_db_tx        tx;
+	//struct m0_db_tx        tx;
 	uint64_t               sender_id;
 	int                    rc;
 
@@ -991,16 +993,18 @@ M0_INTERNAL int m0_rpc_rcv_conn_establish(struct m0_rpc_conn *conn)
 		  m0_rpc_conn_is_rcv(conn));
 
 	conn_state_set(conn, M0_RPC_CONN_CONNECTING);
+	sender_id = m0_rpc_id_generate();
+/*
 	rc = m0_db_tx_init(&tx, machine->rm_dom->cd_dbenv, 0);
 	if (rc == 0) {
-		sender_id = m0_rpc_id_generate();
 		rc = conn_persistent_state_attach(conn, sender_id, &tx);
 		if (rc == 0)
 			rc = m0_db_tx_commit(&tx);
 		else
 			m0_db_tx_abort(&tx);
 	}
-
+*/
+	rc = 0;
 	if (rc == 0) {
 		conn->c_sender_id = sender_id;
 		conn_state_set(conn, M0_RPC_CONN_ACTIVE);
@@ -1011,6 +1015,7 @@ M0_INTERNAL int m0_rpc_rcv_conn_establish(struct m0_rpc_conn *conn)
 	M0_RETURN(rc);
 }
 
+__attribute__((unused))
 static int conn_persistent_state_destroy(struct m0_rpc_conn *conn,
 					 struct m0_db_tx    *tx)
 {
@@ -1022,6 +1027,8 @@ static int conn_persistent_state_destroy(struct m0_rpc_conn *conn,
 	session0 = m0_rpc_conn_session0(conn);
 	M0_ASSERT(conn->c_cob != NULL && session0->s_cob != NULL);
 
+	return 0;
+
 	for (i = 0; i < session0->s_nr_slots; ++i) {
 		slot = session0->s_slot_table[i];
 		m0_cob_delete_put(slot->sl_cob, tx);
@@ -1077,7 +1084,7 @@ M0_INTERNAL void m0_rpc_conn_cleanup_all_sessions(struct m0_rpc_conn *conn)
 M0_INTERNAL int m0_rpc_rcv_conn_terminate(struct m0_rpc_conn *conn)
 {
 	struct m0_rpc_machine *machine;
-	struct m0_db_tx        tx;
+//	struct m0_db_tx        tx;
 	int                    rc;
 
 	M0_ENTRY("conn: %p", conn);
@@ -1096,6 +1103,7 @@ M0_INTERNAL int m0_rpc_rcv_conn_terminate(struct m0_rpc_conn *conn)
 	deregister_all_item_sources(conn);
 
 	conn_state_set(conn, M0_RPC_CONN_TERMINATING);
+/*
 	rc = m0_db_tx_init(&tx, conn->c_cob->co_dom->cd_dbenv, 0);
 	if (rc == 0) {
 		rc = conn_persistent_state_destroy(conn, &tx);
@@ -1104,7 +1112,8 @@ M0_INTERNAL int m0_rpc_rcv_conn_terminate(struct m0_rpc_conn *conn)
 		else
 			m0_db_tx_abort(&tx);
 	}
-
+*/
+	rc = 0;
 	if (rc == 0) {
 		conn_state_set(conn, M0_RPC_CONN_TERMINATED);
 	} else {
diff --git a/rpc/session.c b/rpc/session.c
index 659a58a..fa01d49 100644
--- a/rpc/session.c
+++ b/rpc/session.c
@@ -244,8 +244,7 @@ M0_INTERNAL bool m0_rpc_session_invariant(const struct m0_rpc_session *session)
 		       _0C(m0_rpc_session_is_idle(session));
 
 	case M0_RPC_SESSION_TERMINATED:
-		return  _0C(session->s_cob == NULL) &&
-			_0C(session->s_session_id <= SESSION_ID_MAX) &&
+		return	_0C(session->s_session_id <= SESSION_ID_MAX) &&
 			_0C(m0_rpc_session_is_idle(session));
 
 	case M0_RPC_SESSION_IDLE:
@@ -1110,7 +1109,7 @@ static void rcv_reply_consume(struct m0_rpc_item *req,
 M0_INTERNAL int m0_rpc_rcv_session_establish(struct m0_rpc_session *session)
 {
 	struct m0_rpc_machine *machine;
-	struct m0_db_tx        tx;
+//	struct m0_db_tx        tx;
 	uint64_t               session_id;
 	int                    rc;
 
@@ -1123,15 +1122,18 @@ M0_INTERNAL int m0_rpc_rcv_session_establish(struct m0_rpc_session *session)
 	M0_ASSERT(session_state(session) == M0_RPC_SESSION_INITIALISED);
 
 	session_state_set(session, M0_RPC_SESSION_ESTABLISHING);
+	session_id = session_id_allocate();
+	rc = 0;
+/*
 	rc = m0_db_tx_init(&tx, session->s_conn->c_cob->co_dom->cd_dbenv, 0);
 	if (rc == 0) {
-		session_id = session_id_allocate();
 		rc = session_persistent_state_attach(session, session_id, &tx);
 		if (rc == 0)
 			rc = m0_db_tx_commit(&tx);
 		else
 			m0_db_tx_abort(&tx);
 	}
+*/
 	if (rc == 0) {
 		session->s_session_id = session_id;
 		session_state_set(session, M0_RPC_SESSION_IDLE);
@@ -1143,6 +1145,7 @@ M0_INTERNAL int m0_rpc_rcv_session_establish(struct m0_rpc_session *session)
 	M0_RETURN(rc);
 }
 
+__attribute__((unused))
 static int session_persistent_state_attach(struct m0_rpc_session *session,
 					   uint64_t               session_id,
 					   struct m0_db_tx       *tx)
@@ -1151,6 +1154,8 @@ static int session_persistent_state_attach(struct m0_rpc_session *session,
 	int             rc;
 	int             i;
 
+	return 0;
+
 	M0_ENTRY("session: %p, session_id: %llu", session,
 		 (unsigned long long)session_id);
 	M0_PRE(session != NULL &&
@@ -1195,6 +1200,7 @@ errout:
 	M0_RETURN(rc);
 }
 
+__attribute__((unused))
 static int session_persistent_state_destroy(struct m0_rpc_session *session,
 					    struct m0_db_tx       *tx)
 {
@@ -1204,6 +1210,8 @@ static int session_persistent_state_destroy(struct m0_rpc_session *session,
 	M0_ENTRY("session: %p", session);
 	M0_ASSERT(session != NULL);
 
+	return 0;
+
 	for (i = 0; i < session->s_nr_slots; i++) {
 		slot = session->s_slot_table[i];
 		if (slot != NULL && slot->sl_cob != NULL) {
@@ -1227,7 +1235,7 @@ M0_INTERNAL int m0_rpc_rcv_session_terminate(struct m0_rpc_session *session)
 {
 	struct m0_rpc_machine *machine;
 	struct m0_rpc_conn    *conn;
-	struct m0_db_tx        tx;
+//	struct m0_db_tx        tx;
 	int                    rc;
 
 	M0_ENTRY("session: %p", session);
@@ -1244,7 +1252,7 @@ M0_INTERNAL int m0_rpc_rcv_session_terminate(struct m0_rpc_session *session)
 	session_state_set(session, M0_RPC_SESSION_TERMINATING);
 	/* For receiver side session, no slots are on ready_slots list
 	   since all reply items are bound items. */
-
+/*
 	rc = m0_db_tx_init(&tx, session->s_cob->co_dom->cd_dbenv, 0);
 	if (rc == 0) {
 		rc = session_persistent_state_destroy(session, &tx);
@@ -1253,7 +1261,8 @@ M0_INTERNAL int m0_rpc_rcv_session_terminate(struct m0_rpc_session *session)
 		else
 			m0_db_tx_abort(&tx);
 	}
-
+*/
+	rc = 0;
 	if (rc == 0)
 		session_state_set(session, M0_RPC_SESSION_TERMINATED);
 	else
-- 
1.8.3.2

