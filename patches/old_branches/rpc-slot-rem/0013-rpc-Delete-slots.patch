From dbe0da2520c7d26cd238f24a0d00ec7510783b25 Mon Sep 17 00:00:00 2001
From: Amit Jambure <Amit_Jambure@xyratex.com>
Date: Fri, 24 May 2013 15:47:01 +0530
Subject: [PATCH 13/60] rpc: Delete slots.

---
 rpc/formation2.c   | 36 +--------------------------
 rpc/session_foms.c | 73 +++---------------------------------------------------
 2 files changed, 5 insertions(+), 104 deletions(-)

diff --git a/rpc/formation2.c b/rpc/formation2.c
index 00741db..ab511d3 100644
--- a/rpc/formation2.c
+++ b/rpc/formation2.c
@@ -51,8 +51,6 @@ static void frm_fill_packet(struct m0_rpc_frm *frm, struct m0_rpc_packet *p);
 static void frm_fill_packet_from_item_sources(struct m0_rpc_frm    *frm,
 					      struct m0_rpc_packet *p);
 static bool frm_packet_ready(struct m0_rpc_frm *frm, struct m0_rpc_packet *p);
-static bool frm_try_to_bind_item(struct m0_rpc_frm  *frm,
-				 struct m0_rpc_item *item);
 static void frm_try_merging_item(struct m0_rpc_frm  *frm,
 				 struct m0_rpc_item *item,
 				 m0_bcount_t         limit);
@@ -378,7 +376,7 @@ frm_which_qtype(struct m0_rpc_frm *frm, const struct m0_rpc_item *item)
 	M0_PRE(item != NULL);
 
 	oneway          = m0_rpc_item_is_oneway(item);
-	bound           = oneway ? false : m0_rpc_item_is_bound(item);
+	bound           = !oneway; /* XXX we don't want bound/unbound anymore*/
 	deadline_passed = m0_time_now() >= item->ri_deadline;
 
 	M0_LOG(M0_DEBUG,
@@ -564,13 +562,6 @@ static void frm_fill_packet(struct m0_rpc_frm *frm, struct m0_rpc_packet *p)
 				goto out;
 			if (item_will_exceed_packet_size(item, p, frm))
 				continue;
-			if (m0_rpc_item_is_unbound(item)) {
-				bound = frm_try_to_bind_item(frm, item);
-				if (!bound)
-					continue;
-			}
-			M0_ASSERT(m0_rpc_item_is_oneway(item) ||
-				  m0_rpc_item_is_bound(item));
 			if (M0_FI_ENABLED("skip_oneway_items") &&
 			    m0_rpc_item_is_oneway(item))
 				continue;
@@ -668,31 +659,6 @@ out:
 	M0_LEAVE();
 }
 
-/**
-   @see m0_rpc_frm_ops::f_item_bind()
- */
-static bool
-frm_try_to_bind_item(struct m0_rpc_frm *frm, struct m0_rpc_item *item)
-{
-	bool result;
-
-	M0_ENTRY("frm: %p item: %p", frm, item);
-	M0_PRE(frm != NULL &&
-	       item != NULL &&
-	       item->ri_session != NULL &&
-	       m0_rpc_item_is_unbound(item));
-	M0_PRE(frm->f_ops != NULL &&
-	       frm->f_ops->fo_item_bind != NULL);
-	M0_LOG(M0_DEBUG, "session: %p id: %llu", item->ri_session,
-		   (unsigned long long)item->ri_session->s_session_id);
-
-	/* See item_bind() in rpc/frmops.c */
-	result = frm->f_ops->fo_item_bind(item);
-
-	M0_LEAVE("result: %s", (char *)m0_bool_to_str(result));
-	return result;
-}
-
 M0_INTERNAL void m0_rpc_frm_remove_item(struct m0_rpc_frm  *frm,
 					struct m0_rpc_item *item)
 {
diff --git a/rpc/session_foms.c b/rpc/session_foms.c
index 18c5871..ca35126 100644
--- a/rpc/session_foms.c
+++ b/rpc/session_foms.c
@@ -150,7 +150,7 @@ M0_INTERNAL int m0_rpc_fom_conn_establish_tick(struct m0_fom *fom)
 	struct m0_rpc_fop_conn_establish_rep *reply;
 	struct m0_rpc_fop_conn_establish_ctx *ctx;
 	struct m0_rpc_fop_conn_establish     *request;
-	struct m0_rpc_onwire_slot_ref        *ow_sref;
+	struct m0_rpc_item_header2           *header;
 	struct m0_fom_timeout                *fom_timeout;
 	struct m0_fop                        *fop;
 	struct m0_fop                        *fop_rep;
@@ -188,7 +188,7 @@ M0_INTERNAL int m0_rpc_fom_conn_establish_tick(struct m0_fom *fom)
 	M0_ASSERT(reply != NULL);
 
 	item = &fop->f_item;
-	ow_sref = &item->ri_slot_refs[0].sr_ow;
+	header = &item->ri_header;
 	/*
 	 * On receiver side CONN_ESTABLISH fop is wrapped in
 	 * m0_rpc_fop_conn_etablish_ctx object.
@@ -225,26 +225,11 @@ M0_INTERNAL int m0_rpc_fom_conn_establish_tick(struct m0_fom *fom)
 		goto ret;
 	}
 	rc = m0_rpc_rcv_conn_init(conn, ctx->cec_sender_ep, machine,
-				  &ow_sref->osr_uuid);
+				  &header->osr_uuid);
 	if (rc == 0) {
 		session0 = m0_rpc_conn_session0(conn);
-		if (ow_sref->osr_slot_id >= session0->s_nr_slots) {
-			rc = -EPROTO;
-			m0_rpc_conn_fini_locked(conn);
-			goto out;
-		}
 		conn->c_sender_id = m0_rpc_id_generate();
 		conn_state_set(conn, M0_RPC_CONN_ACTIVE);
-
-		/* See [1] at the end of function */
-		slot = session0->s_slot_table[ow_sref->osr_slot_id];
-		M0_ASSERT(slot != NULL);
-		item->ri_session = session0;
-		m0_rpc_slot_item_add_internal(slot, item);
-		/* See [2] at the end of function */
-		ow_sref->osr_sender_id = SENDER_ID_INVALID;
-		M0_ASSERT(conn_state(conn) == M0_RPC_CONN_ACTIVE);
-		M0_ASSERT(m0_rpc_conn_invariant(conn));
 	}
 	m0_rpc_machine_unlock(machine);
 
@@ -279,45 +264,6 @@ M0_INTERNAL void m0_rpc_fom_conn_establish_addb_init(struct m0_fom *fom,
 }
 
 /*
- * [1]
- * As CONN_ESTABLISH request is directly submitted for execution.
- * Add the item explicitly to the slot0. This makes the slot
- * symmetric to corresponding sender side slot.
- */
-
-/* [2]
- * IMPORTANT
- * @code
- *     item->ri_slot_refs[0].sr_sender_id = SENDER_ID_INVALID;
- * @endcode
- * Request item has SENDER_ID_INVALID.
- * slot_item_add_internal() overwrites it with conn->c_sender_id.
- * But we want reply to have sender_id SENDER_ID_INVALID.
- * m0_rpc_reply_post() simply copies sender id from req item to
- * reply item as it is. So set sender id of request item
- * to SENDER_ID_INVALID
- */
-
-/* [3]
- * CONN_ESTABLISH item is directly submitted for execution. Update
- * rpc-layer stats on INCOMING path here.
- */
-
-/* [4]
- * IMPORTANT: No reply is sent if conn establishing is failed.
- *
- * ACTIVE session is required to send reply. In case of, successful
- * conn establish operation, there is ACTIVE SESSION_0 and slot 0
- * (in the newly established ACTIVE conn) to send reply.
- *
- * But there is no SESSION_0 (in fact here is no conn object) if
- * conn establish operation is failed. Hence reply cannot be sent.
- *
- * In this case, sender will time-out and mark sender side conn
- * as FAILED.
- */
-
-/*
  * FOM session create
  */
 
@@ -342,7 +288,6 @@ M0_INTERNAL int m0_rpc_fom_session_establish_tick(struct m0_fom *fom)
 	struct m0_rpc_session                   *session;
 	struct m0_rpc_conn                      *conn;
 	struct m0_rpc_machine                   *machine;
-	uint32_t                                 slot_cnt;
 	int                                      rc;
 
 	M0_ENTRY("fom: %p", fom);
@@ -357,20 +302,10 @@ M0_INTERNAL int m0_rpc_fom_session_establish_tick(struct m0_fom *fom)
 	reply = m0_fop_data(fop_rep);
 	M0_ASSERT(reply != NULL);
 
-	slot_cnt = request->rse_slot_cnt;
-
-	session = NULL;
-	if (slot_cnt == 0) { /* There should be some upper limit to slot_cnt */
-		rc = -EINVAL;
-		goto out;
-	}
-
 	item = &fop->f_item;
 	M0_ASSERT(item->ri_session != NULL);
-
 	conn = item->ri_session->s_conn;
 	M0_ASSERT(conn != NULL);
-
 	machine = conn->c_rpc_machine;
 
 	RPC_ALLOC_PTR(session, SESSION_FOM_SESSION_ESTABLISH_TICK,
@@ -384,7 +319,7 @@ M0_INTERNAL int m0_rpc_fom_session_establish_tick(struct m0_fom *fom)
 		goto out;
 	}
 	m0_rpc_machine_lock(machine);
-	rc = m0_rpc_session_init_locked(session, conn, slot_cnt);
+	rc = m0_rpc_session_init_locked(session, conn, 1 /* unused */);
 	if (rc == 0) {
 		do {
 			session->s_session_id = m0_rpc_id_generate();
-- 
1.8.3.2

