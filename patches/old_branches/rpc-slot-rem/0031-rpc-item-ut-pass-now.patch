From bb833570bb2528d01cf7973367d046e4bcc0b04b Mon Sep 17 00:00:00 2001
From: Andriy Tkachuk <andriy_tkachuk@xyratex.com>
Date: Wed, 29 Jan 2014 21:51:01 +0200
Subject: [PATCH 31/60] rpc-item-ut pass now

---
 lib/cookie.h        |   2 +-
 rpc/conn.c          |   1 +
 rpc/conn.h          |   3 +
 rpc/frmops.c        |   9 +++
 rpc/item.c          | 194 +++++++++++++++++++++++++++++++++++++++++++++++++++-
 rpc/item.h          |   6 ++
 rpc/item_internal.h |   5 +-
 rpc/rpc.c           |   8 +++
 rpc/rpc_machine.c   |   7 --
 rpc/rpc_onwire.h    |   5 +-
 rpc/session_foms.c  |   3 +
 rpc/ut/item.c       |  77 ++++++---------------
 12 files changed, 250 insertions(+), 70 deletions(-)

diff --git a/lib/cookie.h b/lib/cookie.h
index 805e039..092cb1a 100644
--- a/lib/cookie.h
+++ b/lib/cookie.h
@@ -72,8 +72,8 @@ M0_INTERNAL void m0_cookie_new(uint64_t * gen);
 /**
  * Embeds address of an object along with a generation-count in a cookie.
  *
- * @param obj (in)	 address of an object
  * @param cookie (out)   address of a cookie in which obj gets embedded
+ * @param obj (in)	 address of an object
  */
 M0_INTERNAL void m0_cookie_init(struct m0_cookie *cookie, const uint64_t *obj);
 
diff --git a/rpc/conn.c b/rpc/conn.c
index a526b48..0713802 100644
--- a/rpc/conn.c
+++ b/rpc/conn.c
@@ -294,6 +294,7 @@ static int __conn_init(struct m0_rpc_conn      *conn,
 	conn->c_sender_id   = SENDER_ID_INVALID;
 	conn->c_service     = NULL;
 	conn->c_nr_sessions = 0;
+	conn->c_xid         = 0;
 
 	rpc_session_tlist_init(&conn->c_sessions);
 	item_source_tlist_init(&conn->c_item_sources);
diff --git a/rpc/conn.h b/rpc/conn.h
index f4faa3c..73b48c5 100644
--- a/rpc/conn.h
+++ b/rpc/conn.h
@@ -263,6 +263,9 @@ struct m0_rpc_conn {
 	/** Counts number of sessions (excluding session 0) */
 	uint64_t                  c_nr_sessions;
 
+	/** Unique item identifier counter */
+	uint64_t                  c_xid;
+
 	/** List of all the sessions created under this rpc connection.
 	    m0_rpc_session objects are placed in this list using
 	    m0_rpc_session::s_link.
diff --git a/rpc/frmops.c b/rpc/frmops.c
index 3f39783..47851ad 100644
--- a/rpc/frmops.c
+++ b/rpc/frmops.c
@@ -456,6 +456,15 @@ static void item_sent(struct m0_rpc_item *item)
 		 */
 		stats->rs_nr_resent_items++;
 
+	/*
+	 * Request and Reply items take hold on session until
+	 * they are SENT/FAILED.
+	 * See: m0_rpc__post_locked(), m0_rpc_reply_post()
+	 *      m0_rpc_item_send()
+	 */
+	if (m0_rpc_item_is_request(item) || m0_rpc_item_is_reply(item))
+		m0_rpc_session_release(item->ri_session);
+
 	if (m0_rpc_item_is_request(item)) {
 		m0_rpc_item_change_state(item, M0_RPC_ITEM_WAITING_FOR_REPLY);
 		if (item->ri_pending_reply != NULL) {
diff --git a/rpc/item.c b/rpc/item.c
index 2fb6c92..27727b0 100644
--- a/rpc/item.c
+++ b/rpc/item.c
@@ -41,6 +41,9 @@ static int item_entered_in_urgent_state(struct m0_sm *mach);
 static void item_timer_cb(struct m0_sm_timer *timer);
 static void item_timedout(struct m0_rpc_item *item);
 static void item_resend(struct m0_rpc_item *item);
+static int item_reply_received(struct m0_rpc_item *reply,
+			       struct m0_rpc_item **req_out);
+static int req_replied(struct m0_rpc_item *req, struct m0_rpc_item *reply);
 
 M0_TL_DESCR_DEFINE(rpcitem, "rpc item tlist", M0_INTERNAL,
 		   struct m0_rpc_item, ri_field,
@@ -91,6 +94,7 @@ M0_INTERNAL int m0_rpc_item_module_init(void)
 	 */
 	m0_xc_verno_init();
 	m0_xc_rpc_onwire_init();
+	m0_xc_cookie_init();
 
 	m0_rwlock_init(&rpc_item_types_lock);
 	rit_tlist_init(&rpc_item_types_list);
@@ -364,6 +368,13 @@ void m0_rpc_item_fini(struct m0_rpc_item *item)
 	if (item->ri_sm.sm_state > M0_RPC_ITEM_UNINITIALISED)
 		m0_rpc_item_sm_fini(item);
 
+	if (item->ri_reply != NULL) {
+		m0_rpc_item_put(item->ri_reply);
+		item->ri_reply = NULL;
+	}
+	if (itemq_tlink_is_in(item))
+		m0_rpc_frm_remove_item(item->ri_frm, item);
+
 	itemq_tlink_fini(item);
 	packet_item_tlink_fini(item);
 	rpcitem_tlink_fini(item);
@@ -479,6 +490,18 @@ M0_INTERNAL void m0_rpc_item_failed(struct m0_rpc_item *item, int32_t rc)
 	M0_ENTRY("FAILED: item: %p error %d", item, rc);
 
 	item->ri_rmachine->rm_stats.rs_nr_failed_items++;
+	/*
+	 * Request and Reply items take hold on session until
+	 * they are SENT/FAILED.
+	 * See: m0_rpc__post_locked(), m0_rpc_reply_post()
+	 *      m0_rpc_item_send()
+	 */
+	if (M0_IN(item->ri_sm.sm_state, (M0_RPC_ITEM_ENQUEUED,
+					 M0_RPC_ITEM_URGENT,
+					 M0_RPC_ITEM_SENDING)) &&
+	   (m0_rpc_item_is_request(item) || m0_rpc_item_is_reply(item)))
+		m0_rpc_session_release(item->ri_session);
+
 	item->ri_error = rc;
 	m0_rpc_item_change_state(item, M0_RPC_ITEM_FAILED);
 	m0_rpc_item_stop_timer(item);
@@ -701,8 +724,15 @@ M0_INTERNAL void m0_rpc_item_send(struct m0_rpc_item *item)
 			return;
 		}
 	}
+
 	item->ri_nr_sent++;
+	/*
+	 * This hold will be released when the item is SENT or FAILED.
+	 * See rpc/frmops.c:item_sent() and m0_rpc_item_failed()
+	 */
+	m0_rpc_session_hold_busy(item->ri_session);
 	m0_rpc_frm_enq_item(&item->ri_session->s_conn->c_rpcchan->rc_frm, item);
+	m0_rpc_item_get(item);
 	M0_LEAVE();
 }
 
@@ -714,10 +744,170 @@ m0_rpc_item_remote_ep_addr(const struct m0_rpc_item *item)
 	return item->ri_session->s_conn->c_rpcchan->rc_destep->nep_addr;
 }
 
-M0_INTERNAL void m0_rpc_item_process_reply(struct m0_rpc_item *item,
+M0_INTERNAL int m0_rpc_item_received(struct m0_rpc_item *item,
+				     struct m0_rpc_machine *machine)
+{
+	struct m0_rpc_item    *req;
+	struct m0_rpc_conn    *conn;
+	struct m0_rpc_session *sess;
+	int rc = 0;
+
+	M0_ENTRY("item: %p, machine: %p", item, machine);
+	M0_PRE(item != NULL);
+	M0_PRE(m0_rpc_machine_is_locked(machine));
+
+	m0_addb_counter_update(&machine->rm_cntr_rcvd_item_sizes,
+			       (uint64_t)m0_rpc_item_size(item));
+	++machine->rm_stats.rs_nr_rcvd_items;
+
+	if (m0_rpc_item_is_oneway(item)) {
+		m0_rpc_item_dispatch(item);
+		M0_RETURN(0);
+	}
+
+	M0_ASSERT(m0_rpc_item_is_request(item) || m0_rpc_item_is_reply(item));
+	m0_rpc_item_get(item);
+
+	if (m0_rpc_item_is_conn_establish(item)) {
+		m0_rpc_item_dispatch(item);
+		M0_RETURN(0);
+	}
+
+	conn = m0_rpc_machine_find_conn(machine, item);
+	if (conn == NULL)
+		M0_RETURN(-ENOENT);
+	sess = m0_rpc_session_search(conn, item->ri_header.osr_session_id);
+	if (sess == NULL)
+		M0_RETURN(-ENOENT);
+	item->ri_session = sess;
+
+	if (m0_rpc_item_is_request(item)) {
+		m0_rpc_session_hold_busy(sess);
+		m0_rpc_item_dispatch(item);
+	} else {
+		rc = item_reply_received(item, &req);
+	}
+
+	M0_RETURN(rc);
+}
+
+static int item_reply_received(struct m0_rpc_item *reply,
+			       struct m0_rpc_item **req_out)
+{
+	struct m0_rpc_item     *req;
+	int                     rc;
+
+	M0_ENTRY("item_reply: %p", reply);
+	M0_PRE(reply != NULL && req_out != NULL);
+
+	*req_out = NULL;
+
+	req = m0_cookie_of(&reply->ri_header.osr_cookie,
+	                   struct m0_rpc_item, ri_cookid);
+	if (req == NULL) {
+		/*
+		 * Either it is a duplicate reply and its corresponding request
+		 * item is pruned from the item list, or it is a corrupted
+		 * reply
+		 * XXX This situation is not expected to arise during testing.
+		 *     When control reaches this point during testing it might
+		 *     be because of a possible bug. So assert.
+		 */
+		M0_RETURN(-EPROTO);
+	}
+	rc = req_replied(req, reply);
+	if (rc == 0)
+		*req_out = req;
+
+	M0_RETURN(rc);
+}
+
+static int req_replied(struct m0_rpc_item *req, struct m0_rpc_item *reply)
+{
+	int rc;
+
+	M0_PRE(req != NULL && reply != NULL);
+
+	if (req->ri_error == -ETIMEDOUT) {
+		/*
+		 * The reply is valid but too late. Do nothing.
+		 */
+		M0_LOG(M0_DEBUG, "rply rcvd, timedout req %p [%s/%u]",
+			req, item_kind(req), req->ri_type->rit_opcode);
+	} else {
+		/*
+		 * This is valid reply case.
+		 */
+		m0_rpc_item_get(reply);
+
+		switch (req->ri_sm.sm_state) {
+		case M0_RPC_ITEM_ENQUEUED:
+		case M0_RPC_ITEM_URGENT:
+			m0_rpc_frm_remove_item(
+				&req->ri_session->s_conn->c_rpcchan->rc_frm,
+				req);
+			m0_rpc_item_process_reply(req, reply);
+			m0_rpc_session_release(req->ri_session);
+			break;
+
+		case M0_RPC_ITEM_SENDING:
+			/*
+			 * Buffer sent callback is still pending;
+			 * postpone reply processing.
+			 * item_sent() will process the reply.
+			 */
+			M0_LOG(M0_DEBUG, "req: %p rply: %p rply postponed",
+			       req, reply);
+			req->ri_pending_reply = reply;
+			break;
+
+		case M0_RPC_ITEM_ACCEPTED:
+		case M0_RPC_ITEM_WAITING_FOR_REPLY:
+			m0_rpc_item_process_reply(req, reply);
+			break;
+
+		case M0_RPC_ITEM_REPLIED:
+			/* Duplicate reply. Drop it. */
+			req->ri_rmachine->rm_stats.rs_nr_dropped_items++;
+			m0_rpc_item_put(reply);
+			break;
+
+		default:
+			M0_ASSERT(false);
+		}
+		rc = 0;
+	}
+	return rc;
+}
+
+M0_INTERNAL void m0_rpc_item_process_reply(struct m0_rpc_item *req,
 					   struct m0_rpc_item *reply)
 {
-	M0_LOG(M0_FATAL, "Not yet implemented");
+	M0_ENTRY("req: %p", req);
+
+	M0_PRE(req != NULL && reply != NULL);
+	M0_PRE(m0_rpc_item_is_request(req));
+	M0_PRE(M0_IN(req->ri_sm.sm_state, (M0_RPC_ITEM_WAITING_FOR_REPLY,
+					   M0_RPC_ITEM_ACCEPTED,
+					   M0_RPC_ITEM_ENQUEUED,
+					   M0_RPC_ITEM_URGENT)));
+
+	m0_rpc_item_stop_timer(req);
+	req->ri_reply = reply;
+	if (req->ri_ops != NULL && req->ri_ops->rio_replied != NULL)
+		req->ri_ops->rio_replied(req);
+
+	m0_rpc_item_change_state(req, M0_RPC_ITEM_REPLIED);
+
+	if (m0_rpc_conn_is_rcv(req->ri_session->s_conn)) {
+		m0_rpc_session_release(req->ri_session);
+		reply->ri_header = req->ri_header;
+		m0_rpc_item_send(reply);
+	}
+
+	m0_rpc_item_put(req);
+
+	M0_LEAVE();
 }
 
 /** @} end of rpc group */
diff --git a/rpc/item.h b/rpc/item.h
index a2b1883..2f9fa7e 100644
--- a/rpc/item.h
+++ b/rpc/item.h
@@ -175,7 +175,13 @@ struct m0_rpc_item {
 	    "pending" until the request item moves to SENT state.
 	 */
 	struct m0_rpc_item              *ri_pending_reply;
+
+	/** Cookie id by which we find the request from the reply. */
+	uint64_t                         ri_cookid;
+
+	/** On-wire data of the item. */
 	struct m0_rpc_item_header2       ri_header;
+
 	/** Item size in bytes. header + payload.
 	    Set during first call to m0_rpc_item_size() on this item.
 	 */
diff --git a/rpc/item_internal.h b/rpc/item_internal.h
index bdd78f6..44bc329 100644
--- a/rpc/item_internal.h
+++ b/rpc/item_internal.h
@@ -60,7 +60,10 @@ M0_INTERNAL void m0_rpc_item_send(struct m0_rpc_item *item);
 M0_INTERNAL const char *item_kind(const struct m0_rpc_item *item);
 M0_INTERNAL const char *item_state_name(const struct m0_rpc_item *item);
 
-M0_INTERNAL void m0_rpc_item_process_reply(struct m0_rpc_item *item,
+M0_INTERNAL int m0_rpc_item_received(struct m0_rpc_item *item,
+				     struct m0_rpc_machine *machine);
+
+M0_INTERNAL void m0_rpc_item_process_reply(struct m0_rpc_item *req,
 					   struct m0_rpc_item *reply);
 
 /** @} */
diff --git a/rpc/rpc.c b/rpc/rpc.c
index 216f1da..cf05f34 100644
--- a/rpc/rpc.c
+++ b/rpc/rpc.c
@@ -191,6 +191,13 @@ M0_INTERNAL int m0_rpc__post_locked(struct m0_rpc_item *item)
 	item->ri_rpc_time = m0_time_now();
 	m0_rpc_item_sm_init(item, M0_RPC_ITEM_OUTGOING);
 
+	m0_cookie_new(&item->ri_cookid);
+	m0_cookie_init(&item->ri_header.osr_cookie, &item->ri_cookid);
+	item->ri_header.osr_uuid       = session->s_conn->c_uuid;
+	item->ri_header.osr_sender_id  = session->s_conn->c_sender_id;
+	item->ri_header.osr_session_id = session->s_session_id;
+	item->ri_header.osr_xid        = session->s_conn->c_xid++;
+
 	m0_rpc_item_send(item);
 
 	M0_RETURN(item->ri_error);
@@ -224,6 +231,7 @@ int m0_rpc_reply_post(struct m0_rpc_item *request, struct m0_rpc_item *reply)
 
 	m0_rpc_machine_lock(machine);
 	m0_rpc_item_sm_init(reply, M0_RPC_ITEM_OUTGOING);
+	m0_rpc_item_process_reply(request, reply);
 	m0_rpc_machine_unlock(machine);
 	M0_RETURN(0);
 }
diff --git a/rpc/rpc_machine.c b/rpc/rpc_machine.c
index 0f8bb1b..9603393 100644
--- a/rpc/rpc_machine.c
+++ b/rpc/rpc_machine.c
@@ -811,13 +811,6 @@ static void packet_received(struct m0_rpc_packet    *p,
 	M0_LEAVE();
 }
 
-static int m0_rpc_item_received(struct m0_rpc_item *item,
-				     struct m0_rpc_machine *machine)
-{
-	M0_LOG(M0_FATAL, "Not yet implemented");
-	return 0;
-}
-
 M0_INTERNAL struct m0_rpc_conn *
 m0_rpc_machine_find_conn(const struct m0_rpc_machine *machine,
 			 const struct m0_rpc_item    *item)
diff --git a/rpc/rpc_onwire.h b/rpc/rpc_onwire.h
index e28d12e..61e5222 100644
--- a/rpc/rpc_onwire.h
+++ b/rpc/rpc_onwire.h
@@ -25,6 +25,8 @@
 
 #include "lib/types.h"        /* uint64_t */
 #include "lib/types_xc.h"     /* m0_uint128_xc */
+#include "lib/cookie.h"
+#include "lib/cookie_xc.h"
 #include "xcode/xcode_attr.h" /* M0_XCA_RECORD */
 
 /**
@@ -39,10 +41,8 @@ enum {
 struct m0_rpc_packet_onwire_header {
 	/* Version */
 	uint32_t poh_version;
-
 	/** Number of RPC items in packet */
 	uint32_t poh_nr_items;
-
 	uint64_t poh_magic;
 } M0_XCA_RECORD;
 
@@ -61,6 +61,7 @@ struct m0_rpc_item_header2 {
 	uint64_t          osr_sender_id;
 	uint64_t          osr_session_id;
 	uint64_t          osr_xid;
+	struct m0_cookie  osr_cookie;
 } M0_XCA_RECORD;
 
 M0_INTERNAL int m0_rpc_item_header1_encdec(struct m0_rpc_item_header1 *ioh,
diff --git a/rpc/session_foms.c b/rpc/session_foms.c
index c852544..1438dfb 100644
--- a/rpc/session_foms.c
+++ b/rpc/session_foms.c
@@ -230,6 +230,9 @@ M0_INTERNAL int m0_rpc_fom_conn_establish_tick(struct m0_fom *fom)
 		session0 = m0_rpc_conn_session0(conn);
 		conn->c_sender_id = m0_rpc_id_generate();
 		conn_state_set(conn, M0_RPC_CONN_ACTIVE);
+		item->ri_session = session0;
+		/* freed at m0_rpc_item_process_reply() */
+		m0_rpc_session_hold_busy(session0);
 	}
 	m0_rpc_machine_unlock(machine);
 
diff --git a/rpc/ut/item.c b/rpc/ut/item.c
index 1696502..d77b679 100644
--- a/rpc/ut/item.c
+++ b/rpc/ut/item.c
@@ -90,7 +90,9 @@ static void test_simple_transitions(void)
 	m0_rpc_machine_get_stats(machine, &stats, true);
 	M0_UT_ASSERT(IS_INCR_BY_1(nr_sent_items) &&
 		     IS_INCR_BY_1(nr_rcvd_items));
+	m0_rpc_machine_lock(item->ri_rmachine);
 	m0_fop_put(fop);
+	m0_rpc_machine_unlock(item->ri_rmachine);
 	M0_LOG(M0_DEBUG, "TEST:1:END");
 }
 
@@ -119,7 +121,9 @@ static void test_timeout(void)
 	M0_UT_ASSERT(IS_INCR_BY_1(nr_dropped_items) &&
 		     IS_INCR_BY_1(nr_timedout_items) &&
 		     IS_INCR_BY_1(nr_failed_items));
+	m0_rpc_machine_lock(item->ri_rmachine);
 	m0_fop_put(fop);
+	m0_rpc_machine_unlock(item->ri_rmachine);
 	M0_LOG(M0_DEBUG, "TEST:2.1:END");
 
 	/* Test [ENQUEUED] ---timeout----> [FAILED] */
@@ -251,7 +255,9 @@ static void test_resend(void)
 	M0_UT_ASSERT(item->ri_nr_sent == 3);
 	M0_UT_ASSERT(item->ri_reply != NULL);
 	M0_UT_ASSERT(chk_state(item, M0_RPC_ITEM_REPLIED));
+	m0_rpc_machine_lock(item->ri_rmachine);
 	m0_fop_put(fop);
+	m0_rpc_machine_unlock(item->ri_rmachine);
 	M0_LOG(M0_DEBUG, "TEST:3.4:END");
 
 	/* Test: INITIALISED -> FAILED transition when m0_rpc_post()
@@ -301,8 +307,11 @@ static void __test_resend(struct m0_fop *fop)
 	M0_UT_ASSERT(item->ri_nr_sent >= 1);
 	M0_UT_ASSERT(item->ri_reply != NULL);
 	M0_UT_ASSERT(chk_state(item, M0_RPC_ITEM_REPLIED));
-	if (fop_put_flag)
+	if (fop_put_flag) {
+		m0_rpc_machine_lock(item->ri_rmachine);
 		m0_fop_put(fop);
+		m0_rpc_machine_unlock(item->ri_rmachine);
+	}
 }
 
 static void __test_timer_start_failure(void)
@@ -382,7 +391,9 @@ static int __test(void)
 	M0_UT_ASSERT(chk_state(item, M0_RPC_ITEM_FAILED));
 	m0_rpc_machine_get_stats(machine, &stats, false);
 	M0_UT_ASSERT(IS_INCR_BY_1(nr_failed_items));
+	m0_rpc_machine_lock(item->ri_rmachine);
 	m0_fop_put(fop);
+	m0_rpc_machine_unlock(item->ri_rmachine);
 	return rc;
 }
 
@@ -454,7 +465,9 @@ static void test_oneway_item(void)
 	arrow_sent_cb_called = fop_release_called = false;
 	rc = m0_rpc_oneway_item_post(&cctx.rcx_connection, item);
 	M0_UT_ASSERT(rc == 0);
+	m0_rpc_machine_lock(item->ri_rmachine);
 	m0_fop_put(fop);
+	m0_rpc_machine_unlock(item->ri_rmachine);
 	M0_UT_ASSERT(!arrow_sent_cb_called);
 	M0_UT_ASSERT(!fop_release_called);
 	m0_fi_enable("frm_fill_packet", "skip_oneway_items");
@@ -466,61 +479,6 @@ static void test_oneway_item(void)
 	m0_fi_disable("frm_fill_packet", "skip_oneway_items");
 }
 
-static struct m0_semaphore done_sem;
-enum {NR_ITEMS = 100};
-
-static void bound_item_replied_cb(struct m0_rpc_item *item)
-{
-	struct cs_ds2_rep_fop *reply;
-	static int             expected = 0;
-
-	M0_UT_ASSERT(item->ri_error == 0 && item->ri_reply != NULL);
-	reply = m0_fop_data(m0_rpc_item_to_fop(item->ri_reply));
-	M0_UT_ASSERT(reply->csr_rc == expected);
-	++expected;
-	if (expected == NR_ITEMS)
-		m0_semaphore_up(&done_sem);
-}
-
-static const struct m0_rpc_item_ops bound_item_ops = {
-	.rio_replied = bound_item_replied_cb,
-};
-
-static void test_bound_items(void)
-{
-	struct cs_ds2_req_fop *data;
-	int                    rc;
-	int                    i;
-
-	m0_semaphore_init(&done_sem, 0);
-	/* Test case confirms that items that are posted on a specific slot are
-	   delivered in order.
-
-	   The test posts 100 request items on slot0 of session. Each fop
-	   carries its sequence number. Receiver simply copies the sequence
-	   number in reply fop. RPC is instructed to invoke
-	   bound_item_replied_cb() upon receiving reply to any of the request
-	   items. The callback ensures that the sequence number in
-	   received reply is one greater than sequence number received
-	   in previous call.
-	 */
-	for (i = 0; i < NR_ITEMS; i++) {
-		fop = fop_alloc();
-		data = m0_fop_data(fop);
-		M0_UT_ASSERT(data != NULL);
-		data->csr_value   = i;
-		item              = &fop->f_item;
-		item->ri_session  = session;
-		item->ri_deadline = 0;
-		item->ri_ops      = &bound_item_ops;
-		rc = m0_rpc_post(item);
-		M0_UT_ASSERT(rc == 0);
-		m0_fop_put(fop);
-	}
-	/* wait until reply to all items is received */
-	m0_semaphore_down(&done_sem);
-}
-
 /*
 static void rply_before_sentcb(void)
 {
@@ -572,7 +530,9 @@ static void test_cancel(void)
 	M0_UT_ASSERT(chk_state(item, M0_RPC_ITEM_REPLIED) &&
 		     chk_state(item->ri_reply, M0_RPC_ITEM_ACCEPTED));
 	check_cancel();
+	m0_rpc_machine_lock(item->ri_rmachine);
 	m0_fop_put(fop);
+	m0_rpc_machine_unlock(item->ri_rmachine);
 	M0_LOG(M0_DEBUG, "TEST:5:1:END");
 
 	/* Cancel item while in formation. */
@@ -587,7 +547,9 @@ static void test_cancel(void)
 	M0_UT_ASSERT(item->ri_reply == NULL);
 	M0_UT_ASSERT(chk_state(item, M0_RPC_ITEM_ENQUEUED));
 	check_cancel();
+	m0_rpc_machine_lock(item->ri_rmachine);
 	m0_fop_put(fop);
+	m0_rpc_machine_unlock(item->ri_rmachine);
 	M0_LOG(M0_DEBUG, "TEST:5:2:END");
 
 	/* Cancel while waiting for reply. */
@@ -604,7 +566,9 @@ static void test_cancel(void)
 	m0_nanosleep(m0_time(0, 100000000), NULL);
 	M0_UT_ASSERT(chk_state(item, M0_RPC_ITEM_WAITING_FOR_REPLY));
 	check_cancel();
+	m0_rpc_machine_lock(item->ri_rmachine);
 	m0_fop_put(fop);
+	m0_rpc_machine_unlock(item->ri_rmachine);
 	M0_LOG(M0_DEBUG, "TEST:5:3:END");
 }
 
@@ -618,7 +582,6 @@ const struct m0_test_suite item_ut = {
 		{ "item-resend",            test_resend                 },
 		{ "failure-before-sending", test_failure_before_sending },
 		{ "oneway-item",            test_oneway_item            },
-		{ "bound-item",             test_bound_items            },
 		{ "cancel",                 test_cancel                 },
 		{ NULL, NULL },
 	}
-- 
1.8.3.2

