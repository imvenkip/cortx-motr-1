diff -rupN db-4.8.24.orig/dbinc/db_int.in db-4.8.24/dbinc/db_int.in
--- db-4.8.24.orig/dbinc/db_int.in	2009-08-17 16:26:17.000000000 +0300
+++ db-4.8.24/dbinc/db_int.in	2010-01-30 10:31:15.000000000 +0200
@@ -161,10 +161,15 @@ typedef SH_TAILQ_HEAD(__hash_head) DB_HA
 #define	DB_ALIGN(v, bound)						\
 	(((v) + (bound) - 1) & ~(((uintmax_t)(bound)) - 1))
 
+/* Increment an integer to a specific boundary. */
+#undef  ALIGNI_INC
+#define ALIGNI_INC(i, bound)						\
+        (((i) + (bound) - 1) & ~((bound) - 1))
+
 /* Increment a pointer to a specific boundary. */
-#undef	ALIGNP_INC
-#define	ALIGNP_INC(p, bound)						\
-	(void *)(((uintptr_t)(p) + (bound) - 1) & ~(((uintptr_t)(bound)) - 1))
+#undef  ALIGNP_INC
+#define ALIGNP_INC(p, bound)
+        ALIGNI_INC((uintptr_t)p, bound)						\
 
 /*
  * Print an address as a u_long (a u_long is the largest type we can print
diff -rupN db-4.8.24.orig/dbinc/mp.h db-4.8.24/dbinc/mp.h
--- db-4.8.24.orig/dbinc/mp.h	2009-08-17 16:26:17.000000000 +0300
+++ db-4.8.24/dbinc/mp.h	2010-01-30 10:35:18.000000000 +0200
@@ -477,6 +477,40 @@ struct __mpoolfile {
 #define	BH_FREE_REUSE		0x02
 #define	BH_FREE_UNLOCKED	0x04
 
+/* 
+ * Do not allow generic buffers alignment for DIO in case of DIAG_MVCC. 
+ * The reason is rather simple, DIAG_MVCC requires 4k alignment, which
+ * not suitable for DIO in 2.6.x kernels.
+ */
+#ifdef DIAG_MVCC
+#define BH_ALIGNED
+#undef  BF_ALIGNED
+#define DIO_ALIGNSIZE (4096)
+#else /* !DIAG_MVCC */
+#if defined(HAVE_O_DIRECT) || (defined(HAVE_DIRECTIO) && defined(DIRECTIO_ON))
+/* 
+ * Linux O_DIRECT needs aligned buffers. 2.6.x kernel allows 512 byte
+ * alignment, other versions need page sized (4096).
+ */
+#if defined(linux)
+#define BH_ALIGNED
+#define BF_ALIGNED
+#ifdef LINUX_NEEDS_PAGE_ALIGNMENT
+#define DIO_ALIGNSIZE (4096)
+#else	/* Linux 2.6+ */
+#define DIO_ALIGNSIZE (512)
+#endif
+#else  /* ! defined(linux) */
+#define DIO_ALIGNSIZE (512)
+#endif /* defined(linux) */
+#else
+#define DIO_ALIGNSIZE (512)
+#endif /* HAVE_O_DIRECT */
+#endif /* DIAG_MVCC */
+
+#define BUILD_ASSERT(cond)                                              \
+    ({ switch(42) { case (cond): case 0: break; } })
+
 /*
  * BH --
  *	Buffer header.
@@ -507,7 +541,7 @@ struct __bh {
 
 	roff_t		td_off;		/* MVCC: creating TXN_DETAIL offset. */
 	SH_CHAIN_ENTRY	vc;		/* MVCC: version chain. */
-#ifdef DIAG_MVCC
+#ifdef BH_ALIGNED
 	u_int16_t	align_off;	/* Alignment offset for diagnostics.*/
 #endif
 
@@ -571,66 +605,129 @@ struct __bh_frozen_a {
  */
 #define	BH_VISIBLE(env, bhp, read_lsnp, vlsn)				\
     (bhp->td_off == INVALID_ROFF ||					\
-    ((vlsn).file = VISIBLE_LSN(env, bhp)->file,			\
+    ((vlsn).file = VISIBLE_LSN(env, bhp)->file,			        \
     (vlsn).offset = VISIBLE_LSN(env, bhp)->offset,			\
     LOG_COMPARE((read_lsnp), &(vlsn)) >= 0))
 
 #define	BH_OBSOLETE(bhp, old_lsn, vlsn)	(SH_CHAIN_HASNEXT(bhp, vc) ?	\
-    BH_VISIBLE(env, SH_CHAIN_NEXTP(bhp, vc, __bh), &(old_lsn), vlsn) :\
+    BH_VISIBLE(env, SH_CHAIN_NEXTP(bhp, vc, __bh), &(old_lsn), vlsn) :  \
     BH_VISIBLE(env, bhp, &(old_lsn), vlsn))
 
-#define	MVCC_SKIP_CURADJ(dbc, pgno)					\
-    (dbc->txn != NULL && F_ISSET(dbc->txn, TXN_SNAPSHOT) &&		\
+#define MVCC_SKIP_CURADJ(dbc, pgno)                                     \
+    (dbc->txn != NULL && F_ISSET(dbc->txn, TXN_SNAPSHOT) &&             \
     dbc->txn->td != NULL && __memp_skip_curadj(dbc, pgno))
 
-#if defined(DIAG_MVCC) && defined(HAVE_MPROTECT)
-#define	VM_PAGESIZE 4096
-#define	MVCC_BHSIZE(mfp, sz) do {					\
-	sz += VM_PAGESIZE + sizeof(BH);					\
-	if (mfp->stat.st_pagesize < VM_PAGESIZE)			\
-		sz += VM_PAGESIZE - mfp->stat.st_pagesize;		\
-} while (0)
-
-#define	MVCC_BHALIGN(p) do {						\
-	BH *__bhp;							\
-	void *__orig = (p);						\
-	p = ALIGNP_INC(p, VM_PAGESIZE);					\
-	if ((u_int8_t *)p < (u_int8_t *)__orig + sizeof(BH))		\
-		p = (u_int8_t *)p + VM_PAGESIZE;			\
-	__bhp = (BH *)((u_int8_t *)p - SSZA(BH, buf));			\
-	DB_ASSERT(env,							\
-	    ((uintptr_t)__bhp->buf & (VM_PAGESIZE - 1)) == 0);		\
-	DB_ASSERT(env,							\
-	    (u_int8_t *)__bhp >= (u_int8_t *)__orig);			\
-	DB_ASSERT(env, (u_int8_t *)p + mfp->stat.st_pagesize <		\
-	    (u_int8_t *)__orig + len);					\
-	__bhp->align_off =						\
-	    (u_int16_t)((u_int8_t *)__bhp - (u_int8_t *)__orig);	\
-	p = __bhp;							\
+#ifdef BH_ALIGNED
+
+#define BHSIZE(mfp, sz) do {                                            \
+    BUILD_ASSERT((DIO_ALIGNSIZE & -DIO_ALIGNSIZE) == DIO_ALIGNSIZE);    \
+    sz += DIO_ALIGNSIZE + sizeof(BH);                                   \
+    if (mfp->stat.st_pagesize < DIO_ALIGNSIZE)                          \
+        sz += DIO_ALIGNSIZE - mfp->stat.st_pagesize;                    \
+} while (0)
+
+#define BHALIGN(p) do {                                                 \
+    BH *__bhp;                                                          \
+    void *__orig = (p);                                                 \
+    BUILD_ASSERT((DIO_ALIGNSIZE & -DIO_ALIGNSIZE) == DIO_ALIGNSIZE);    \
+    p = ALIGNP_INC(p, DIO_ALIGNSIZE);                                   \
+    if ((u_int8_t *)p < (u_int8_t *)__orig + sizeof(BH))                \
+        p = (u_int8_t *)p + DIO_ALIGNSIZE;                              \
+    __bhp = (BH *)((u_int8_t *)p - SSZA(BH, buf));                      \
+    DB_ASSERT(env,                                                      \
+        ((uintptr_t)__bhp->buf & (DIO_ALIGNSIZE - 1)) == 0);            \
+    DB_ASSERT(env,                                                      \
+        (u_int8_t *)__bhp >= (u_int8_t *)__orig);                       \
+    DB_ASSERT(env, (u_int8_t *)p + mfp->stat.st_pagesize <              \
+        (u_int8_t *)__orig + len);                                      \
+    __bhp->align_off =                                                  \
+        (u_int16_t)((u_int8_t *)__bhp - (u_int8_t *)__orig);            \
+    p = __bhp;                                                          \
+} while (0)
+
+#define BHUNALIGN(bhp) do {                                             \
+    BUILD_ASSERT((DIO_ALIGNSIZE & -DIO_ALIGNSIZE) == DIO_ALIGNSIZE);    \
+    (bhp) = (BH *)((u_int8_t *)(bhp) - (bhp)->align_off);               \
+} while (0)
+
+#else
+#define BHSIZE(mfp, sz) do {} while (0)
+#define BHALIGN(p) do {} while (0)
+#define BHUNALIGN(p) do {} while (0)
+#endif
+
+/*
+ * Do not align ordinary buffers if BF_ALIGNED is not defined, which is
+ * DIAG_MVCC case.
+ */
+#ifdef BF_ALIGNED
+/* 
+ * Add the alignment to DIO_ALIGNSIZE (may be something < DIO_ALIGNSIZE).
+ * The additional space may be used for storing align offset. We need
+ * u_int16_t for this purpose. If it is less than u_int16_t, we add one
+ * more DIO_ALIGNSIZE for it, plus another DIO_ALIGNSIZE for the last
+ * chunk of buffer if buffer size is not aligned with DIO_ALIGNSIZE just
+ * to be on safer side.
+ */
+#define BFSIZE(sz) do {                                                 \
+    u_int32_t __orig = sz;                                              \
+    BUILD_ASSERT((DIO_ALIGNSIZE & -DIO_ALIGNSIZE) == DIO_ALIGNSIZE);    \
+    sz = ALIGNI_INC(sz, DIO_ALIGNSIZE);                                 \
+    if (sz - __orig < sizeof(u_int16_t))                                \
+        sz += DIO_ALIGNSIZE;                                            \
+    sz += DIO_ALIGNSIZE;                                                \
 } while (0)
 
-#define	MVCC_BHUNALIGN(bhp) do {					\
-	(bhp) = (BH *)((u_int8_t *)(bhp) - (bhp)->align_off);		\
+/*
+ * Align passed pointer p to DIO_ALIGNSIZE, so that it is suitable for DIO.
+ * Save alignment offset in first uint16_t before aligned pointer, so that
+ * we can find it later for unaligning purposes. Read the comment above to
+ * understand sizing policies.
+ */
+#define BFALIGN(p) do {                                                 \
+    u_int8_t  *__p    = (void *)(p);                                    \
+    u_int8_t  *__orig = __p;                                            \
+    BUILD_ASSERT((DIO_ALIGNSIZE & -DIO_ALIGNSIZE) == DIO_ALIGNSIZE);    \
+    __p = ALIGNP_INC(__p, DIO_ALIGNSIZE);                               \
+    if (__p < __orig + sizeof(u_int16_t))                                \
+        __p += DIO_ALIGNSIZE;                                           \
+    *(u_int16_t *)(__p - sizeof(u_int16_t)) = (u_int16_t)(__p - __orig);  \
+    (p) = __p;                                                          \
 } while (0)
 
+/*
+ * Unalign previously aligned pointer. Use align offset saved before aligned
+ * pointer to know how much should we shift. Unalignment is important for
+ * mallocated buffers before freeing.
+ */
+#define BFUNALIGN(p) do {                                               \
+    u_int16_t *__align_off =                                            \
+        (u_int16_t *)((u_int8_t *)(p) - sizeof(u_int16_t));             \
+    BUILD_ASSERT((DIO_ALIGNSIZE & -DIO_ALIGNSIZE) == DIO_ALIGNSIZE);    \
+    (p) = ((u_int8_t *)(p) - *__align_off);                             \
+} while (0)
+
+#else
+#define BFSIZE(sz) do {} while (0)
+#define BFALIGN(p) do {} while (0)
+#define BFUNALIGN(p) do {} while (0)
+#endif
+
+#if defined(DIAG_MVCC) && defined(HAVE_MPROTECT)
 #ifdef linux
-#define	MVCC_MPROTECT(buf, sz, mode) do {				\
-	int __ret = mprotect((buf), (sz), (mode));			\
-	DB_ASSERT(env, __ret == 0);					\
+#define MVCC_MPROTECT(buf, sz, mode) do {                               \
+    int __ret = mprotect((buf), (sz), (mode));                          \
+    DB_ASSERT(env, __ret == 0);                                         \
 } while (0)
 #else
-#define	MVCC_MPROTECT(buf, sz, mode) do {				\
-	if (!F_ISSET(env, ENV_PRIVATE | ENV_SYSTEM_MEM)) {		\
-		int __ret = mprotect((buf), (sz), (mode));		\
-		DB_ASSERT(env, __ret == 0);				\
-	}								\
+#define MVCC_MPROTECT(buf, sz, mode) do {                               \
+    if (!F_ISSET(env, ENV_PRIVATE | ENV_SYSTEM_MEM)) {                  \
+        int __ret = mprotect((buf), (sz), (mode));                      \
+        DB_ASSERT(env, __ret == 0);                                     \
+    }                                                                   \
 } while (0)
 #endif /* linux */
-
-#else /* defined(DIAG_MVCC) && defined(HAVE_MPROTECT) */
-#define	MVCC_BHSIZE(mfp, sz) do {} while (0)
-#define	MVCC_BHALIGN(p) do {} while (0)
-#define	MVCC_BHUNALIGN(bhp) do {} while (0)
+#else
 #define	MVCC_MPROTECT(buf, size, mode) do {} while (0)
 #endif
 
diff -rupN db-4.8.24.orig/dbinc_auto/os_ext.h db-4.8.24/dbinc_auto/os_ext.h
--- db-4.8.24.orig/dbinc_auto/os_ext.h	2009-08-17 16:26:18.000000000 +0300
+++ db-4.8.24/dbinc_auto/os_ext.h	2010-01-30 10:22:41.000000000 +0200
@@ -20,6 +20,9 @@ void __os_ufree __P((ENV *, void *));
 int __os_strdup __P((ENV *, const char *, void *));
 int __os_calloc __P((ENV *, size_t, size_t, void *));
 int __os_malloc __P((ENV *, size_t, void *));
+int __os_calloc_aligned __P((ENV *, size_t, size_t, int, void *));
+int __os_malloc_aligned __P((ENV *, size_t, int, void *));
+int __os_calloc_for_IO __P((ENV *, size_t, size_t, int, void *));
 int __os_realloc __P((ENV *, size_t, void *));
 void __os_free __P((ENV *, void *));
 void *__ua_memcpy __P((void *, const void *, size_t));
diff -rupN db-4.8.24.orig/env/env_file.c db-4.8.24/env/env_file.c
--- db-4.8.24.orig/env/env_file.c	2009-08-17 16:26:28.000000000 +0300
+++ db-4.8.24/env/env_file.c	2010-01-30 10:22:13.000000000 +0200
@@ -9,6 +9,7 @@
 #include "db_config.h"
 
 #include "db_int.h"
+#include "dbinc/mp.h"
 
 /*
  * __db_file_extend --
@@ -37,7 +38,7 @@ __db_file_extend(env, fhp, size)
 	 */
 #undef	FILE_EXTEND_IO_SIZE
 #define	FILE_EXTEND_IO_SIZE	(8 * 1024)
-	if ((ret = __os_calloc(env, FILE_EXTEND_IO_SIZE, 1, &buf)) != 0)
+	if ((ret = __os_calloc_for_IO(env, FILE_EXTEND_IO_SIZE, 1, DIO_ALIGNSIZE, &buf)) != 0)
 		return (ret);
 
 	pages = (db_pgno_t)((size - FILE_EXTEND_IO_SIZE) / MEGABYTE);
diff -rupN db-4.8.24.orig/log/log.c db-4.8.24/log/log.c
--- db-4.8.24.orig/log/log.c	2009-08-17 16:26:29.000000000 +0300
+++ db-4.8.24/log/log.c	2010-01-30 10:22:28.000000000 +0200
@@ -13,6 +13,7 @@
 #include "dbinc/hmac.h"
 #include "dbinc/log.h"
 #include "dbinc/txn.h"
+#include "dbinc/mp.h"
 
 static int	__log_init __P((ENV *, DB_LOG *));
 static int	__log_recover __P((DB_LOG *));
@@ -245,11 +246,22 @@ __log_init(env, dblp)
 	if ((ret = __mutex_alloc(env, MTX_LOG_FLUSH, 0, &lp->mtx_flush)) != 0)
 		return (ret);
 
+	/* 
+	 * Add space for possible alignment.
+	 */
+	BFSIZE(dbenv->lg_bsize);
+
 	/* Initialize the buffer. */
 	if ((ret = __env_alloc(&dblp->reginfo, dbenv->lg_bsize, &p)) != 0) {
 mem_err:	__db_errx( env, "unable to allocate log region memory");
 		return (ret);
 	}
+
+	/* 
+	 * Align with DIO_ALIGNSIZE boundary for possible direct IO. 
+	 */
+	BFALIGN(p);
+
 	lp->regionmax = dbenv->lg_regionmax;
 	lp->buffer_off = R_OFFSET(&dblp->reginfo, p);
 	lp->buffer_size = dbenv->lg_bsize;
@@ -606,7 +618,7 @@ __log_valid(dblp, number, set_persist, f
 	LOGP *persist;
 	logfile_validity status;
 	size_t hdrsize, nr, recsize;
-	int is_hmac, ret;
+	int is_hmac, ret, rlen;
 	u_int8_t *tmp;
 	char *fname;
 
@@ -638,7 +650,15 @@ __log_valid(dblp, number, set_persist, f
 		recsize += db_cipher->adj_size(recsize);
 		is_hmac = 1;
 	}
-	if ((ret = __os_calloc(env, 1, recsize + hdrsize, &tmp)) != 0)
+
+	rlen = recsize + hdrsize;
+	
+	/* 
+	 * Add space for possible direct IO, which requires x512 bytes chunks. 
+	 */
+	BFSIZE(rlen);
+	
+        if ((ret = __os_calloc_for_IO(env, 1, rlen, DIO_ALIGNSIZE, &tmp)) != 0)
 		goto err;
 
 	hdr = (HDR *)tmp;
@@ -649,7 +669,7 @@ __log_valid(dblp, number, set_persist, f
 	 * if we find a preallocated log file where the header has not yet been
 	 * written, so we need to check whether the header is zero-filled.
 	 */
-	if ((ret = __os_read(env, fhp, tmp, recsize + hdrsize, &nr)) != 0 ||
+	if ((ret = __os_read(env, fhp, tmp, rlen, &nr)) != 0 ||
 	    nr != recsize + hdrsize ||
 	    (hdr->len == 0 && persist->magic == 0 && persist->log_size == 0)) {
 		if (ret == 0)
@@ -870,6 +890,8 @@ __log_env_refresh(env)
 	 * owned by any particular process.
 	 */
 	if (F_ISSET(env, ENV_PRIVATE)) {
+		void *p;
+		
 		reginfo->mtx_alloc = MUTEX_INVALID;
 		/* Discard the flush mutex. */
 		if ((t_ret =
@@ -877,7 +899,10 @@ __log_env_refresh(env)
 			ret = t_ret;
 
 		/* Discard the buffer. */
-		__env_alloc_free(reginfo, R_ADDR(reginfo, lp->buffer_off));
+		p = R_ADDR(reginfo, lp->buffer_off);
+		BFUNALIGN(p);
+
+		__env_alloc_free(reginfo, p);
 
 		/* Discard stack of free file IDs. */
 		if (lp->free_fid_stack != INVALID_ROFF)
diff -rupN db-4.8.24.orig/log/log_put.c db-4.8.24/log/log_put.c
--- db-4.8.24.orig/log/log_put.c	2009-08-17 16:26:29.000000000 +0300
+++ db-4.8.24/log/log_put.c	2010-01-19 06:25:24.000000000 +0200
@@ -13,6 +13,7 @@
 #include "dbinc/hmac.h"
 #include "dbinc/log.h"
 #include "dbinc/txn.h"
+#include "dbinc/mp.h"
 
 static int __log_encrypt_record __P((ENV *, DBT *, HDR *, u_int32_t));
 static int __log_file __P((ENV *, const DB_LSN *, char *, size_t));
@@ -494,10 +495,15 @@ __log_flush_commit(env, lsnp, flags)
 	 */
 	if (LF_ISSET(DB_FLUSH))
 		ret = __log_flush_int(dblp, &flush_lsn, 1);
-	else if (!lp->db_log_inmemory && lp->b_off != 0)
-		if ((ret = __log_write(dblp,
-		    dblp->bufp, (u_int32_t)lp->b_off)) == 0)
+	else if (!lp->db_log_inmemory && lp->b_off != 0) {
+		u_int32_t rlen = (u_int32_t)lp->b_off;
+		
+		/* Add space for direct IO buffer */
+		BFSIZE(rlen);
+	
+		if ((ret = __log_write(dblp, dblp->bufp, rlen)) == 0)
 			lp->b_off = 0;
+	}
 
 	/*
 	 * If a flush supporting a transaction commit fails, we must abort the
@@ -1007,8 +1013,12 @@ flush:	MUTEX_LOCK(env, lp->mtx_flush);
 	 * already have one.
 	 */
 	if (lp->b_off != 0 && LOG_COMPARE(&flush_lsn, &lp->f_lsn) >= 0) {
-		if ((ret = __log_write(dblp,
-		    dblp->bufp, (u_int32_t)lp->b_off)) != 0) {
+		u_int32_t rlen = (u_int32_t)lp->b_off;
+		
+		/* Add space for direct IO buffer */
+		BFSIZE(rlen);
+
+		if ((ret = __log_write(dblp, dblp->bufp, rlen)) != 0) {
 			MUTEX_UNLOCK(env, lp->mtx_flush);
 			goto done;
 		}
diff -rupN db-4.8.24.orig/mp/mp_alloc.c db-4.8.24/mp/mp_alloc.c
--- db-4.8.24.orig/mp/mp_alloc.c	2009-08-17 16:26:29.000000000 +0300
+++ db-4.8.24/mp/mp_alloc.c	2010-01-15 23:52:27.000000000 +0200
@@ -65,7 +65,7 @@ __memp_alloc(dbmp, infop, mfp, len, offs
 	if (mfp != NULL) {
 		len = SSZA(BH, buf) + mfp->stat.st_pagesize;
 		/* Add space for alignment padding for MVCC diagnostics. */
-		MVCC_BHSIZE(mfp, len);
+		BHSIZE(mfp, len);
 	}
 
 	MPOOL_REGION_LOCK(env, infop);
@@ -88,15 +88,15 @@ __memp_alloc(dbmp, infop, mfp, len, offs
 alloc:	if ((ret = __env_alloc(infop, len, &p)) == 0) {
 		if (mfp != NULL) {
 			/*
-			 * For MVCC diagnostics, align the pointer so that the
+			 * If necessary, align the pointer so that the
 			 * buffer starts on a page boundary.
 			 */
-			MVCC_BHALIGN(p);
+			BHALIGN(p);
 			bhp = (BH *)p;
 
 			if ((ret = __mutex_alloc(env, MTX_MPOOL_BH,
 			    DB_MUTEX_SHARED, &bhp->mtx_buf)) != 0) {
-				MVCC_BHUNALIGN(bhp);
+				BHUNALIGN(bhp);
 				__env_alloc_free(infop, bhp);
 				goto search;
 			}
diff -rupN db-4.8.24.orig/mp/mp_bh.c db-4.8.24/mp/mp_bh.c
--- db-4.8.24.orig/mp/mp_bh.c	2009-08-17 16:26:29.000000000 +0300
+++ db-4.8.24/mp/mp_bh.c	2010-01-15 23:56:54.000000000 +0200
@@ -613,7 +613,7 @@ no_hp:	MVCC_MPROTECT(bhp->buf, pagesize,
 			return (ret);
 		MPOOL_REGION_LOCK(env, infop);
 
-		MVCC_BHUNALIGN(bhp);
+		BHUNALIGN(bhp);
 		__memp_free(infop, bhp);
 		c_mp = infop->primary;
 		c_mp->stat.st_pages--;
diff -rupN db-4.8.24.orig/os/os_alloc.c db-4.8.24/os/os_alloc.c
--- db-4.8.24.orig/os/os_alloc.c	2009-08-17 16:26:30.000000000 +0300
+++ db-4.8.24/os/os_alloc.c	2010-01-30 10:21:45.000000000 +0200
@@ -199,38 +199,34 @@ __os_strdup(env, str, storep)
 }
 
 /*
- * __os_calloc --
- *	The calloc(3) function for DB.
+ * __os_calloc_aligned --
+ *	The calloc for aligned buffer.
  *
- * PUBLIC: int __os_calloc __P((ENV *, size_t, size_t, void *));
+ * PUBLIC: int __os_calloc_aligned __P((ENV *, size_t, size_t, int, void *));
  */
 int
-__os_calloc(env, num, size, storep)
+__os_calloc_aligned(env, num, size, bound, storep)
 	ENV *env;
 	size_t num, size;
+	int bound;
 	void *storep;
 {
 	int ret;
-
+	
 	size *= num;
-	if ((ret = __os_malloc(env, size, storep)) != 0)
+
+	if ((ret = __os_malloc_aligned(env, size, bound, storep)) != 0)
 		return (ret);
 
 	memset(*(void **)storep, 0, size);
-
 	return (0);
 }
 
-/*
- * __os_malloc --
- *	The malloc(3) function for DB.
- *
- * PUBLIC: int __os_malloc __P((ENV *, size_t, void *));
- */
 int
-__os_malloc(env, size, storep)
+__os_malloc_helper(env, size, bound, storep)
 	ENV *env;
 	size_t size;
+	int bound;
 	void *storep;
 {
 	int ret;
@@ -247,10 +243,16 @@ __os_malloc(env, size, storep)
 	size += sizeof(db_allocinfo_t) + 1;
 #endif
 
-	if (DB_GLOBAL(j_malloc) != NULL)
-		p = DB_GLOBAL(j_malloc)(size);
-	else
-		p = malloc(size);
+        if (bound) {
+	        if ((ret = posix_memalign(&p, bound, size)))
+		        return (ret);
+        } else {
+	        if (DB_GLOBAL(j_malloc) != NULL)
+		        p = DB_GLOBAL(j_malloc)(size);
+	        else
+		        p = malloc(size);
+        }
+        
 	if (p == NULL) {
 		/*
 		 * Some C libraries don't correctly set errno when malloc(3)
@@ -262,7 +264,7 @@ __os_malloc(env, size, storep)
 			ret = ENOMEM;
 			__os_set_errno(ENOMEM);
 		}
-		__db_err(env, ret, "malloc: %lu", (u_long)size);
+		__db_err(env, ret, "posix_memalign: %lu", (u_long)size);
 		return (ret);
 	}
 
@@ -286,6 +288,87 @@ __os_malloc(env, size, storep)
 }
 
 /*
+ * __os_malloc_aligned --
+ *	The allocate aligned bytes function.
+ *
+ * PUBLIC: int __os_malloc_aligned __P((ENV *, size_t, int, void *));
+ */
+int
+__os_malloc_aligned(env, size, bound, storep)
+	ENV *env;
+	size_t size;
+	int bound;
+	void *storep;
+{
+	int ret;
+	ret = __os_malloc_helper(env, size, bound, storep);
+	return ret;
+}
+
+/*
+ * __os_calloc --
+ *	The calloc(3) function for DB.
+ *
+ * PUBLIC: int __os_calloc __P((ENV *, size_t, size_t, void *));
+ */
+int
+__os_calloc(env, num, size, storep)
+	ENV *env;
+	size_t num, size;
+	void *storep;
+{
+	int ret;
+
+	size *= num;
+	if ((ret = __os_malloc(env, size, storep)) != 0)
+		return (ret);
+
+	memset(*(void **)storep, 0, size);
+
+	return (0);
+}
+
+/*
+ * __os_calloc_for_IOr --
+ *	The calloc(3) wrapper function for DIO vs. non DIO allocations.
+ *
+ * PUBLIC: int __os_calloc_for_IO __P((ENV *, size_t, size_t, void *));
+ */
+int
+__os_calloc_for_IO(env, num, size, bound, storep)
+	ENV *env;
+	size_t num, size;
+	int bound;
+	void *storep;
+{
+        int ret;
+        
+	if (__os_support_direct_io()) {
+		ret = __os_calloc_aligned(env, num, size, bound, storep);
+	} else {
+		ret = __os_calloc(env, num, size, storep);
+	}
+        return (ret);
+}
+
+/*
+ * __os_malloc --
+ *	The malloc(3) function for DB.
+ *
+ * PUBLIC: int __os_malloc __P((ENV *, size_t, void *));
+ */
+int
+__os_malloc(env, size, storep)
+	ENV *env;
+	size_t size;
+	void *storep;
+{
+	int ret;
+	ret = __os_malloc_helper(env, size, 0, storep);
+	return (ret);
+}
+
+/*
  * __os_realloc --
  *	The realloc(3) function for DB.
  *
diff -rupN db-4.8.24.orig/test/scr003/chk.define db-4.8.24/test/scr003/chk.define
--- db-4.8.24.orig/test/scr003/chk.define	2009-08-17 16:26:31.000000000 +0300
+++ db-4.8.24/test/scr003/chk.define	2010-01-30 05:39:34.000000000 +0200
@@ -75,7 +75,7 @@ egrep '^#define' $d/dbinc/*.h $d/dbinc/*
 	-e '/^TAILQ_/d' \
 	-e '/^UINT64_FMT/d' \
 	-e '/^UINT64_MAX/d' \
-	-e '/^VM_PAGESIZE/d' \
+	-e '/^DIO_ALIGNSIZE/d' \
 	-e '/^WRAPPED_CLASS/d' \
 	-e '/^_WIN32_WINNT/d' \
 	-e '/^__BIT_TYPES_DEFINED__/d' \
