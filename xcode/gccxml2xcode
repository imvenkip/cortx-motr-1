#!/usr/bin/perl

# COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
#
# THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
# HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
# LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
# THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
# BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
# USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
# EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
# THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
# http://www.xyratex.com/contact
#
# Original author: Dmitriy Chumak <dmitriy_chumak@xyratex.com>
# Original creation date: 18-Jul-2012


# This script generates c2 xcode data from gccxml's output.

# For detailed description and usage information please refer to the POD
# documentation at the end of file, after the __END__ marker.


BEGIN {

# check that all required external modules are available and display a hint to
# the user about how they can be installed using default package management
# system, if they are missing

    my $some_module_is_missing = 0;

    my $check_module_availability = sub {

        my ($module, $deb_pkg, $redhat_pkg) = @_;

        my $module_name = $module;

        $module_name =~ s/\.pm$//xms;
        $module_name =~ s#/#::#g;

        if (eval { require $module; 1; } ne 1) {
            $some_module_is_missing = 1;
            print "$module_name perl module is missing\n"
                  . "   It can be installed manually or using package management system:\n"
                  . "     debian based:  apt-get install $deb_pkg\n"
                  . "     red-hat based: yum install $redhat_pkg\n"
                  . "     manually:      cpanm $module_name\n\n";
        }
    };

    # check XML::LibXML module
    &$check_module_availability('XML/LibXML.pm', 'libxml-libxml-perl',
                                                 'perl-XML-LibXML');

    # check List::MoreUtils module
    &$check_module_availability('List/MoreUtils.pm', 'liblist-moreutils-perl',
                                                     'perl-List-MoreUtils');

    die 'Please, install all required modules'
        if ($some_module_is_missing);
}


# enable all features of Modern Perl, almost the same as done by Modern::Perl
# module, but doesn't require it as dependency
use 5.010;
use strict;
use warnings;

# core modules
use Carp;
use File::Basename;
use Getopt::Long qw( :config no_ignore_case );
use Pod::Usage;
use Fatal qw( open close );
use English qw( -no_match_vars ); # avoids regex performance penalty

# external modules (not included into base perl distribution)
use XML::LibXML;
use List::MoreUtils qw( none );


# ###############################################
#  Parser
# ###############################################

my $header_file_name;
my $header_file_path;
my $header_file_id;
my $xcode_name;
my $include_protector_name;
my $dom;


sub get_member_nodes_of
{
    my $node = shift;

    return if !$node->getAttribute('members');

    my @member_ids = split /\s+/, $node->getAttribute('members');
    my @member_nodes;

    for my $member_id (@member_ids) {
        # The 'members' attribute may contain not only direct members of
        # structure, so we need to search by id only for <Field> tags which are
        # direct members of our node.
        my ($member_node) = $dom->findnodes(qq{//Field[\@id='$member_id']});

        if (defined $member_node) {
            push @member_nodes, $member_node;
        }
    }

    return @member_nodes;
}

sub get_type_node_of
{
    my $node = shift;

    my $type_id     = $node->getAttribute('type');
    my ($type_node) = $dom->findnodes(qq{//*[\@id='$type_id']});

    return $type_node;
}

sub get_file_name_of
{
    my $node = shift;

    my $file_id = $node->getAttribute('file');
    my ($file_node) = $dom->findnodes(qq{//File[\@id='$file_id']});

    return $file_node->getAttribute('name');
}

sub set_item_attr
{
    my ($item, $node) = @_;

    if (defined (my $item_attributes = $node->getAttribute('attributes'))) {

        my ($attr_name, $attr_value)
            = $item_attributes =~ / gccxml \( (\w+) , (\w+) \) /xms;

        croak "Incorrect format of gccxml attributes near " . $item->{'name'}
              . ' at ' . get_file_name_of($node) . ':'
              . $node->getAttribute('line')
            if !defined $attr_name || !defined $attr_value;

        $item->{'attribute'}->{$attr_name} = $attr_value;

        if ($attr_name =~ /^xc_opaque$/xms) {
            $item->{'xc_type'} = '&C2_XT_OPAQUE';
        }
    }
}

# this function is modeled after c2_xcode_type_invariant() from xcode/xcode.c
# and it should be kept in sync with it's C ancestor if the latter is changed
sub check_xc_atype_invariant
{
    my $item = shift;

    my %xc_atype = (
        C2_XA_RECORD    => { min_members => 0, max_members => ~0 },
        C2_XA_UNION     => { min_members => 2, max_members => ~0 },
        C2_XA_SEQUENCE  => { min_members => 2, max_members => 2 },
        C2_XA_TYPEDEF   => { min_members => 1, max_members => 1 },
        C2_XA_OPAQUE    => { min_members => 0, max_members => 0 },
        C2_XA_ATOM      => { min_members => 0, max_members => 0 },
    );

    my $type = "$item->{'type'} $item->{'name'}";

    croak "Error: $type should have 'xc_atype' gccxml __attribute__, please"
            . " use an appropriate C2_XCA_* macro to set it"
        if !defined $item->{'attribute'}
           || !defined $item->{'attribute'}->{'xc_atype'};

    my $atype = $item->{'attribute'}->{'xc_atype'};

    croak "Error: Incorrect value ($atype) of 'xc_atype' attribute of '$type',"
            . " please use one of the following values: @{[ keys %xc_atype ]}"
        if none { $atype eq $_ } keys %xc_atype;

    my $members_number = count_members_of($item);
    my $min            = $xc_atype{$atype}->{'min_members'};
    my $max            = $xc_atype{$atype}->{'max_members'};

    croak "Error: incorrect number of members ($members_number) of '$type',"
            . " it should be in range [$min, $max]"
        if $members_number < $min || $members_number > $max;

    # ensure that first field of UNION or SEQUENCE is of type C2_XT_U8,
    # C2_XT_U32, C2_XT_U64 or C2_XT_VOID
    croak "Error: first field of '$type' should be of integral type,"
            . " but it's '$item->{'members'}->[0]->{'type'}' instead"
        if $atype =~ /C2_XA_UNION|C2_XA_SEQUENCE/
           && $item->{'members'}->[0]->{'xc_type'} !~ /C2_XT_(?:U\d{1,2}|VOID)/;
}

sub get_info_about
{
    my $node = shift;

    my $item->{'name'}   = $node->getAttribute('name');
       $item->{'offset'} = $node->getAttribute('offset');
    my $type_node        = get_type_node_of($node);

    given ($type_node->nodeName()) {
        when (/FundamentalType/) {
            $item->{'size'}    = $type_node->getAttribute('size');
            $item->{'type'}    = $type_node->getAttribute('name');

            # Normally, a 'void' C type can't be a valid type of a variable and
            # thus it doesn't have a corresponding xcode C2_XT_XXX type. But
            # just in case of some internal logic error in this scrip, when
            # 'void' could "leak" into generated code, we set xc_type for 'void'
            # to 'UNDEFINED' which will lead to compilation error, so it would
            # be easier to sort such error out.
            $item->{'xc_type'} = $item->{'type'} eq 'void'
                                    ? 'UNDEFINED'
                                    : '&C2_XT_U' . $item->{'size'};
        }

        when (/Typedef/) {
            $item->{'size'}    = get_info_about($type_node)->{'size'};
            $item->{'type'}    = $type_node->getAttribute('name');
            $item->{'xc_type'} = get_info_about($type_node)->{'xc_type'};
        }

        when (/CvQualifiedType/) {
            $item->{'size'}    = get_info_about($type_node)->{'size'};
            $item->{'type'}    = 'const ' . get_info_about($type_node)->{'type'};
            $item->{'xc_type'} = get_info_about($type_node)->{'xc_type'};
        }

        when (/PointerType/) {
            $item->{'size'}    = $type_node->getAttribute('size');
            $item->{'type'}    = get_info_about($type_node)->{'type'} . '*';
            $item->{'xc_type'}
                = get_info_about($type_node)->{'type'} eq 'void'
                    # pointer to 'void' is treated specially, because 'void'
                    # type doesn't have size, but 'void*' is a commonly used
                    # type for buffers; in order to be able to serialize such
                    # buffers with xcode, we set it the same as pointer to
                    # 'unsigned char' or 'u8'.
                    ? '&C2_XT_U8'
                    : get_info_about($type_node)->{'xc_type'};
        }

        when (/ArrayType/) {
            $item->{'size'}    = $type_node->getAttribute('size');
            $item->{'xc_type'} = '&C2_XT_VOID';
        }

        when (/Struct|Union/) {
            my $entity_name    = lc $type_node->nodeName();
            my $item_type_name = $type_node->getAttribute('name') // 'anonymous';

            $item->{'size'}    = $type_node->getAttribute('size');
            $item->{'type'}    = "$entity_name " . ($item_type_name // 'anonymous');
            $item->{'xc_type'} = $item_type_name eq 'c2_void_t' ? '&C2_XT_VOID'
                                 :                                $item_type_name . '_xc'
                                 ;

            # if sturct/union is defined in current header file (the one we
            # are processing), then also get information about its members
            if ($type_node->getAttribute('file') eq $header_file_id) {
                my @member_nodes = get_member_nodes_of($type_node);

                for my $member_node (@member_nodes) {
                    push @{$item->{'members'}}, get_info_about($member_node);
                }
            }
        }

        default {
            croak "Unhandled node type '" . $type_node->nodeName() . "'";
        }
    }

    set_item_attr($item, $node);

    return $item;
}

sub count_members_of
{
    my $item = shift;

    # count union fields as a direct members of enclosing structure, so each
    # union is counted as many times as many members it has
    return scalar map { $_->{'type'} =~ /union/ ? @{$_->{'members'}} : $_ }
                      @{$item->{'members'}};
}

sub get_global_namespace_id
{
    my ($global_ns_node) = $dom->findnodes(qq{//Namespace[\@name='::']});
    return $global_ns_node->getAttribute('id');
}

sub get_header_file_id
{
    my ($header_file_node) = $dom->findnodes(qq{//File[\@name='$header_file_path']});

    croak "Error: unable to find xml tag for header file '$header_file_path' in"
          . " the gccxml's output.\n\nPlease, notice that gccxml writes an exact"
          . " path of it's input arguments into output xml, so input files for"
          . " gccxml and gccxml2xcode should use the same path, for example:\n"
          . "   gccxml -fxml=my_header.gccxml path/to/header/my_header.h\n"
          . "   gccxml2xcode -i path/to/header/my_header.gccxml\n"
          . "\n"
          . "But not a:\n"
          . "   gccxml -fxml=my_header.gccxml path/to/header/my_header.h\n"
          . "   gccxml2xcode -i my_header.gccxml\n"
          . "\n"
          . "Or:\n"
          . "   gccxml -fxml=my_header.gccxml my_header.h\n"
          . "   gccxml2xcode -i path/to/header/my_header.gccxml\n"
          . "\n"
        if !defined $header_file_node;

    return $header_file_node->getAttribute('id');
}

sub init_xml_parser
{
    my $gccxml_file = shift;

    #
    # parse gccxml file
    #

    $dom = XML::LibXML->load_xml(IO => $gccxml_file);

    # index all DOM elements to considerably speeds up XPath queries for large
    # xml documents.
    $dom->indexElements();

    # set global variables
    $header_file_id = get_header_file_id();

    return;
}

sub build_item_list
{
    my $gccxml_file_name = shift;

    init_xml_parser($gccxml_file_name);

    # find all structures which are defined in our header file
    # and have gccxml attribute
    my @struct_nodes
        = $dom->findnodes(qq{//Struct[\@file='$header_file_id'
                                      and not(\@incomplete)
                                      and contains(\@attributes, 'gccxml')]});
    my @items;

    for my $struct_node (@struct_nodes) {

        my $item;

        $item->{'type'}    = lc $struct_node->nodeName();
        $item->{'name'}    = $struct_node->getAttribute('name');
        $item->{'size'}    = $struct_node->getAttribute('size');

        set_item_attr($item, $struct_node);

        my @member_nodes = get_member_nodes_of($struct_node);

        # get information about all members
        for my $member_node (@member_nodes) {
            push @{$item->{'members'}}, get_info_about($member_node);
        }

        $item->{'scope'}
            = $struct_node->getAttribute('context')
                eq get_global_namespace_id() ? '' : 'static ';

        check_xc_atype_invariant($item);

        push @items, $item;
    }

    return @items;
}

# ###############################################
#  Generator
# ###############################################

sub gen_xc_h_header
{
    return <<"END_HEADER"
/* This file is automatically generated from $header_file_name */

#pragma once

#ifndef $include_protector_name
#define $include_protector_name

#ifndef __KERNEL__
#include <sys/types.h>
#endif

#include "xcode/xcode.h"

END_HEADER
}

sub gen_xc_h_footer
{
    return <<"END_FOOTER"

/* $include_protector_name */
#endif

END_FOOTER
}

sub gen_xc_h
{
    my @items = @_;

    my $xcode = gen_xc_h_header();

    # generate forward declarations of xcode type pointers for all global
    # structures
    for my $item (grep { $_->{'scope'} !~ /static/ } @items) {
        $xcode .= 'extern struct c2_xcode_type *' . $item->{'name'} . "_xc;\n";
    }
    $xcode .= "\n";

    # prototypes of xcode init/fini functions
    $xcode .= "void c2_xc_${xcode_name}_init(void);\n";
    $xcode .= "void c2_xc_${xcode_name}_fini(void);\n";

    $xcode .= gen_xc_h_footer();
}

sub gen_xc_c_header
{
    return <<"END_HEADER"
/* This file is automatically generated from $header_file_name */

#include "lib/cdefs.h"                       /* offsetof */
#include "lib/assert.h"
#include "xcode/xcode.h"

#include "$header_file_name"
#include "${xcode_name}_xc.h"

END_HEADER
}

# call visitor function for each item and it's members recursively
sub walk_members_tree
{
    my ($items_ref, $visitor_func) = @_;

    for my $item (@$items_ref) {
        for my $member (@{$item->{'members'}}) {
            &$visitor_func($member);
            if (defined $member->{'members'}) {
                walk_members_tree($member->{'members'}, $visitor_func);
            }
        }
    }
}

# generate declarations of xcode type pointers
sub gen_xc_c_type_struct_decl
{
    my @items = @_;

    my $xcode;

    for my $item (@items) {
        $xcode .= $item->{'scope'} . 'struct c2_xcode_type *' . $item->{'name'} . "_xc;\n";
    }

    return $xcode . "\n";
}

# generate declarations of xcode opaque callbacks
sub gen_xc_c_opaque_func_decl
{
    my @items = @_;

    my $xcode = '';
    my $gen_opaque_func_decl = sub {
        my $item = shift;
        if (defined $item->{'attribute'} && defined $item->{'attribute'}->{'xc_opaque'}) {
            $xcode .= 'int ' . $item->{'attribute'}->{'xc_opaque'}
                      . "(const struct c2_xcode_obj *par,\n\t\t"
                      . "const struct c2_xcode_type **out);\n";
        }
    };

    walk_members_tree(\@items, $gen_opaque_func_decl);

    return $xcode . "\n";
}

# generate definitions and initializations of helper type structures
sub gen_xc_c_helper_type_struct_def
{
    my @items = @_;

    my $xcode;

    for my $item (@items) {

        my $name           = $item->{'name'};
        my $type           = $item->{'type'};
        my $xc_atype       = $item->{'attribute'}->{'xc_atype'};
        my $scope          = $item->{'scope'};
        my $members_number = count_members_of($item);

        $xcode .= <<"END_STRUCT"
static struct _${name}_s {
\tstruct c2_xcode_type  _type;
\tstruct c2_xcode_field _child[$members_number];
} _$name = {
\t._type = {
\t\t.xct_aggr   = $xc_atype,
\t\t.xct_name   = "$name",
\t\t.xct_sizeof = sizeof ($type $name),
\t\t.xct_nr     = $members_number,
\t}
};

${scope}struct c2_xcode_type *${name}_xc = &_${name}._type;
C2_BASSERT(offsetof(struct _${name}_s, _child[0]) ==
\toffsetof(struct c2_xcode_type, xct_child[0]));

END_STRUCT
;
    }

    return $xcode . "\n";
}

sub gen_xc_c_compiletime_checks
{
    my @items = @_;

    my $xcode;

    for my $item (@items) {

        my $name = $item->{'name'};
        my $type = $item->{'type'};

        # NOTICE: gccxml provides offset and size values in bits, so we need to
        # convert them into units of C sizeof - bytes (actually not bytes, but
        # units of sizeof(char) in size, so more portable solution would be to
        # divide values, provided by gccxml, in sizeof(char) directly in the
        # generated C code)
        my $size = $item->{'size'} / 8;

        $xcode .= "C2_BASSERT(sizeof($type $name) == ${size}U);\n\n";

        for my $member (@{$item->{'members'}}) {

            # see above notice about sizes
            my $member_size   = $member->{'size'} / 8;
            my $member_offset = $member->{'offset'} / 8;
            my $union_field = '';

            my $gen_child_check = sub {

                my $child = shift;

            $xcode .= <<"END_BASSERT"
C2_BASSERT(sizeof (($type $name *)0)->$member->{'name'}$union_field == ${member_size}U);
C2_BASSERT(offsetof($type $name, $member->{'name'}$union_field) == ${member_offset}U);
END_BASSERT
;
            };

            if ($member->{'type'} =~ /union/) {
                # if member type is union, than generate code for each
                # field of the union instead of union itself
                for my $union_member (@{$member->{'members'}}) {
                    # see above notice about sizes
                    $member_size   = $union_member->{'size'} / 8;
                    $union_field   = '.' . $union_member->{'name'};
                    &$gen_child_check($union_member);
                }
            }
            else {
                # if member type is other than union, that generate code
                # for the member itself
                &$gen_child_check($member);
            }
        }

        $xcode .= "\n";
    }

    return $xcode . "\n";
}

# generate xcode init func, which initializes all xcode field structures
sub gen_xc_c_init_func
{
    my @items = @_;

    my $xcode = "void c2_xc_${xcode_name}_init(void)\n{\n";

    for my $item (@items) {

        my $child_idx = 0;

        for my $member (@{$item->{'members'}}) {

            my $union_field = '';

            my $gen_child_init = sub {

                my $child = shift;

                my $xc_tag = 0;
                my $opaque_func_name = 'NULL';

                if (defined $child->{'attribute'}) {
                    $xc_tag = $child->{'attribute'}->{'xc_tag'} // 0;
                    $opaque_func_name = $child->{'attribute'}->{'xc_opaque'} // 'NULL';
                }

                $xcode .= <<"END_CHILD_INIT"
\t_$item->{'name'}._child[$child_idx] = (struct c2_xcode_field) {
\t\t.xf_name   = "$child->{'name'}",
\t\t.xf_type   = $child->{'xc_type'},
\t\t.xf_tag    = $xc_tag,
\t\t.xf_opaque = $opaque_func_name,
\t\t.xf_offset = offsetof($item->{'type'} $item->{'name'}, $member->{'name'}$union_field)
\t};
END_CHILD_INIT
;
                $child_idx++;
            };

            if ($member->{'type'} =~ /union/) {
                # if member type is union, than generate init code for each
                # field of the union instead of union itself
                for my $union_member (@{$member->{'members'}}) {
                    $union_field = '.' . $union_member->{'name'};
                    &$gen_child_init($union_member);
                }
            }
            else {
                # if member type is other than union, that generate init code
                # for the member itself
                &$gen_child_init($member);
            }
        }
        $xcode .= "\n";
    }
    $xcode .= "}\n\n";

    return $xcode;
}

sub gen_xc_c_fini_func
{
    return "void c2_xc_${xcode_name}_fini(void)\n{\n}\n";
}

sub gen_xc_c
{
    my @items = @_;

    my $xcode = gen_xc_c_header();

    $xcode .= gen_xc_c_type_struct_decl(@items);
    $xcode .= gen_xc_c_opaque_func_decl(@items);
    $xcode .= gen_xc_c_helper_type_struct_def(@items);
    $xcode .= gen_xc_c_compiletime_checks(@items);
    $xcode .= gen_xc_c_init_func(@items);
    $xcode .= gen_xc_c_fini_func(@items);

    return $xcode;
}

# ###############################################
#  Main
# ###############################################

sub usage
{
    pod2usage(-verbose => 0);
}

sub help
{
    pod2usage(-verbose => 1);
}

sub man
{
    pod2usage(-verbose => 2);
}

my $script_name = basename($PROGRAM_NAME);
my %cli_option  = (
    'input_file_name' => '-' # STDIN
);

sub process_cli_options
{
    help() if !GetOptions(
        'i|input=s'         =>  \$cli_option{'input_file_name'},
        'o|output-prefix=s' =>  \$cli_option{'output_prefix'},
        'x|xcode-name=s'    =>  \$cli_option{'xcode_name'},
        'h|help'            =>  \&help,
        'usage'             =>  \&usage,
        'man'               =>  \&man
    );

    croak "Error: provide either -i or -x option.\n"
          . "Please, see `$script_name --help` for more information."
        if $cli_option{'input_file_name'} eq '-'
           && !defined $cli_option{'xcode_name'};

    # if input is STDIN than also set output to STDOUT,
    # if input is *.gccxml file, than set output prefix to *
    if (!defined $cli_option{'output_prefix'}) {
        ($cli_option{'output_prefix'} = $cli_option{'input_file_name'})
            =~ s/\.gccxml$//xms;
    }

    $cli_option{'output_h_file_name'} = $cli_option{'output_prefix'} . '_xc.h';
    $cli_option{'output_c_file_name'} = $cli_option{'output_prefix'} . '_xc.c';

    # if output prefix is STDOUT, then also set output .h and .c files to STDOUT
    if ($cli_option{'output_prefix'} eq '-') {
        $cli_option{'output_h_file_name'} = '-';
        $cli_option{'output_c_file_name'} = '-';
    }
}

sub set_global_vars
{
    if (defined $cli_option{'xcode_name'}) {
        $xcode_name = $cli_option{'xcode_name'};
    }
    else {
        # trim filename extention and path prefix
        $xcode_name = basename($cli_option{'input_file_name'}, '.gccxml');
        # replace all consecutive spaces and dashes with a single underscore
        $xcode_name =~ s/ \s+ | -+ /_/xmsg;
    }

    # according to the colibri coding style, all header files should be included
    # using full path relative to the colibri/core/ directory; for example
    # trace.h header from colibri/core/lib/ should be included as "lib/trace.h"
    # and not as "trace.h"; so we need to preserve a directory path after the
    # "core/" part.
    if ($cli_option{'input_file_name'} =~ m#/core/#) {
        ($header_file_name = $cli_option{'input_file_name'})
            =~ s#^.*/core/(.*)\.gccxml$#$1.h#xms;
    }
    else {
        # if we processing file not from colibri/core/ source tree, then
        # just use a file name without directory path
        $header_file_name = $xcode_name . '.h';
    }

    if (defined $cli_option{'input_file_name'}) {
        ($header_file_path = $cli_option{'input_file_name'}) =~ s/\.gccxml$/.h/xms;
    }
    else {
        $header_file_path = $header_file_name;
    }

    $include_protector_name = '__COLIBRI_' . uc $xcode_name . '_XC_H__';
}

sub main
{
    process_cli_options();
    set_global_vars();

    # parse gccxml's output
    open my $gccxml_file, "<$cli_option{'input_file_name'}";
    my @items = build_item_list($gccxml_file);
    close $gccxml_file;

    # generate xcode .h file
    open my $h_file, ">$cli_option{'output_h_file_name'}";
    print {$h_file} gen_xc_h(@items)
        or croak "Failed to write '$h_file' file";
    close $h_file;

    # generate xcode .c file
    open my $c_file, ">$cli_option{'output_c_file_name'}";
    print {$c_file} gen_xc_c(@items)
        or croak "Failed to write '$c_file' file";
    close $c_file;
}

main();


__END__

=head1 NAME

gccxml2xcode - generates c2 xcode data from gccxml's output.

=head1 SYNOPSIS

gccxml2xcode -x <name> | -i <input_file> [-o <output_prefix>] [-h|--help]
[--usage] [--man]

=head1 OPTIONS

Either -x or -i option should be provided.

=over 8

=item B<-i|--input>  <file_name>

Input file name, if this option is ommited then STDIN is used instead and
"xcode-name" should be provided via -x option.

=item B<-o|--output-prefix>  <prefix>

Prefix name (all before the last dot) for the output .h and .c files.

=item B<-x|--xcode-name>  <name>

Name of generated xcode data (used in xcode init functions, include protectors,
etc.). This should be equal to the name of an input file of gccxml, but with
file extension removed. E.g. if gccxml proccess example.h, then xcode-name
should be "example". xcode-name is set automatically if -i option is provided.

=item B<-h|--help>

Print this help summary.

=item B<--usage>

Print usage line of this summary.

=item B<--man>

Print the complete manpage.

=back

=head1 DESCRIPTION

The idea behind this script is to use some special gcc's __attribute__() with
C struct declarations in C header files to automatically generate corresponding
xcode data (see c2 xcode documentation in colibri/core/xcode/xcode.h).

It does the same thing as ff2c generator, but instead of using pseudo-code
description of data structures, it uses C structure declarations directly from
.h files. For this purpose .h files are processed by gccxml first, and then
gccxml's output (which is in xml format) are parsed by this script into
internal format, which then used to generate xcode data.

=head2 Gccxml attributes

There is a mapping between ff2c's pseudo-language and gcc's attributes used by
this script to extract additional high-level information about C structures.

  record:      __attribute__((gccxml("xc_atype","C2_XA_RECORD")))
  sequence:    __attribute__((gccxml("xc_atype","C2_XA_SEQUENCE")))
  union:       __attribute__((gccxml("xc_atype","C2_XA_UNION")))
  [] (opaque): __attribute__((gccxml("xc_opaque","c2_package_cred_get")))
  : (tag):     __attribute__((gccxml("xc_tag","NR")))

There is a shorthand macros in xcode/xcode_attr.h: C2_XCA_XXX(). They
should be used instead of bare __attribute__((gccxml(...))):

  record:      C2_XCA_RECORD
  sequence:    C2_XCA_SEQUENCE
  union:       C2_XCA_UNION
  [] (opaque): C2_XCA_OPAQUE("c2_package_cred_get")
  : (tag):     C2_XCA_TAG("NR")

Here are some simple examples:

  struct fid {
    uint64_t        f_container;
    struct c2_cred *p_cred C2_XCA_OPAQUE("c2_package_cred_get");
    uint64_t        f_offset;
  } C2_XCA_RECORD;

  struct optfid {
     uint8_t o_flag;
     union {
        struct fid  o_fid   C2_XCA_TAG("1");
        uint32_t    o_short C2_XCA_TAG("3");
     } u;
  } C2_XCA_UNION;

This script generates xcode data only for global C structures which have
either record, sequence or union gccxml attribute. All other structures
without gccxml attribute are ignored. Structures can be defined inside other
structures, but they still have to used gccxml attribute if they need to be
processed.

=head2 Gccxml output format

Gccxml uses relatively simple output format. All information is stored in a
plain list of xml nodes of different type. Some nodes may refer to other nodes
by "type", "members" and "id" attributes.

Here is an example. Consider the following code in C:

  struct fid {
   uint64_t f_container;
   uint64_t f_offset;
  } __attribute__((gccxml("xc_atype","C2_XA_RECORD")));

Gccxml will generate xml nodes for this example like these:

  <Struct id="_366" name="fid" context="_1" mangled="3fid" demangled="fid"
          location="f2:13" file="f2" line="13" artificial="1"
          attributes="gccxml(xc_atype,C2_XA_RECORD)" size="128" align="64"
          members="_654 _655 _656 _657 _658 _659 " bases=""
  />

This xml node tells us that it describes a structure with name "fid",
attributes "gccxml(xc_atype,C2_XA_RECORD)" and members with ids "_654 _655
_656 _657 _658 _659 ".

All members are described by a <Field> tags with corresponding "id"
attributes:

  <Field id="_654" name="f_container" type="_376" offset="0" context="_366"
         access="public" location="f2:14" file="f2" line="14"
  />

  <Field id="_655" name="f_offset" type="_376" offset="64" context="_366"
         access="public" location="f2:15" file="f2" line="15"
  />

Each of the following type:

  <Typedef id="_376" name="uint64_t" type="_11" context="_1" location="f4:56"
  file="f4" line="56"/>

Which finally is:

  <FundamentalType id="_11" name="long unsigned int" size="64" align="64"/>

Note that only complete primary types have "size" attribute.

=head2 XPath

This script uses XPath queries to find required xml nodes. XPath syntax quick
reference can be found on the following web site:

  http://www.w3schools.com/xpath/xpath_syntax.asp

=head2 Internal data format

Here is an example of internal data structure used by this script to store
information extracted from gccxml, which is then used to generate xcode. It's
represented using native perl syntax, this dump is produced using Data::Dumper
module:

  [
    {
      'name' => 'optfidarray',
      'type' => 'struct',
      'scope' => '',
      'size' => '256'
      'attribute' => {
                       'xc_atype' => 'C2_XA_SEQUENCE'
                     },
      'members' => [
                     {
                       'xc_type' => '&C2_XT_U64',
                       'name' => 'ofa_nr',
                       'type' => 'uint64_t',
                       'size' => '64'
                     },
                     {
                       'xc_type' => 'optfid_xc',
                       'name' => 'ofa_data',
                       'type' => 'struct optfid*',
                       'size' => '64'
                     },
                     {
                       'xc_type' => 'fid_xc',
                       'name' => 'p_fid',
                       'type' => 'struct fid',
                       'size' => '128'
                       'members' => [
                                      {
                                        'xc_type' => '&C2_XT_U64',
                                        'name' => 'f_container',
                                        'type' => 'uint64_t',
                                        'size' => '64'
                                      },
                                      {
                                        'xc_type' => '&C2_XT_U64',
                                        'name' => 'f_offset',
                                        'type' => 'uint64_t',
                                        'size' => '64'
                                      }
                                    ]
                     }
                   ]
    }
  ];

And here is a corresponding C structure:

  struct fid {
    uint64_t f_container;
    uint64_t f_offset;
  } __attribute__((gccxml("xc_atype","C2_XA_RECORD")));

  struct optfidarray {
    uint64_t ofa_nr;
    struct optfid *ofa_data;
    struct fid p_fid;
  } __attribute__((gccxml("xc_atype","C2_XA_SEQUENCE")));

=cut

