/* -*- C -*- */
/*
 * COPYRIGHT 2011 XYRATEX TECHNOLOGY LIMITED
 *
 * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
 * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
 * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
 * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
 * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
 * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
 * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
 *
 * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
 * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
 * http://www.xyratex.com/contact
 *
 * Original author: Nikita Danilov <nikita_danilov@xyratex.com>
 * Original creation date: 30-Dec-2011
 */

/**
   @addtogroup xcode

   @{
 */

#include <stdbool.h>
#include <stdio.h>
#include <assert.h>
#include <string.h>                         /* strcpy, strcat, strrchr */

#include "xcode/ff2c/parser.h"
#include "xcode/ff2c/gen.h"

#define out printf

static char *suffix(const char *orig, size_t nr, const char *new, char *buf)
{
	char *ch;

	strncpy(buf, orig, nr);
	buf[nr] = 0;
	ch = strrchr(buf, '.');
	if (ch != NULL) {
		sprintf(ch + 1, "%s\"", new);
	}
	return buf;
}

static const char *cnames[] = {
	[FTT_VOID]       = "c2_void_t",
	[FTT_U8]         = "uint8_t",
	[FTT_U32]        = "uint32_t",
	[FTT_U64]        = "uint64_t",
	[FTT_RECORD]     = "struct",
	[FTT_UNION]      = "struct", /* sic */
	[FTT_SEQUENCE]   = "struct", /* sic */
	[FTT_IDENTIFIER] = "struct"  /* sic */
};

static void indent(int depth)
{
	static const char ruler[] = "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t";

	out("%*.*s", depth, depth, ruler);
}

static void out_token(const struct ff2c_token *tok)
{
	out("%*.*s", (int)tok->ft_len, (int)tok->ft_len, tok->ft_val);
}

static void field_h(const struct ff2c_term *decl, int depth, bool ptr);

static void record_h(const struct ff2c_term *type, int depth)
{
	const struct ff2c_term *field;

	for (field = type->fn_head; field != NULL; field = field->fn_next)
		field_h(field, depth + 1, false);
}

static void union_h(const struct ff2c_term *type, int depth)
{
	const struct ff2c_term *field;

	field = type->fn_head;
	field_h(field, depth + 1, false);
	indent(depth + 1);
	out("union {\n");
	for (field = field->fn_next; field != NULL; field = field->fn_next)
		field_h(field, depth + 2, false);
	indent(depth + 1);
	out("} u;\n");
}

static void sequence_h(const struct ff2c_term *type, int depth)
{
	const struct ff2c_term *field;

	field = type->fn_head;
	field_h(field, depth + 1, false);
	field = field->fn_next;
	field_h(field, depth + 1, true);
	assert(field->fn_next == NULL);
}

static void type_h(const struct ff2c_term *type, int depth,
		   const struct ff2c_token *name)
{
	indent(depth);
	if (type->fn_tok.ft_type == FTT_OPAQUE) {
		out("struct ");
		out_token(&type->fn_tok);
		out(" *");
	} else {
		const char *cname;

		cname = cnames[type->fn_tok.ft_type];
		assert(cname != NULL);

		out("%s", cname);
		if (name != NULL) {
			out(" ");
			out_token(name);
		}
		if (type->fn_type == FNT_COMPOUND) {
			out(" {\n");
			switch (type->fn_tok.ft_type) {
			case FTT_RECORD:
				record_h(type, depth);
				break;
			case FTT_UNION:
				union_h(type, depth);
				break;
			case FTT_SEQUENCE:
				sequence_h(type, depth);
				break;
			default:
				assert("impossible" == 0);
			}
			indent(depth);
			out("}");
		}
	}
}

static void field_h(const struct ff2c_term *field, int depth, bool ptr)
{
	const struct ff2c_term *type;

	assert(field->fn_type == FNT_DECLARATION);

	type = field->fn_head;
	assert(type != NULL);

	type_h(type, depth,
	       type->fn_type == FNT_TYPENAME ? &type->fn_tok : NULL);
	out(" %s", ptr ? "*" : "");
	out_token(&field->fn_tok);
	out(";\n");
}

static void decl_h(const struct ff2c_term *decl)
{
	const struct ff2c_term *type;

	type = decl->fn_head;
	assert(type != NULL);

	switch (type->fn_type) {
	case FNT_COMPOUND:
		type_h(type, 0, &decl->fn_tok);
		out(";\n\n");
		break;
	case FNT_ATOMIC:
	case FNT_TYPENAME:
		assert("not supported" == NULL);
		break;
	default:
		assert("impossible type" == NULL);
	}
}

int ff2c_h_gen(const struct ff2c_term *term, const struct ff2c_gen_opt *opt)
{
	struct ff2c_term *st;
	char              buf[500];
	bool              first_decl = true;

	out("/* This file is automatically generated from %s.ff */\n\n",
	    opt->go_basename);
	out("#ifndef %s\n"
	    "#define %s\n\n", opt->go_guardname, opt->go_guardname);
	out("#include <sys/types.h>\n\n");

	for (st = term->fn_head; st != NULL; st = st->fn_next) {
		if (st->fn_type == FNT_REQUIRE) {
			out("#include %s\n", suffix(st->fn_tok.ft_val,
						    st->fn_tok.ft_len,
						    "h", buf));
		} else {
			assert(st->fn_type == FNT_DECLARATION);
			if (first_decl) {
				out("\n");
				first_decl = false;
			}
			decl_h(st);
		}
	}
	out("\n");
	for (st = term->fn_head; st != NULL; st = st->fn_next) {
		if (st->fn_type == FNT_DECLARATION) {
			out("extern struct c2_xcode_type *");
			out_token(&st->fn_tok);
			out("_xc;\n");
		}
	}
	out("\n"
	    "int  c2_xc_%s_init(void);\n"
	    "void c2_xc_%s_fini(void);\n\n", opt->go_basename, opt->go_basename);
	out("/* %s */\n"
	    "#endif\n\n", opt->go_guardname);
	return 0;
}

int ff2c_c_gen(const struct ff2c_term *term, const struct ff2c_gen_opt *opts)
{
	return 0;
}

/** @} end of xcode group */

/*
 *  Local variables:
 *  c-indentation-style: "K&R"
 *  c-basic-offset: 8
 *  tab-width: 8
 *  fill-column: 80
 *  scroll-step: 1
 *  End:
 */
