This document describes Colibri project coding style. This document
does NOT describe code documentation practices, they are explained
elsewhere.

The first thing to remember is that a primary purpose that a coding
style exists for is to make understanding code easier for a project
participant. To this end, a code should be as uniform and idiomatic as
possible similarly with the properties that make usual human speech
easier to understand.

Colibri coding style is based on the Linux kernel coding style, which
everyone is advised to familiarize with at
http://www.kernel.org/doc/Documentation/CodingStyle

To summarise:

    * tabs are 8 characters;

    * block indentation is done with tabs;

    * braces placement and spacing is as following:

        if (condition) {
                branch0;
        } else {
                branch1;
        }

        func(arg0, arg1, ...);

        while (condition) {
                body;
        }

        switch (expression) {
        case VALUE0:
                branch0;
        case VALUE1:
                branch1;
        ...
        default:
                defaultbranch;
        }

    * no white spaces at the end of a line;

    * braces around single statement blocks can be optionally omitted;

    * Comment formatting follows Linux kernel style.

    * continuation line starts one column after the last unclosed
      opening parenthesis:

	C2_ASSERT(ergo(service != NULL,
		       c2_rpc_service_invariant(service) &&
		       service->svc_state == C2_RPC_SERVICE_STATE_INITIALISED));

    * In a if statement with multiple conditions, a new line should not start
      with a binary operator.

	if (pl_oldrec->pr_let_id != stl->ls_enum->le_type->let_id ||
                    pl_oldrec->pr_attr.pa_N != pl->pl_attr.pa_N) {
	}

In addition to the above syntactic conventions, Colibri code should
try to adhere to some higher level idioms.

    * a loop repeated N times is written

        for (i = 0; i < N; ++i) {
                body;
        }

    * an infinite loop is written as

        while (1) {
                ...
        }

    * names of struct and union members (fields) are have a short
      (1--4 characters) prefix, derived from the union or struct tag:

        struct misc_imperium_translatio {
                destination_t mit_rome[3]; /* there shall be no fourth Rome */
                enum reason   mit_why;
        };

      (Rationale: his makes search for field name usage easier.)     

    * typedefs are used only for "scalar" data types, including
      function pointers, but excluding enums. Compound data types
      (structs and unions) should never be aliased with typedef.

      Names introduced by typedef end with "_t";

    * sizeof expr is preferred to sizeof(type):

        struct foo *bar = c2_alloc(sizeof *bar);

      (Rationale: when bar's type changes code remains correct.);

    * to iterate over indices of an array X use ARRAY_SIZE(X) macro
      instead of an explicit array size:

        #define MAX_DEGREE_OF_SEPARATION (7)

        int degrees_of_separation[MAX_DEGREE_OF_SEPARATION + 1];

        for (i = 0; i < ARRAY_SIZE(degrees_of_separation); ++i) {
                body;
        }

      (Rationale: when array's declaration changes code remains correct.);

    * in the spirit of the two examples above, always try to make the
      code as autonomous as possible, so that the code correctness
      survives changes;

    * use difference between NULL, 0 and "false" to emphasize whether
      an expression is used as a pointer, integer (including success
      or failure code) or boolean:

        if (p == NULL) { /* assumes that p is a pointer */
        } else if (q != 0) { /* q is an integer */
        } else if (r) { /* r is a boolean */
        }

      Specifically, never use if (r == true);

    * simplify:

              return q != 0;            to     return q;
              return expr ? 0 : 1;      to     return !expr;

      Specifically, never use (x == true) or (x == false) instead of
      (x) or (!x) respectively. Rationale: if (x == true) is clearer
      than (x), then ((x == true) == true) is even more clearer.

      Use !!x to convert a "boolean" integer into an "arithmetic" integer;

    * use C99 bool type;

    * naming:

      globally visible name:

         struct c2_<module>_<noun> { ... }; /* data-type */
         int    c2_<module>_<noun>[size];   /* variable */
         int    c2_<module>_<noun>_<verb>(...); /* function */
	 bool   c2_<module>_<noun>_is_<adjective>(...); /* predicate function */

      Static names don't have "c2_" prefix. Function pointers within
      "operation" structs count as static. Names of constants are
      capitalized;

    * use C99 "designated initializers":

        static const struct foo bar = { /* initialize a struct */
                .field0 = ...,
                .field1 = { /* initialize an array */
                        [3] = ...,
                        [0] = ...
                },
                ...
        };

    * use enums to define numerical constants:

        enum LSD_HASHTABLE_PARAMS {
                LHP_PRIME   = 32416190071ULL,
                LHP_ORDER   = 11,
                LHP_SIZE    = 1 << LHP_ORDER,
                LHP_MASK    = LHP_SIZE - 1,
                LHP_FACTOR0 = 0.577215665,
                LHP_FACTOR1,
                LHP_FACTOR2
        };

      (Rationale: enums (as opposed to #defines) have types, visible
      in a debugger, etc.)

    * inline functions are preferable to macros

      (Rationale: type-checking, sane argument evaluation rules.);

    * macros should be used only when other language constructs cannot
      achieve the required goal. When creating a macro take care to:

        . evaluate arguments only once,

        . type-check (see min_t() macro in the Linux kernel),

        . never affect control flow from a macro,

        . capitalize macro name,

        . properly parenthesize so that macro works in any context;

    * return code conventions follow linux: return 0 for success,
      negated error code for a failure, positive values for other non
      failure conditions;

    * use "const" as a documentation and help for type-checker. Do not
      use casts to trick type-checking system into believing your
      consts. A typical scenario is a function that doesn't modify its
      input struct argument except for taking and releasing a lock
      inside of the struct. Don't use "const" in this case. Instead,
      document why the argument is not technically a constant;

    * control flow statement conditions should have no side-effects:

        alive = qoo_is_alive(elvis);
        if (alive) { /* rather than if (qoo_is_alive(elvis)) */
                ...
        }

      (Rationale: with this convention statement coverage metric is
      more adequate.);

    * use C precedence rules to omit noise in _obvious_ expressions:

        (left <= x && x < right)  /* not ((left <= x) && (x < right)) */

      but don't overdo:

        (mask << (bits & 0xf)) /* not (mask << bits & 0xf) */

    * use assertions freely to verify state invariants. An asserted
      expression should have no side-effects;

    * factor common code. Always prefer creating a common helper
      function to copying code

      (Rationale: avoids duplication of bugs.);

    * use standard scalar data type with explicit width, instead of
      "long" or "int".  E.g., int32_t, int64_t, uint32_t, uint64_t
      should be used to represent 32-bits, 64-bits integers, unsigned
      32-bits, unsigned 64-bits integers respectively

      (Rationale: avoids inconsistent data structures on different arch);

    * no comparison between signed vs unsigned without explicit casting.

    * the canonical order of type qualifiers in declarations and
      definitions is

        {static|extern|auto} {const|volatile} typename;

    * when using long or long long qualifiers, omit int;

    * declare one variable per line;

    * avoid dead assignments and initializations (i.e., assignments
      which are overwritten before the variable is read)

        int x = 0;

        if (y)
                x = foo();
        else
                x = bar();

      Instead, initialize a variable with a meaningful value, when the
      latter is known.

      (Rationale: dead initializations potentially hide errors. If,
      after the code restructuring, the variable remains
      un-initialized in a conditional branch or in a loop that might
      execute 0 times, the initializer suppresses compiler warning).
