gccxml
------

gccxml is an xml output extension to the C++ front-end of gcc. It creates an xml
representation of C++ declarations. It parses a C++ source file as it is seen by
the compiler when it is built. An easy-to-parse xml representation of the class,
function, and namespace declarations is dumped to a specified output file.

This allows to create tools, which parse gccxml's output and generate additional
C/C++ code for any C++ declaration.

Notice that gccxml is a C++ compiler under the hood and though it can process C
code as well, it implies some restrictions on C code.


xcode
-----

xcode is a Colibri module, which implements a modest set of introspection
facilities. A motivating example of xcode usage is universal encoding and
decoding interface (c2_xcode_decode(), c2_xcode_encode(), c2_xcode_length())
which converts between an in-memory object and its serialized representation.

But in order to be used with a particular data type, xcode requires a number of
additional structures and functions to be defined. A user defines a structure
(c2_xcode_type) which describes the in memory layout of a C data-type. xcode
provides interfaces to iterate over hierarchy of such descriptors and to
associate user defined state with types and fields.

And this is where gccxml comes into game.

(for more information about xcode, please refer to the doxygen documentation in
xcode/xcode.h)


gccxml2xcode
------------

gccxml2xcode is a perl script which does an actual work of analyzing gccxml's
output and generating xcode data structures and initialization code.

It does the same thing as ff2c compiler (xcode/ff2c/ff2c), but instead of using
pseudo-code description of data structures, it uses C structure declarations
directly from .h files. But it requires a little help from developer in order
top map plain C struct declarations to a higher-level abstract types, recognized
by xcode API (record, sequence, union). For this purpose each C struct
definition, which needs xcode data to be generated for it, should be "marked"
whith a special gcc __attribute__().

Let's use a little example code first, to see how it works, and then describe
attributes, gccxml2xcode invocation and integration with build system in more
details.

This is our test.h header:

    #ifndef __COLIBRI___TEST_H__
    #define __COLIBRI___TEST_H__

    #include <sys/types.h>
    #include <stdint.h>

    #include "xcode/xcode.h"

    struct fid {
        uint64_t f_container;
        uint64_t f_offset;
    } C2_XCA_RECORD;

    struct fidarray {
        uint64_t    ofa_nr;
        struct fid *ofa_data;
    } C2_XCA_SEQUENCE;

    extern uint32_t counter;

    struct test_data {
        char   *test_name;
        int     port;
        char   *buf;
        int     buf_size;
    };

    #endif /* __COLIBRI___TEST_H__ */

It may look like a declaration of two variables C2_XCA_RECORD and
C2_XCA_SEQUENCE of types 'struct fid' and 'struct fidarray' respectively, but
it's not. These C2_XCA_XXX entities are actually macros which unfold into
particular __attribute__() property of struct definition.

To generate xcode from this test.h header we need to do the following:

    $ gccxml -I ~/colibri/core -fxml=test.gccxml test.h
    $ gccxml2xcode -i test.gccxml

This will produce two files: test_xc.h and test_xc.c, which will contain
xcode data structures and initialization function, similarly to the
output of xcode/ff2c compiler:

  text_xc.h:

    /* This file is automatically generated from test.h */

    #ifndef __COLIBRI___TEST_XC_H__
    #define __COLIBRI___TEST_XC_H__

    #include <sys/types.h>

    #include "xcode/xcode.h"

    extern struct c2_xcode_type *fidarray_xc;
    extern struct c2_xcode_type *fid_xc;

    void c2_xc_test_init(void);
    void c2_xc_test_fini(void);

    /* __COLIBRI___TEST_XC_H__ */
    #endif


  test_xc.c:

    /* This file is automatically generated from test.h */

    #include "lib/cdefs.h"                       /* offsetof */
    #include "lib/assert.h"
    #include "xcode/xcode.h"

    #include "test.h"
    #include "test_xc.h"

    struct c2_xcode_type *fidarray_xc;
    struct c2_xcode_type *fid_xc;


    static struct _fidarray_s {
        struct c2_xcode_type  _type;
        struct c2_xcode_field _child[2];
    } _fidarray = {
        ._type = {
            .xct_aggr   = C2_XA_SEQUENCE,
            .xct_name   = "fidarray",
            .xct_sizeof = sizeof (struct fidarray),
            .xct_nr     = 2,
        }
    };

    struct c2_xcode_type *fidarray_xc = &_fidarray._type;
    C2_BASSERT(offsetof(struct _fidarray_s, _child[0]) ==
        offsetof(struct c2_xcode_type, xct_child[0]));

    static struct _fid_s {
        struct c2_xcode_type  _type;
        struct c2_xcode_field _child[2];
    } _fid = {
        ._type = {
            .xct_aggr   = C2_XA_RECORD,
            .xct_name   = "fid",
            .xct_sizeof = sizeof (struct fid),
            .xct_nr     = 2,
        }
    };

    struct c2_xcode_type *fid_xc = &_fid._type;
    C2_BASSERT(offsetof(struct _fid_s, _child[0]) ==
        offsetof(struct c2_xcode_type, xct_child[0]));


    C2_BASSERT(sizeof(struct fidarray) == 16U);

    C2_BASSERT(sizeof ((struct fidarray *)0)->ofa_nr == 8U);
    C2_BASSERT(offsetof(struct fidarray, ofa_nr) == 0U);
    C2_BASSERT(sizeof ((struct fidarray *)0)->ofa_data == 8U);
    C2_BASSERT(offsetof(struct fidarray, ofa_data) == 8U);

    C2_BASSERT(sizeof(struct fid) == 16U);

    C2_BASSERT(sizeof ((struct fid *)0)->f_container == 8U);
    C2_BASSERT(offsetof(struct fid, f_container) == 0U);
    C2_BASSERT(sizeof ((struct fid *)0)->f_offset == 8U);
    C2_BASSERT(offsetof(struct fid, f_offset) == 8U);


    void c2_xc_test_init(void)
    {
        _fidarray._child[0] = (struct c2_xcode_field) {
            .xf_name   = "ofa_nr",
            .xf_type   = &C2_XT_U64,
            .xf_tag    = 0,
            .xf_opaque = NULL,
            .xf_offset = offsetof(struct fidarray, ofa_nr)
        };
        _fidarray._child[1] = (struct c2_xcode_field) {
            .xf_name   = "ofa_data",
            .xf_type   = fid_xc,
            .xf_tag    = 0,
            .xf_opaque = NULL,
            .xf_offset = offsetof(struct fidarray, ofa_data)
        };

        _fid._child[0] = (struct c2_xcode_field) {
            .xf_name   = "f_container",
            .xf_type   = &C2_XT_U64,
            .xf_tag    = 0,
            .xf_opaque = NULL,
            .xf_offset = offsetof(struct fid, f_container)
        };
        _fid._child[1] = (struct c2_xcode_field) {
            .xf_name   = "f_offset",
            .xf_type   = &C2_XT_U64,
            .xf_tag    = 0,
            .xf_opaque = NULL,
            .xf_offset = offsetof(struct fid, f_offset)
        };

    }

    void c2_xc_test_fini(void)
    {
    }

Notice, that xcode is generated only for C data structures, which are marked
with one of C2_XCA_XXX attributes. Here is a mapping of these attributes to the
original ff2c syntax:

  record:      C2_XCA_RECORD
  sequence:    C2_XCA_SEQUENCE
  union:       C2_XCA_UNION
  [] (opaque): C2_XCA_OPAQUE("c2_package_cred_get")
  : (tag):     C2_XCA_TAG("NR")

Their up-to-date declaration can be found in xcode/xcode_attr.h file.

The process of '*_xc.[hc]' files generation is automated. Let's say one needs to
generate xocde for the 'xcode/ut/test_gccxml.h' header. For this, one just needs
to add the following code into 'xcode/ut/Makefile.am':

    include $(top_srcdir)/Makefile.xc

    libxcode_ut_la_SOURCES  += test_gccxml_xc.c

    clean-local: clean-xc

What it does is:

  * include Makefile.xc, which contains build and clean targets
    for '*_xc.[hc]' files

  * add not(-yet) existing test_gccxml_xc.c file to the list
    of sources, which will invoke xcode generation for test_gccxml.h

  * and add xc clean target as prerequisite for clean-local,
    so '*_xc.[hco]' and '*.gccxml' files will be removed on `make clean`.

In order to successfully use automatic xcode generation in colibri code, the
following tools should be installed in the development environment:

  * gccxml:

        yum install gccxml

  * g++ (required by gccxml):

        yum install gcc-c++

  * perl (required by gccxml2xcode):

        yum install perl

  * XML::LibXML perl module (required by gccxml2xcode):

        yum install perl-XML-LibXML

  * List::MoreUtils perl module (required by gccxml2xcode):

        yum install perl-List-MoreUtils

This is, essentially, everything what one needs to know to use automatic
xcode data generation for C structures in colibri code.

For more information about gccxml2xcode please refer to the script documentation
and script code itself:

    $ gccxml2xcode --help
    $ gccxml2xcode --man
    $ view gccxml2xcode

The script is located in 'colibri/core/xcode/' directory.
