This document describes structure of the Colibri source code tree.

Colibri sources are stored in multiple git repositories. The top one,
at "gitosis@git.clusterstor.com/colibri.git" contains a "checkout"
script fetching all the others. Currently this script pulls Oracle
Berkeley DB (ssh://gitosis@git.clusterstor.com/colibri-db4.git, a
misnomer, because currently db5 is used) and a "core"
(ssh://gitosis@git.clusterstor.com/colibri-core.git) repositories.

Structure
=========

Each major Colibri sub-system and component has a sub-directory in
core/ directory. Such sub-directory might contain other
sub-directories for sub-sub-systems. In addition, a sub-directory
might contain the following standard sub-directories:

    - ut: for CUnit based unit testing;

    - st: for system testing scripts;

    - ub: for unit benchmarking (not currently implemented, 2010.06.27).

Build
=====

Core build system is based on auto-* tools: autoheader, autoconf and
automake.

Core is built either by running "./autogen.sh && ./configure && make"
in its top-level directory or by running "../configure" from a
separate build directory where build output will be stored. This
process builds all the libraries and executable specified in the
current configuration (currently only one configuration is supported,
2010.06.27), including Oracle Berkeley DB, internal Colibri libraries,
unit and system tests, benchmarks and Colibri executables.

There are two types of top-level sub-directories in core/: ones
building internal Colibri libraries, typically stored in
core/foo/libcolibri-foo.la and ones building Colibri executables (none
at the moment, 2010.06.27). Internal Colibri libraries are built
first. All libraries needed by the current configuration are linked
together into core/colibri/libcolibri.la. Then binaries, including
unit tests are built and linked against libcolibri.

Kernel code is built by using Linux kernel build.

Recipes (for user space code)
=============================

How to add a new file to the source tree?
-----------------------------------------

Create a new file, say, core/foo/bar.c in the file system, edit
it. Add bar.c to he corresponding _SOURCES entry in
core/foo/Makefile.am. Add the file to git (git add foo/bar.c) and
commit your changes.

How headers should be included in C sources?
--------------------------------------------

First, your .c files should typically start with 

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

Include system headers as usual:

#include <unistd.h>

To include a Colibri header core/foo/foo_bar.h do

#include "foo/foo_bar.h"

This applies even to the headers from the same directory, that is,
core/foo/foo.c must include core/foo/foo_internal.h as

#include "foo/foo_internal.h"

Oracle Berkeley data-base interfaces must be included as

#include <db.h>

How to add a new internal Colibri library?
------------------------------------------

Create a new core/foo directory, if necessary. In core/foo/Makefile.am
put:

noinst_LTLIBRARIES            = libcolibri-foo.la
libcolibri_foo_la_SOURCES     = foo.c foo.h foo_internal.h foo_bar.c ...
INCLUDES                      = -I. -I$(top_srcdir) -I$(top_srcdir)/include

In core/Makefile.am add "foo" to SUBDIRS_LIBS, and, if necessary,
"foo/ut", "foo/st" and "foo/ub" to SUBDIRS_{UT,ST,UB} respectively.

Add "core/Makefile" and (if necessary) "core/{ut,st,ub}/Makefile" to
AC_CONFIG_FILES section at the end of core/configure.ac.

Finally, add $(top_builddir)/foo/libcolibri-foo.la to
libcolibri_la_LIBADD in core/colibri/Makefile.am

How to add a new executable?
----------------------------

To build a new executable core/foo/baz (including core/foo/ut/utbaz)
add to the core/foo/Makefile.am:

INCLUDES           = -I. -I$(top_srcdir)/include -I$(top_srcdir)

noinst_PROGRAMS    = baz
baz_SOURCES        = baz.c baz.h ...
baz_LDADD          = $(top_builddir)/colibri/libcolibri.la

If necessary also add 

baz_LDFLAGS   = -pthread ...

System initialization and finalisation
--------------------------------------

core/colibri/init.h declares functions

int  c2_init(void);
void c2_fini(void);

That must be called by an executable to respectively initialise and
finalise Colibri internal libraries.

If your library (say, core/foo/libcolibri-foo.la) requires some global
(per address space) initialisation or finalisation actions (e.g.,
starting service threads, opening files), declare

int  foo_init(void);
void foo_fini(void);

in core/foo/foo.h, add

#include "foo/foo.h"

to core/colibri/init.c and add { &foo_init, &foo_fini } to the
subsystem[] array, defined in core/colibri/init.c. foo_init() must
follow standard return conventions: 0 on success, negated errno value
on failure.
