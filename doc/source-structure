This document describes structure of the Mero source code tree.

Mero sources are stored in multiple git repositories. The top one,
at "gitosis@git.clusterstor.com/mero.git" contains a "checkout"
script fetching all the others. Currently this script pulls Oracle
Berkeley DB (ssh://gitosis@git.clusterstor.com/mero-db4.git, a
misnomer, because currently db5 is used) and a "core"
(ssh://gitosis@git.clusterstor.com/mero-core.git) repositories.

Structure
=========

Each major Mero sub-system and component has a sub-directory in
core/ directory. Such sub-directory might contain other
sub-directories for sub-sub-systems. In addition, a sub-directory
might contain the following standard sub-directories:

    - ut: for CUnit based unit testing and unit benchmarking;

    - st: for system testing scripts;

Build
=====

Core build system is based on auto-* tools: autoheader, autoconf and
automake.

Core is built either by running "./autogen.sh && ./configure && make"
in its top-level directory or by running "../configure" from a
separate build directory where build output will be stored (the latter
will work only for user-space part, i.e. `make all-user`, because our
kerne-mode makefiles don't support this feature at the moment). This
process builds all the libraries and executable specified in the
current configuration (currently only one configuration is supported,
2010.06.27), including Oracle Berkeley DB, internal Mero libraries,
unit and system tests, benchmarks and Mero executables.

All sources needed by the current configuration are linked
together into core/mero/libmero.la. Then binaries, including
unit tests are built and linked against libmero.

Kernel code is built by using Linux kernel build. The modules for mero
components are generated in build_kernel_modules directory.

Recipes (for user space code)
=============================

How to add a new file to the source tree?
-----------------------------------------

Create a new file, say, core/foo/bar.c in the file system, edit
it. Add bar.c to he corresponding _SOURCES entry in
core/foo/Makefile.sub. Add the file to git (git add foo/bar.c) and
commit your changes.

If you are planning to add file bar.h then bar.h should typically
start with:

    #pragma once

    #ifndef __MERO_FOO_BAR_H__
    #define __MERO_FOO_BAR_H__

End the file bar.h with:

    #endif /* __MERO_FOO_BAR_H__ */

    /*
     *  Local variables:
     *  c-indentation-style: "K&R"
     *  c-basic-offset: 8
     *  tab-width: 8
     *  fill-column: 80
     *  scroll-step: 1
     *  End:
     */

How headers should be included in C sources?
--------------------------------------------

Include system headers as usual:

#include <unistd.h>

To include a Mero header core/foo/foo_bar.h do

#include "foo/foo_bar.h"

This applies even to the headers from the same directory, that is,
core/foo/foo.c must include core/foo/foo_internal.h as

#include "foo/foo_internal.h"

Oracle Berkeley data-base interfaces must be included as

#include <db.h>

How Mero build system is organized?
------------------------------------------

Please, read the "Quick start guide" section at the beginning of
top-level core/Makefile.am makefile.

How to add a new internal Mero library?
------------------------------------------

Create a new core/foo directory, if necessary. Add something like this
to top-level core/Makefile.am:

    noinst_LTLIBRARIES += foo/libmero-foo.la

    include $(top_srcdir)/foo/Makefile.sub

In core/foo/Makefile.sub put:

    foo_libmero_foo_la_HEADERS = foo/foo.h

    foo_libmero_foo_la_SOURCES = foo/foo.c \
                                    foo/foo_internal.h \
                                    foo/foo_bar.c

NOTICE: public headers (which are used by other mero modules) of
foo module should go into _HEADERS variable - this is what will be
installed to /usr/include on `make install`. While internal headers of
foo module should go into _SOURCES variable.

If necessary, add sources under foo/{ut,st} to the
ut_libmero_ut_la_SOURCES variable in core/foo/{ut,st}/Makefile.sub:

    ut_libmero_ut_la_SOURCES += foo/ut/foo_test.c

And include this core/foo/{ut,st}/Makefile.sub makefile into
core/Makefile.am in appropriate place (search where other ut/st
makefiles are included, in alphabetic order).

How to add a new Mero module?
--------------------------------

It's almost the same as adding a new internal library (see previous
section), but instead of using new _HEADERS and _SOURCES
library variables, one need to use the existing
mero_libmero_la_{SOURCES,HEADERS} variables in foo/Makefile.sub:

    mero_libmero_la_SOURCES += foo/foo.c

And include this foo/Makefile.sub into the top-levevl core/Makefile.am
in appropriate place in alphabetic order (search where other
makefiles, which are part of libmero.la library, are included).

How to add a new executable?
----------------------------

To build a new executable core/foo/baz add to the
core/foo/Makefile.sub:

    noinst_PROGRAMS += foo/baz
    foo_baz_LDADD    = $(top_builddir)/mero/libmero.la

    include $(top_srcdir)/foo/Makefile.sub

And in core/foo/Makefile.sub:

    foo_baz_SOURCES = foo/baz.c \
                      foo/bar.c

NOTICE: if executable comprised only from one source file of the same
name as the binary (foo/baz.c), there is no need to add a
corresponding _SOURCES variable - automake handles this automatically.

Some real-world examples of module's Makefile.sub
-------------------------------------------------

The rpc/Makefile.sub can be used as a most complete example of how to write
module's Makefile.sub makefiles. It uses almost all constructs like _HEADERS,
_SOURCES, FF_FILES, XC_FILES and CLEANFILES.

System initialization and finalisation
--------------------------------------

core/mero/init.h declares functions

int  m0_init(void);
void m0_fini(void);

That must be called by an executable to respectively initialise and
finalise Mero internal libraries.

If your library (say, core/foo/libmero-foo.la) requires some global
(per address space) initialisation or finalisation actions (e.g.,
starting service threads, opening files), declare

int  m0_foo_init(void);
void m0_foo_fini(void);

in core/foo/foo.h, add

#include "foo/foo.h"

to core/mero/init.c and add { &m0_foo_init, &m0_foo_fini } to the
subsystem[] array, defined in core/mero/init.c. foo_init() must
follow standard return conventions: 0 on success, negated errno value
on failure.

How to add a new unit test?
---------------------------

M0 uses a unit test framework based on CUnit
(http://cunit.sourceforge.net/).

To add a collection of unit tests ("test suite") for a module foo:

In a file core/foo/ut/foo.c do something like:

#include "lib/ut.h"

void test_foo0(void)
{
	struct foo F;

	foo_init(&F);
	M0_UT_ASSERT(foo_bar(&F) == foo_baz(&F) + 1);
        ...
}

void test_foo1(void)
{
        ...
}

...

int foo_ut_init(void)
{
	/* prepare for testing */
        ...
}

int foo_it_fini(void)
{
	/* cleanup after testing */
        ...
}

const struct m0_test_suite foo_ut = {
	.ts_name = "foo-ut",
	.ts_init = foo_ut_init, /* optional, may be NULL */
	.ts_fini = foo_ut_fini, /* optional, may be NULL */
	.ts_tests = {
		{ "test0", test_foo0 },
		{ "test1", test_foo1 },
		...
		{ NULL, NULL }
	}
};

In core/foo/ut/Makefile.sub do:

    ut_libmero_ut_la_SOURCES += foo/ut/foo.c ...

In core/Makefile.am add the following include line in appropriate
place, in alphabetic order (search where other ut makefiles are
included).

    include $(top_srcdir)/foo/ut/Makefile.sub

In core/utils/ut_main.c add

extern const struct m0_test_suite foo_ut;

declaration and

	m0_ut_add(&foo_ut);

to add_uts().

All unit tests are executed by ./core/utils/ut.

A few comments:

    * unit testing functions should use M0_UT_ASSERT() or other CUnit
      macros (see <CUnit/CUnit.h>) for testing;

    * unit testing functions should produce no output;

    * unit testing code should be ready to be ran multiple
      times. Avoid static initialisers or carefully re-set everything
      in foo_ut_fini();

    * unit tests are ran in an address space where m0_init() was
      already executed.

See core/lib/ut/*.c, core/stob/ut/adieu.c, core/fop/ut/fmt_test.c for
examples.

Note, that a unit test should create no files outside of current process
directory (except for possibly in its sub-directories).

How to add a new unit benchmark?
--------------------------------

Unit benchmarks for a component is a collection of micro-benchmarks
measuring performance of common code-paths at the function level.

It is clear that unit benchmarks are somewhat similar to unit
tests. Indeed, they usually happen to share a lot of code. As a
result, unit benchmark code is typically kept in the same
core/foo/ut/foo.c code as unit tests for the same component. See
core/lib/ut/*.c and core/stob/ut/adieu.c for examples.

Note, that a unit benchmark should create no files outside of current
process directory (except for possibly in its sub-directories).

How to add a new kernel module?
-------------------------------

A new module can be added to Mero in two ways,
  1) functionality built into m0mero.ko
  2) Module for stand-alone UT's

1) In mero all the functionality for kernel side is implemented into
a single kernel module called m0mero.ko
So to add your new kernel source(s) for core/module to m0mero,
create core/module/ directory

Add the following lines into build_kernel_modules/Makefile.in:
In macro dirs:
add source dir "module"

then the sources for the module are listed as
module_SOURCES := foo.c bar.c baz.c
module_HEADERS := foo.h bar.h baz.h

create these source and header files in core/module directory

2) If you want to build the module as separate stand-alone UT named
core/module, create

core/module/linux_kernel directory and add
core/module/linux_kernel/Makefile.in into:

obj-m       := <mod.name.o>
shared_src  := <shared sources>
kernel_src  := <kernel sources>
ksns-y      := $(shared_src:.c=.o) $(kernel_src:.c=.o)
orig        := $(shared_src:%=../%)

EXTRA_CFLAGS = -DHAVE_CONFIG_H -I@top_srcdir@ @M0_KCPPFLAGS@ @M0_KCFLAGS@ @KCFLAGS@

prepare:
       ln -fs $(orig) .

clean distclean:
       $(RM) $(shared_src) Module.markers Module.symvers modules.order
       $(MAKE) -C @LINUX_OBJ@ M=`pwd` clean

distdir:
       cp $(<MOD.DIR>)/Makefile.in \
           @top_builddir@/@PACKAGE@-@PACKAGE_VERSION@/<mod.name>/linux_kernel

Add the following lines into configure.ac:
In macro AC_CONFIG_FILES:
add source "core/module/linux_kernel/Makefile".

add following lines into build_kernel_modules/Makefile.in:
In macro testdirs:
add source dir "module/linux_kernel"

Note: build system should be reconfigured after affected changes.
