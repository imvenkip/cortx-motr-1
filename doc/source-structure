This document describes structure of the Colibri source code tree.

Colibri sources are stored in multiple git repositories. The top one,
at "gitosis@git.clusterstor.com/colibri.git" contains a "checkout"
script fetching all the others. Currently this script pulls Oracle
Berkeley DB (ssh://gitosis@git.clusterstor.com/colibri-db4.git, a
misnomer, because currently db5 is used) and a "core"
(ssh://gitosis@git.clusterstor.com/colibri-core.git) repositories.

Structure
=========

Each major Colibri sub-system and component has a sub-directory in
core/ directory. Such sub-directory might contain other
sub-directories for sub-sub-systems. In addition, a sub-directory
might contain the following standard sub-directories:

    - ut: for CUnit based unit testing and unit benchmarking;

    - st: for system testing scripts;

Build
=====

Core build system is based on auto-* tools: autoheader, autoconf and
automake.

Core is built either by running "./autogen.sh && ./configure && make"
in its top-level directory or by running "../configure" from a
separate build directory where build output will be stored. This
process builds all the libraries and executable specified in the
current configuration (currently only one configuration is supported,
2010.06.27), including Oracle Berkeley DB, internal Colibri libraries,
unit and system tests, benchmarks and Colibri executables.

There are two types of top-level sub-directories in core/: ones
building internal Colibri libraries, typically stored in
core/foo/libcolibri-foo.la and ones building Colibri executables (none
at the moment, 2010.06.27). Internal Colibri libraries are built
first. All libraries needed by the current configuration are linked
together into core/colibri/libcolibri.la. Then binaries, including
unit tests are built and linked against libcolibri.

Kernel code is built by using Linux kernel build. The modules for colibri
components are generated in build_kernel_modules directory

Recipes (for user space code)
=============================

How to add a new file to the source tree?
-----------------------------------------

Create a new file, say, core/foo/bar.c in the file system, edit
it. Add bar.c to he corresponding _SOURCES entry in
core/foo/Makefile.am. Add the file to git (git add foo/bar.c) and
commit your changes.

How headers should be included in C sources?
--------------------------------------------

First, your .c files should typically start with

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

Include system headers as usual:

#include <unistd.h>

To include a Colibri header core/foo/foo_bar.h do

#include "foo/foo_bar.h"

This applies even to the headers from the same directory, that is,
core/foo/foo.c must include core/foo/foo_internal.h as

#include "foo/foo_internal.h"

Oracle Berkeley data-base interfaces must be included as

#include <db.h>

How to add a new internal Colibri library?
------------------------------------------

Create a new core/foo directory, if necessary. In core/foo/Makefile.am
put:

noinst_LTLIBRARIES            = libcolibri-foo.la
libcolibri_foo_la_SOURCES     = foo.c foo.h foo_internal.h foo_bar.c ...
INCLUDES                      = -I. -I$(top_srcdir) -I$(top_srcdir)/include

In core/Makefile.am add "foo" to SUBDIRS_LIBS, and, if necessary,
"foo/ut", "foo/st" and "foo/ub" to SUBDIRS_{UT,ST,UB} respectively.

Add "core/Makefile" and (if necessary) "core/{ut,st,ub}/Makefile" to
AC_CONFIG_FILES section at the end of core/configure.ac.

Finally, add $(top_builddir)/foo/libcolibri-foo.la to
libcolibri_la_LIBADD in core/colibri/Makefile.am

How to add a new executable?
----------------------------

To build a new executable core/foo/baz add to the
core/foo/Makefile.am:

INCLUDES           = -I. -I$(top_srcdir)/include -I$(top_srcdir)

noinst_PROGRAMS    = baz
baz_SOURCES        = baz.c baz.h ...
baz_LDADD          = $(top_builddir)/colibri/libcolibri.la

If necessary also add

baz_LDFLAGS   = -pthread ...

System initialization and finalisation
--------------------------------------

core/colibri/init.h declares functions

int  c2_init(void);
void c2_fini(void);

That must be called by an executable to respectively initialise and
finalise Colibri internal libraries.

If your library (say, core/foo/libcolibri-foo.la) requires some global
(per address space) initialisation or finalisation actions (e.g.,
starting service threads, opening files), declare

int  foo_init(void);
void foo_fini(void);

in core/foo/foo.h, add

#include "foo/foo.h"

to core/colibri/init.c and add { &foo_init, &foo_fini } to the
subsystem[] array, defined in core/colibri/init.c. foo_init() must
follow standard return conventions: 0 on success, negated errno value
on failure.

How to add a new unit test?
---------------------------

C2 uses a unit test framework based on CUnit
(http://cunit.sourceforge.net/).

To add a collection of unit tests ("test suite") for a module foo:

In a file core/foo/ut/foo.c do something like:

#include "lib/ut.h"

void test_foo0(void)
{
	struct foo F;

	foo_init(&F);
	C2_UT_ASSERT(foo_bar(&F) == foo_baz(&F) + 1);
        ...
}

void test_foo1(void)
{
        ...
}

...

int foo_ut_init(void)
{
	/* prepare for testing */
        ...
}

int foo_it_fini(void)
{
	/* cleanup after testing */
        ...
}

const struct c2_test_suite foo_ut = {
	.ts_name = "foo-ut",
	.ts_init = foo_ut_init, /* optional, may be NULL */
	.ts_fini = foo_ut_fini, /* optional, may be NULL */
	.ts_tests = {
		{ "test0", test_foo0 },
		{ "test1", test_foo1 },
		...
		{ NULL, NULL }
	}
};

In core/foo/ut/Makefile.am do:

noinst_LTLIBRARIES   = libfoo-ut.la
libfoo_ut_la_SOURCES = foo.c ...

In core/utils/Makefile.am add $(top_builddir)/foo/ut/libfoo-ut.la to ut_LDADD.

In core/utils/ut_main.c add

extern const struct c2_test_suite foo_ut;

declaration and

	c2_ut_add(&foo_ut);

to main().

Add foo/ut to SUBDIR_UT in core/Makefile.am.

All unit tests are executed by ./core/utils/ut.

A few comments:

    * unit testing functions should use C2_UT_ASSERT() or other CUnit
      macros (see <CUnit/CUnit.h>) for testing;

    * unit testing functions should produce no output;

    * unit testing code should be ready to be ran multiple
      times. Avoid static initialisers or carefully re-set everything
      in foo_ut_fini();

    * unit tests are ran in an address space where c2_init() was
      already executed.

See core/lib/ut/*.c, core/stob/ut/adieu.c, core/fop/ut/fmt_test.c for
examples.

Note, that a unit test should create no files outside of current process
directory (except for possibly in its sub-directories).

How to add a new unit benchmark?
--------------------------------

Unit benchmarks for a component is a collection of micro-benchmarks
measuring performance of common code-paths at the function level.

It is clear that unit benchmarks are somewhat similar to unit
tests. Indeed, they usually happen to share a lot of code. As a
result, unit benchmark code is typically kept in the same
core/foo/ut/foo.c code as unit tests for the same component. See
core/lib/ut/*.c and core/stob/ut/adieu.c for examples.

Note, that a unit benchmark should create no files outside of current
process directory (except for possibly in its sub-directories).

How to add a new kernel module?
-------------------------------

A new module can be added to Colibri in two ways,
  1) functionality built into kcolibri.ko
  2) Module for stand-alone UT's

1) In colibri all the functionality for kernel side is implemented into
a single kernel module called kcolibri.ko
So to add your new kernel source(s) for core/module to kcolibri,
create core/module/ directory

Add the following lines into build_kernel_modules/Makefile.in:
In macro dirs:
add source dir "module"

then the sources for the module are listed as
module_SOURCES := foo.c bar.c baz.c
module_HEADERS := foo.h bar.h baz.h

create these source and header files in core/module directory

2) If you want to build the module as separate stand-alone UT named
core/module, create

core/module/linux_kernel directory and add
core/module/linux_kernel/Makefile.in into:

obj-m       := <mod.name.o>
shared_src  := <shared sources>
kernel_src  := <kernel sources>
ksns-y      := $(shared_src:.c=.o) $(kernel_src:.c=.o)
orig        := $(shared_src:%=../%)

EXTRA_CFLAGS = -DHAVE_CONFIG_H -I@SRCDIR@ @KCFLAGS@

prepare:
       ln -fs $(orig) .

clean distclean:
       $(RM) $(shared_src) Module.markers Module.symvers modules.order
       $(MAKE) -C @LINUX_OBJ@ M=`pwd` clean

distdir:
       cp $(<MOD.DIR>)/Makefile.in \
           @top_builddir@/@PACKAGE@-@VERSION@/<mod.name>/linux_kernel

Add the following lines into configure.ac:
In macro AC_CONFIG_FILES:
add source "core/module/linux_kernel/Makefile".

add following lines into build_kernel_modules/Makefile.in:
In macro testdirs:
add source dir "module/linux_kernel"

Note: build system should be reconfigured after affected changes.
