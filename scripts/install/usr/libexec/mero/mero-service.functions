# Print message on console (STDERR) and write it into system log
#   @param  $1  msg
m0_log()
{
    logger -p daemon.info -s -t mero -- "$*"
}

# Report error and exit.
#   @param  $*  error msg
m0_exit()
{
    m0_log "$*"
    exit 1
}

# path to binaries inside working directory
declare -rA _path_inside_workdir=(
    [m0mero.ko]='mero/m0mero.ko'
    [m0ctl.ko]='mero/m0ctl.ko'
    [m0gf.ko]='extra-libs/gf-complete/src/linux_kernel/m0gf.ko'
    [m0d]='mero/m0d'
    [m0mkfs]='utils/mkfs/m0mkfs'
    [m0traced]='utils/trace/m0traced'
)

# Return a path to Mero executables.
#   @param  $1  name of an executable
m0_path_to()
{
    local binary=$1

    if [ -n "$MERO_DEVEL_WORKDIR_PATH" ] ; then
        echo "$MERO_DEVEL_WORKDIR_PATH/${_path_inside_workdir[$binary]}"
    else
        echo "$binary"
    fi
}

# Return value of particular variable, stored in genders "database"
#   @param  $1  name of a variable
#   @param  $2  optional name of a node, for which the query is performed, if
#               ommited, then value is returned for current node
m0_genders_value_of()
{
    local var_name=$1
    local node=$2

    nodeattr -f $MERO_GENDERS_CONF -v $node $var_name
}

# Start LNET service
m0_start_lnet()
{
    if test -x /usr/bin/systemctl && systemctl list-unit-files | grep -q lnet ; then
        # do nothing, systemd lnet service will handle it
        true
    elif chkconfig --list | grep -q lnet ; then
        service lnet start
    else
        if ! lsmod | grep -q lnet ; then
            modprobe lnet || m0_exit "Failed to load lnet module"
            lctl network up
        fi
    fi
}

# Stop LNET service
m0_stop_lnet()
{
    if test -x /usr/bin/systemctl && systemctl list-unit-files | grep -q lnet ; then
        # do nothing, systemd lnet service will handle it
        true
    elif chkconfig --list | grep -q lnet ; then
        service lnet stop
    else
        lctl network down
        modprobe -r ksocklnd || m0_exit "Failed to unload lnet modules"
    fi
}

# Load Mero modules.
m0_load_modules()
{
    local m0mero_params

    m0_start_lnet

    if [ -n "$MERO_KMOD_PARAMS" ] ; then
        m0mero_params="$MERO_KMOD_PARAMS $MERO_KMOD_EXTRA_PARAMS"
    else
        local uuid=${MERO_KMOD_NODE_UUID:-$(m0_genders_value_of m0_uuid)}
        local msg_size=$(m0_genders_value_of m0_max_rpc_msg_size)
        local qlen=$(m0_genders_value_of m0_min_rpc_recvq_len)
        local ep=$(m0_get_kmod_ep)

        m0mero_params="$m0mero_params node_uuid=$uuid"
        m0mero_params="$m0mero_params local_addr=$ep"
        m0mero_params="$m0mero_params max_rpc_msg_size=$msg_size"
        m0mero_params="$m0mero_params tm_recv_queue_min_len=$qlen"
        m0mero_params="$m0mero_params $MERO_KMOD_EXTRA_PARAMS"
    fi

    if [ -n "$MERO_DEVEL_WORKDIR_PATH" ] ; then
        insmod $(m0_path_to m0gf.ko) || m0_exit "Failed to load m0gf module"
        insmod $(m0_path_to m0mero.ko) $m0mero_params\
            || m0_exit "Failed to load m0mero module"
        insmod $(m0_path_to m0ctl.ko) || m0_exit "Failed to load m0ctl module"
    else
        modprobe m0mero $m0mero_params
        modprobe m0ctl
    fi
}

# Unload Mero modules.
m0_unload_modules()
{
    lsmod | grep -q m0ctl && ( rmmod m0ctl || m0_exit "Failed to unload m0ctl module" )

    if [ -n "$MERO_DEVEL_WORKDIR_PATH" ] ; then
        rmmod m0mero || m0_exit "Failed to unload m0mero module"
        rmmod m0gf || m0_exit "Failed to unload m0gf module"
    else
        modprobe -r m0mero
    fi

    m0_stop_lnet
}

# Return path to a working directory of particular m0d instance
#   @param  $1  m0d service name
m0_get_m0d_data_dir_for()
{
    local service=$1

    echo "${MERO_M0D_DATA_DIR:-$(m0_genders_value_of m0_datadir)}/$service"
}

# Return space-separated list of all nodes in the cluster from genders file
m0_get_nodes()
{
    nodeattr -f $MERO_GENDERS_CONF -c -A | tr ',' ' '
}

# Return lnet NID of a node
#   @param  $1  optional name of a node, for which the query is performed, if
#               ommited, then value is returned for current node
m0_get_lnet_nid()
{
    local node=$1

    local lnid
    # if $node is empty, then query is for current node
    if [ -z "$node" -o "$node" = "$(hostname -s)" ] ; then
        lnid=${MERO_LNET_NID:=$(m0_genders_value_of m0_lnet_nid)}
        if [ "$lnid" = 'auto' ] ; then
            lnid=$(lctl list_nids | head -n1)
            [ -z "$lnid" ] && \
                m0_exit 'Failed to auto-detect Lnet NID, please check that' \
                        ' lnet service is running'
        fi
    else
        lnid=$(m0_genders_value_of m0_lnet_nid $node)
    fi

    echo $lnid
}

# Return space-separated list of all services for particular node
#   @param  $1  optional name of a node, for which the query is performed, if
#               ommited, then value is returned for current node
m0_get_services()
{
    local node=$1
    local services

    # if $node is empty, then query is for current node
    if [ -z "$node" -o "$node" = "$(hostname -s)" ] ; then
        services=${SERVICES:-$MERO_SERVICES}
    fi

    echo ${services:-$(m0_genders_value_of m0_services $node | tr ';' ' ')}
}

# Return space-separated list of all services in the cluster
m0_get_global_services()
{
    local services

    for node in $(m0_get_nodes); do
        services="$services $(m0_get_services $node)"
    done

    echo $services
}

# Return space-separated list of all services in the cluster
m0_get_global_ios_services()
{
    echo $(m0_get_global_services) | grep -E -o 'ios([[:digit:]]+)?|singlenode'
}

# Return m0mero.ko endpoint
m0_get_kmod_ep()
{
    echo "$(m0_get_lnet_nid):12345:41:301"
}

# Return MDS endpoint
m0_get_mds_ep()
{
    local node
    local service

    for node in $(m0_get_nodes); do
        for service in $(m0_get_services $node); do
            if [ "$service" = "mds" -o "$service" = "singlenode" ]; then
                echo "lnet:$(m0_get_lnet_nid $node):12345:41:101"
                return
            fi
        done
    done
}

# Return confd service endpoint
m0_get_confd_ep()
{
    local node
    local service

    for node in $(m0_get_nodes); do
        for service in $(m0_get_services $node); do
            if [ "$service" = "confd" ]; then
                echo "lnet:$(m0_get_lnet_nid $node):12345:41:100"
                return
            fi
        done
    done
}

#
# Build parameters list for m0d running "core" services
#
#   @param $1 directory to store configuration file.
#
m0_get_core_params()
{
    local dir=$1

    m0_build_local_conf > $dir/conf.xc
    echo "-s addb2 -s rmservice"
}

# Return space-separated list of IOS endpoints of a node
#   @param  $1  optional name of a node, for which the query is performed, if
#               ommited, then value is returned for current node
m0_get_ios_eps()
{
    local node=$1

    local ios_eps
    local lnid=$(m0_get_lnet_nid $node)
    local ios_tid=201
    local service

    for service in $(m0_get_services $node); do
        if echo $service | grep -q -E '^ios([[:digit:]]+)?$'; then
            ios_eps="$ios_eps lnet:$lnid:12345:41:$((ios_tid++))"
        elif echo $service | grep -q -E '^singlenode$'; then
            ios_eps=$(m0_get_mds_ep)
        fi
    done

    echo $ios_eps
}

# Return space-separated list of all IOS endpoints in the cluster, from genders
# file
m0_get_global_ios_eps()
{
    local global_ios_eps
    local node

    for node in $(m0_get_nodes); do
        global_ios_eps="$global_ios_eps $(m0_get_ios_eps $node)"
    done

    echo $global_ios_eps
}

# Return space-separated list of running Mero servers on a current node
m0_get_running_servers()
{
    if [ -x /usr/bin/systemctl ] ; then
        systemctl \
        | sed -n -r -e 's#^mero-server[-@](.*)\.service.*running.*#\1#p'
    elif [ -x /sbin/initctl ] ; then
        initctl list \
        | grep mero-server \
        | sed -n -r -e 's#.*mero-server \((.*)\) start/running.*#\1#p'
    fi
}

# Return PID of running m0d daemon for particular Mero service
#   @param  $1  name of a service, e.g. 'mds', 'ios1'
m0_get_server_pid_for()
{
    local service=$1

    local t='@'
    [[ $service != confd ]] || t='-'

    if [ -x /usr/bin/systemctl ] ; then
        systemctl show -pMainPID mero-server${t}${service}.service \
        | sed -e 's/MainPID=//'
    elif [ -x /sbin/initctl ] ; then
        initctl list \
        | sed -n -r -e \
            "s/mero-server \\($service\\) start\\/.* process ([[:digit:]]+)/\\1/p"
    fi
}

_build_disk_ids_str()
{
    local start_id=$1
    local count=$2

    local dev_ids
    local id
    for id in $(seq $start_id $(($start_id + $count - 1))) ; do
        local dev_id="(0x6400000000000001, $id)"
        dev_ids="$dev_ids${dev_ids:+, }$dev_id"
    done

    echo "[$count: $dev_ids]"
}

_build_disk_fids_str()
{
    local count=$1

    local disk_fids
    local id
    for id in $(seq 1 $count) ; do
        local ddisk_id="(0x6b00000000000001, $id)"
        disk_fids="$disk_fids${disk_fids:+, }$ddisk_id"
    done

    echo "[$count: $disk_fids]"
}

_build_diskv_fids_str()
{
    local count=$1

    local disk_fids
    local id
    for id in $(seq 1 $count) ; do
        local ddiskv_id="(0x6a00000000000001, $id)"
        disk_fids="$disk_fids${disk_fids:+, }$ddiskv_id"
    done

    echo "[$count: $disk_fids]"
}

_build_ios_devs()
{
    local count=$1

    local devs
    local id
    for id in $(seq 1 $count) ; do
        local ddev_id="(0x6400000000000001, $id)"
        local ddisk_id="(0x6b00000000000001, $id)"
        local ddiskv_id="(0x6a00000000000001, $id)"
        local ddev_obj="{0x64| (($ddev_id), 4, 1, 4096, 596000000000, 3, 4, \"/disk/path/is/not/used/yet\")}"
        local ddisk_obj="{0x6b| (($ddisk_id), $ddev_id)}"
        local ddiskv_obj="{0x6a| (($ddiskv_id), $ddisk_id, [0])}"
        local dev="$ddev_obj,\n  $ddisk_obj,\n  $ddiskv_obj"
        devs="$devs${devs:+,\n  }$dev"
    done

    echo -e "$devs"
}

# Profile fid in the format suitable for 'prof=' mount option. Must match $prof
# variable in m0_build_local_conf()
m0_prof_opt='<0x7000000000000001:0>'

# Construct local_conf mount option from genders file
m0_build_local_conf()
{
    local local_conf
    local mds_ep=$(m0_get_mds_ep | sed -e 's/^lnet://')
    local rms_ep=$mds_ep # RM service is running on the same node as MDS
    local stats_ep=$mds_ep # STATS service is running on the same node as MDS
    local pool_width=$(m0_genders_value_of m0_pool_width)
    local data_units=$(m0_genders_value_of m0_data_units)
    local parity_units=$(m0_genders_value_of m0_parity_units)

    # IOS objects
    local ios_count=$(m0_get_global_ios_services | wc -w)
    local disks_per_ios=$(( $pool_width / $ios_count ))
    local ios_idx=0
    local ios_names
    local ios_objs
    local ios_ep
    for ios_ep in $(m0_get_global_ios_eps | sed -e 's/lnet://g'); do
        local disk_ids=$(_build_disk_ids_str $(($ios_idx * $disks_per_ios + 1)) $disks_per_ios)
        local ios_name="(0x7300000000000002, $((ios_idx++)))"
        ios_names="$ios_names${ios_names:+, }$ios_name"
        ios_objs="$ios_objs${ios_objs:+, }{0x73| (($ios_name), 2, [1: \"$ios_ep\"], $disk_ids)}"
    done

    # MDS objects (current version of initscripts support only single MDS
    # it will be eliminated completely in LA release
    local mds_name="(0x7300000000000003, 0)"
    local mds_obj="{0x73| (($mds_name), 1, [1: \"$mds_ep\"], [0])}"

    local  root='(0x7400000000000001, 0)'
    local  prof='(0x7000000000000001, 0)'
    local    fs='(0x6600000000000001, 1)'
    local  node='(0x6e00000000000001, 2)'
    local  proc='(0x7200000000000001, 3)'
    local    rm='(0x7300000000000001, 4)'
    local stats='(0x7300000000000001, 5)'

    local rackid='(0x6100000000000001, 6)'
    local enclid='(0x6500000000000001, 7)'
    local ctrlid='(0x6300000000000001, 8)'
    local poolid='(0x6f00000000000001, 9)'
    local pverid='(0x7600000000000001, 10)'

    local rackvid="(0x6a00000000000001, $(($pool_width + 1)))"
    local enclvid="(0x6a00000000000001, $(($pool_width + 2)))"
    local ctrlvid="(0x6a00000000000001, $(($pool_width + 3)))"

    local rack="{0x61| (($rackid), [1: $enclid], [1: $pverid])}"
    local encl="{0x65| (($enclid), [1: $ctrlid], [1: $pverid])}"
    local ctrl="{0x63| (($ctrlid), $node, $(_build_disk_fids_str $pool_width), [1: $pverid])}"
    local pool="{0x6f| (($poolid), 0, [1: $pverid])}"
    local pver="{0x76| (($pverid), 0, $data_units, $parity_units, $pool_width, [3: 1, 2, 3], [0], [1: $rackvid])}"
    local rackv="{0x6a| (($rackvid), $rackid, [1: $enclvid])}"
    local enclv="{0x6a| (($enclvid), $enclid, [1: $ctrlvid])}"
    local ctrlv="{0x6a| (($ctrlvid), $ctrlid, $(_build_diskv_fids_str $pool_width))}"

    local_conf=$(cat <<CONF_END
[$(( $ios_count + 1 + $pool_width * 3 + 15 )):
  {0x74| (($root), 1, [1: $prof])},
  {0x70| (($prof), $fs)},
  {0x66| (($fs), (11, 22), 1,
          [1: "$pool_width $data_units $parity_units"],
          $poolid,
          [1: $node],
          [1: $poolid],
          [1: $rackid])},
  {0x6e| (($node), 16000, 2, 3, 2, $poolid, [1: $proc])},
  {0x72| (($proc), 4000, 2,
               [$(($ios_count + 3)): $mds_name, $rm, $ios_names, $stats])},
  {0x73| (($rm), 4, [1: "$rms_ep"], [0])},
  {0x73| (($stats), 5, [1: "$stats_ep"], [0])},
  $mds_obj,
  $ios_objs,
  $(_build_ios_devs $pool_width),
  $rack,
  $encl,
  $ctrl,
  $pool,
  $pver,
  $rackv,
  $enclv,
  $ctrlv]
CONF_END
)

    echo "$local_conf"
}

# vim: tabstop=4 shiftwidth=4 expandtab filetype=sh
