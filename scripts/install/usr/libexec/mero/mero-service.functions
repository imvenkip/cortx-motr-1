# Profile fid in the format suitable for 'prof=' mount option. Must match $prof
# variable in m0_build_local_conf()
m0_prof_opt='<0x7000000000000001:0>'


# Print message on console (STDERR) and write it into system log
#   @param  $1  msg
m0_log()
{
    logger -p daemon.info -s -t mero -- "$*"
}


# Print message on STDERR
m0_echo_err()
{
    echo "mero: ERROR: $*" >&2
}

# Report error and exit.
#   @param  $*  error msg
m0_exit()
{
    m0_log "$*"
    exit 1
}

# path to binaries inside working directory
declare -rA _path_inside_workdir=(
    [m0mero.ko]='mero/m0mero.ko'
    [m0ctl.ko]='mero/m0ctl.ko'
    [m0gf.ko]='extra-libs/gf-complete/src/linux_kernel/m0gf.ko'
    [m0d]='mero/m0d'
    [m0mkfs]='utils/mkfs/m0mkfs'
    [m0traced]='utils/trace/m0traced'
)

# Return a path to Mero executables.
#   @param  $1  name of an executable
m0_path_to()
{
    local binary=$1

    if [ -n "$MERO_DEVEL_WORKDIR_PATH" ] ; then
        echo "$MERO_DEVEL_WORKDIR_PATH/${_path_inside_workdir[$binary]}"
    else
        echo "$binary"
    fi
}

# Return value of particular variable, stored in genders "database"
#   @param  $1  name of a variable
#   @param  $2  optional name of a node, for which the query is performed, if
#               ommited, then value is returned for current node
m0_genders_value_of()
{
    local var_name=$1
    local node=$2

    nodeattr -f $MERO_GENDERS_CONF -v $node $var_name
}

# Start LNET service
m0_start_lnet()
{
    if test -x /usr/bin/systemctl && systemctl list-unit-files | grep -q lnet ; then
        # do nothing, systemd lnet service will handle it
        true
    elif chkconfig --list | grep -q lnet ; then
        service lnet start
    else
        if ! lsmod | grep -q lnet ; then
            modprobe lnet || m0_exit "Failed to load lnet module"
            lctl network up
        fi
    fi
}

# Stop LNET service
m0_stop_lnet()
{
    if test -x /usr/bin/systemctl && systemctl list-unit-files | grep -q lnet ; then
        # do nothing, systemd lnet service will handle it
        true
    elif chkconfig --list | grep -q lnet ; then
        service lnet stop
    else
        lctl network down
        modprobe -r ksocklnd || m0_exit "Failed to unload lnet modules"
    fi
}

# Load Mero modules.
m0_load_modules()
{
    local m0mero_params

    m0_start_lnet

    if [ -n "$MERO_KMOD_PARAMS" ] ; then
        m0mero_params="$MERO_KMOD_PARAMS $MERO_KMOD_EXTRA_PARAMS"
    else
        local uuid=${MERO_KMOD_NODE_UUID:-$(m0_genders_value_of m0_uuid)}
        local msg_size=$(m0_genders_value_of m0_max_rpc_msg_size)
        local qlen=$(m0_genders_value_of m0_min_rpc_recvq_len)
        local ep=$(m0_get_kmod_ep)

        m0mero_params="$m0mero_params node_uuid=$uuid"
        m0mero_params="$m0mero_params local_addr=$ep"
        m0mero_params="$m0mero_params max_rpc_msg_size=$msg_size"
        m0mero_params="$m0mero_params tm_recv_queue_min_len=$qlen"
        m0mero_params="$m0mero_params $MERO_KMOD_EXTRA_PARAMS"
    fi

    if [ -n "$MERO_DEVEL_WORKDIR_PATH" ] ; then
        insmod $(m0_path_to m0gf.ko) || m0_exit "Failed to load m0gf module"
        insmod $(m0_path_to m0mero.ko) $m0mero_params\
            || m0_exit "Failed to load m0mero module"
        insmod $(m0_path_to m0ctl.ko) || m0_exit "Failed to load m0ctl module"
    else
        modprobe m0mero $m0mero_params
        modprobe m0ctl
    fi
}

# Unload Mero modules.
m0_unload_modules()
{
    lsmod | grep -q m0ctl && ( rmmod m0ctl || m0_exit "Failed to unload m0ctl module" )

    if [ -n "$MERO_DEVEL_WORKDIR_PATH" ] ; then
        rmmod m0mero || m0_exit "Failed to unload m0mero module"
        rmmod m0gf || m0_exit "Failed to unload m0gf module"
    else
        modprobe -r m0mero
    fi

    m0_stop_lnet
}

# Return path to a working directory of particular m0d instance
#   @param  $1  m0d service name
m0_get_m0d_data_dir_for()
{
    local service=$1

    echo "${MERO_M0D_DATA_DIR:-$(m0_genders_value_of m0_datadir)}/$service"
}

# Return space-separated list of all nodes in the cluster from genders file
m0_get_nodes()
{
    nodeattr -f $MERO_GENDERS_CONF -c -A | tr ',' ' '
}

# Return lnet NID of a node
#   @param  $1  optional name of a node, for which the query is performed, if
#               ommited, then value is returned for current node
m0_get_lnet_nid()
{
    local node=$1

    local lnid
    # if $node is empty, then query is for current node
    if [ -z "$node" -o "$node" = "$(hostname -s)" ] ; then
        lnid=${MERO_LNET_NID:=$(m0_genders_value_of m0_lnet_nid)}
        if [ "$lnid" = 'auto' ] ; then
            lnid=$(lctl list_nids | head -n1)
            [ -z "$lnid" ] && \
                m0_exit 'Failed to auto-detect Lnet NID, please check that' \
                        ' lnet service is running'
        fi
    else
        lnid=$(m0_genders_value_of m0_lnet_nid $node)
    fi

    echo $lnid
}

# Return space-separated list of all services for particular node
#   @param  $1  optional name of a node, for which the query is performed, if
#               ommited, then value is returned for current node
m0_get_services()
{
    local node=$1
    local services

    # if $node is empty, then query is for current node
    if [ -z "$node" -o "$node" = "$(hostname -s)" ] ; then
        services=${SERVICES:-$MERO_SERVICES}
    fi

    echo ${services:-$(m0_genders_value_of m0_services $node | tr ';' ' ')}
}

# Return space-separated list of all services in the cluster
#   @param  $1  optional service type name, if ommited, the list of all services
#               in cluster is returned
m0_get_global_services()
{
    local service_type=$1

    local services

    for node in $(m0_get_nodes); do
        services="$services $(m0_get_services $node)"
    done

    # RMS and STATS services run on MDS' endpoint
    case $service_type in
        rms|stats) service_type=mds ;;
    esac

    case $service_type in
        '') echo $services
            ;;
        *)
            echo $services | grep -E -o "$service_type([[:digit:]]+)?"
            ;;
    esac
}

# Return m0mero.ko endpoint
m0_get_kmod_ep()
{
    echo "$(m0_get_lnet_nid):12345:41:301"
}

# Return endpoint of a particular service
#   @param  $1  service name
#   @param  $2  optional name of a node, for which the query is performed, if
#               ommited, then value is returned for current node
m0_get_ep_of()
{
    local service=$1
    local node=$2

    local found=false
    local lnid=$(m0_get_lnet_nid $node)
    local lpid=12345
    local confd_portal=41
    local mds_portal=41
    local ha_portal=34
    local ios_portal=41
    local confd_tid=101
    local mds_tid=201
    local ha_tid=1
    local ios_tid=401
    local ep
    local s

    for s in $(m0_get_services $node); do
        case $s in
            confd*)
                local global_confd_ep="$lnid:$lpid:$confd_portal:$((confd_tid++))"
                ep="${MERO_CONFD_LOCAL_EP:-$global_confd_ep}"
                ;;
            mds*) ep="$lnid:$lpid:$mds_portal:$((mds_tid++))"
                ;;
            ios*) ep="$lnid:$lpid:$ios_portal:$((ios_tid++))"
                ;;
            ha*)  ep="$lnid:$lpid:$ha_portal:$((ha_tid++))"
                ;;
        esac

        if [[ $s == $service ]] ; then
            found=true
            break
        fi
    done

    if ! $found ; then
        m0_echo_err "cannot find endpoint of '$service' on the" \
                    " ${node:+current} node"
        ep=''
    fi

    echo $ep
}

_word_index()
{
    local str=$1
    local word=$2

    echo $str | awk "{ for (i = 1; i <= NF; i++) if (\"$word\" == \$i) print i }"
}

m0_get_proc_fid_for()
{
    local service=$1
    local node=$2

    local nidx
    local sidx
    local proc_fid=''

    nidx=$(_word_index "$(m0_get_nodes)" ${node:-$(hostname -s)})

    if [[ -n $nidx ]] ; then
        sidx=$(_word_index "$(m0_get_services)" $service)
        if [[ -n $sidx ]] ; then
            proc_fid=$(printf 0x%x:%d $((0x7200000000000000+$nidx)) $sidx)
        else
            m0_exit "cannot find service $service"
        fi
    else
        m0_exit "cannot find node $node"
    fi

    echo $proc_fid
}

# Return space-separated list of all endpoints in the cluster for particular
# service type, from genders file
#   @param  $1  service type (confd mds ios ha rms stats)
m0_get_global_eps_of()
{
    local stype=$1

    local global_eps
    local n
    local s

    for n in $(m0_get_nodes); do
        for s in $(m0_get_services $n); do
            case $s in
                ${stype}*)
                    global_eps="$global_eps $(m0_get_ep_of $s $n)"
                    ;;
                mds*)
                    [[ $stype == rms || $stype == stats ]] || continue
                    global_eps="$global_eps $(m0_get_ep_of $s $n)"
                    ;;
            esac
        done
    done

    echo $global_eps
}

# Return first found endpoint of a particular service in the cluster, from
# genders file
#   @param  $1  service
m0_get_global_ep_of()
{
    local stype=$1

    echo $(m0_get_global_eps_of $stype) | awk '{print $1}'
}

#
# Build parameters list for m0d running "core" services
#
#   @param $1 directory to store configuration file.
#
m0_get_core_params()
{
    echo " -D db -S stobs -A linuxstob:addb-stobs" \
         " -P $m0_prof_opt" \
         " -w $(m0_genders_value_of m0_pool_width)" \
         " -m $(m0_genders_value_of m0_max_rpc_msg_size)" \
         " -q $(m0_genders_value_of m0_min_rpc_recvq_len)"
}

# Return space-separated list of running Mero servers on a current node
m0_get_running_servers()
{
    if [ -x /usr/bin/systemctl ] ; then
        systemctl \
        | sed -n -r -e 's#^mero-server[-@](.*)\.service.*running.*#\1#p'
    elif [ -x /sbin/initctl ] ; then
        initctl list \
        | grep mero-server \
        | sed -n -r -e 's#.*mero-server \((.*)\) start/running.*#\1#p'
    fi
}

# Return PID of running m0d daemon for particular Mero service
#   @param  $1  name of a service, e.g. 'mds', 'ios1'
m0_get_server_pid_for()
{
    local service=$1

    local t='@'
    case $service in
        confd|ha) t='-' ;;
    esac

    if [ -x /usr/bin/systemctl ] ; then
        systemctl show -pMainPID mero-server${t}${service}.service \
        | sed -e 's/MainPID=//'
    elif [ -x /sbin/initctl ] ; then
        initctl list \
        | sed -n -r -e \
            "s/mero-server \\($service\\) start\\/.* process ([[:digit:]]+)/\\1/p"
    fi
}

# Return generated service FID in form of container:key
#   @param  $1  name of a service, e.g. 'mds', 'ios1'
#   @param  $2  node index in global nodes array where service is located
m0_build_service_fid()
{
    local service=$1
    local node_idx=$2
    local sidx_param=${3:-0}

    local stype
    local sidx
    local container

    if [[ $service == "addb2" ]] ; then
       stype="addb2"
       sidx=0
    else
       stype=${service//[0-9]}
       sidx=${service//[^0-9]}
       sidx=${sidx:-$sidx_param}
    fi

    case $stype in
        mds)       container='0x7300000000000001' ;;
        ios)       container='0x7300000000000002' ;;
        confd)     container='0x7300000000000003' ;;
        rms)       container='0x7300000000000004' ;;
        stats)     container='0x7300000000000005' ;;
        ha)        container='0x7300000000000006' ;;
        repair)    container='0x7300000000000007' ;;
        rebalance) container='0x7300000000000008' ;;
        addb2)     container='0x7300000000000009' ;;
        sss)       container='0x730000000000000a' ;;
    esac

    printf %x:%d $(( $container + $node_idx * 16 )) $sidx
}

# Return well formed -s command line options ready to be inserted in m0d command
# line. Command line options are formed for one particular service.
#   @param  $1  name of a service, e.g. 'mds', 'ios1'
#   @param  $2  node index in global nodes array where service is located
m0_get_m0d_services_for()
{
    local service=$1
    local node=$2

    local nidx
    local res=''

    nidx=$(_word_index "$(m0_get_nodes)" ${node:-$(hostname -s)})

    if [[ -n $nidx ]] ; then
        case "$service" in
            mds*)
               res+=" -s mdservice:<$(m0_build_service_fid $service $nidx)>"
               res+=" -s rmservice:<$(m0_build_service_fid ${service/mds/rms} $nidx)>"
               res+=" -s stats:<$(m0_build_service_fid ${service/mds/stats} $nidx)>"
               ;;
            ios*)
               res+=" -s ioservice:<$(m0_build_service_fid $service $nidx)>"
               res+=" -s sns_repair:<$(m0_build_service_fid ${service/ios/repair} $nidx)>"
               res+=" -s sns_rebalance:<$(m0_build_service_fid ${service/ios/rebalance} $nidx)>"
               ;;
            confd|addb2)
               res+=" -s $service:<$(m0_build_service_fid $service $nidx)>"
               ;;
        esac
    else
        m0_exit "cannot find node $node"
    fi

    echo $res
}

_build_disk_ids_str()
{
    local start_id=$1
    local count=$2

    local dev_ids
    local id
    for id in $(seq $start_id $(($start_id + $count - 1))) ; do
        local dev_id="(0x6400000000000001, $id)"
        dev_ids="$dev_ids${dev_ids:+, }$dev_id"
    done

    echo "[$count: $dev_ids]"
}

_build_disk_fids_str()
{
    local count=$1

    local disk_fids
    local id
    for id in $(seq 1 $count) ; do
        local ddisk_id="(0x6b00000000000001, $id)"
        disk_fids="$disk_fids${disk_fids:+, }$ddisk_id"
    done

    echo "[$count: $disk_fids]"
}

_build_diskv_fids_str()
{
    local count=$1

    local disk_fids
    local id
    for id in $(seq 1 $count) ; do
        local ddiskv_id="(0x6a00000000000001, $id)"
        disk_fids="$disk_fids${disk_fids:+, }$ddiskv_id"
    done

    echo "[$count: $disk_fids]"
}

_build_ios_devs()
{
    local count=$1

    local devs
    local id
    for id in $(seq 1 $count) ; do
        local ddev_id="(0x6400000000000001, $id)"
        local ddisk_id="(0x6b00000000000001, $id)"
        local ddiskv_id="(0x6a00000000000001, $id)"
        local ddev_obj="{0x64| (($ddev_id), 4, 1, 4096, 596000000000, 3, 4, \"/dev/loop$id\")}"
        local ddisk_obj="{0x6b| (($ddisk_id), $ddev_id)}"
        local ddiskv_obj="{0x6a| (($ddiskv_id), $ddisk_id, [0])}"
        local dev="$ddev_obj,\n  $ddisk_obj,\n  $ddiskv_obj"
        devs="$devs${devs:+,\n  }$dev"
    done

    echo -e "$devs"
}

_build_service_names_for()
{
    local service_type=$1

    local genders_stype

    # check service type
    case $service_type in
        ios|mds|ha|sss)
            genders_stype=$service_type
           ;;
        rms|stats)
            genders_stype=mds
           ;;
        *) m0_exit "Internal error, unkonwn service type '$service_type' in"
                   " _build_service_names_for()"
           ;;
    esac

    local node_idx=0
    local idx=0
    local names
    local node
    local s

    for node in $(m0_get_nodes) ; do
        for s in $(m0_get_services $node) ; do
            if [[ $s == $genders_stype* ]] ; then
                local name="(0x$(m0_build_service_fid ${s/$genders_stype/$service_type} $node_idx))"
                names="$names${names:+, }${name/:/,}"
            elif [[ $genders_stype == sss ]] ; then
                local name="(0x$(m0_build_service_fid sss $node_idx $idx))"
                names="$names${names:+, }${name/:/,}"
            fi
            ((idx++))
        done
        ((node_idx++))
    done

    echo "$names"
}

_build_service_objects_for()
{
    local service_type=$1
    local genders_stype
    local eps=($(m0_get_global_eps_of $service_type));

    # check service type
    case $service_type in
        ios|mds|rms|stats|ha|sss) # valid services
            ;;
        *) m0_exit "Internal error, unkonwn service type '$service_type' in"
                   " _build_service_objects_for()"
           ;;
    esac

    local type_id
    case $service_type in
        mds)   genders_stype=$service_type ; type_id=1 ;;
        ios)   genders_stype=$service_type ; type_id=2 ;;
        rms)   genders_stype=mds ; type_id=4 ;;
        stats) genders_stype=mds ; type_id=5 ;;
        ha)    genders_stype=$service_type ; type_id=6 ;;
        sss)   genders_stype=$service_type ; type_id=7 ;;
    esac

    local idx=0
    local node_idx=0
    local node
    local objs

    for node in $(m0_get_nodes) ; do
        for s in $(m0_get_services $node) ; do
            if [[ $s == $genders_stype* ]] ; then
                local disk_ids='[0]'
                if [[ $service_type == ios ]] ; then
                    local count=$(m0_get_global_services $service_type | wc -w)
                    local disks_per_service=$(( $pool_width / $count ))
                    disk_ids=$(_build_disk_ids_str $(($idx * $disks_per_service + 1)) $disks_per_service)
                fi
                local name="(0x$(m0_build_service_fid ${s/$genders_stype/$service_type} $node_idx))"
                name=${name/:/, }
                objs="$objs${objs:+,\n  }{0x73| (($name), $type_id, [1: \"${eps[$idx]}\"], $disk_ids)}"
                ((idx++))
            elif [[ $service_type == sss ]] ; then
                local ep=$(m0_get_ep_of $s $node)
                local name="(0x$(m0_build_service_fid sss $node_idx $idx))"
                name=${name/:/, }
                objs="$objs${objs:+,\n  }{0x73| (($name), $type_id, [1: \"$ep\"], [0])}"
                ((idx++))
            fi
        done
        ((node_idx++))
    done

    echo -e "$objs"
}

# Construct local_conf mount option from genders file
m0_build_local_conf()
{
    local pool_width=$(m0_genders_value_of m0_pool_width)
    local data_units=$(m0_genders_value_of m0_data_units)
    local parity_units=$(m0_genders_value_of m0_parity_units)

    local  root='^t|1:0'
    local  prof='^p|1:0'
    local    fs='^f|1:1'
    local  node='^n|1:2'
    local  proc='^r|1:3'

    local rackid='^a|1:6'
    local enclid='^e|1:7'
    local ctrlid='^c|1:8'
    local poolid='^o|1:9'
    local pverid='^v|1:10'

    local rackvid="(0x6a00000000000001, $(($pool_width + 1)))"
    local enclvid="(0x6a00000000000001, $(($pool_width + 2)))"
    local ctrlvid="(0x6a00000000000001, $(($pool_width + 3)))"

    local rack="{0x61| (($rackid), [1: $enclid], [1: $pverid])}"
    local encl="{0x65| (($enclid), [1: $ctrlid], [1: $pverid])}"
    local ctrl="{0x63| (($ctrlid), $node, $(_build_disk_fids_str $pool_width), [1: $pverid])}"
    local pool="{0x6f| (($poolid), 0, [1: $pverid])}"
    local pver="{0x76| (($pverid), 0, $data_units, $parity_units, $pool_width, [5: 0, 0, 0, 0, $parity_units], [1: $rackvid])}"
    local rackv="{0x6a| (($rackvid), $rackid, [1: $enclvid])}"
    local enclv="{0x6a| (($enclvid), $enclid, [1: $ctrlvid])}"
    local ctrlv="{0x6a| (($ctrlvid), $ctrlid, $(_build_diskv_fids_str $pool_width))}"

    local ios_count=$(m0_get_global_services ios | wc -w)
    local ios_names=$(_build_service_names_for ios)
    local ios_objs=$(_build_service_objects_for ios)

    local mds_count=$(m0_get_global_services mds | wc -w)
    local mds_names=$(_build_service_names_for mds)
    local mds_objs=$(_build_service_objects_for mds)

    local rms_count=$(m0_get_global_services rms | wc -w)
    local rms_names=$(_build_service_names_for rms)
    local rms_objs=$(_build_service_objects_for rms)

    local stats_count=$(m0_get_global_services stats | wc -w)
    local stats_names=$(_build_service_names_for stats)
    local stats_objs=$(_build_service_objects_for stats)

    local ha_count=$(m0_get_global_services ha | wc -w)
    local ha_names=$(_build_service_names_for ha)
    local ha_objs=$(_build_service_objects_for ha)

    local sss_count=$(m0_get_global_services | wc -w)
    local sss_names=$(_build_service_names_for sss)
    local sss_objs=$(_build_service_objects_for sss)

    local local_conf=$(cat <<CONF_END
[$(( $ios_count + $mds_count + $rms_count + $stats_count + $ha_count + $sss_count + $pool_width * 3 + 13 )):
  {0x74| (($root), 1, [1: $prof])},
  {0x70| (($prof), $fs)},
  {0x66| (($fs), (11, 22), 1,
          [1: "$pool_width $data_units $parity_units"],
          $poolid,
          [1: $node],
          [1: $poolid],
          [1: $rackid])},
  {0x6e| (($node), 16000, 2, 3, 2, $poolid, [1: $proc])},
  {0x72| (($proc), [1:3], 0, 0, 0, 0,
               [$(($mds_count + $ios_count + $rms_count + $stats_count + $ha_count + $sss_count)): $mds_names, $ios_names, $rms_names, $stats_names, $ha_names, $sss_names])},
  $mds_objs,
  $ios_objs,
  $rms_objs,
  $stats_objs,
  $ha_objs,
  $sss_objs,
  $(_build_ios_devs $pool_width),
  $rack,
  $encl,
  $ctrl,
  $pool,
  $pver,
  $rackv,
  $enclv,
  $ctrlv]
CONF_END
)

    echo "$local_conf"
}

# vim: tabstop=4 shiftwidth=4 expandtab filetype=sh
