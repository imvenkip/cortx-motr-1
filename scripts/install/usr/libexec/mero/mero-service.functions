#
# Error handling
#

# By default, bash doesn't propagate error exit code from a subshell process to
# the parent shell. Especially, if a subshell is called in double quotes as an
# assignment to a local variable:
#
#   local nodes="$current_node $(get_sibling_nodes)"
#
# In order to enable proper error handling, additional options and traps need to
# be enabled.

set -e
set -E

_error_handler()
{
    kill -TERM $$
    echo 'propagating error to parent shell' >&2
}
trap _error_handler ERR

_term_handler()
{
    echo 'got sub-shell error, terminating..' >&2
    exit 42
}
trap _term_handler TERM

#
# Library functions
#

# Profile fid in the format suitable for 'prof=' mount option. Must match $prof
# variable in m0_build_local_conf()
m0_prof_opt='<0x7000000000000001:0>'

# Print message on console (STDERR)
#   @param  $1  msg
m0_log()
{
    echo "$@" >&2
}


# Print message on STDERR
m0_echo_err()
{
    echo "mero: ERROR: $*" >&2
}

# Report error and exit.
#   @param  $*  error msg
m0_exit()
{
    m0_log "$*"
    exit 1
}

# path to binaries inside working directory
declare -rA _path_inside_workdir=(
    [m0mero.ko]='mero/m0mero.ko'
    [m0ctl.ko]='mero/m0ctl.ko'
    [m0gf.ko]='extra-libs/gf-complete/src/linux_kernel/m0gf.ko'
    [m0d]='mero/m0d'
    [m0mkfs]='utils/mkfs/m0mkfs'
    [m0traced]='utils/trace/m0traced'
)

# Return a path to Mero executables.
#   @param  $1  name of an executable
m0_path_to()
{
    local binary=$1

    if [ -n "$MERO_DEVEL_WORKDIR_PATH" ] ; then
        echo "$MERO_DEVEL_WORKDIR_PATH/${_path_inside_workdir[$binary]}"
    else
        echo "$binary"
    fi
}

# Checks if particular variable exists in genders "database"
#   @param  $1  name of a variable
#   @param  $2  optional name of a node, for which the query is performed, if
#               ommited, then current node is queried
m0_genders_has_variable()
{
    local var_name=$1
    local node=$2

    nodeattr -f $MERO_GENDERS_CONF -Q $node $var_name
}

# Return value of particular variable, stored in genders "database"
#   @param  $1  name of a variable
#   @param  $2  optional name of a node, for which the query is performed, if
#               ommited, then value is returned for current node
m0_genders_value_of()
{
    local var_name=$1
    local node=$2

    if m0_genders_has_variable $var_name $node ; then
        nodeattr -f $MERO_GENDERS_CONF -v $node $var_name
    else
        m0_log "WARN: query not existing genders var '$var_name'${node:+ node $node}"
    fi
}

# Start LNET service
m0_start_lnet()
{
    if test -x /usr/bin/systemctl && systemctl list-unit-files | grep -q lnet ; then
        # do nothing, systemd lnet service will handle it
        true
    elif chkconfig --list | grep -q lnet ; then
        service lnet start
    else
        if ! lsmod | grep -q lnet ; then
            modprobe lnet || m0_exit "Failed to load lnet module"
            lctl network up
        fi
    fi
}

# Stop LNET service
m0_stop_lnet()
{
    if test -x /usr/bin/systemctl && systemctl list-unit-files | grep -q lnet ; then
        # do nothing, systemd lnet service will handle it
        true
    elif chkconfig --list | grep -q lnet ; then
        service lnet stop
    else
        lctl network down
        modprobe -r ksocklnd || m0_exit "Failed to unload lnet modules"
    fi
}

# Load Mero modules.
m0_load_modules()
{
    local m0mero_params

    m0_start_lnet

    if [ -n "$MERO_KMOD_PARAMS" ] ; then
        m0mero_params="$MERO_KMOD_PARAMS $MERO_KMOD_EXTRA_PARAMS"
    else
        local uuid=${MERO_KMOD_NODE_UUID:-$(m0_genders_value_of m0_uuid)}
        local msg_size=${MERO_M0D_MAX_RPC_MSG_SIZE:-$(m0_genders_value_of m0_max_rpc_msg_size)}
        local qlen=${MERO_M0D_MIN_RPC_RECVQ_LEN:-$(m0_genders_value_of m0_min_rpc_recvq_len)}
        local ep=$(m0_get_kmod_ep)

        m0mero_params="$m0mero_params node_uuid=$uuid"
        m0mero_params="$m0mero_params local_addr=$ep"
        m0mero_params="$m0mero_params max_rpc_msg_size=$msg_size"
        m0mero_params="$m0mero_params tm_recv_queue_min_len=$qlen"
        m0mero_params="$m0mero_params $MERO_KMOD_EXTRA_PARAMS"
    fi

    if [ -n "$MERO_DEVEL_WORKDIR_PATH" ] ; then
        insmod $(m0_path_to m0gf.ko) || m0_exit "Failed to load m0gf module"
        insmod $(m0_path_to m0mero.ko) $m0mero_params\
            || m0_exit "Failed to load m0mero module"
        insmod $(m0_path_to m0ctl.ko) || m0_exit "Failed to load m0ctl module"
    else
        modprobe m0mero $m0mero_params
        modprobe m0ctl
    fi
}

# Unload Mero modules.
m0_unload_modules()
{
    lsmod | grep -q m0ctl && ( rmmod m0ctl || m0_exit "Failed to unload m0ctl module" )

    if [ -n "$MERO_DEVEL_WORKDIR_PATH" ] ; then
        rmmod m0mero || m0_exit "Failed to unload m0mero module"
        rmmod m0gf || m0_exit "Failed to unload m0gf module"
    else
        modprobe -r m0mero
    fi

    m0_stop_lnet
}

# Return path to a working directory of particular m0d instance
#   @param  $1  m0d service name
m0_get_m0d_data_dir_for()
{
    local service=$1

    echo "${MERO_M0D_DATA_DIR:-$(m0_genders_value_of m0_datadir)}/$service"
}

# Return space-separated list of all nodes in the cluster from genders file
m0_get_nodes()
{
    nodeattr -f $MERO_GENDERS_CONF -c -A | tr ',' ' '
}

# Return lnet NID of a node
#   @param  $1  optional name of a node, for which the query is performed, if
#               ommited, then value is returned for current node
m0_get_lnet_nid()
{
    local node=$1

    local lnid
    # if $node is empty, then query is for current node
    if [[ -z $node || $node == $(hostname -s) ]] ; then
        lnid=${MERO_LNET_NID:=$(m0_genders_value_of m0_lnet_nid)}
        if [[ -z $lnid || $lnid == auto ]] ; then
            lnid=$(lctl list_nids | head -n1)
            [[ -z $lnid ]] && \
                m0_exit 'Failed to auto-detect Lnet NID, please check that' \
                        ' lnet service is running'
        fi
    else
        lnid=$(m0_genders_value_of m0_lnet_nid $node)
    fi

    echo $lnid
}

# Return space-separated list of all services for particular node
#   @param  $1  optional name of a node, for which the query is performed, if
#               ommited, then value is returned for current node
m0_get_services()
{
    local node=$1
    local services

    # if $node is empty, then query is for current node
    if [ -z "$node" -o "$node" = "$(hostname -s)" ] ; then
        services=${SERVICES:-$MERO_SERVICES}
    fi

    echo ${services:-$(m0_genders_value_of m0_services $node | tr ';' ' ')}
}

# Return space-separated list of all services in the cluster
#   @param  $1  optional service type name, if ommited, the list of all services
#               in cluster is returned
m0_get_global_services()
{
    local service_type=$1

    local services

    for node in $(m0_get_nodes); do
        services="$services $(m0_get_services $node)"
    done

    case $service_type in
        '') echo $services
            ;;
        *)
            echo $services | grep -E -o "$service_type([[:digit:]]+)?" || true
            ;;
    esac
}

# Return m0mero.ko endpoint
m0_get_kmod_ep()
{
    echo "$(m0_get_lnet_nid):12345:41:301"
}

_portal_id()
{
    local s=$1
    local portal_id;

    case $s in
        mkfs)   portal_id=35;;
        mds*)   portal_id=41;;
        ios*)   portal_id=42;;
        rms*)   portal_id=43;;
        confd)  portal_id=44;;
        ha)     portal_id=45;;
    esac
    echo $portal_id
}

m0_get_mkfs_ep_of()
{
    local service=$1
    local service_ep=$(m0_get_ep_of $1)
    local svc_tmid=$(echo $service_ep | cut -d: -f4)
    local portal_id=$(_portal_id mkfs)

    echo "${service_ep%:*:*}:$portal_id:$svc_tmid"
}

# Return endpoint of a particular service
#   @param  $1  service name
#   @param  $2  optional name of a node, for which the query is performed, if
#               ommited, then value is returned for current node
m0_get_ep_of()
{
    local service=$1
    local node=$2

    local found=false
    local lnid=$(m0_get_lnet_nid $node)
    local lpid=12345
    local confd_tid=101
    local mds_tid=201
    local rms_tid=301
    local ha_tid=1
    local ios_tid=401
    local portal=$(_portal_id $1)
    local ep
    local s

    for s in $(m0_get_services $node); do
        case $s in
            confd*) ep=${MERO_CONFD_EP:-"$lnid:$lpid:$portal:$((confd_tid++))"}
                ;;
            mds*) ep=${MERO_MDS_EP:-"$lnid:$lpid:$portal:$((mds_tid++))"}
                ;;
            ios*) ep="$lnid:$lpid:$portal:$((ios_tid++))"
                ;;
            rms*) ep="$lnid:$lpid:$portal:$((rms_tid++))"
                ;;
            ha*)  ep="$lnid:$lpid:$portal:$((ha_tid++))"
                ;;
        esac

        if [[ $s == $service ]] ; then
            found=true
            break
        fi
    done

    if ! $found ; then
        m0_echo_err "cannot find endpoint of '$service' on the" \
                    " ${node:+current} node"
        ep=''
    fi

    echo $ep
}

_word_index()
{
    local str=$1
    local word=$2

    echo $str | awk "{ for (i = 1; i <= NF; i++) if (\"$word\" == \$i) print i }"
}

m0_get_proc_fid_for()
{
    local service=$1
    local node=$2

    local nidx
    local sidx
    local proc_fid=''

    nidx=$(_word_index "$(m0_get_nodes)" ${node:-$(hostname -s)})

    if [[ -n $nidx ]] ; then
        sidx=$(_word_index "$(m0_get_services)" $service)

        if [[ -n $sidx ]] ; then
            ((--sidx)) || true
            proc_fid=$(printf 0x%x:%d $((0x7200000000000000+$nidx)) $sidx)
        else
            m0_exit "cannot find service $service"
        fi
    else
        m0_exit "cannot find node $node"
    fi

    echo $proc_fid
}

# Return space-separated list of all endpoints in the cluster for particular
# service type, from genders file
#   @param  $1  service type (confd mds ios ha rms)
m0_get_global_eps_of()
{
    local stype=$1
    local global_eps
    local n
    local s

    for n in $(m0_get_nodes); do
        for s in $(m0_get_services $n); do
            if [[ $s == ${stype}* ]]; then
                global_eps="$global_eps $(m0_get_ep_of $s $n)"
            fi
        done
    done

    echo $global_eps
}

# Return first found endpoint of a particular service in the cluster, from
# genders file
#   @param  $1  service
m0_get_global_ep_of()
{
    local stype=$1

    echo $(m0_get_global_eps_of $stype) | awk '{print $1}'
}

#
# Build parameters list for m0d running "core" services
#
#   @param $1 directory to store configuration file.
#
m0_get_core_params()
{
    local optional_params

    if m0_genders_has_variable m0_be_tx_group_tx_nr_max ; then
        optional_params+=" -n $(m0_genders_value_of m0_be_tx_group_tx_nr_max)"
    fi

    if m0_genders_has_variable m0_be_tx_group_reg_nr_max ; then
        optional_params+=" -k $(m0_genders_value_of m0_be_tx_group_reg_nr_max)"
    fi

    if m0_genders_has_variable m0_be_tx_group_reg_size_max ; then
        optional_params+=" -K $(m0_genders_value_of m0_be_tx_group_reg_size_max)"
    fi

    if m0_genders_has_variable m0_be_tx_group_payload_size_max ; then
        optional_params+=" -p $(m0_genders_value_of m0_be_tx_group_payload_size_max)"
    fi

    echo " -D db -S stobs -A linuxstob:addb-stobs" \
         " -P $m0_prof_opt" \
         " -w $(m0_genders_value_of m0_pool_width)" \
         " -m ${MERO_M0D_MAX_RPC_MSG_SIZE:-$(m0_genders_value_of m0_max_rpc_msg_size)}" \
         " -q ${MERO_M0D_MIN_RPC_RECVQ_LEN:-$(m0_genders_value_of m0_min_rpc_recvq_len)}" \
         " $optional_params"
}

# Return space-separated list of running Mero servers on a current node
m0_get_running_servers()
{
    if [ -x /usr/bin/systemctl ] ; then
        systemctl \
        | sed -n -r -e 's#^mero-server[-@](.*)\.service.*running.*#\1#p'
    elif [ -x /sbin/initctl ] ; then
        initctl list \
        | grep mero-server \
        | sed -n -r -e 's#.*mero-server \((.*)\) start/running.*#\1#p'
    fi
}

# Return PID of running m0d daemon for particular Mero service
#   @param  $1  name of a service, e.g. 'mds', 'ios1'
m0_get_server_pid_for()
{
    local service=$1

    local t='@'
    case $service in
        confd|ha) t='-' ;;
    esac

    if [ -x /usr/bin/systemctl ] ; then
        systemctl show -pMainPID mero-server${t}${service}.service \
        | sed -e 's/MainPID=//'
    elif [ -x /sbin/initctl ] ; then
        initctl list \
        | sed -n -r -e \
            "s/mero-server \\($service\\) start\\/.* process ([[:digit:]]+)/\\1/p"
    fi
}

# Return generated service FID in form of container:key
#   @param  $1  name of a service, e.g. 'mds', 'ios1'
#   @param  $2  node index in global nodes array where service is located
m0_build_service_fid()
{
    local service=$1
    local node_idx=$2
    local sidx_param=${3:-0}
    local cid=0

    local stype
    local sidx

    stype=${service//[0-9]}
    sidx=${service//[^0-9]}
    sidx=${sidx:-$sidx_param}

    case $stype in
        mds)       cid=1 ;;
        ios)       cid=2 ;;
        confd)     cid=3 ;;
        rms)       cid=4 ;;
        ha)        cid=5 ;;
        repair)    cid=6 ;;
        rebalance) cid=7 ;;
        addb)      cid=8 ;;
        sss)       cid=9 ;;
    esac

    printf %s:%d "^s|$(( $cid + $node_idx * 16 ))" $sidx
}

_build_disk_ids_str()
{
    local start_id=$1
    local count=$2
    local pverid=$3

    local dev_ids
    local id
    for id in $(seq $start_id $(($start_id + $count - 1))) ; do
        local dev_id="^d|1:$id"
        dev_ids="$dev_ids${dev_ids:+, }$dev_id"
    done

    echo "[$count: $dev_ids]"
}

_build_disk_fids_str()
{
    local count=$1

    local disk_fids
    local id
    for id in $(seq 1 $count) ; do
        local ddisk_id="^k|1:$id"
        disk_fids="$disk_fids${disk_fids:+, }$ddisk_id"
    done

    echo "[$count: $disk_fids]"
}

_build_diskv_fids_str()
{
    local count=$1

    local disk_fids
    local id
    for id in $(seq 1 $count) ; do
        local ddiskv_id="^j|1:$id"
        disk_fids="$disk_fids${disk_fids:+, }$ddiskv_id"
    done

    echo "[$count: $disk_fids]"
}

_build_ios_devs()
{
    local count=$1
    local pverid=$2

    local devs
    local id
    for id in $(seq 1 $count) ; do
        local ddev_id="^d|1:$id"
        local ddisk_id="^k|1:$id"
        local ddiskv_id="^j|1:$id"
        local ddev_obj="{0x64| (($ddev_id), $id, 4, 1, 4096, 596000000000, 3, 4, \"/dev/loop$id\")}"
        local ddisk_obj="{0x6b| (($ddisk_id), $ddev_id, [1: $pverid])}"
        local ddiskv_obj="{0x6a| (($ddiskv_id), $ddisk_id, [0])}"
        local dev="$ddev_obj,\n  $ddisk_obj,\n  $ddiskv_obj"
        devs="$devs${devs:+,\n  }$dev"
    done

    echo -e "$devs"
}

_build_process_names()
{
    local proc_fid_con=$1
    local node
    local names=""
    local key=0

    for node in $(m0_get_nodes) ; do
        for s in $(m0_get_services $node) ; do
            local name="$proc_fid_con:$key"
            names="$names${names:+, }$name"
            ((++key)) || true
        done
    done

    echo -e "$names"
}

_build_process_objects()
{
    local proc_fid_con=$1
    local idx=0
    local node_idx=0
    local node
    local objs=""
    local rms_nr=$(m0_get_global_services rms | wc -w)

    for node in $(m0_get_nodes) ; do
        for s in $(m0_get_services $node) ; do
            local ep=$(m0_get_ep_of $s $node)
            local sname="$(m0_build_service_fid $s $node_idx)"
            local addb="$(m0_build_service_fid "addb2$idx" $node_idx)"

            proc_name="$proc_fid_con:$idx"

            if [[ $s == ios* ]] ; then
                local repair="$(m0_build_service_fid ${s/ios/repair} $node_idx)"
                local rebalance="$(m0_build_service_fid ${s/ios/rebalance} $node_idx)"

                obj="{0x72| (($proc_name), [1:3], 0, 0, 0, 0, "\"$ep\"", [4: $sname, $repair, $rebalance, $addb])}"
            elif [[ $s == mds* && $rms_nr -eq 0 ]] ; then
                local rms="$(m0_build_service_fid ${s/mds/rms} $node_idx)"

                obj="{0x72| (($proc_name), [1:3], 0, 0, 0, 0, "\"$ep\"", [3: $sname, $rms, $addb])}"
            else
                obj="{0x72| (($proc_name), [1:3], 0, 0, 0, 0, "\"$ep\"", [2: $sname, $addb])}"
            fi

            objs="$objs${objs:+, \n} $obj"
            ((idx++)) || true
        done
        ((node_idx++)) || true
    done

    echo -e "$objs"
}

_type_id()
{
    local s=$1
    local type_id;

    case $s in
        mds*)      type_id=1 ;;
        ios*)      type_id=2 ;;
        rms*)      type_id=4 ;;
        ha)        type_id=6 ;;
        confd)     type_id=3 ;;
        sss)       type_id=7 ;;
        repair)    type_id=8 ;;
        rebalance) type_id=9 ;;
        sss)       type_id=7 ;;
        addb*)     type_id=10 ;;
    esac
    echo $type_id
}

_build_service_objects()
{
    local idx=0
    local node_idx=0
    local node
    local objs
    local ios_nr=0
    local rms_nr=$(m0_get_global_services rms | wc -w)

    for node in $(m0_get_nodes) ; do
        for s in $(m0_get_services $node) ; do
            local ep=$(m0_get_ep_of $s $node)
            local type_id=$(_type_id $s)
            local disk_ids='[0]'
            local name="$(m0_build_service_fid $s $node_idx)"

            if [[ $s == ios* ]] ; then
                local count=$(m0_get_global_services ios | wc -w)
                local disks_per_service=$(( $pool_width / $count ))

                disk_ids=$(_build_disk_ids_str $(($ios_nr * $disks_per_service + 1)) $disks_per_service $pverid)
                ((ios_nr++)) || true
            fi

            objs="$objs${objs:+,\n  }{0x73| (($name), $type_id, [1: "\"$ep\""], $disk_ids)}"

	        addb="$(m0_build_service_fid "addb2$idx" $node_idx)"
            type_id=$(_type_id "addb")
            objs="$objs${objs:+,\n  }{0x73| (($addb), $type_id, [1: "\"$ep\""], [0])}"

            if [[ $s == ios* ]] ; then
                local repair="$(m0_build_service_fid ${s/ios/repair} $node_idx)"
                local rebalance="$(m0_build_service_fid ${s/ios/rebalance} $node_idx)"

                type_id=$(_type_id "repair")
                objs="$objs${objs:+,\n  }{0x73| (($repair), $type_id, [1: "\"$ep\""], [0])}"

                type_id=$(_type_id "rebalance")
                objs="$objs${objs:+,\n  }{0x73| (($rebalance), $type_id, [1: "\"$ep\""], [0])}"
            elif [[ $s == mds* && $rms_nr -eq 0 ]] ; then
                local rms="$(m0_build_service_fid ${s/mds/rms} $node_idx)"

                type_id=$(_type_id "rms")
                objs="$objs${objs:+,\n  }{0x73| (($rms), $type_id, [1: "\"$ep\""], [0])}"
            fi

            ((idx++)) || true
        done
        ((node_idx++)) || true
    done

    echo -e "$objs"
}

# Construct local_conf mount option from genders file
m0_build_local_conf()
{
    local pool_width=$(m0_genders_value_of m0_pool_width)
    local data_units=$(m0_genders_value_of m0_data_units)
    local parity_units=$(m0_genders_value_of m0_parity_units)

    local  root='^t|1:0'
    local  prof='^p|1:0'
    local    fs='^f|1:1'
    local  node='^n|1:2'
    local  proc='^r|1:3'

    local rackid='^a|1:6'
    local enclid='^e|1:7'
    local ctrlid='^c|1:8'
    local poolid='^o|1:9'
    local pverid='^v|1:10'

    local rackvid="^j|1:$(($pool_width + 1))"
    local enclvid="^j|1:$(($pool_width + 2))"
    local ctrlvid="^j|1:$(($pool_width + 3))"

    local rack="{0x61| (($rackid), [1: $enclid], [1: $pverid])}"
    local encl="{0x65| (($enclid), [1: $ctrlid], [1: $pverid])}"
    local ctrl="{0x63| (($ctrlid), $node, $(_build_disk_fids_str $pool_width), [1: $pverid])}"
    local pool="{0x6f| (($poolid), 0, [1: $pverid])}"
    local pver="{0x76| (($pverid), 0, $data_units, $parity_units, $pool_width, [5: 0, 0, 0, 0, $parity_units], [1: $rackvid])}"
    local rackv="{0x6a| (($rackvid), $rackid, [1: $enclvid])}"
    local enclv="{0x6a| (($enclvid), $enclid, [1: $ctrlvid])}"
    local ctrlv="{0x6a| (($ctrlvid), $ctrlid, $(_build_diskv_fids_str $pool_width))}"
    local proc_fid_con='^r|1'
    local proc_names=$(_build_process_names $proc_fid_con)
    local proc_objs=$(_build_process_objects $proc_fid_con)
    local procs=$(m0_get_global_services | wc -w)
    local service_objs=$(_build_service_objects)
    local services=$(echo "$service_objs" | wc -l)
    local local_conf=$(cat <<CONF_END
[$(( $procs + $services + $pool_width * 3 + 12 )):
  {0x74| (($root), 1, [1: $prof])},
  {0x70| (($prof), $fs)},
  {0x66| (($fs), (11, 22), 1,
          [1: "$pool_width $data_units $parity_units"],
          $poolid,
          [1: $node],
          [1: $poolid],
          [1: $rackid])},
  {0x6e| (($node), 16000, 2, 3, 2, $poolid, [$procs: $proc_names])},
  $proc_objs,
  $service_objs,
  $(_build_ios_devs $pool_width $pverid),
  $rack,
  $encl,
  $ctrl,
  $pool,
  $pver,
  $rackv,
  $enclv,
  $ctrlv]
CONF_END
)

    echo "$local_conf"
}

# vim: tabstop=4 shiftwidth=4 expandtab filetype=sh
