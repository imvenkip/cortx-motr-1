/* -*- C -*- */

/*
 * COPYRIGHT 2012 XYRATEX TECHNOLOGY LIMITED
 *
 * THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
 * HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
 * LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
 * THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
 * BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
 * USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
 * EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
 *
 * YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
 * THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
 * http://www.xyratex.com/contact
 *
 * Original author: Anand Vidwansa <Anand_Vidwansa@xyratex.com>
 *                  Anup Barve <Anup_Barve@xyratex.com>
 * Original creation date: 03/21/2011
 */

/**
 * @defgroup io_fops FOPs for Data Operations
 *
 * This component contains the File Operation Packets (FOP) definitions
 * for following operations
 * - readv
 * - writev
 *
 * It describes the FOP formats along with brief description of the flow.
 *
 * Note: As authorization is carried on server, all request FOPs
 * contain uid and gid. For authentication, nid is included in every FOP.
 * This is to serve very primitive authentication for now.
 *
 * @{
 */

/** @file io_fops_xc.ff
 *
 * <b>IO fop formats</b>
 *
 */

require "net/net_otw_types_ff";
require "addb/addbff/addb_ff";
require "fid/fid_xc";
require "fid/fid";

/**
 * @section IO FOP Definitions
 */

/**
 * Represents the extent information for an io segment. m0_ioseg typically
 * represents a user space data buffer or a kernel page.
 */
record {
	u64 ci_index;
	u64 ci_count
} m0_ioseg;

/**
 * Represents an index vector with {index, count}  tuples for a target
 * device (typically a cob).
 */
sequence {
	u32      ci_nr;
	m0_ioseg ci_iosegs
} m0_io_indexvec;

/**
 * Represents sequence of index vector, one per network buffer.
 * As a result of io coalescing, there could be multiple network
 * buffers associated with an io fop. Hence a SEQUENCE of m0_io_indexvec
 * is needed, one per network buffer.
 */
sequence {
	u32            cis_nr;
	m0_io_indexvec cis_ivecs
} m0_io_indexvec_seq;

/**
 * Sequence of net buf desc that can be accommodated in single io fop.
 * As a result of io coalescing, there could be multiple network
 * buffers associated with an io fop. Hence a SEQUENCE of m0_net_buf_desc
 * is needed.
 */
sequence {
	u32             id_nr;
	m0_net_buf_desc id_descs
} m0_io_descs;

/**
 * Failure vector (pool machine state) version numbers.
 * This is declared as a record, not a sequence (which is more like an
 * array, such that to avoid dynamic memory allocation for every
 * request and reply fop. The size of this struct will be assert to
 * be the same of struct m0_pool_version_numbers.
 */
record {
	u64 fvv_read;
	u64 fvv_write
} m0_fv_version;

record {
	u32 fve_type;
	u32 fve_index;
	u32 fve_state
} m0_fv_event;

/**
 * Failure vector updates.
 * This update is represented as an array of chars. This is the serialized
 * representation of failure vector.
 */
sequence {
	u32 fvu_count;
	m0_fv_event fvu_events
} m0_fv_updates;

/**
 * A common sub structure to be referred by read and write reply fops.
 */
record {
        /** Status code of operation. */
	u32 rwr_rc;

	/** Number of bytes read or written. */
	u64 rwr_count;

	/** latest version number */
	m0_fv_version rwr_fv_version;

	/**
	 * Failure vector updates. This field is valid  iff rc is some
	 * defined special code.
	 */
	m0_fv_updates rwr_fv_updates
} m0_fop_cob_rw_reply;

/**
 * Reply FOP for a readv request.
 */
record {
	/** Common read/write reply. */
	m0_fop_cob_rw_reply c_rep
} m0_fop_cob_readv_rep;

/**
 * Reply FOP for writev FOPs.
 * The m0_fop_cob_writev_rep FOP is sent as a response by the
 * Data server to a client.
 * It contains the status code and number of bytes written.
 */
record {
	/** Common read/write reply structure. */
	m0_fop_cob_rw_reply c_rep
} m0_fop_cob_writev_rep;

/**
 * Common structure for read and write request fops.
 */
record {
	/** Client known failure vector version number */
	m0_fv_version crw_version;

	/** File identifier of read/write request. */

	m0_fid    crw_fid;

	/** Net buf descriptors representing the m0_net_buffer containing
	    the IO buffers. */

	m0_io_descs        crw_desc;

	/** Index vectors representing the extent information for the
	    IO request. */

	m0_io_indexvec_seq crw_ivecs;

	/** Miscellaneous flags. */

	u64                crw_flags
} m0_fop_cob_rw;

/**
 * This fop is representation of a read component object request.
 * The m0_fop_cob_readv FOP is sent by client to the Data server.
 * The FOP supplies the stob id on which the read has to be performed.
 * The IO vector signifies the region within Component Object on which IO
 * has to be performed.
 * On completion, the reply FOP (m0_fop_cob_readv_rep) is created
 * and sent to the client.
 */
record {
	/** Common definition of read/write fops. */
	m0_fop_cob_rw c_rwv
} m0_fop_cob_readv;

/**
 * The m0_fop_cob_writev FOP is used to send write requests by a
 * client to a Data server.
 * The FOP supplies the stob id on which the write has to be performed.
 * The IO vector signifies the region within Component Object on which IO
 * has to be performed.
 * On completion, the reply FOP (m0_fop_cob_writev_rep) is created
 * and sent to the client.
 */
record {
	/** Common definition of read/write fops. */
	m0_fop_cob_rw c_rwv
} m0_fop_cob_writev;

record {
	u64             if_st;
	m0_net_buf_desc if_nbd
} m0_test_ios_fop;

record {
	u64            if_st;
	m0_addb_record if_addb
} m0_test_io_addb;

record {
	/** Client known failure vector version number */
	m0_fv_version c_version;

	/**
	 * Fid of global file.
	 */
	m0_fid c_gobfid;

	/**
	 * Fid of component object.
	 */
	m0_fid c_cobfid;

	/** Unique cob index in pool. */
	u32             c_cob_idx
} m0_fop_cob_common;

/**
 * On-wire representation of "cob create" request.
 * Cob create fops are sent to data servers when a new global file
 * is created.
 */
record {
	m0_fop_cob_common cc_common
} m0_fop_cob_create;

/**
 * On-wire representation of "cob delete" request.
 * Cob delete fops are sent to data servers when a global file
 * is deleted.
 * Cob is located based on stob-id. Currently, cob-id is same
 * as stob-id.
 */
record {
	m0_fop_cob_common cd_common
} m0_fop_cob_delete;

/**
 * On-wire representation of reply for both "cob create" and "cob delete"
 * requests.
 */
record {
	u32 cor_rc;

	/** latest version number */
	m0_fv_version cor_fv_version;

	/**
	 * Failure vector updates. This field is valid  iff rc is some
	 * defined special code.
	 */
	m0_fv_updates cor_fv_updates
} m0_fop_cob_op_reply;

/**
 * Fop to notify the failure vector version number if changed.
 * This fop itself contains the latest failure vector version number.
 */
record {
	/** the pool id of this failure vector */
	u64 fvn_poolid;

	/** its latest failure vector version */
	m0_fv_version fvn_version
} m0_fop_fv_notification;


/** @} end of FOP_data_ops */

/*
 *  Local variables:
 *  c-indentation-style: "K&R"
 *  c-basic-offset: 8
 *  tab-width: 8
 *  fill-column: 80
 *  scroll-step: 1
 *  End:
 */
