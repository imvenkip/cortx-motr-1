/* -*- C -*- */
#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#include <linux/kernel.h>
#include <linux/string.h>
#include <linux/sunrpc/stats.h>
#include <linux/sunrpc/svc.h>
#include <linux/sunrpc/svcsock.h>

#include "lib/assert.h"
#include "lib/errno.h"
#include "lib/memory.h"
#include "lib/thread.h"
#include "fop/fop.h"
#include "addb/addb.h"

#include "ksunrpc.h"
#include "sunrpc_io_k.h"
#include "net/bulk_emulation/sunrpc_xprt.h"

/**
   @addtogroup ksunrpc Sun RPC

   Sunrpc server implementation.  Based on the design of user-level
   sunrpc server implementation.

   @{
 */

enum {
	C2_SESSION_PROGRAM = 0x20000001,
	C2_DEF_RPC_VER = 1,
	KSUNRPC_XDRSIZE = C2_NET_BULK_SUNRPC_MAX_BUFFER_SIZE + 1024,
	KSUNRPC_BUFSIZE = C2_NET_BULK_SUNRPC_MAX_BUFFER_SIZE + 1024,
	KSUNRPC_MAXCONN = 1024,
	SERVER_THR_NR = 8,
	MIN_SERVER_THR_NR = 2
};

/**
   Allow all access in this limited implementation.
 */
static int ksunrpc_authenticate(struct svc_rqst *req)
{
	return SVC_OK;
}

static __be32 ksunrpc_proc_msg(struct svc_rqst *req, void *argp, void *resp)
{
	C2_IMPOSSIBLE("implement me");
	return 0;
}

static __be32 ksunrpc_proc_get(struct svc_rqst *req, void *argp, void *resp)
{
	C2_IMPOSSIBLE("implement me");
	return 0;
}

static __be32 ksunrpc_proc_put(struct svc_rqst *req, void *argp, void *resp)
{
	C2_IMPOSSIBLE("implement me");
	return 0;
}

/*
 * This is the generic XDR function. rqstp is either a rpc_rqst (client
 * side) or svc_rqst pointer (server side).
 * Encode functions always assume there's enough room in the buffer.
 */
static int ksunrpc_decode_msg(void *rqstp, __be32 *data, void *obj)
{
	C2_IMPOSSIBLE("implement me");
	return 0;
}

static int ksunrpc_encode_msg_resp(void *rqstp, __be32 *data, void *obj)
{
	C2_IMPOSSIBLE("implement me");
	return 0;
}

static int ksunrpc_encode_msg_rel(void *rqstp, __be32 *data, void *obj)
{
	C2_IMPOSSIBLE("implement me");
	return 0;
}

static int ksunrpc_decode_get(void *rqstp, __be32 *data, void *obj)
{
	C2_IMPOSSIBLE("implement me");
	return 0;
}

static int ksunrpc_encode_get_resp(void *rqstp, __be32 *data, void *obj)
{
	C2_IMPOSSIBLE("implement me");
	return 0;
}

static int ksunrpc_encode_get_rel(void *rqstp, __be32 *data, void *obj)
{
	C2_IMPOSSIBLE("implement me");
	return 0;
}

static int ksunrpc_decode_put(void *rqstp, __be32 *data, void *obj)
{
	C2_IMPOSSIBLE("implement me");
	return 0;
}

static int ksunrpc_encode_put_resp(void *rqstp, __be32 *data, void *obj)
{
	C2_IMPOSSIBLE("implement me");
	return 0;
}

static int ksunrpc_encode_put_rel(void *rqstp, __be32 *data, void *obj)
{
	C2_IMPOSSIBLE("implement me");
	return 0;
}

#define PROC(num, name, respsize)				\
 [num] = {							\
   .pc_func	= (svc_procfunc) ksunrpc_proc_##name,		\
   .pc_decode	= (kxdrproc_t) ksunrpc_decode_##name,		\
   .pc_encode	= (kxdrproc_t) ksunrpc_encode_##name##_resp,	\
   .pc_release	= (kxdrproc_t) ksunrpc_encode_##name##_rel,	\
   .pc_argsize	= sizeof(struct sunrpc_##name),			\
   .pc_ressize	= sizeof(struct sunrpc_##name##_resp),		\
   .pc_xdrressize = respsize,					\
 }

/**
   This would be generated by fop2c, but sunrpc is deprecated so this
   table, required by kernel sunrpc, is hard-coded.
 */
static struct svc_procedure ksunrpc_procedures[] = {
	PROC(30, msg, 0),
	PROC(31, get, 0),
	PROC(32, put, 0),
};

/**
   Service version.  In this limited implementation, only a single
   version is supported.
 */
static struct svc_version ksunrpc_version1 = {
	.vs_vers	= 1,
	.vs_nproc	= 3,
	.vs_proc	= ksunrpc_procedures,
	.vs_xdrsize	= KSUNRPC_XDRSIZE,
	.vs_hidden      = 1,	/* XXX want this or not? */
	.vs_dispatch    = NULL  /* XXX want this? */
};

/**
   Table of versions.
 */
static struct svc_version *ksunrpc_versions[] = {
	[1] = &ksunrpc_version1,
};

/**
   Service statistics
 */
static struct svc_stat ksunrpc_svc_stats;

/**
   Sunrpc service program information
 */
#define KSUNRPC_NRVERS	ARRAY_SIZE(ksunrpc_versions)
static struct svc_program ksunrpc_program = {
	.pg_prog		= C2_SESSION_PROGRAM,
	.pg_nvers		= C2_DEF_RPC_VER,
	.pg_vers		= ksunrpc_versions,
	.pg_name		= "c2_service",
	.pg_class		= "c2_service",
	.pg_stats		= &ksunrpc_svc_stats,
	.pg_authenticate	= ksunrpc_authenticate
};

struct ksunrpc_service {
	/**
	   SUNRPC service handle for this service
	 */
	struct svc_serv	       *s_serv;
	/**
	   SUNRPC request handle for this service
	 */
	struct svc_rqst	       *s_rqst;
	/**
	   scheduler thread handle
	 */
	struct c2_thread	s_scheduler_thread;
	/**
	   number of worker threads
	 */
	int			s_nr_workers;
	/**
	   worker thread array
	 */
	struct c2_thread       *s_workers;
	/**
	   The service is being shut down.
	 */
	bool			s_shutdown;
	/**
	   Service mutex, must be held across various sunrpc svc calls.
	 */
	struct c2_mutex		s_svc_mutex;
};

static const struct c2_addb_loc ksunrpc_addb_server = {
	.al_name = "ksunrpc-server"
};

static void ksunrpc_service_worker(struct c2_service *service)
{
	C2_IMPOSSIBLE("implement me");
}

static void ksunrpc_op(struct c2_service *service,
		       struct c2_fop_type *fopt, struct svc_xprt *transp)
{
	C2_IMPOSSIBLE("implement me");
}

static void ksunrpc_dispatch(struct svc_rqst *req)
{
	C2_IMPOSSIBLE("implement me");
	ksunrpc_op(NULL, NULL, NULL);
}

static int ksunrpc_scheduler_init(struct c2_service *service)
{
	C2_IMPOSSIBLE("implement me");
	ksunrpc_dispatch(NULL);
	return -ENOSYS;
}

static void ksunrpc_scheduler(struct c2_service *service)
{
	C2_IMPOSSIBLE("implement me");
}

static void ksunrpc_service_stop(struct ksunrpc_service *xs)
{
	C2_IMPOSSIBLE("implement me");
}

static int ksunrpc_service_start(struct c2_service *service,
				 struct ksunrpc_service_id *xid, int nr_workers)
{
	struct ksunrpc_service *xservice;
	struct svc_serv *serv;
	struct svc_xprt *xprt;
	struct svc_rqst *rqst;
	int rc = 0;

	xservice = service->s_xport_private;
	c2_mutex_lock(&xservice->s_svc_mutex);
	serv = svc_create(&ksunrpc_program, KSUNRPC_BUFSIZE, NULL);
	if (serv == NULL) {
		printk(KERN_ERR
		       "ksunrpc_service_start: create service failed\n");
		rc = -ENOMEM;
		goto done;
	}
	xservice->s_serv = serv;

	xprt = svc_find_xprt(serv, "tcp", PF_INET, 0);
	if (xprt != NULL) {
		svc_xprt_put(xprt);
	} else {
		rc = svc_create_xprt(serv, "tcp", PF_INET, xid->ssi_port,
				     SVC_SOCK_DEFAULTS);
		if (rc != 0)
			goto done;
	}
	rqst = svc_prepare_thread(serv, &serv->sv_pools[0]);
	if (IS_ERR(rqst)) {
		rc = PTR_ERR(rqst);
		printk(KERN_ERR "ksunrpc_service_start: "
		       "svc_rqst allocation failed, error=%d\n", rc);
		goto done;
	}
	xservice->s_rqst = rqst;
	svc_sock_update_bufs(serv);
	serv->sv_maxconn = KSUNRPC_MAXCONN;

	C2_IMPOSSIBLE("implement me");
	ksunrpc_scheduler_init(service);
	ksunrpc_scheduler(service);
	ksunrpc_service_worker(NULL);
done:
	if (rc != 0) {
		if (xservice->s_serv != NULL) {
			svc_destroy(xservice->s_serv);
			xservice->s_serv = NULL;
		}
	}
	c2_mutex_unlock(&xservice->s_svc_mutex);
	return rc;
}

static void ksunrpc_service_fini(struct c2_service *service)
{
	struct ksunrpc_service *xs;

	xs = service->s_xport_private;

	ksunrpc_service_stop(xs);

	C2_ASSERT(xs->s_workers == NULL);
	c2_mutex_fini(&xs->s_svc_mutex);
	c2_free(xs);
}

int ksunrpc_service_init(struct c2_service *service)
{
	struct ksunrpc_service    *xservice;
	struct ksunrpc_service_id *xid;
	int                        result;

	C2_ALLOC_PTR(xservice);
	if (xservice != NULL) {
		int num_threads;
		c2_mutex_init(&xservice->s_svc_mutex);
		service->s_xport_private = xservice;
		service->s_ops = &ksunrpc_service_ops;
		xid = service->s_id->si_xport_private;
		C2_ASSERT(service->s_id->si_ops == &ksunrpc_service_id_ops);
		if (service->s_domain->nd_xprt == &c2_net_ksunrpc_minimal_xprt)
			num_threads = MIN_SERVER_THR_NR;
		else
			num_threads = SERVER_THR_NR;
		result = ksunrpc_service_start(service, xid, num_threads);
	} else {
		C2_ADDB_ADD(&service->s_domain->nd_addb, &ksunrpc_addb_server,
			    c2_addb_oom);
		result = -ENOMEM;
	}
	return result;
}

/**
   Implementation of c2_service_ops::sio_reply_post.
 */
static void ksunrpc_reply_post(struct c2_service *service,
			       struct c2_fop *fop, void *cookie)
{
	struct c2_fop **ret = cookie;

	C2_ASSERT(*ret == NULL);
	*ret = fop;
}

int ksunrpc_server_init(void)
{
	return 0;
}

void ksunrpc_server_fini(void)
{
}

const struct c2_service_ops ksunrpc_service_ops = {
	.so_fini       = ksunrpc_service_fini,
	.so_reply_post = ksunrpc_reply_post
};

/** @} end of group ksunrpc */

/*
 *  Local variables:
 *  c-indentation-style: "K&R"
 *  c-basic-offset: 8
 *  tab-width: 8
 *  fill-column: 80
 *  scroll-step: 1
 *  End:
 */
